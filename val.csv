,file,code,label
7605,0,CWE197_Numeric_Truncation_Error__int_fscanf_to_short_63a.c,"    int data;
    
    data = -1;
    
    fscanf(stdin, ""%d"", &data);
"
11975,0,CWE190_Integer_Overflow__short_rand_multiply_61a.c,"    short data;
    data = 0;
    data = CWE190_Integer_Overflow__short_rand_multiply_61b_badSource(data);
    if(data > 0) 
    {
        
        short result = data * 2;
        printIntLine(result);
"
882,0,CWE190_Integer_Overflow__short_max_postinc_05.c,"    short data;
    data = 0;
    if(staticTrue)
    {
        
        data = SHRT_MAX;
    }
    if(staticTrue)
    {
        {
            
            data++;
            short result = data;
            printIntLine(result);
        }
"
9983,0,CWE467_Use_of_sizeof_on_Pointer_Type__int_13.c,"    if(GLOBAL_CONST_FIVE==5)
    {
        {
            int * badInt = NULL;
            
            badInt = (int *)malloc(sizeof(badInt));
            if (badInt == NULL) {exit(-1);}
            *badInt = 5;
            printIntLine(*badInt);
            free(badInt);
        }
"
13736,0,CWE590_Free_Memory_Not_on_Heap__delete_array_class_declare_72a.cpp,"    TwoIntsClass * data;
    vector<TwoIntsClass *> dataVector;
    data = NULL; 
    {
        
        TwoIntsClass dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i].intOne = 1;
                dataBuffer[i].intTwo = 1;
            }
        }
        data = dataBuffer;
    }
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
2342,0,CWE590_Free_Memory_Not_on_Heap__delete_int_static_04.cpp,"    int * data;
    data = NULL; 
    if(STATIC_CONST_TRUE)
    {
        {
            
            static int dataBuffer;
            dataBuffer = 5;
            data = &dataBuffer;
        }
    }
    printIntLine(*data);
    
"
15394,0,CWE690_NULL_Deref_From_Return__long_calloc_72a.cpp,"    long * data;
    vector<long *> dataVector;
    data = NULL; 
    
    data = (long *)calloc(1, sizeof(long));
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
11496,0,CWE590_Free_Memory_Not_on_Heap__delete_struct_placement_new_17.cpp,"    int i;
    twoIntsStruct * data;
    data = NULL; 
    for(i = 0; i < 1; i++)
    {
        {
            
            char buffer[sizeof(twoIntsStruct)];
            twoIntsStruct * dataBuffer = new(buffer) twoIntsStruct;
            dataBuffer->intOne = 1;
            dataBuffer->intTwo = 1;
            data = dataBuffer;
        }
    }
    printStructLine(data);
    
"
8139,0,CWE401_Memory_Leak__int_calloc_18.c,"    int * data;
    data = NULL;
    goto source;
source:
    
    data = (int *)calloc(100, sizeof(int));
    if (data == NULL) {exit(-1);}
    
    data[0] = 5;
    printIntLine(data[0]);
    goto sink;
sink:
    
"
13059,0,CWE190_Integer_Overflow__int_fscanf_add_65a.c,"    int data;
    
    void (*funcPtr) (int) = CWE190_Integer_Overflow__int_fscanf_add_65b_badSink;
    
    data = 0;
    
    fscanf(stdin, ""%d"", &data);
    
"
14715,1,CWE758_Undefined_Behavior__int_malloc_use_15.c,"    switch(6)
    {
    case 6:
    {
        int data;
        int * pointer = (int *)malloc(sizeof(int));
        if (pointer == NULL) {exit(-1);}
        data = 5;
        *pointer = data; 
        {
            int data = *pointer;
            printIntLine(data);
        }
        free(pointer);
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
18237,0,CWE401_Memory_Leak__new_struct_twoIntsStruct_74a.cpp,"    struct _twoIntsStruct * data;
    map<int, struct _twoIntsStruct *> dataMap;
    data = NULL;
    
    data = new struct _twoIntsStruct;
    
    data->intOne = 0;
    data->intTwo = 0;
    printStructLine((twoIntsStruct *)data);
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
9914,0,CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_84_bad.cpp,"Label Definition File: CWE134_Uncontrolled_Format_String.label.xml
Template File: sources-sinks-84_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 134 Uncontrolled Format String
 * BadSource: listen_socket Read data using a listen socket (server side)
 * GoodSource: Copy a fixed string into data
 * Sinks: fprintf
 *    GoodSink: fprintf with ""%s"" as the second argument and data as the third
 *    BadSink : fprintf with data as the second argument
 * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_84.h""

#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif

#define TCP_PORT 27015
#define LISTEN_BACKLOG 5

namespace CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_84
{
CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_84_bad::CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_84_bad(char * dataCopy)
{
    data = dataCopy;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
}

CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_84_bad::~CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_84_bad()
{
    
    fprintf(stdout, data);
}
}
"
10491,0,CWE78_OS_Command_Injection__char_environment_execl_62a.cpp,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    badSource(data);
    
    
"
7208,0,CWE590_Free_Memory_Not_on_Heap__delete_class_alloca_73a.cpp,"    TwoIntsClass * data;
    list<TwoIntsClass *> dataList;
    data = NULL; 
    {
        
        TwoIntsClass * dataBuffer = (TwoIntsClass *)ALLOCA(sizeof(TwoIntsClass));
        dataBuffer->intOne = 2;
        dataBuffer->intTwo = 2;
        data = dataBuffer;
    }
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
5185,0,CWE190_Integer_Overflow__unsigned_int_max_multiply_43.cpp,"    unsigned int data;
    data = 0;
    badSource(data);
    if(data > 0) 
    {
        
        unsigned int result = data * 2;
        printUnsignedLine(result);
"
14251,0,CWE190_Integer_Overflow__int_rand_postinc_18.c,"    int data;
    
    data = 0;
    goto source;
source:
    
    data = RAND32();
    goto sink;
sink:
    {
        
        data++;
        int result = data;
        printIntLine(result);
"
6095,0,CWE690_NULL_Deref_From_Return__int_realloc_51a.c,"    int * data;
    data = NULL; 
    
    data = (int *)realloc(data, 1*sizeof(int));
"
17718,0,CWE252_Unchecked_Return_Value__char_putchar_03.c,"    if(5==5)
    {
        
        putchar((int)'A');
"
445,0,CWE197_Numeric_Truncation_Error__short_connect_socket_03.c,"    short data;
    
    data = -1;
    if(5==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = (short)atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
4792,1,CWE758_Undefined_Behavior__int64_t_alloca_use_07.c,"    if(staticFive==5)
    {
        {
            int64_t data;
            int64_t * pointer = (int64_t *)ALLOCA(sizeof(int64_t));
            data = 5LL;
            *pointer = data; 
            {
                int64_t data = *pointer;
                printLongLongLine(data);
            }
        }
"
9438,0,CWE190_Integer_Overflow__int_listen_socket_multiply_01.c,"    int data;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    if(data > 0) 
    {
        
        int result = data * 2;
        printIntLine(result);
"
12282,1,CWE401_Memory_Leak__malloc_realloc_int_03.c,"    if(5==5)
    {
        {
            int * data = (int *)malloc(100*sizeof(int));
            if (data == NULL) {exit(-1);}
            int * tmpData;
            
            data[0] = 5;
            printIntLine(data[0]);
            tmpData = (int *)realloc(data, (130000)*sizeof(int));
            /* FIX: Ensure realloc() was successful before assigning data to the memory block
            * allocated with realloc() */
            if (tmpData != NULL)
            {
                data = tmpData;
                
                data[0] = 10;
                printIntLine(data[0]);
            }
            free(data);
        }
"
2078,0,CWE457_Use_of_Uninitialized_Variable__twointsclass_array_alloca_partial_init_06.cpp,"    TwoIntsClass * data;
    data = reinterpret_cast<TwoIntsClass *>(ALLOCA(10*sizeof(TwoIntsClass)));
    if(STATIC_CONST_FIVE==5)
    {
        
        for(int i=0; i<(10/2); i++)
        {
            data[i].intOne = i;
            data[i].intTwo = i;
        }
    }
    if(STATIC_CONST_FIVE==5)
    {
        
        for(int i=0; i<10; i++)
        {
            printIntLine(data[i].intOne);
            printIntLine(data[i].intTwo);
        }
"
16107,0,CWE197_Numeric_Truncation_Error__int_fscanf_to_char_09.c,"    int data;
    
    data = -1;
    if(GLOBAL_CONST_TRUE)
    {
        
        fscanf(stdin, ""%d"", &data);
    }
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
2923,0,CWE78_OS_Command_Injection__char_environment_execlp_73a.cpp,"    char * data;
    list<char *> dataList;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        
        if (environment != NULL)
        {
            
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
3144,0,CWE401_Memory_Leak__strdup_char_67a.c,"    char * data;
    CWE401_Memory_Leak__strdup_char_67_structType myStruct;
    data = NULL;
    {
        char myString[] = ""myString"";
        
        data = strdup(myString);
        
        printLine(data);
    }
    myStruct.structFirst = data;
"
7487,0,CWE590_Free_Memory_Not_on_Heap__free_int_alloca_12.c,"    int * data;
    data = NULL; 
    if(globalReturnsTrueOrFalse())
    {
        {
            
            int * dataBuffer = (int *)ALLOCA(100*sizeof(int));
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5;
                }
            }
            data = dataBuffer;
        }
    }
    else
    {
        {
            
            int * dataBuffer = (int *)malloc(100*sizeof(int));
            if (dataBuffer == NULL)
            {
                printLine(""malloc() failed"");
                exit(1);
            }
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5;
                }
            }
            data = dataBuffer;
        }
    }
    printIntLine(data[0]);
    
"
5836,0,CWE457_Use_of_Uninitialized_Variable__struct_array_alloca_partial_init_04.c,"    twoIntsStruct * data;
    data = (twoIntsStruct *)ALLOCA(10*sizeof(twoIntsStruct));
    if(STATIC_CONST_TRUE)
    {
        
        {
            int i;
            for(i=0; i<(10/2); i++)
            {
                data[i].intOne = i;
                data[i].intTwo = i;
            }
        }
    }
    if(STATIC_CONST_TRUE)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i].intOne);
                printIntLine(data[i].intTwo);
            }
        }
"
8916,0,CWE590_Free_Memory_Not_on_Heap__delete_int_declare_13.cpp,"    int * data;
    data = NULL; 
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            
            int dataBuffer;
            dataBuffer = 5;
            data = &dataBuffer;
        }
    }
    printIntLine(*data);
    
"
17078,0,CWE190_Integer_Overflow__int64_t_fscanf_multiply_84_bad.cpp,"Label Definition File: CWE190_Integer_Overflow.label.xml
Template File: sources-sinks-84_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 190 Integer Overflow
 * BadSource: fscanf Read data from the console using fscanf()
 * GoodSource: Set data to a small, non-zero number (two)
 * Sinks: multiply
 *    GoodSink: Ensure there will not be an overflow before multiplying data by 2
 *    BadSink : If data is positive, multiply by 2, which can cause an overflow
 * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use
 *
 * */
#ifndef OMITBAD

#include <inttypes.h>
#include ""std_testcase.h""
#include ""CWE190_Integer_Overflow__int64_t_fscanf_multiply_84.h""

namespace CWE190_Integer_Overflow__int64_t_fscanf_multiply_84
{
CWE190_Integer_Overflow__int64_t_fscanf_multiply_84_bad::CWE190_Integer_Overflow__int64_t_fscanf_multiply_84_bad(int64_t dataCopy)
{
    data = dataCopy;
    
    fscanf (stdin, ""%"" SCNd64, &data);
}

CWE190_Integer_Overflow__int64_t_fscanf_multiply_84_bad::~CWE190_Integer_Overflow__int64_t_fscanf_multiply_84_bad()
{
    if(data > 0) 
    {
        
        int64_t result = data * 2;
        printLongLongLine(result);
    }
}
}
"
3664,0,CWE401_Memory_Leak__int_malloc_07.c,"    int * data;
    data = NULL;
    if(staticFive==5)
    {
        
        data = (int *)malloc(100*sizeof(int));
        if (data == NULL) {exit(-1);}
        
        data[0] = 5;
        printIntLine(data[0]);
    }
    if(staticFive==5)
    {
        
        ; 
"
17907,0,CWE590_Free_Memory_Not_on_Heap__free_char_alloca_63a.c,"    char * data;
    data = NULL; 
    {
        
        char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
        memset(dataBuffer, 'A', 100-1); 
        dataBuffer[100-1] = '\0'; 
        data = dataBuffer;
    }
"
9002,1,CWE469_Use_of_Pointer_Subtraction_to_Determine_Size__char_02.c,"    if(0)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            char string1[] = SOURCE_STRING;
            char * slashInString1;
            size_t indexOfSlashInString1;
            slashInString1 = strchr(string1, '/');
            if (slashInString1 == NULL)
            {
                exit(1);
            }
            
            indexOfSlashInString1 = (size_t)(slashInString1 - string1);
            
            printUnsignedLine(indexOfSlashInString1);
        }
"
13119,0,CWE190_Integer_Overflow__int64_t_fscanf_multiply_33.cpp,"    int64_t data;
    int64_t &dataRef = data;
    data = 0LL;
    
    fscanf (stdin, ""%"" SCNd64, &data);
    {
        int64_t data = dataRef;
        if(data > 0) 
        {
            
            int64_t result = data * 2;
            printLongLongLine(result);
        }
"
6996,0,CWE590_Free_Memory_Not_on_Heap__delete_array_int_static_74a.cpp,"    int * data;
    map<int, int *> dataMap;
    data = NULL; 
    {
        
        static int dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5;
            }
        }
        data = dataBuffer;
    }
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
11571,0,CWE415_Double_Free__malloc_free_int64_t_84_bad.cpp,"Label Definition File: CWE415_Double_Free__malloc_free.label.xml
Template File: sources-sinks-84_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 415 Double Free
 * BadSource:  Allocate data using malloc() and Deallocate data using free()
 * GoodSource: Allocate data using malloc()
 * Sinks:
 *    GoodSink: do nothing
 *    BadSink : Deallocate data using free()
 * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE415_Double_Free__malloc_free_int64_t_84.h""

namespace CWE415_Double_Free__malloc_free_int64_t_84
{
CWE415_Double_Free__malloc_free_int64_t_84_bad::CWE415_Double_Free__malloc_free_int64_t_84_bad(int64_t * dataCopy)
{
    data = dataCopy;
    data = (int64_t *)malloc(100*sizeof(int64_t));
    if (data == NULL) {exit(-1);}
    
    free(data);
}

CWE415_Double_Free__malloc_free_int64_t_84_bad::~CWE415_Double_Free__malloc_free_int64_t_84_bad()
{
    
    free(data);
}
}
"
2319,0,CWE690_NULL_Deref_From_Return__struct_calloc_84_bad.cpp,"Label Definition File: CWE690_NULL_Deref_From_Return.free.label.xml
Template File: source-sinks-84_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 690 Unchecked Return Value To NULL Pointer
 * BadSource: calloc Allocate data using calloc()
 * Sinks:
 *    GoodSink: Check to see if the data allocation failed and if not, use data
 *    BadSink : Don't check for NULL and use data
 * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE690_NULL_Deref_From_Return__struct_calloc_84.h""

namespace CWE690_NULL_Deref_From_Return__struct_calloc_84
{
CWE690_NULL_Deref_From_Return__struct_calloc_84_bad::CWE690_NULL_Deref_From_Return__struct_calloc_84_bad(twoIntsStruct * dataCopy)
{
    data = dataCopy;
    
    data = (twoIntsStruct *)calloc(1, sizeof(twoIntsStruct));
}

CWE690_NULL_Deref_From_Return__struct_calloc_84_bad::~CWE690_NULL_Deref_From_Return__struct_calloc_84_bad()
{
    
    data[0].intOne = 1;
    data[0].intTwo = 1;
    printStructLine(&data[0]);
    free(data);
}
}
"
4220,0,CWE190_Integer_Overflow__int_connect_socket_preinc_04.c,"    int data;
    
    data = 0;
    if(STATIC_CONST_TRUE)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(STATIC_CONST_TRUE)
    {
        {
            
            ++data;
            int result = data;
            printIntLine(result);
        }
"
9880,0,CWE401_Memory_Leak__int64_t_realloc_31.c,"    int64_t * data;
    data = NULL;
    
    data = (int64_t *)realloc(data, 100*sizeof(int64_t));
    if (data == NULL) {exit(-1);}
    
    data[0] = 5LL;
    printLongLongLine(data[0]);
    {
        int64_t * dataCopy = data;
        int64_t * data = dataCopy;
        
        ; 
"
19421,0,CWE401_Memory_Leak__int64_t_malloc_34.c,"    int64_t * data;
    CWE401_Memory_Leak__int64_t_malloc_34_unionType myUnion;
    data = NULL;
    
    data = (int64_t *)malloc(100*sizeof(int64_t));
    if (data == NULL) {exit(-1);}
    
    data[0] = 5LL;
    printLongLongLine(data[0]);
    myUnion.unionFirst = data;
    {
        int64_t * data = myUnion.unionSecond;
        
        ; 
"
11602,0,CWE457_Use_of_Uninitialized_Variable__twointsclass_array_new_partial_init_62a.cpp,"    TwoIntsClass * data;
    data = new TwoIntsClass[10];
    badSource(data);
    
    for(int i=0; i<10; i++)
    {
        printIntLine(data[i].intOne);
        printIntLine(data[i].intTwo);
"
1508,0,CWE789_Uncontrolled_Mem_Alloc__new_char_fgets_13.cpp,"    size_t data;
    
    data = 0;
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                
                data = strtoul(inputBuffer, NULL, 0);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            char * myString;
            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
             * for the strcpy() function to not cause a buffer overflow */
            
            if (data > strlen(HELLO_STRING))
            {
                myString = new char[data];
                
                strcpy(myString, HELLO_STRING);
                printLine(myString);
                delete [] myString;
            }
            else
            {
                printLine(""Input is less than the length of the source string"");
            }
        }
"
13829,0,CWE190_Integer_Overflow__short_max_preinc_31.c,"    short data;
    data = 0;
    
    data = SHRT_MAX;
    {
        short dataCopy = data;
        short data = dataCopy;
        {
            
            ++data;
            short result = data;
            printIntLine(result);
        }
"
4110,0,CWE401_Memory_Leak__int64_t_malloc_68a.c,"    int64_t * data;
    data = NULL;
    
    data = (int64_t *)malloc(100*sizeof(int64_t));
    if (data == NULL) {exit(-1);}
    
    data[0] = 5LL;
    printLongLongLine(data[0]);
    CWE401_Memory_Leak__int64_t_malloc_68_badData = data;
"
141,1,CWE758_Undefined_Behavior__int_pointer_malloc_use_12.c,"    if(globalReturnsTrueOrFalse())
    {
        {
            int * data;
            int * * pointer = (int * *)malloc(sizeof(int *));
            if (pointer == NULL) {exit(-1);}
            
            data = (int *)malloc(sizeof(int));
            if (data == NULL) {exit(-1);}
            *data = 5;
            *pointer = data; 
            {
                int * data = *pointer;
                printIntLine(*data);
            }
            free(pointer);
        }
    }
    else
    {
        {
            int * data;
            int * * pointer = (int * *)malloc(sizeof(int *));
            if (pointer == NULL) {exit(-1);}
            
            data = (int *)malloc(sizeof(int));
            if (data == NULL) {exit(-1);}
            *data = 5;
            *pointer = data; 
            {
                int * data = *pointer;
                printIntLine(*data);
            }
            free(pointer);
        }
"
1547,0,CWE190_Integer_Overflow__int_listen_socket_multiply_66a.c,"    int data;
    int dataArray[5];
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
    dataArray[2] = data;
"
17480,0,CWE590_Free_Memory_Not_on_Heap__delete_array_class_declare_15.cpp,"    TwoIntsClass * data;
    data = NULL; 
    switch(6)
    {
    case 6:
    {
        
        TwoIntsClass dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i].intOne = 1;
                dataBuffer[i].intTwo = 1;
            }
        }
        data = dataBuffer;
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    printIntLine(data[0].intOne);
    
"
2629,0,CWE190_Integer_Overflow__int_fscanf_multiply_01.c,"    int data;
    
    data = 0;
    
    fscanf(stdin, ""%d"", &data);
    if(data > 0) 
    {
        
        int result = data * 2;
        printIntLine(result);
"
10156,0,CWE190_Integer_Overflow__int64_t_fscanf_postinc_54a.c,"    int64_t data;
    data = 0LL;
    
    fscanf (stdin, ""%"" SCNd64, &data);
"
12785,0,CWE415_Double_Free__new_delete_array_struct_02.cpp,"    twoIntsStruct * data;
    
    data = NULL;
    if(1)
    {
        data = new twoIntsStruct[100];
        
        delete [] data;
    }
    if(1)
    {
        
        delete [] data;
"
11741,0,CWE369_Divide_by_Zero__int_fgets_modulo_81_bad.cpp,"Label Definition File: CWE369_Divide_by_Zero__int.label.xml
Template File: sources-sinks-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 369 Divide by Zero
 * BadSource: fgets Read data from the console using fgets()
 * GoodSource: Non-zero
 * Sinks: modulo
 *    GoodSink: Check for zero before modulo
 *    BadSink : Modulo a constant with data
 * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE369_Divide_by_Zero__int_fgets_modulo_81.h""

namespace CWE369_Divide_by_Zero__int_fgets_modulo_81
{

void CWE369_Divide_by_Zero__int_fgets_modulo_81_bad::action(int data) const
{
    
    printIntLine(100 % data);
}

}
"
6532,0,CWE758_Undefined_Behavior__char_pointer_malloc_use_05.c,"    if(staticTrue)
    {
        {
            char * * pointer = (char * *)malloc(sizeof(char *));
            if (pointer == NULL) {exit(-1);}
            char * data = *pointer; 
            free(pointer);
            printLine(data);
        }
"
7683,0,CWE190_Integer_Overflow__char_rand_add_65a.c,"    char data;
    
    void (*funcPtr) (char) = CWE190_Integer_Overflow__char_rand_add_65b_badSink;
    data = ' ';
    
    data = (char)RAND32();
    
"
10229,0,CWE590_Free_Memory_Not_on_Heap__delete_struct_static_81_bad.cpp,"Label Definition File: CWE590_Free_Memory_Not_on_Heap__delete.nonpointer.label.xml
Template File: sources-sink-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 590 Free Memory Not on Heap
 * BadSource: static Data buffer is declared static on the stack
 * GoodSource: Allocate memory on the heap
 * Sinks:
 *    BadSink : Print then free data
 * Flow Variant: 81 Data flow: data passed in a parameter to a virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE590_Free_Memory_Not_on_Heap__delete_struct_static_81.h""

namespace CWE590_Free_Memory_Not_on_Heap__delete_struct_static_81
{

void CWE590_Free_Memory_Not_on_Heap__delete_struct_static_81_bad::action(twoIntsStruct * data) const
{
    printStructLine(data);
    
    delete data;
}

}
"
14015,0,CWE690_NULL_Deref_From_Return__int_calloc_10.c,"    int * data;
    data = NULL; 
    
    data = (int *)calloc(1, sizeof(int));
    if(globalTrue)
    {
        
        data[0] = 5;
        printIntLine(data[0]);
        free(data);
"
14599,0,CWE190_Integer_Overflow__char_rand_square_82a.cpp,"    char data;
    data = ' ';
    
    data = (char)RAND32();
    CWE190_Integer_Overflow__char_rand_square_82_base* baseObject = new CWE190_Integer_Overflow__char_rand_square_82_bad;
    baseObject->action(data);
"
8942,0,CWE134_Uncontrolled_Format_String__char_environment_printf_32.c,"    char * data;
    char * *dataPtr1 = &data;
    char * *dataPtr2 = &data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        char * data = *dataPtr1;
        {
            
            size_t dataLen = strlen(data);
            char * environment = GETENV(ENV_VARIABLE);
            
            if (environment != NULL)
            {
                
                strncat(data+dataLen, environment, 100-dataLen-1);
            }
        }
        *dataPtr1 = data;
    }
    {
        char * data = *dataPtr2;
        
        printf(data);
"
15574,0,CWE78_OS_Command_Injection__char_listen_socket_execlp_12.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(globalReturnsTrueOrFalse())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                data[dataLen + recvResult / sizeof(char)] = '\0';
                
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    else
    {
        
        strcat(data, ""*.*"");
    }
    /* execlp - searches for the location of the command among
     * the directories specified by the PATH environment variable */
    
"
8760,1,CWE758_Undefined_Behavior__struct_pointer_alloca_use_03.c,"    if(5!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            twoIntsStruct * data;
            twoIntsStruct * * pointer = (twoIntsStruct * *)ALLOCA(sizeof(twoIntsStruct *));
            
            data = (twoIntsStruct *)malloc(sizeof(twoIntsStruct));
            if (data == NULL) {exit(-1);}
            data->intOne = 5;
            data->intTwo = 6;
            *pointer = data; 
            {
                twoIntsStruct * data = *pointer;
                printIntLine(data->intOne);
                printIntLine(data->intTwo);
            }
        }
"
9206,0,CWE401_Memory_Leak__int64_t_realloc_84_bad.cpp,"Label Definition File: CWE401_Memory_Leak.c.label.xml
Template File: sources-sinks-84_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 401 Memory Leak
 * BadSource: realloc Allocate data using realloc()
 * GoodSource: Allocate data on the stack
 * Sinks:
 *    GoodSink: call free() on data
 *    BadSink : no deallocation of data
 * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE401_Memory_Leak__int64_t_realloc_84.h""

namespace CWE401_Memory_Leak__int64_t_realloc_84
{
CWE401_Memory_Leak__int64_t_realloc_84_bad::CWE401_Memory_Leak__int64_t_realloc_84_bad(int64_t * dataCopy)
{
    data = dataCopy;
    
    data = (int64_t *)realloc(data, 100*sizeof(int64_t));
    if (data == NULL) {exit(-1);}
    
    data[0] = 5LL;
    printLongLongLine(data[0]);
}

CWE401_Memory_Leak__int64_t_realloc_84_bad::~CWE401_Memory_Leak__int64_t_realloc_84_bad()
{
    
    ; 
}
}
"
12079,0,CWE690_NULL_Deref_From_Return__char_calloc_05.c,"    char * data;
    data = NULL; 
    
    data = (char *)calloc(20, sizeof(char));
    if(staticTrue)
    {
        
        strcpy(data, ""Initialize"");
        printLine(data);
        free(data);
"
9109,0,CWE190_Integer_Overflow__int_fgets_postinc_12.c,"    int data;
    
    data = 0;
    if(globalReturnsTrueOrFalse())
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    else
    {
        
        data = 2;
    }
    if(globalReturnsTrueOrFalse())
    {
        {
            
            data++;
            int result = data;
            printIntLine(result);
        }
    }
    else
    {
        
        if (data < INT_MAX)
        {
            data++;
            int result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
"
17376,0,CWE457_Use_of_Uninitialized_Variable__int_array_declare_partial_init_01.c,"    int * data;
    int dataUninitArray[10];
    data = dataUninitArray;
    
    {
        int i;
        for(i=0; i<(10/2); i++)
        {
            data[i] = i;
        }
    }
    
    {
        int i;
        for(i=0; i<10; i++)
        {
            printIntLine(data[i]);
        }
"
2793,0,CWE416_Use_After_Free__new_delete_array_char_09.cpp,"    char * data;
    
    data = NULL;
    if(GLOBAL_CONST_TRUE)
    {
        data = new char[100];
        memset(data, 'A', 100-1);
        data[100-1] = '\0';
        
        delete [] data;
    }
    if(GLOBAL_CONST_TRUE)
    {
        
        printLine(data);
        
"
6398,0,CWE134_Uncontrolled_Format_String__char_environment_vfprintf_10.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(globalTrue)
    {
        {
            
            size_t dataLen = strlen(data);
            char * environment = GETENV(ENV_VARIABLE);
            
            if (environment != NULL)
            {
                
                strncat(data+dataLen, environment, 100-dataLen-1);
            }
        }
    }
    if(globalTrue)
    {
        badVaSinkB(data, data);
"
3367,0,CWE134_Uncontrolled_Format_String__char_environment_printf_07.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(staticFive==5)
    {
        {
            
            size_t dataLen = strlen(data);
            char * environment = GETENV(ENV_VARIABLE);
            
            if (environment != NULL)
            {
                
                strncat(data+dataLen, environment, 100-dataLen-1);
            }
        }
    }
    if(staticFive==5)
    {
        
        printf(data);
"
2029,1,CWE476_NULL_Pointer_Dereference__binary_if_16.c,"    while(1)
    {
        {
            twoIntsStruct *twoIntsStructPointer = NULL;
            /* FIX: Use && in the if statement so that if the left side of the expression fails then
             * the right side will not be evaluated */
            if ((twoIntsStructPointer != NULL) && (twoIntsStructPointer->intOne == 5))
            {
                printLine(""intOne == 5"");
            }
        }
        break;
"
1154,0,CWE690_NULL_Deref_From_Return__int64_t_malloc_54a.c,"    int64_t * data;
    data = NULL; 
    
    data = (int64_t *)malloc(1*sizeof(int64_t));
"
10851,0,CWE415_Double_Free__new_delete_array_int64_t_82_bad.cpp,"Label Definition File: CWE415_Double_Free__new_delete_array.label.xml
Template File: sources-sinks-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 415 Double Free
 * BadSource:  Allocate data using new and Deallocae data using delete
 * GoodSource: Allocate data using new
 * Sinks:
 *    GoodSink: do nothing
 *    BadSink : Deallocate data using delete
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE415_Double_Free__new_delete_array_int64_t_82.h""

namespace CWE415_Double_Free__new_delete_array_int64_t_82
{

void CWE415_Double_Free__new_delete_array_int64_t_82_bad::action(int64_t * data)
{
    
    delete [] data;
}

}
"
1797,0,CWE758_Undefined_Behavior__char_malloc_use_11.c,"    if(globalReturnsTrue())
    {
        {
            char * pointer = (char *)malloc(sizeof(char));
            if (pointer == NULL) {exit(-1);}
            char data = *pointer; 
            free(pointer);
            printHexCharLine(data);
        }
"
15907,0,CWE415_Double_Free__new_delete_array_char_07.cpp,"    char * data;
    
    data = NULL;
    if(staticFive==5)
    {
        data = new char[100];
        
        delete [] data;
    }
    if(staticFive==5)
    {
        
        delete [] data;
"
17388,0,CWE197_Numeric_Truncation_Error__int_rand_to_short_53a.c,"    int data;
    
    data = -1;
    
    data = RAND32();
"
968,0,CWE563_Unused_Variable__unused_value_int_08.c,"    int data;
    if(staticReturnsTrue())
    {
        
        data = 5;
    }
    if(staticReturnsTrue())
    {
        
        data = 10;
        printIntLine(data);
"
10118,0,CWE190_Integer_Overflow__short_max_add_09.c,"    short data;
    data = 0;
    if(GLOBAL_CONST_TRUE)
    {
        
        data = SHRT_MAX;
    }
    if(GLOBAL_CONST_TRUE)
    {
        {
            
            short result = data + 1;
            printIntLine(result);
        }
"
429,0,CWE415_Double_Free__new_delete_int64_t_14.cpp,"    int64_t * data;
    
    data = NULL;
    if(globalFive==5)
    {
        data = new int64_t;
        
        delete data;
    }
    if(globalFive==5)
    {
        
        delete data;
"
6006,0,CWE190_Integer_Overflow__int64_t_rand_postinc_45.c,"    int64_t data;
    data = 0LL;
    
    data = (int64_t)RAND64();
    CWE190_Integer_Overflow__int64_t_rand_postinc_45_badData = data;
"
6617,1,CWE758_Undefined_Behavior__char_malloc_use_02.c,"    if(1)
    {
        {
            char data;
            char * pointer = (char *)malloc(sizeof(char));
            if (pointer == NULL) {exit(-1);}
            data = 5;
            *pointer = data; 
            {
                char data = *pointer;
                printHexCharLine(data);
            }
            free(pointer);
        }
"
16582,0,CWE190_Integer_Overflow__short_max_add_03.c,"    short data;
    data = 0;
    if(5==5)
    {
        
        data = SHRT_MAX;
    }
    if(5==5)
    {
        {
            
            short result = data + 1;
            printIntLine(result);
        }
"
13404,0,CWE401_Memory_Leak__new_array_twointsStruct_65a.cpp,"    twoIntsStruct * data;
    
    void (*funcPtr) (twoIntsStruct *) = badSink;
    data = NULL;
    
    data = new twoIntsStruct[100];
    
    data[0].intOne = 0;
    data[0].intTwo = 0;
    printStructLine(&data[0]);
    
"
13880,0,CWE190_Integer_Overflow__int64_t_rand_square_21.c,"    int64_t data;
    data = 0LL;
    
    data = (int64_t)RAND64();
    badStatic = 1; 
"
11236,0,CWE401_Memory_Leak__twoIntsStruct_realloc_81a.cpp,"    twoIntsStruct * data;
    data = NULL;
    
    data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));
    if (data == NULL) {exit(-1);}
    
    data[0].intOne = 0;
    data[0].intTwo = 0;
    printStructLine(&data[0]);
    const CWE401_Memory_Leak__twoIntsStruct_realloc_81_base& baseObject = CWE401_Memory_Leak__twoIntsStruct_realloc_81_bad();
"
5312,0,CWE190_Integer_Overflow__int_rand_preinc_10.c,"    int data;
    
    data = 0;
    if(globalTrue)
    {
        
        data = RAND32();
    }
    if(globalTrue)
    {
        {
            
            ++data;
            int result = data;
            printIntLine(result);
        }
"
2365,0,CWE590_Free_Memory_Not_on_Heap__delete_int_declare_67a.cpp,"    int * data;
    structType myStruct;
    data = NULL; 
    {
        
        int dataBuffer;
        dataBuffer = 5;
        data = &dataBuffer;
    }
    myStruct.structFirst = data;
"
12529,0,CWE690_NULL_Deref_From_Return__struct_realloc_83_bad.cpp,"Label Definition File: CWE690_NULL_Deref_From_Return.free.label.xml
Template File: source-sinks-83_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 690 Unchecked Return Value To NULL Pointer
 * BadSource: realloc Allocate data using realloc()
 * Sinks:
 *    GoodSink: Check to see if the data allocation failed and if not, use data
 *    BadSink : Don't check for NULL and use data
 * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE690_NULL_Deref_From_Return__struct_realloc_83.h""

namespace CWE690_NULL_Deref_From_Return__struct_realloc_83
{
CWE690_NULL_Deref_From_Return__struct_realloc_83_bad::CWE690_NULL_Deref_From_Return__struct_realloc_83_bad(twoIntsStruct * dataCopy)
{
    data = dataCopy;
    
    data = (twoIntsStruct *)realloc(data, 1*sizeof(twoIntsStruct));
}

CWE690_NULL_Deref_From_Return__struct_realloc_83_bad::~CWE690_NULL_Deref_From_Return__struct_realloc_83_bad()
{
    
    data[0].intOne = 1;
    data[0].intTwo = 1;
    printStructLine(&data[0]);
    free(data);
}
}
"
16655,0,CWE415_Double_Free__new_delete_struct_10.cpp,"    twoIntsStruct * data;
    
    data = NULL;
    if(globalTrue)
    {
        data = new twoIntsStruct;
        
        delete data;
    }
    if(globalTrue)
    {
        
        delete data;
"
18183,0,CWE476_NULL_Pointer_Dereference__struct_45.c,"    twoIntsStruct * data;
    
    data = NULL;
    CWE476_NULL_Pointer_Dereference__struct_45_badData = data;
"
6913,0,CWE758_Undefined_Behavior__struct_pointer_new_use_03.cpp,"    if(5==5)
    {
        {
            twoIntsStruct * * pointer = new twoIntsStruct *;
            twoIntsStruct * data = *pointer; 
            delete pointer;
            printIntLine(data->intOne);
            printIntLine(data->intTwo);
        }
"
17931,0,CWE590_Free_Memory_Not_on_Heap__delete_array_char_static_02.cpp,"    char * data;
    data = NULL; 
    if(1)
    {
        {
            
            static char dataBuffer[100];
            memset(dataBuffer, 'A', 100-1); 
            dataBuffer[100-1] = '\0'; 
            data = dataBuffer;
        }
    }
    printLine(data);
    
"
13770,0,CWE190_Integer_Overflow__short_max_add_16.c,"    short data;
    data = 0;
    while(1)
    {
        
        data = SHRT_MAX;
        break;
    }
    while(1)
    {
        {
            
            short result = data + 1;
            printIntLine(result);
        }
        break;
"
7472,0,CWE590_Free_Memory_Not_on_Heap__delete_array_long_static_53a.cpp,"    long * data;
    data = NULL; 
    {
        
        static long dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5L;
            }
        }
        data = dataBuffer;
    }
"
2619,0,CWE78_OS_Command_Injection__char_file_execl_83_bad.cpp,"Label Definition File: CWE78_OS_Command_Injection.strings.label.xml
Template File: sources-sink-83_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 78 OS Command Injection
 * BadSource: file Read input from a file
 * GoodSource: Fixed string
 * Sinks: execl
 *    BadSink : execute command with execl
 * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE78_OS_Command_Injection__char_file_execl_83.h""

#ifdef _WIN32
#define FILENAME ""C:\\temp\\file.txt""
#else
#define FILENAME ""/tmp/file.txt""
#endif

#ifdef _WIN32
#include <process.h>
#define EXECL _execl
#else 
#define EXECL execl
#endif

namespace CWE78_OS_Command_Injection__char_file_execl_83
{
CWE78_OS_Command_Injection__char_file_execl_83_bad::CWE78_OS_Command_Injection__char_file_execl_83_bad(char * dataCopy)
{
    data = dataCopy;
    {
        
        size_t dataLen = strlen(data);
        FILE * pFile;
        
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
}

CWE78_OS_Command_Injection__char_file_execl_83_bad::~CWE78_OS_Command_Injection__char_file_execl_83_bad()
{
    
    
    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
}
"
3253,0,CWE78_OS_Command_Injection__char_console_popen_63a.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
        
        size_t dataLen = strlen(data);
        
        if (100-dataLen > 1)
        {
            
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgets() */
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
                    data[dataLen-1] = '\0';
                }
            }
            else
            {
                printLine(""fgets() failed"");
                
                data[dataLen] = '\0';
            }
        }
    }
"
7284,0,CWE457_Use_of_Uninitialized_Variable__twointsclass_array_alloca_no_init_12.cpp,"    TwoIntsClass * data;
    data = reinterpret_cast<TwoIntsClass *>(ALLOCA(10*sizeof(TwoIntsClass)));
    if(globalReturnsTrueOrFalse())
    {
        
        ; 
    }
    else
    {
        
        for(int i=0; i<10; i++)
        {
            data[i].intOne = i;
            data[i].intTwo = i;
        }
    }
    if(globalReturnsTrueOrFalse())
    {
        
        for(int i=0; i<10; i++)
        {
            printIntLine(data[i].intOne);
            printIntLine(data[i].intTwo);
        }
    }
    else
    {
        
        for(int i=0; i<10; i++)
        {
            data[i].intOne = i;
            data[i].intTwo = i;
        }
        for(int i=0; i<10; i++)
        {
            printIntLine(data[i].intOne);
            printIntLine(data[i].intTwo);
        }
"
6798,0,CWE690_NULL_Deref_From_Return__struct_malloc_44.c,"    twoIntsStruct * data;
    
    void (*funcPtr) (twoIntsStruct *) = badSink;
    data = NULL; 
    
    data = (twoIntsStruct *)malloc(1*sizeof(twoIntsStruct));
    
"
3432,0,CWE190_Integer_Overflow__char_max_square_53a.c,"    char data;
    data = ' ';
    
    data = CHAR_MAX;
"
5692,0,CWE190_Integer_Overflow__short_max_add_02.c,"    short data;
    data = 0;
    if(1)
    {
        
        data = SHRT_MAX;
    }
    if(1)
    {
        {
            
            short result = data + 1;
            printIntLine(result);
        }
"
5238,0,CWE78_OS_Command_Injection__char_file_system_08.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(staticReturnsTrue())
    {
        {
            
            size_t dataLen = strlen(data);
            FILE * pFile;
            
            if (100-dataLen > 1)
            {
                pFile = fopen(FILENAME, ""r"");
                if (pFile != NULL)
                {
                    
                    if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                    {
                        printLine(""fgets() failed"");
                        
                        data[dataLen] = '\0';
                    }
                    fclose(pFile);
                }
            }
        }
    }
    
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
"
16331,0,CWE665_Improper_Initialization__char_ncat_82a.cpp,"    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    
    ; 
    CWE665_Improper_Initialization__char_ncat_82_base* baseObject = new CWE665_Improper_Initialization__char_ncat_82_bad;
    baseObject->action(data);
"
8363,0,CWE401_Memory_Leak__struct_twoIntsStruct_calloc_83_bad.cpp,"Label Definition File: CWE401_Memory_Leak.c.label.xml
Template File: sources-sinks-83_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 401 Memory Leak
 * BadSource: calloc Allocate data using calloc()
 * GoodSource: Allocate data on the stack
 * Sinks:
 *    GoodSink: call free() on data
 *    BadSink : no deallocation of data
 * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE401_Memory_Leak__struct_twoIntsStruct_calloc_83.h""

namespace CWE401_Memory_Leak__struct_twoIntsStruct_calloc_83
{
CWE401_Memory_Leak__struct_twoIntsStruct_calloc_83_bad::CWE401_Memory_Leak__struct_twoIntsStruct_calloc_83_bad(struct _twoIntsStruct * dataCopy)
{
    data = dataCopy;
    
    data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));
    if (data == NULL) {exit(-1);}
    
    data[0].intOne = 0;
    data[0].intTwo = 0;
    printStructLine((twoIntsStruct *)&data[0]);
}

CWE401_Memory_Leak__struct_twoIntsStruct_calloc_83_bad::~CWE401_Memory_Leak__struct_twoIntsStruct_calloc_83_bad()
{
    
    ; 
}
}
"
1676,0,CWE190_Integer_Overflow__char_max_multiply_13.c,"    char data;
    data = ' ';
    if(GLOBAL_CONST_FIVE==5)
    {
        
        data = CHAR_MAX;
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        if(data > 0) 
        {
            
            char result = data * 2;
            printHexCharLine(result);
        }
"
1278,0,CWE134_Uncontrolled_Format_String__char_environment_printf_22a.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        
        if (environment != NULL)
        {
            
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    CWE134_Uncontrolled_Format_String__char_environment_printf_22_badGlobal = 1; 
"
3528,0,CWE690_NULL_Deref_From_Return__struct_calloc_05.c,"    twoIntsStruct * data;
    data = NULL; 
    
    data = (twoIntsStruct *)calloc(1, sizeof(twoIntsStruct));
    if(staticTrue)
    {
        
        data[0].intOne = 1;
        data[0].intTwo = 1;
        printStructLine(&data[0]);
        free(data);
"
12394,0,CWE476_NULL_Pointer_Dereference__int64_t_54a.c,"    int64_t * data;
    
    data = NULL;
"
14661,0,CWE190_Integer_Overflow__int64_t_max_add_22a.c,"    int64_t data;
    data = 0LL;
    
    data = LLONG_MAX;
    CWE190_Integer_Overflow__int64_t_max_add_22_badGlobal = 1; 
"
9651,0,CWE190_Integer_Overflow__int_fscanf_square_84a.cpp,"    int data;
    
    data = 0;
    CWE190_Integer_Overflow__int_fscanf_square_84_bad * badObject = new CWE190_Integer_Overflow__int_fscanf_square_84_bad(data);
"
3934,0,CWE415_Double_Free__new_delete_long_06.cpp,"    long * data;
    
    data = NULL;
    if(STATIC_CONST_FIVE==5)
    {
        data = new long;
        
        delete data;
    }
    if(STATIC_CONST_FIVE==5)
    {
        
        delete data;
"
12769,0,CWE401_Memory_Leak__new_array_int_73a.cpp,"    int * data;
    list<int *> dataList;
    data = NULL;
    
    data = new int[100];
    
    data[0] = 5;
    printIntLine(data[0]);
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
13605,0,CWE190_Integer_Overflow__int_rand_multiply_14.c,"    int data;
    
    data = 0;
    if(globalFive==5)
    {
        
        data = RAND32();
    }
    if(globalFive==5)
    {
        if(data > 0) 
        {
            
            int result = data * 2;
            printIntLine(result);
        }
"
9422,0,CWE690_NULL_Deref_From_Return__char_malloc_22a.c,"    char * data;
    data = NULL; 
    
    data = (char *)malloc(20*sizeof(char));
    CWE690_NULL_Deref_From_Return__char_malloc_22_badGlobal = 1; 
"
16110,0,CWE690_NULL_Deref_From_Return__char_calloc_84_bad.cpp,"Label Definition File: CWE690_NULL_Deref_From_Return.free.label.xml
Template File: source-sinks-84_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 690 Unchecked Return Value To NULL Pointer
 * BadSource: calloc Allocate data using calloc()
 * Sinks:
 *    GoodSink: Check to see if the data allocation failed and if not, use data
 *    BadSink : Don't check for NULL and use data
 * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE690_NULL_Deref_From_Return__char_calloc_84.h""

namespace CWE690_NULL_Deref_From_Return__char_calloc_84
{
CWE690_NULL_Deref_From_Return__char_calloc_84_bad::CWE690_NULL_Deref_From_Return__char_calloc_84_bad(char * dataCopy)
{
    data = dataCopy;
    
    data = (char *)calloc(20, sizeof(char));
}

CWE690_NULL_Deref_From_Return__char_calloc_84_bad::~CWE690_NULL_Deref_From_Return__char_calloc_84_bad()
{
    
    strcpy(data, ""Initialize"");
    printLine(data);
    free(data);
}
}
"
6831,0,CWE369_Divide_by_Zero__int_fscanf_modulo_84_bad.cpp,"Label Definition File: CWE369_Divide_by_Zero__int.label.xml
Template File: sources-sinks-84_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 369 Divide by Zero
 * BadSource: fscanf Read data from the console using fscanf()
 * GoodSource: Non-zero
 * Sinks: modulo
 *    GoodSink: Check for zero before modulo
 *    BadSink : Modulo a constant with data
 * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE369_Divide_by_Zero__int_fscanf_modulo_84.h""

namespace CWE369_Divide_by_Zero__int_fscanf_modulo_84
{
CWE369_Divide_by_Zero__int_fscanf_modulo_84_bad::CWE369_Divide_by_Zero__int_fscanf_modulo_84_bad(int dataCopy)
{
    data = dataCopy;
    
    fscanf(stdin, ""%d"", &data);
}

CWE369_Divide_by_Zero__int_fscanf_modulo_84_bad::~CWE369_Divide_by_Zero__int_fscanf_modulo_84_bad()
{
    
    printIntLine(100 % data);
}
}
"
3453,0,CWE190_Integer_Overflow__short_fscanf_add_32.c,"    short data;
    short *dataPtr1 = &data;
    short *dataPtr2 = &data;
    data = 0;
    {
        short data = *dataPtr1;
        
        fscanf (stdin, ""%hd"", &data);
        *dataPtr1 = data;
    }
    {
        short data = *dataPtr2;
        {
            
            short result = data + 1;
            printIntLine(result);
        }
"
12974,0,CWE590_Free_Memory_Not_on_Heap__delete_class_declare_44.cpp,"    TwoIntsClass * data;
    
    void (*funcPtr) (TwoIntsClass *) = badSink;
    data = NULL; 
    {
        
        TwoIntsClass dataBuffer;
        dataBuffer.intOne = 1;
        dataBuffer.intTwo = 1;
        data = &dataBuffer;
    }
    
"
6389,0,CWE190_Integer_Overflow__int64_t_max_postinc_16.c,"    int64_t data;
    data = 0LL;
    while(1)
    {
        
        data = LLONG_MAX;
        break;
    }
    while(1)
    {
        {
            
            data++;
            int64_t result = data;
            printLongLongLine(result);
        }
        break;
"
13242,0,CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_22a.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_22_badGlobal = 1; 
"
6580,0,CWE467_Use_of_sizeof_on_Pointer_Type__char_11.c,"    if(globalReturnsTrue())
    {
        {
            char * badChar = NULL;
            
            badChar = (char *)malloc(sizeof(badChar));
            if (badChar == NULL) {exit(-1);}
            *badChar = 'B';
            printHexCharLine(*badChar);
            free(badChar);
        }
"
13202,0,CWE190_Integer_Overflow__unsigned_int_rand_add_65a.c,"    unsigned int data;
    
    void (*funcPtr) (unsigned int) = CWE190_Integer_Overflow__unsigned_int_rand_add_65b_badSink;
    data = 0;
    
    data = (unsigned int)RAND32();
    
"
1891,1,CWE252_Unchecked_Return_Value__char_puts_15.c,"    switch(5)
    {
    case 6:
        
        printLine(""Benign, fixed string"");
        break;
    default:
        
        if (PUTS(""string"") == EOF)
        {
            printLine(""puts failed!"");
        }
        break;
"
8301,1,CWE758_Undefined_Behavior__char_pointer_malloc_use_04.c,"    if(STATIC_CONST_FALSE)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            char * data;
            char * * pointer = (char * *)malloc(sizeof(char *));
            if (pointer == NULL) {exit(-1);}
            data = ""string"";
            *pointer = data; 
            {
                char * data = *pointer;
                printLine(data);
            }
            free(pointer);
        }
"
1070,0,CWE197_Numeric_Truncation_Error__int_listen_socket_to_short_62a.cpp,"    int data;
    
    data = -1;
    badSource(data);
    {
        
        short shortData = (short)data;
        printShortLine(shortData);
"
12435,0,CWE401_Memory_Leak__twoIntsStruct_malloc_04.c,"    twoIntsStruct * data;
    data = NULL;
    if(STATIC_CONST_TRUE)
    {
        
        data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
        if (data == NULL) {exit(-1);}
        
        data[0].intOne = 0;
        data[0].intTwo = 0;
        printStructLine(&data[0]);
    }
    if(STATIC_CONST_TRUE)
    {
        
        ; 
"
2347,0,CWE416_Use_After_Free__malloc_free_int64_t_10.c,"    int64_t * data;
    
    data = NULL;
    if(globalTrue)
    {
        data = (int64_t *)malloc(100*sizeof(int64_t));
        if (data == NULL) {exit(-1);}
        {
            size_t i;
            for(i = 0; i < 100; i++)
            {
                data[i] = 5LL;
            }
        }
        
        free(data);
    }
    if(globalTrue)
    {
        
        printLongLongLine(data[0]);
        
"
4211,0,CWE590_Free_Memory_Not_on_Heap__free_int_declare_02.c,"    int * data;
    data = NULL; 
    if(1)
    {
        {
            
            int dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5;
                }
            }
            data = dataBuffer;
        }
    }
    printIntLine(data[0]);
    
"
5509,0,CWE190_Integer_Overflow__char_fscanf_add_72a.cpp,"    char data;
    vector<char> dataVector;
    data = ' ';
    
    fscanf (stdin, ""%c"", &data);
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
5848,0,CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_08.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(staticReturnsTrue())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                data[dataLen + recvResult / sizeof(char)] = '\0';
                
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(staticReturnsTrue())
    {
        {
            char dest[100] = """";
            
            SNPRINTF(dest, 100-1, data);
            printLine(dest);
        }
"
3314,0,CWE690_NULL_Deref_From_Return__char_realloc_12.c,"    char * data;
    data = NULL; 
    
    data = (char *)realloc(data, 20*sizeof(char));
    if(globalReturnsTrueOrFalse())
    {
        
        strcpy(data, ""Initialize"");
        printLine(data);
        free(data);
    }
    else
    {
        
        if (data != NULL)
        {
            strcpy(data, ""Initialize"");
            printLine(data);
            free(data);
        }
"
13590,0,CWE134_Uncontrolled_Format_String__char_file_vprintf_01.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        FILE * pFile;
        
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
"
3571,0,CWE197_Numeric_Truncation_Error__int_connect_socket_to_short_21.c,"    int data;
    
    data = -1;
    badStatic = 1; 
    data = badSource(data);
    {
        
        short shortData = (short)data;
        printShortLine(shortData);
"
10741,0,CWE190_Integer_Overflow__char_rand_preinc_65a.c,"    char data;
    
    void (*funcPtr) (char) = CWE190_Integer_Overflow__char_rand_preinc_65b_badSink;
    data = ' ';
    
    data = (char)RAND32();
    
"
2214,0,CWE197_Numeric_Truncation_Error__int_fscanf_to_char_84_bad.cpp,"Label Definition File: CWE197_Numeric_Truncation_Error__int.label.xml
Template File: sources-sink-84_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 197 Numeric Truncation Error
 * BadSource: fscanf Read data from the console using fscanf()
 * GoodSource: Less than CHAR_MAX
 * Sinks: to_char
 *    BadSink : Convert data to a char
 * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE197_Numeric_Truncation_Error__int_fscanf_to_char_84.h""

namespace CWE197_Numeric_Truncation_Error__int_fscanf_to_char_84
{
CWE197_Numeric_Truncation_Error__int_fscanf_to_char_84_bad::CWE197_Numeric_Truncation_Error__int_fscanf_to_char_84_bad(int dataCopy)
{
    data = dataCopy;
    
    fscanf(stdin, ""%d"", &data);
}

CWE197_Numeric_Truncation_Error__int_fscanf_to_char_84_bad::~CWE197_Numeric_Truncation_Error__int_fscanf_to_char_84_bad()
{
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
    }
}
}
"
837,0,CWE190_Integer_Overflow__short_fscanf_multiply_73a.cpp,"    short data;
    list<short> dataList;
    data = 0;
    
    fscanf (stdin, ""%hd"", &data);
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
12722,1,CWE758_Undefined_Behavior__struct_malloc_use_02.c,"    if(0)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            twoIntsStruct data;
            twoIntsStruct * pointer = (twoIntsStruct *)malloc(sizeof(twoIntsStruct));
            if (pointer == NULL) {exit(-1);}
            data.intOne = 1;
            data.intTwo = 2;
            *pointer = data; 
            {
                twoIntsStruct data = *pointer;
                printIntLine(data.intOne);
                printIntLine(data.intTwo);
            }
            free(pointer);
        }
"
18853,1,CWE401_Memory_Leak__malloc_realloc_struct_twoIntsStruct_03.c,"    if(5!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            struct _twoIntsStruct * data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));
            if (data == NULL) {exit(-1);}
            struct _twoIntsStruct * tmpData;
            
            data[0].intOne = 0;
            data[0].intTwo = 0;
            printStructLine((twoIntsStruct *)&data[0]);
            tmpData = (struct _twoIntsStruct *)realloc(data, (130000)*sizeof(struct _twoIntsStruct));
            /* FIX: Ensure realloc() was successful before assigning data to the memory block
            * allocated with realloc() */
            if (tmpData != NULL)
            {
                data = tmpData;
                
                data[0].intOne = 1;
                data[0].intTwo = 1;
                printStructLine((twoIntsStruct *)&data[0]);
            }
            free(data);
        }
"
4927,0,CWE190_Integer_Overflow__short_max_multiply_15.c,"    short data;
    data = 0;
    switch(6)
    {
    case 6:
        
        data = SHRT_MAX;
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
        if(data > 0) 
        {
            
            short result = data * 2;
            printIntLine(result);
        }
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
10999,0,CWE590_Free_Memory_Not_on_Heap__delete_int_static_65a.cpp,"    int * data;
    
    void (*funcPtr) (int *) = badSink;
    data = NULL; 
    {
        
        static int dataBuffer;
        dataBuffer = 5;
        data = &dataBuffer;
    }
    
"
1034,0,CWE190_Integer_Overflow__int64_t_rand_preinc_67a.c,"    int64_t data;
    CWE190_Integer_Overflow__int64_t_rand_preinc_67_structType myStruct;
    data = 0LL;
    
    data = (int64_t)RAND64();
    myStruct.structFirst = data;
"
9288,1,CWE252_Unchecked_Return_Value__char_rename_10.c,"    if(globalFalse)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        
        if (RENAME(OLD_GOOD_FILE_NAME, ""newgoodfilename.txt"") != 0)
        {
            printLine(""rename failed!"");
        }
"
9646,1,CWE476_NULL_Pointer_Dereference__null_check_after_deref_09.c,"    if(GLOBAL_CONST_FALSE)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            int *intPointer = NULL;
            intPointer = (int *)malloc(sizeof(int));
            *intPointer = 5;
            printIntLine(*intPointer);
            
            *intPointer = 10;
            printIntLine(*intPointer);
        }
"
11721,1,CWE401_Memory_Leak__malloc_realloc_char_14.c,"    if(globalFive!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            char * data = (char *)malloc(100*sizeof(char));
            if (data == NULL) {exit(-1);}
            char * tmpData;
            
            strcpy(data, ""A String"");
            printLine(data);
            tmpData = (char *)realloc(data, (130000)*sizeof(char));
            /* FIX: Ensure realloc() was successful before assigning data to the memory block
            * allocated with realloc() */
            if (tmpData != NULL)
            {
                data = tmpData;
                
                strcpy(data, ""New String"");
                printLine(data);
            }
            free(data);
        }
"
3100,0,CWE590_Free_Memory_Not_on_Heap__free_long_alloca_63a.c,"    long * data;
    data = NULL; 
    {
        
        long * dataBuffer = (long *)ALLOCA(100*sizeof(long));
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5L;
            }
        }
        data = dataBuffer;
    }
"
13632,0,CWE457_Use_of_Uninitialized_Variable__struct_16.c,"    twoIntsStruct data;
    while(1)
    {
        
        ; 
        break;
    }
    while(1)
    {
        
        printIntLine(data.intOne);
        printIntLine(data.intTwo);
        break;
"
2274,0,CWE467_Use_of_sizeof_on_Pointer_Type__char_01.c,"    {
        char * badChar = NULL;
        
        badChar = (char *)malloc(sizeof(badChar));
        if (badChar == NULL) {exit(-1);}
        *badChar = 'B';
        printHexCharLine(*badChar);
        free(badChar);
"
13690,1,CWE758_Undefined_Behavior__double_pointer_malloc_use_10.c,"    if(globalFalse)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            double * data;
            double * * pointer = (double * *)malloc(sizeof(double *));
            if (pointer == NULL) {exit(-1);}
            
            data = (double *)malloc(sizeof(double));
            if (data == NULL) {exit(-1);}
            *data = 5.0;
            *pointer = data; 
            {
                double * data = *pointer;
                printDoubleLine(*data);
            }
            free(pointer);
        }
"
9256,0,CWE690_NULL_Deref_From_Return__struct_calloc_53a.c,"    twoIntsStruct * data;
    data = NULL; 
    
    data = (twoIntsStruct *)calloc(1, sizeof(twoIntsStruct));
"
1212,0,CWE563_Unused_Variable__unused_uninit_variable_long_10.c,"    long data;
    
    ; 
    if(globalTrue)
    {
        
        
        ; 
"
1788,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_33.cpp,"    size_t data;
    size_t &dataRef = data;
    
    data = 0;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = strtoul(inputBuffer, NULL, 0);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    {
        size_t data = dataRef;
        {
            char * myString;
            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
             * for the strcpy() function to not cause a buffer overflow */
            
            if (data > strlen(HELLO_STRING))
            {
                myString = (char *)malloc(data*sizeof(char));
                if (myString == NULL) {exit(-1);}
                
                strcpy(myString, HELLO_STRING);
                printLine(myString);
                free(myString);
            }
            else
            {
                printLine(""Input is less than the length of the source string"");
            }
        }
"
16389,0,CWE590_Free_Memory_Not_on_Heap__delete_array_char_alloca_34.cpp,"    char * data;
    unionType myUnion;
    data = NULL; 
    {
        
        char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
        memset(dataBuffer, 'A', 100-1); 
        dataBuffer[100-1] = '\0'; 
        data = dataBuffer;
    }
    myUnion.unionFirst = data;
    {
        char * data = myUnion.unionSecond;
        printLine(data);
        
        delete [] data;
"
7382,0,CWE590_Free_Memory_Not_on_Heap__delete_int_declare_06.cpp,"    int * data;
    data = NULL; 
    if(STATIC_CONST_FIVE==5)
    {
        {
            
            int dataBuffer;
            dataBuffer = 5;
            data = &dataBuffer;
        }
    }
    printIntLine(*data);
    
"
9448,0,CWE590_Free_Memory_Not_on_Heap__delete_char_static_52a.cpp,"    char * data;
    data = NULL; 
    {
        
        static char dataBuffer;
        dataBuffer = 'A';
        data = &dataBuffer;
    }
"
9067,0,CWE416_Use_After_Free__new_delete_class_06.cpp,"    TwoIntsClass * data;
    
    data = NULL;
    if(STATIC_CONST_FIVE==5)
    {
        data = new TwoIntsClass;
        data->intOne = 1;
        data->intTwo = 2;
        
        delete data;
    }
    if(STATIC_CONST_FIVE==5)
    {
        
        printIntLine(data->intOne);
        
"
9898,0,CWE197_Numeric_Truncation_Error__int_connect_socket_to_short_11.c,"    int data;
    
    data = -1;
    if(globalReturnsTrue())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    {
        
        short shortData = (short)data;
        printShortLine(shortData);
"
829,0,CWE190_Integer_Overflow__int64_t_max_square_41.c,"    int64_t data;
    data = 0LL;
    
    data = LLONG_MAX;
"
12459,0,CWE78_OS_Command_Injection__char_listen_socket_popen_81_bad.cpp,"Label Definition File: CWE78_OS_Command_Injection.one_string.label.xml
Template File: sources-sink-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 78 OS Command Injection
 * BadSource: listen_socket Read data using a listen socket (server side)
 * GoodSource: Fixed string
 * Sinks: popen
 *    BadSink : Execute command in data using popen()
 * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE78_OS_Command_Injection__char_listen_socket_popen_81.h""


#ifdef _WIN32
#define POPEN _popen
#define PCLOSE _pclose
#else 
#define POPEN popen
#define PCLOSE pclose
#endif

namespace CWE78_OS_Command_Injection__char_listen_socket_popen_81
{

void CWE78_OS_Command_Injection__char_listen_socket_popen_81_bad::action(char * data) const
{
    {
        FILE *pipe;
        
        pipe = POPEN(data, ""w"");
        if (pipe != NULL)
        {
            PCLOSE(pipe);
        }
    }
}

}
"
8778,0,CWE190_Integer_Overflow__int_fgets_multiply_22a.c,"    int data;
    
    data = 0;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    CWE190_Integer_Overflow__int_fgets_multiply_22_badGlobal = 1; 
"
13133,0,CWE457_Use_of_Uninitialized_Variable__double_array_alloca_partial_init_63a.c,"    double * data;
    data = (double *)ALLOCA(10*sizeof(double));
    
    {
        int i;
        for(i=0; i<(10/2); i++)
        {
            data[i] = (double)i;
        }
    }
"
2761,0,CWE590_Free_Memory_Not_on_Heap__delete_long_declare_66a.cpp,"    long * data;
    long * dataArray[5];
    data = NULL; 
    {
        
        long dataBuffer;
        dataBuffer = 5L;
        data = &dataBuffer;
    }
    
    dataArray[2] = data;
"
867,1,CWE758_Undefined_Behavior__class_new_use_06.cpp,"    if(STATIC_CONST_FIVE==5)
    {
        {
            TwoIntsClass data;
            data.intOne = 1;
            data.intTwo = 2;
            TwoIntsClass * pointer = new TwoIntsClass;
            *pointer = data; 
            {
                TwoIntsClass data = *pointer;
                printIntLine(data.intOne);
                printIntLine(data.intTwo);
            }
            delete pointer;
        }
"
13564,0,CWE415_Double_Free__new_delete_array_class_42.cpp,"    TwoIntsClass * data;
    
    data = NULL;
    data = badSource(data);
    
"
10057,0,CWE134_Uncontrolled_Format_String__char_console_fprintf_13.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            
            size_t dataLen = strlen(data);
            
            if (100-dataLen > 1)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
                {
                    /* The next few lines remove the carriage return from the string that is
                     * inserted by fgets() */
                    dataLen = strlen(data);
                    if (dataLen > 0 && data[dataLen-1] == '\n')
                    {
                        data[dataLen-1] = '\0';
                    }
                }
                else
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
            }
        }
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        
        fprintf(stdout, data);
"
13790,0,CWE457_Use_of_Uninitialized_Variable__twointsclass_array_malloc_partial_init_14.cpp,"    TwoIntsClass * data;
    data = reinterpret_cast<TwoIntsClass *>(malloc(10*sizeof(TwoIntsClass)));
    if (data == NULL) {exit(-1);}
    if(globalFive==5)
    {
        
        for(int i=0; i<(10/2); i++)
        {
            data[i].intOne = i;
            data[i].intTwo = i;
        }
    }
    if(globalFive==5)
    {
        
        for(int i=0; i<10; i++)
        {
            printIntLine(data[i].intOne);
            printIntLine(data[i].intTwo);
        }
"
18129,0,CWE415_Double_Free__malloc_free_int64_t_81_bad.cpp,"Label Definition File: CWE415_Double_Free__malloc_free.label.xml
Template File: sources-sinks-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 415 Double Free
 * BadSource:  Allocate data using malloc() and Deallocate data using free()
 * GoodSource: Allocate data using malloc()
 * Sinks:
 *    GoodSink: do nothing
 *    BadSink : Deallocate data using free()
 * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE415_Double_Free__malloc_free_int64_t_81.h""

namespace CWE415_Double_Free__malloc_free_int64_t_81
{

void CWE415_Double_Free__malloc_free_int64_t_81_bad::action(int64_t * data) const
{
    
    free(data);
}

}
"
18299,0,CWE590_Free_Memory_Not_on_Heap__free_int_declare_14.c,"    int * data;
    data = NULL; 
    if(globalFive==5)
    {
        {
            
            int dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5;
                }
            }
            data = dataBuffer;
        }
    }
    printIntLine(data[0]);
    
"
2776,0,CWE401_Memory_Leak__new_int_64a.cpp,"    int * data;
    data = NULL;
    
    data = new int;
    
    *data = 5;
    printIntLine(*data);
"
11098,1,CWE758_Undefined_Behavior__struct_pointer_malloc_use_10.c,"    if(globalTrue)
    {
        {
            twoIntsStruct * data;
            twoIntsStruct * * pointer = (twoIntsStruct * *)malloc(sizeof(twoIntsStruct *));
            if (pointer == NULL) {exit(-1);}
            
            data = (twoIntsStruct *)malloc(sizeof(twoIntsStruct));
            if (data == NULL) {exit(-1);}
            data->intOne = 5;
            data->intTwo = 6;
            *pointer = data; 
            {
                twoIntsStruct * data = *pointer;
                printIntLine(data->intOne);
                printIntLine(data->intTwo);
            }
            free(pointer);
        }
"
12965,0,CWE190_Integer_Overflow__short_fscanf_multiply_31.c,"    short data;
    data = 0;
    
    fscanf (stdin, ""%hd"", &data);
    {
        short dataCopy = data;
        short data = dataCopy;
        if(data > 0) 
        {
            
            short result = data * 2;
            printIntLine(result);
        }
"
12800,0,CWE758_Undefined_Behavior__struct_pointer_malloc_use_02.c,"    if(1)
    {
        {
            twoIntsStruct * * pointer = (twoIntsStruct * *)malloc(sizeof(twoIntsStruct *));
            if (pointer == NULL) {exit(-1);}
            twoIntsStruct * data = *pointer; 
            free(pointer);
            printIntLine(data->intOne);
            printIntLine(data->intTwo);
        }
"
11078,0,CWE590_Free_Memory_Not_on_Heap__delete_array_class_static_68a.cpp,"    TwoIntsClass * data;
    data = NULL; 
    {
        
        static TwoIntsClass dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i].intOne = 1;
                dataBuffer[i].intTwo = 1;
            }
        }
        data = dataBuffer;
    }
    CWE590_Free_Memory_Not_on_Heap__delete_array_class_static_68_badData = data;
"
667,0,CWE78_OS_Command_Injection__char_environment_system_07.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(staticFive==5)
    {
        {
            
            size_t dataLen = strlen(data);
            char * environment = GETENV(ENV_VARIABLE);
            
            if (environment != NULL)
            {
                
                strncat(data+dataLen, environment, 100-dataLen-1);
            }
        }
    }
    
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
"
3187,0,CWE401_Memory_Leak__int64_t_realloc_12.c,"    int64_t * data;
    data = NULL;
    if(globalReturnsTrueOrFalse())
    {
        
        data = (int64_t *)realloc(data, 100*sizeof(int64_t));
        if (data == NULL) {exit(-1);}
        
        data[0] = 5LL;
        printLongLongLine(data[0]);
    }
    else
    {
        
        data = (int64_t *)ALLOCA(100*sizeof(int64_t));
        
        data[0] = 5LL;
        printLongLongLine(data[0]);
    }
    if(globalReturnsTrueOrFalse())
    {
        
        ; 
    }
    else
    {
        
        free(data);
"
19513,0,CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_04.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(STATIC_CONST_TRUE)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                data[dataLen + recvResult / sizeof(char)] = '\0';
                
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(STATIC_CONST_TRUE)
    {
        {
            char dest[100] = """";
            
            SNPRINTF(dest, 100-1, data);
            printLine(dest);
        }
"
15533,0,CWE190_Integer_Overflow__char_fscanf_square_22a.c,"    char data;
    data = ' ';
    
    fscanf (stdin, ""%c"", &data);
    CWE190_Integer_Overflow__char_fscanf_square_22_badGlobal = 1; 
"
17550,0,CWE369_Divide_by_Zero__int_rand_modulo_53a.c,"    int data;
    
    data = -1;
    
    data = RAND32();
"
16982,0,CWE190_Integer_Overflow__int_listen_socket_square_17.c,"    int i,j;
    int data;
    
    data = 0;
    for(i = 0; i < 1; i++)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    for(j = 0; j < 1; j++)
    {
        {
            
            int result = data * data;
            printIntLine(result);
        }
"
9026,0,CWE789_Uncontrolled_Mem_Alloc__new_char_rand_82a.cpp,"    size_t data;
    
    data = 0;
    
    data = rand();
    CWE789_Uncontrolled_Mem_Alloc__new_char_rand_82_base* baseObject = new CWE789_Uncontrolled_Mem_Alloc__new_char_rand_82_bad;
    baseObject->action(data);
"
4857,1,CWE476_NULL_Pointer_Dereference__binary_if_15.c,"    switch(5)
    {
    case 6:
        
        printLine(""Benign, fixed string"");
        break;
    default:
    {
        twoIntsStruct *twoIntsStructPointer = NULL;
        /* FIX: Use && in the if statement so that if the left side of the expression fails then
         * the right side will not be evaluated */
        if ((twoIntsStructPointer != NULL) && (twoIntsStructPointer->intOne == 5))
        {
            printLine(""intOne == 5"");
        }
    }
    break;
"
15220,0,CWE197_Numeric_Truncation_Error__short_fscanf_83a.cpp,"    short data;
    
    data = -1;
"
12573,0,CWE416_Use_After_Free__new_delete_array_char_64a.cpp,"    char * data;
    
    data = NULL;
    data = new char[100];
    memset(data, 'A', 100-1);
    data[100-1] = '\0';
    
    delete [] data;
"
15039,0,CWE401_Memory_Leak__int_realloc_08.c,"    int * data;
    data = NULL;
    if(staticReturnsTrue())
    {
        
        data = (int *)realloc(data, 100*sizeof(int));
        if (data == NULL) {exit(-1);}
        
        data[0] = 5;
        printIntLine(data[0]);
    }
    if(staticReturnsTrue())
    {
        
        ; 
"
5385,0,CWE190_Integer_Overflow__int_connect_socket_multiply_31.c,"    int data;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    {
        int dataCopy = data;
        int data = dataCopy;
        if(data > 0) 
        {
            
            int result = data * 2;
            printIntLine(result);
        }
"
15740,0,CWE457_Use_of_Uninitialized_Variable__struct_array_alloca_partial_init_02.c,"    twoIntsStruct * data;
    data = (twoIntsStruct *)ALLOCA(10*sizeof(twoIntsStruct));
    if(1)
    {
        
        {
            int i;
            for(i=0; i<(10/2); i++)
            {
                data[i].intOne = i;
                data[i].intTwo = i;
            }
        }
    }
    if(1)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i].intOne);
                printIntLine(data[i].intTwo);
            }
        }
"
2268,0,CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_01.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
"
120,0,CWE590_Free_Memory_Not_on_Heap__delete_array_class_declare_66a.cpp,"    TwoIntsClass * data;
    TwoIntsClass * dataArray[5];
    data = NULL; 
    {
        
        TwoIntsClass dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i].intOne = 1;
                dataBuffer[i].intTwo = 1;
            }
        }
        data = dataBuffer;
    }
    
    dataArray[2] = data;
"
12297,0,CWE190_Integer_Overflow__short_fscanf_postinc_63a.c,"    short data;
    data = 0;
    
    fscanf (stdin, ""%hd"", &data);
"
260,0,CWE590_Free_Memory_Not_on_Heap__delete_array_int_static_44.cpp,"    int * data;
    
    void (*funcPtr) (int *) = badSink;
    data = NULL; 
    {
        
        static int dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5;
            }
        }
        data = dataBuffer;
    }
    
"
15561,1,CWE758_Undefined_Behavior__double_pointer_malloc_use_09.c,"    if(GLOBAL_CONST_TRUE)
    {
        {
            double * data;
            double * * pointer = (double * *)malloc(sizeof(double *));
            if (pointer == NULL) {exit(-1);}
            
            data = (double *)malloc(sizeof(double));
            if (data == NULL) {exit(-1);}
            *data = 5.0;
            *pointer = data; 
            {
                double * data = *pointer;
                printDoubleLine(*data);
            }
            free(pointer);
        }
"
17420,0,CWE401_Memory_Leak__struct_twoIntsStruct_calloc_45.c,"    struct _twoIntsStruct * data;
    data = NULL;
    
    data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));
    if (data == NULL) {exit(-1);}
    
    data[0].intOne = 0;
    data[0].intTwo = 0;
    printStructLine((twoIntsStruct *)&data[0]);
    CWE401_Memory_Leak__struct_twoIntsStruct_calloc_45_badData = data;
"
11137,0,CWE590_Free_Memory_Not_on_Heap__free_int_alloca_41.c,"    int * data;
    data = NULL; 
    {
        
        int * dataBuffer = (int *)ALLOCA(100*sizeof(int));
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5;
            }
        }
        data = dataBuffer;
    }
"
11124,0,CWE789_Uncontrolled_Mem_Alloc__new_char_fgets_68a.cpp,"    size_t data;
    
    data = 0;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = strtoul(inputBuffer, NULL, 0);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    badData = data;
"
17178,0,CWE78_OS_Command_Injection__char_connect_socket_system_67a.c,"    char * data;
    CWE78_OS_Command_Injection__char_connect_socket_system_67_structType myStruct;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    myStruct.structFirst = data;
"
5366,1,CWE758_Undefined_Behavior__struct_alloca_use_18.c,"    goto sink;
sink:
    {
        twoIntsStruct data;
        twoIntsStruct * pointer = (twoIntsStruct *)ALLOCA(sizeof(twoIntsStruct));
        data.intOne = 1;
        data.intTwo = 2;
        *pointer = data; 
        {
            twoIntsStruct data = *pointer;
            printIntLine(data.intOne);
            printIntLine(data.intTwo);
        }
"
18309,0,CWE78_OS_Command_Injection__char_file_execlp_42.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    data = badSource(data);
    /* execlp - searches for the location of the command among
     * the directories specified by the PATH environment variable */
    
"
3538,0,CWE190_Integer_Overflow__int64_t_max_square_81_bad.cpp,"Label Definition File: CWE190_Integer_Overflow.label.xml
Template File: sources-sinks-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 190 Integer Overflow
 * BadSource: max Set data to the max value for int64_t
 * GoodSource: Set data to a small, non-zero number (two)
 * Sinks: square
 *    GoodSink: Ensure there will not be an overflow before squaring data
 *    BadSink : Square data, which can lead to overflow
 * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE190_Integer_Overflow__int64_t_max_square_81.h""

#include <math.h>

namespace CWE190_Integer_Overflow__int64_t_max_square_81
{

void CWE190_Integer_Overflow__int64_t_max_square_81_bad::action(int64_t data) const
{
    {
        
        int64_t result = data * data;
        printLongLongLine(result);
    }
}

}
"
11232,0,CWE190_Integer_Overflow__int_max_add_68a.c,"    int data;
    
    data = 0;
    
    data = INT_MAX;
    CWE190_Integer_Overflow__int_max_add_68_badData = data;
"
13118,0,CWE590_Free_Memory_Not_on_Heap__delete_long_static_03.cpp,"    long * data;
    data = NULL; 
    if(5==5)
    {
        {
            
            static long dataBuffer;
            dataBuffer = 5L;
            data = &dataBuffer;
        }
    }
    printLongLine(*data);
    
"
5608,0,CWE369_Divide_by_Zero__int_connect_socket_modulo_05.c,"    int data;
    
    data = -1;
    if(staticTrue)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(staticTrue)
    {
        
        printIntLine(100 % data);
"
2141,1,CWE758_Undefined_Behavior__int_pointer_alloca_use_10.c,"    if(globalTrue)
    {
        {
            int * data;
            int * * pointer = (int * *)ALLOCA(sizeof(int *));
            
            data = (int *)malloc(sizeof(int));
            if (data == NULL) {exit(-1);}
            *data = 5;
            *pointer = data; 
            {
                int * data = *pointer;
                printIntLine(*data);
            }
        }
"
1316,0,CWE457_Use_of_Uninitialized_Variable__twointsclass_array_declare_partial_init_16.cpp,"    TwoIntsClass * data;
    TwoIntsClass dataUninitArray[10];
    data = dataUninitArray;
    while(1)
    {
        
        for(int i=0; i<(10/2); i++)
        {
            data[i].intOne = i;
            data[i].intTwo = i;
        }
        break;
    }
    while(1)
    {
        
        for(int i=0; i<10; i++)
        {
            printIntLine(data[i].intOne);
            printIntLine(data[i].intTwo);
        }
        break;
"
19202,0,CWE690_NULL_Deref_From_Return__char_malloc_84_bad.cpp,"Label Definition File: CWE690_NULL_Deref_From_Return.free.label.xml
Template File: source-sinks-84_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 690 Unchecked Return Value To NULL Pointer
 * BadSource: malloc Allocate data using malloc()
 * Sinks:
 *    GoodSink: Check to see if the data allocation failed and if not, use data
 *    BadSink : Don't check for NULL and use data
 * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE690_NULL_Deref_From_Return__char_malloc_84.h""

namespace CWE690_NULL_Deref_From_Return__char_malloc_84
{
CWE690_NULL_Deref_From_Return__char_malloc_84_bad::CWE690_NULL_Deref_From_Return__char_malloc_84_bad(char * dataCopy)
{
    data = dataCopy;
    
    data = (char *)malloc(20*sizeof(char));
}

CWE690_NULL_Deref_From_Return__char_malloc_84_bad::~CWE690_NULL_Deref_From_Return__char_malloc_84_bad()
{
    
    strcpy(data, ""Initialize"");
    printLine(data);
    free(data);
}
}
"
11414,0,CWE415_Double_Free__malloc_free_long_09.c,"    long * data;
    
    data = NULL;
    if(GLOBAL_CONST_TRUE)
    {
        data = (long *)malloc(100*sizeof(long));
        if (data == NULL) {exit(-1);}
        
        free(data);
    }
    if(GLOBAL_CONST_TRUE)
    {
        
        free(data);
"
12117,0,CWE190_Integer_Overflow__char_rand_postinc_66a.c,"    char data;
    char dataArray[5];
    data = ' ';
    
    data = (char)RAND32();
    
    dataArray[2] = data;
"
5041,0,CWE190_Integer_Overflow__int64_t_rand_add_68a.c,"    int64_t data;
    data = 0LL;
    
    data = (int64_t)RAND64();
    CWE190_Integer_Overflow__int64_t_rand_add_68_badData = data;
"
10311,0,CWE190_Integer_Overflow__int_listen_socket_multiply_02.c,"    int data;
    
    data = 0;
    if(1)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(1)
    {
        if(data > 0) 
        {
            
            int result = data * 2;
            printIntLine(result);
        }
"
17890,0,CWE690_NULL_Deref_From_Return__long_realloc_42.c,"    long * data;
    data = NULL; 
    data = badSource(data);
    
    data[0] = 5L;
    printLongLine(data[0]);
"
19157,0,CWE190_Integer_Overflow__char_rand_square_67a.c,"    char data;
    CWE190_Integer_Overflow__char_rand_square_67_structType myStruct;
    data = ' ';
    
    data = (char)RAND32();
    myStruct.structFirst = data;
"
7961,1,CWE758_Undefined_Behavior__char_pointer_alloca_use_15.c,"    switch(5)
    {
    case 6:
        
        printLine(""Benign, fixed string"");
        break;
    default:
    {
        char * data;
        char * * pointer = (char * *)ALLOCA(sizeof(char *));
        data = ""string"";
        *pointer = data; 
        {
            char * data = *pointer;
            printLine(data);
        }
    }
    break;
"
2474,0,CWE401_Memory_Leak__int64_t_realloc_09.c,"    int64_t * data;
    data = NULL;
    if(GLOBAL_CONST_TRUE)
    {
        
        data = (int64_t *)realloc(data, 100*sizeof(int64_t));
        if (data == NULL) {exit(-1);}
        
        data[0] = 5LL;
        printLongLongLine(data[0]);
    }
    if(GLOBAL_CONST_TRUE)
    {
        
        ; 
"
4564,0,CWE78_OS_Command_Injection__char_connect_socket_system_81_bad.cpp,"Label Definition File: CWE78_OS_Command_Injection.one_string.label.xml
Template File: sources-sink-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 78 OS Command Injection
 * BadSource: connect_socket Read data using a connect socket (client side)
 * GoodSource: Fixed string
 * Sinks: system
 *    BadSink : Execute command in data using system()
 * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE78_OS_Command_Injection__char_connect_socket_system_81.h""
"
11081,0,CWE369_Divide_by_Zero__float_fscanf_83_bad.cpp,"Label Definition File: CWE369_Divide_by_Zero__float.label.xml
Template File: sources-sinks-83_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 369 Divide by Zero
 * BadSource: fscanf Read data from the console using fscanf()
 * GoodSource: A hardcoded non-zero number (two)
 * Sinks:
 *    GoodSink: Check value of or near zero before dividing
 *    BadSink : Divide a constant by data
 * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE369_Divide_by_Zero__float_fscanf_83.h""

namespace CWE369_Divide_by_Zero__float_fscanf_83
{
CWE369_Divide_by_Zero__float_fscanf_83_bad::CWE369_Divide_by_Zero__float_fscanf_83_bad(float dataCopy)
{
    data = dataCopy;
    
    fscanf (stdin, ""%f"", &data);
}

CWE369_Divide_by_Zero__float_fscanf_83_bad::~CWE369_Divide_by_Zero__float_fscanf_83_bad()
{
    {
        
        int result = (int)(100.0 / data);
        printIntLine(result);
    }
}
}
"
19273,1,CWE758_Undefined_Behavior__struct_malloc_use_06.c,"    if(STATIC_CONST_FIVE==5)
    {
        {
            twoIntsStruct data;
            twoIntsStruct * pointer = (twoIntsStruct *)malloc(sizeof(twoIntsStruct));
            if (pointer == NULL) {exit(-1);}
            data.intOne = 1;
            data.intTwo = 2;
            *pointer = data; 
            {
                twoIntsStruct data = *pointer;
                printIntLine(data.intOne);
                printIntLine(data.intTwo);
            }
            free(pointer);
        }
"
19038,0,CWE416_Use_After_Free__new_delete_class_01.cpp,"    TwoIntsClass * data;
    
    data = NULL;
    data = new TwoIntsClass;
    data->intOne = 1;
    data->intTwo = 2;
    
    delete data;
    
    printIntLine(data->intOne);
"
10590,0,CWE197_Numeric_Truncation_Error__short_listen_socket_12.c,"    short data;
    
    data = -1;
    if(globalReturnsTrueOrFalse())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = (short)atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    else
    {
        
        data = CHAR_MAX-5;
    }
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
2375,0,CWE190_Integer_Overflow__unsigned_int_max_postinc_66a.c,"    unsigned int data;
    unsigned int dataArray[5];
    data = 0;
    
    data = UINT_MAX;
    
    dataArray[2] = data;
"
14529,0,CWE758_Undefined_Behavior__char_pointer_new_use_02.cpp,"    if(1)
    {
        {
            char * * pointer = new char *;
            char * data = *pointer; 
            delete pointer;
            printLine(data);
        }
"
12369,0,CWE190_Integer_Overflow__short_max_add_05.c,"    short data;
    data = 0;
    if(staticTrue)
    {
        
        data = SHRT_MAX;
    }
    if(staticTrue)
    {
        {
            
            short result = data + 1;
            printIntLine(result);
        }
"
17729,0,CWE690_NULL_Deref_From_Return__long_calloc_45.c,"    long * data;
    data = NULL; 
    
    data = (long *)calloc(1, sizeof(long));
    CWE690_NULL_Deref_From_Return__long_calloc_45_badData = data;
"
8470,0,CWE415_Double_Free__new_delete_array_char_83_bad.cpp,"Label Definition File: CWE415_Double_Free__new_delete_array.label.xml
Template File: sources-sinks-83_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 415 Double Free
 * BadSource:  Allocate data using new and Deallocae data using delete
 * GoodSource: Allocate data using new
 * Sinks:
 *    GoodSink: do nothing
 *    BadSink : Deallocate data using delete
 * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE415_Double_Free__new_delete_array_char_83.h""

namespace CWE415_Double_Free__new_delete_array_char_83
{
CWE415_Double_Free__new_delete_array_char_83_bad::CWE415_Double_Free__new_delete_array_char_83_bad(char * dataCopy)
{
    data = dataCopy;
    data = new char[100];
    
    delete [] data;
}

CWE415_Double_Free__new_delete_array_char_83_bad::~CWE415_Double_Free__new_delete_array_char_83_bad()
{
    
    delete [] data;
}
}
"
16073,0,CWE590_Free_Memory_Not_on_Heap__free_long_static_41.c,"    long * data;
    data = NULL; 
    {
        
        static long dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5L;
            }
        }
        data = dataBuffer;
    }
"
15839,0,CWE590_Free_Memory_Not_on_Heap__delete_array_long_declare_72a.cpp,"    long * data;
    vector<long *> dataVector;
    data = NULL; 
    {
        
        long dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5L;
            }
        }
        data = dataBuffer;
    }
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
6623,0,CWE457_Use_of_Uninitialized_Variable__new_struct_array_no_init_04.cpp,"    twoIntsStruct * data;
    data = new twoIntsStruct[10];
    if(STATIC_CONST_TRUE)
    {
        
        ; 
    }
    if(STATIC_CONST_TRUE)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i].intOne);
                printIntLine(data[i].intTwo);
            }
        }
        
        delete [] data;
"
10152,0,CWE134_Uncontrolled_Format_String__char_environment_snprintf_83_bad.cpp,"Label Definition File: CWE134_Uncontrolled_Format_String.label.xml
Template File: sources-sinks-83_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 134 Uncontrolled Format String
 * BadSource: environment Read input from an environment variable
 * GoodSource: Copy a fixed string into data
 * Sinks: snprintf
 *    GoodSink: snprintf with ""%s"" as the third argument and data as the fourth
 *    BadSink : snprintf with data as the third argument
 * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE134_Uncontrolled_Format_String__char_environment_snprintf_83.h""

#define ENV_VARIABLE ""ADD""

#ifdef _WIN32
#define GETENV getenv
#else
#define GETENV getenv
#endif

#ifdef _WIN32
#define SNPRINTF _snprintf
#else
#define SNPRINTF snprintf
#endif

namespace CWE134_Uncontrolled_Format_String__char_environment_snprintf_83
{
CWE134_Uncontrolled_Format_String__char_environment_snprintf_83_bad::CWE134_Uncontrolled_Format_String__char_environment_snprintf_83_bad(char * dataCopy)
{
    data = dataCopy;
    {
        
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        
        if (environment != NULL)
        {
            
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
}

CWE134_Uncontrolled_Format_String__char_environment_snprintf_83_bad::~CWE134_Uncontrolled_Format_String__char_environment_snprintf_83_bad()
{
    {
        char dest[100] = """";
        
        SNPRINTF(dest, 100-1, data);
        printLine(dest);
    }
}
}
"
16806,0,CWE197_Numeric_Truncation_Error__int_fgets_to_short_82_bad.cpp,"Label Definition File: CWE197_Numeric_Truncation_Error__int.label.xml
Template File: sources-sink-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 197 Numeric Truncation Error
 * BadSource: fgets Read data from the console using fgets()
 * GoodSource: Less than CHAR_MAX
 * Sinks: to_short
 *    BadSink : Convert data to a short
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE197_Numeric_Truncation_Error__int_fgets_to_short_82.h""

namespace CWE197_Numeric_Truncation_Error__int_fgets_to_short_82
{

void CWE197_Numeric_Truncation_Error__int_fgets_to_short_82_bad::action(int data)
{
    {
        
        short shortData = (short)data;
        printShortLine(shortData);
    }
}

}
"
1821,0,CWE590_Free_Memory_Not_on_Heap__free_struct_alloca_14.c,"    twoIntsStruct * data;
    data = NULL; 
    if(globalFive==5)
    {
        {
            
            twoIntsStruct * dataBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i].intOne = 1;
                    dataBuffer[i].intTwo = 1;
                }
            }
            data = dataBuffer;
        }
    }
    printStructLine(&data[0]);
    
"
8459,0,CWE590_Free_Memory_Not_on_Heap__free_int64_t_static_54a.c,"    int64_t * data;
    data = NULL; 
    {
        
        static int64_t dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5LL;
            }
        }
        data = dataBuffer;
    }
"
10866,0,CWE190_Integer_Overflow__int_listen_socket_postinc_12.c,"    int data;
    
    data = 0;
    if(globalReturnsTrueOrFalse())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    else
    {
        
        data = 2;
    }
    if(globalReturnsTrueOrFalse())
    {
        {
            
            data++;
            int result = data;
            printIntLine(result);
        }
    }
    else
    {
        
        if (data < INT_MAX)
        {
            data++;
            int result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
"
4128,0,CWE78_OS_Command_Injection__char_console_system_42.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    data = badSource(data);
    
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
    }
}

#endif 

#ifndef OMITGOOD

static char * goodG2BSource(char * data)
"
13674,0,CWE134_Uncontrolled_Format_String__char_console_vfprintf_63a.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        
        if (100-dataLen > 1)
        {
            
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgets() */
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
                    data[dataLen-1] = '\0';
                }
            }
            else
            {
                printLine(""fgets() failed"");
                
                data[dataLen] = '\0';
            }
        }
    }
"
3394,1,CWE758_Undefined_Behavior__struct_malloc_use_16.c,"    while(1)
    {
        {
            twoIntsStruct data;
            twoIntsStruct * pointer = (twoIntsStruct *)malloc(sizeof(twoIntsStruct));
            if (pointer == NULL) {exit(-1);}
            data.intOne = 1;
            data.intTwo = 2;
            *pointer = data; 
            {
                twoIntsStruct data = *pointer;
                printIntLine(data.intOne);
                printIntLine(data.intTwo);
            }
            free(pointer);
        }
        break;
"
6943,0,CWE789_Uncontrolled_Mem_Alloc__new_char_fgets_54a.cpp,"    size_t data;
    
    data = 0;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = strtoul(inputBuffer, NULL, 0);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
"
18252,0,CWE590_Free_Memory_Not_on_Heap__delete_array_class_alloca_06.cpp,"    TwoIntsClass * data;
    data = NULL; 
    if(STATIC_CONST_FIVE==5)
    {
        {
            
            TwoIntsClass * dataBuffer = (TwoIntsClass *)ALLOCA(100*sizeof(TwoIntsClass));
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i].intOne = 1;
                    dataBuffer[i].intTwo = 1;
                }
            }
            data = dataBuffer;
        }
    }
    printIntLine(data[0].intOne);
    
"
14192,0,CWE190_Integer_Overflow__int_max_square_84a.cpp,"    int data;
    
    data = 0;
    CWE190_Integer_Overflow__int_max_square_84_bad * badObject = new CWE190_Integer_Overflow__int_max_square_84_bad(data);
"
508,0,CWE369_Divide_by_Zero__int_connect_socket_modulo_06.c,"    int data;
    
    data = -1;
    if(STATIC_CONST_FIVE==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(STATIC_CONST_FIVE==5)
    {
        
        printIntLine(100 % data);
"
13707,0,CWE134_Uncontrolled_Format_String__char_environment_printf_82a.cpp,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        
        if (environment != NULL)
        {
            
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    CWE134_Uncontrolled_Format_String__char_environment_printf_82_base* baseObject = new CWE134_Uncontrolled_Format_String__char_environment_printf_82_bad;
    baseObject->action(data);
"
16764,0,CWE197_Numeric_Truncation_Error__short_large_51a.c,"    short data;
    
    data = -1;
    
    data = CHAR_MAX + 1;
"
7037,0,CWE401_Memory_Leak__char_calloc_04.c,"    char * data;
    data = NULL;
    if(STATIC_CONST_TRUE)
    {
        
        data = (char *)calloc(100, sizeof(char));
        if (data == NULL) {exit(-1);}
        
        strcpy(data, ""A String"");
        printLine(data);
    }
    if(STATIC_CONST_TRUE)
    {
        
        ; 
"
16587,0,CWE369_Divide_by_Zero__float_listenSocket_74a.cpp,"    float data;
    map<int, float> dataMap;
    
    data = 0.0F;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = (float)atof(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
17752,0,CWE190_Integer_Overflow__int_fscanf_multiply_41.c,"    int data;
    
    data = 0;
    
    fscanf(stdin, ""%d"", &data);
"
5036,0,CWE190_Integer_Overflow__unsigned_int_max_add_16.c,"    unsigned int data;
    data = 0;
    while(1)
    {
        
        data = UINT_MAX;
        break;
    }
    while(1)
    {
        {
            
            unsigned int result = data + 1;
            printUnsignedLine(result);
        }
        break;
"
11930,0,CWE190_Integer_Overflow__int_fscanf_postinc_34.c,"    int data;
    CWE190_Integer_Overflow__int_fscanf_postinc_34_unionType myUnion;
    
    data = 0;
    
    fscanf(stdin, ""%d"", &data);
    myUnion.unionFirst = data;
    {
        int data = myUnion.unionSecond;
        {
            
            data++;
            int result = data;
            printIntLine(result);
        }
"
16456,0,CWE690_NULL_Deref_From_Return__char_malloc_74a.cpp,"    char * data;
    map<int, char *> dataMap;
    data = NULL; 
    
    data = (char *)malloc(20*sizeof(char));
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
10071,1,CWE252_Unchecked_Return_Value__char_fscanf_07.c,"    if(staticFive==5)
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            
            if (fscanf(stdin, ""%99s\0"", data) == EOF)
            {
                printLine(""fscanf failed!"");
            }
        }
"
6847,0,CWE190_Integer_Overflow__short_fscanf_add_12.c,"    short data;
    data = 0;
    if(globalReturnsTrueOrFalse())
    {
        
        fscanf (stdin, ""%hd"", &data);
    }
    else
    {
        
        data = 2;
    }
    if(globalReturnsTrueOrFalse())
    {
        {
            
            short result = data + 1;
            printIntLine(result);
        }
    }
    else
    {
        
        if (data < SHRT_MAX)
        {
            short result = data + 1;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
"
1098,0,CWE190_Integer_Overflow__int_rand_add_64a.c,"    int data;
    
    data = 0;
    
    data = RAND32();
"
5358,0,CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_14.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(globalFive==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                data[dataLen + recvResult / sizeof(char)] = '\0';
                
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(globalFive==5)
    {
        badVaSinkB(data, data);
"
7944,0,CWE457_Use_of_Uninitialized_Variable__int_array_malloc_partial_init_04.c,"    int * data;
    data = (int *)malloc(10*sizeof(int));
    if (data == NULL) {exit(-1);}
    if(STATIC_CONST_TRUE)
    {
        
        {
            int i;
            for(i=0; i<(10/2); i++)
            {
                data[i] = i;
            }
        }
    }
    if(STATIC_CONST_TRUE)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i]);
            }
        }
"
18612,0,CWE190_Integer_Overflow__int_fscanf_multiply_08.c,"    int data;
    
    data = 0;
    if(staticReturnsTrue())
    {
        
        fscanf(stdin, ""%d"", &data);
    }
    if(staticReturnsTrue())
    {
        if(data > 0) 
        {
            
            int result = data * 2;
            printIntLine(result);
        }
"
17902,0,CWE197_Numeric_Truncation_Error__int_large_to_char_05.c,"    int data;
    
    data = -1;
    if(staticTrue)
    {
        
        data = SHRT_MAX + 5;
    }
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
17797,1,CWE758_Undefined_Behavior__long_alloca_use_08.c,"    if(staticReturnsTrue())
    {
        {
            long data;
            long * pointer = (long *)ALLOCA(sizeof(long));
            data = 5L;
            *pointer = data; 
            {
                long data = *pointer;
                printLongLine(data);
            }
        }
"
8478,0,CWE758_Undefined_Behavior__long_alloca_use_11.c,"    if(globalReturnsTrue())
    {
        {
            long * pointer = (long *)ALLOCA(sizeof(long));
            long data = *pointer; 
            printLongLine(data);
        }
"
18278,0,CWE197_Numeric_Truncation_Error__short_listen_socket_81_bad.cpp,"Label Definition File: CWE197_Numeric_Truncation_Error__short.label.xml
Template File: sources-sink-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 197 Numeric Truncation Error
 * BadSource: listen_socket Read data using a listen socket (server side)
 * GoodSource: Less than CHAR_MAX
 * Sinks:
 *    BadSink : Convert data to a char
 * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE197_Numeric_Truncation_Error__short_listen_socket_81.h""

namespace CWE197_Numeric_Truncation_Error__short_listen_socket_81
{

void CWE197_Numeric_Truncation_Error__short_listen_socket_81_bad::action(short data) const
{
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
    }
}

}
"
1502,0,CWE690_NULL_Deref_From_Return__struct_calloc_72a.cpp,"    twoIntsStruct * data;
    vector<twoIntsStruct *> dataVector;
    data = NULL; 
    
    data = (twoIntsStruct *)calloc(1, sizeof(twoIntsStruct));
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
17700,0,CWE590_Free_Memory_Not_on_Heap__free_char_alloca_11.c,"    char * data;
    data = NULL; 
    if(globalReturnsTrue())
    {
        {
            
            char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
            memset(dataBuffer, 'A', 100-1); 
            dataBuffer[100-1] = '\0'; 
            data = dataBuffer;
        }
    }
    printLine(data);
    
"
8211,0,CWE476_NULL_Pointer_Dereference__binary_if_02.c,"    if(1)
    {
        {
            twoIntsStruct *twoIntsStructPointer = NULL;
            /* FLAW: Using a single & in the if statement will cause both sides of the expression to be evaluated
             * thus causing a NPD */
            if ((twoIntsStructPointer != NULL) & (twoIntsStructPointer->intOne == 5))
            {
                printLine(""intOne == 5"");
            }
        }
"
16721,0,CWE590_Free_Memory_Not_on_Heap__free_long_declare_52a.c,"    long * data;
    data = NULL; 
    {
        
        long dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5L;
            }
        }
        data = dataBuffer;
    }
"
5762,0,CWE134_Uncontrolled_Format_String__char_environment_printf_53a.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        
        if (environment != NULL)
        {
            
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
"
8512,0,CWE590_Free_Memory_Not_on_Heap__delete_array_int64_t_alloca_05.cpp,"    int64_t * data;
    data = NULL; 
    if(staticTrue)
    {
        {
            
            int64_t * dataBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5LL;
                }
            }
            data = dataBuffer;
        }
    }
    printLongLongLine(data[0]);
    
"
9277,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_16.c,"    size_t data;
    
    data = 0;
    while(1)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = strtoul(inputBuffer, NULL, 0);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
        break;
    }
    while(1)
    {
        {
            char * myString;
            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
             * for the strcpy() function to not cause a buffer overflow */
            
            if (data > strlen(HELLO_STRING))
            {
                myString = (char *)malloc(data*sizeof(char));
                if (myString == NULL) {exit(-1);}
                
                strcpy(myString, HELLO_STRING);
                printLine(myString);
                free(myString);
            }
            else
            {
                printLine(""Input is less than the length of the source string"");
            }
        }
        break;
"
1877,0,CWE415_Double_Free__new_delete_class_81a.cpp,"    TwoIntsClass * data;
    
    data = NULL;
    data = new TwoIntsClass;
    
    delete data;
    const CWE415_Double_Free__new_delete_class_81_base& o = CWE415_Double_Free__new_delete_class_81_bad();
"
3431,0,CWE758_Undefined_Behavior__long_alloca_use_04.c,"    if(STATIC_CONST_TRUE)
    {
        {
            long * pointer = (long *)ALLOCA(sizeof(long));
            long data = *pointer; 
            printLongLine(data);
        }
"
18202,0,CWE590_Free_Memory_Not_on_Heap__delete_class_static_04.cpp,"    TwoIntsClass * data;
    data = NULL; 
    if(STATIC_CONST_TRUE)
    {
        {
            
            static TwoIntsClass dataBuffer;
            dataBuffer.intOne = 1;
            dataBuffer.intTwo = 1;
            data = &dataBuffer;
        }
    }
    printIntLine(data->intOne);
    
"
1525,0,CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_51a.c,"    int data;
    
    data = -1;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
5773,0,CWE590_Free_Memory_Not_on_Heap__delete_array_class_static_81_bad.cpp,"Label Definition File: CWE590_Free_Memory_Not_on_Heap__delete_array.label.xml
Template File: sources-sink-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 590 Free Memory Not on Heap
 * BadSource: static Data buffer is declared static on the stack
 * GoodSource: Allocate memory on the heap
 * Sinks:
 *    BadSink : Print then free data
 * Flow Variant: 81 Data flow: data passed in a parameter to a virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE590_Free_Memory_Not_on_Heap__delete_array_class_static_81.h""

namespace CWE590_Free_Memory_Not_on_Heap__delete_array_class_static_81
{

void CWE590_Free_Memory_Not_on_Heap__delete_array_class_static_81_bad::action(TwoIntsClass * data) const
{
    printIntLine(data[0].intOne);
    
    delete [] data;
}

}
"
11049,0,CWE415_Double_Free__new_delete_long_73a.cpp,"    long * data;
    list<long *> dataList;
    
    data = NULL;
    data = new long;
    
    delete data;
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
13333,0,CWE758_Undefined_Behavior__struct_pointer_alloca_use_13.c,"    if(GLOBAL_CONST_FIVE==5)
    {
        {
            twoIntsStruct * * pointer = (twoIntsStruct * *)ALLOCA(sizeof(twoIntsStruct *));
            twoIntsStruct * data = *pointer; 
            printIntLine(data->intOne);
            printIntLine(data->intTwo);
        }
"
6978,1,CWE401_Memory_Leak__malloc_realloc_char_05.c,"    if(staticFalse)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            char * data = (char *)malloc(100*sizeof(char));
            if (data == NULL) {exit(-1);}
            char * tmpData;
            
            strcpy(data, ""A String"");
            printLine(data);
            tmpData = (char *)realloc(data, (130000)*sizeof(char));
            /* FIX: Ensure realloc() was successful before assigning data to the memory block
            * allocated with realloc() */
            if (tmpData != NULL)
            {
                data = tmpData;
                
                strcpy(data, ""New String"");
                printLine(data);
            }
            free(data);
        }
"
14186,0,CWE416_Use_After_Free__malloc_free_char_07.c,"    char * data;
    
    data = NULL;
    if(staticFive==5)
    {
        data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        memset(data, 'A', 100-1);
        data[100-1] = '\0';
        
        free(data);
    }
    if(staticFive==5)
    {
        
        printLine(data);
        
"
15933,0,CWE190_Integer_Overflow__int_fgets_multiply_73a.cpp,"    int data;
    list<int> dataList;
    
    data = 0;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
9943,0,CWE134_Uncontrolled_Format_String__char_environment_vfprintf_52a.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        
        if (environment != NULL)
        {
            
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
"
10030,1,CWE758_Undefined_Behavior__int64_t_malloc_use_11.c,"    if(globalReturnsTrue())
    {
        {
            int64_t data;
            int64_t * pointer = (int64_t *)malloc(sizeof(int64_t));
            if (pointer == NULL) {exit(-1);}
            data = 5LL;
            *pointer = data; 
            {
                int64_t data = *pointer;
                printLongLongLine(data);
            }
            free(pointer);
        }
"
9296,0,CWE401_Memory_Leak__strdup_char_45.c,"    char * data;
    data = NULL;
    {
        char myString[] = ""myString"";
        
        data = strdup(myString);
        
        printLine(data);
    }
    CWE401_Memory_Leak__strdup_char_45_badData = data;
"
4957,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_43.cpp,"    size_t data;
    
    data = 0;
    badSource(data);
    {
        char * myString;
        /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
         * for the strcpy() function to not cause a buffer overflow */
        
        if (data > strlen(HELLO_STRING))
        {
            myString = (char *)malloc(data*sizeof(char));
            if (myString == NULL) {exit(-1);}
            
            strcpy(myString, HELLO_STRING);
            printLine(myString);
            free(myString);
        }
        else
        {
            printLine(""Input is less than the length of the source string"");
        }
"
13618,0,CWE590_Free_Memory_Not_on_Heap__delete_long_declare_63a.cpp,"    long * data;
    data = NULL; 
    {
        
        long dataBuffer;
        dataBuffer = 5L;
        data = &dataBuffer;
    }
"
12485,0,CWE758_Undefined_Behavior__char_pointer_alloca_use_16.c,"    while(1)
    {
        {
            char * * pointer = (char * *)ALLOCA(sizeof(char *));
            char * data = *pointer; 
            printLine(data);
        }
        break;
"
6557,0,CWE190_Integer_Overflow__int64_t_max_multiply_02.c,"    int64_t data;
    data = 0LL;
    if(1)
    {
        
        data = LLONG_MAX;
    }
    if(1)
    {
        if(data > 0) 
        {
            
            int64_t result = data * 2;
            printLongLongLine(result);
        }
"
787,0,CWE369_Divide_by_Zero__float_rand_83a.cpp,"    float data;
    
    data = 0.0F;
"
15179,0,CWE190_Integer_Overflow__int_listen_socket_square_31.c,"    int data;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    {
        int dataCopy = data;
        int data = dataCopy;
        {
            
            int result = data * data;
            printIntLine(result);
        }
"
1226,0,CWE369_Divide_by_Zero__float_zero_65a.c,"    float data;
    
    void (*funcPtr) (float) = CWE369_Divide_by_Zero__float_zero_65b_badSink;
    
    data = 0.0F;
    
    data = 0.0F;
    
"
2019,0,CWE476_NULL_Pointer_Dereference__char_68a.c,"    char * data;
    
    data = NULL;
    CWE476_NULL_Pointer_Dereference__char_68_badData = data;
"
3164,0,CWE476_NULL_Pointer_Dereference__null_check_after_deref_01.c,"    {
        int *intPointer = NULL;
        intPointer = (int *)malloc(sizeof(int));
        *intPointer = 5;
        printIntLine(*intPointer);
        
        if (intPointer != NULL)
        {
            *intPointer = 10;
        }
        printIntLine(*intPointer);
"
11708,0,CWE590_Free_Memory_Not_on_Heap__delete_long_alloca_13.cpp,"    long * data;
    data = NULL; 
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            
            long * dataBuffer = (long *)ALLOCA(sizeof(long));
            *dataBuffer = 5L;
            data = dataBuffer;
        }
    }
    printLongLine(*data);
    
"
8066,0,CWE369_Divide_by_Zero__int_connect_socket_modulo_54a.c,"    int data;
    
    data = -1;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
6822,1,CWE758_Undefined_Behavior__class_pointer_new_use_04.cpp,"    if(STATIC_CONST_TRUE)
    {
        {
            TwoIntsClass * data;
            
            data = new TwoIntsClass;
            data->intOne = 5;
            data->intTwo = 6;
            TwoIntsClass * * pointer = new TwoIntsClass *;
            *pointer = data; 
            {
                TwoIntsClass * data = *pointer;
                printIntLine(data->intOne);
                printIntLine(data->intTwo);
            }
            delete pointer;
        }
"
14849,0,CWE590_Free_Memory_Not_on_Heap__delete_array_class_static_18.cpp,"    TwoIntsClass * data;
    data = NULL; 
    goto source;
source:
    {
        
        static TwoIntsClass dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i].intOne = 1;
                dataBuffer[i].intTwo = 1;
            }
        }
        data = dataBuffer;
    }
    printIntLine(data[0].intOne);
    
"
2321,0,CWE401_Memory_Leak__int64_t_realloc_43.cpp,"    int64_t * data;
    data = NULL;
    badSource(data);
    
"
17242,0,CWE590_Free_Memory_Not_on_Heap__delete_struct_declare_01.cpp,"    twoIntsStruct * data;
    data = NULL; 
    {
        
        twoIntsStruct dataBuffer;
        dataBuffer.intOne = 1;
        dataBuffer.intTwo = 1;
        data = &dataBuffer;
    }
    printStructLine(data);
    
"
13296,0,CWE457_Use_of_Uninitialized_Variable__char_pointer_14.c,"    char * data;
    if(globalFive==5)
    {
        
        ; 
    }
    if(globalFive==5)
    {
        
        printLine(data);
"
8633,0,CWE690_NULL_Deref_From_Return__int_malloc_04.c,"    int * data;
    data = NULL; 
    
    data = (int *)malloc(1*sizeof(int));
    if(STATIC_CONST_TRUE)
    {
        
        data[0] = 5;
        printIntLine(data[0]);
        free(data);
"
7157,0,CWE401_Memory_Leak__char_realloc_74a.cpp,"    char * data;
    map<int, char *> dataMap;
    data = NULL;
    
    data = (char *)realloc(data, 100*sizeof(char));
    if (data == NULL) {exit(-1);}
    
    strcpy(data, ""A String"");
    printLine(data);
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
16953,0,CWE369_Divide_by_Zero__int_fgets_modulo_05.c,"    int data;
    
    data = -1;
    if(staticTrue)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    if(staticTrue)
    {
        
        printIntLine(100 % data);
"
757,0,CWE590_Free_Memory_Not_on_Heap__delete_class_placement_new_34.cpp,"    TwoIntsClass * data;
    unionType myUnion;
    data = NULL; 
    {
        
        char buffer[sizeof(TwoIntsClass)];
        TwoIntsClass * dataBuffer = new(buffer) TwoIntsClass;
        dataBuffer->intOne = 2;
        dataBuffer->intTwo = 2;
        data = dataBuffer;
    }
    myUnion.unionFirst = data;
    {
        TwoIntsClass * data = myUnion.unionSecond;
        printIntLine(data->intOne);
        
        delete data;
"
2855,0,CWE190_Integer_Overflow__int_connect_socket_square_09.c,"    int data;
    
    data = 0;
    if(GLOBAL_CONST_TRUE)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(GLOBAL_CONST_TRUE)
    {
        {
            
            int result = data * data;
            printIntLine(result);
        }
"
6160,0,CWE134_Uncontrolled_Format_String__char_file_vprintf_04.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(STATIC_CONST_TRUE)
    {
        {
            
            size_t dataLen = strlen(data);
            FILE * pFile;
            
            if (100-dataLen > 1)
            {
                pFile = fopen(FILENAME, ""r"");
                if (pFile != NULL)
                {
                    
                    if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                    {
                        printLine(""fgets() failed"");
                        
                        data[dataLen] = '\0';
                    }
                    fclose(pFile);
                }
            }
        }
    }
    if(STATIC_CONST_TRUE)
    {
        badVaSinkB(data, data);
"
3808,0,CWE190_Integer_Overflow__char_rand_add_61a.c,"    char data;
    data = ' ';
    data = CWE190_Integer_Overflow__char_rand_add_61b_badSource(data);
    {
        
        char result = data + 1;
        printHexCharLine(result);
"
9852,0,CWE190_Integer_Overflow__char_rand_multiply_81_bad.cpp,"Label Definition File: CWE190_Integer_Overflow.label.xml
Template File: sources-sinks-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 190 Integer Overflow
 * BadSource: rand Set data to result of rand()
 * GoodSource: Set data to a small, non-zero number (two)
 * Sinks: multiply
 *    GoodSink: Ensure there will not be an overflow before multiplying data by 2
 *    BadSink : If data is positive, multiply by 2, which can cause an overflow
 * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE190_Integer_Overflow__char_rand_multiply_81.h""

namespace CWE190_Integer_Overflow__char_rand_multiply_81
{

void CWE190_Integer_Overflow__char_rand_multiply_81_bad::action(char data) const
{
    if(data > 0) 
    {
        
        char result = data * 2;
        printHexCharLine(result);
    }
}

}
"
16525,0,CWE190_Integer_Overflow__int_fscanf_postinc_44.c,"    int data;
    
    void (*funcPtr) (int) = badSink;
    
    data = 0;
    
    fscanf(stdin, ""%d"", &data);
    
"
10903,1,CWE758_Undefined_Behavior__int64_t_alloca_use_13.c,"    if(GLOBAL_CONST_FIVE!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            int64_t data;
            int64_t * pointer = (int64_t *)ALLOCA(sizeof(int64_t));
            data = 5LL;
            *pointer = data; 
            {
                int64_t data = *pointer;
                printLongLongLine(data);
            }
        }
"
18448,0,CWE457_Use_of_Uninitialized_Variable__int_array_malloc_partial_init_06.c,"    int * data;
    data = (int *)malloc(10*sizeof(int));
    if (data == NULL) {exit(-1);}
    if(STATIC_CONST_FIVE==5)
    {
        
        {
            int i;
            for(i=0; i<(10/2); i++)
            {
                data[i] = i;
            }
        }
    }
    if(STATIC_CONST_FIVE==5)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i]);
            }
        }
"
12409,0,CWE190_Integer_Overflow__short_fscanf_square_06.c,"    short data;
    data = 0;
    if(STATIC_CONST_FIVE==5)
    {
        
        fscanf (stdin, ""%hd"", &data);
    }
    if(STATIC_CONST_FIVE==5)
    {
        {
            
            short result = data * data;
            printIntLine(result);
        }
"
7084,0,CWE190_Integer_Overflow__int_rand_multiply_84_bad.cpp,"Label Definition File: CWE190_Integer_Overflow__int.label.xml
Template File: sources-sinks-84_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 190 Integer Overflow
 * BadSource: rand Set data to result of rand(), which may be zero
 * GoodSource: Set data to a small, non-zero number (two)
 * Sinks: multiply
 *    GoodSink: Ensure there will not be an overflow before multiplying data by 2
 *    BadSink : If data is positive, multiply by 2, which can cause an overflow
 * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE190_Integer_Overflow__int_rand_multiply_84.h""

namespace CWE190_Integer_Overflow__int_rand_multiply_84
{
CWE190_Integer_Overflow__int_rand_multiply_84_bad::CWE190_Integer_Overflow__int_rand_multiply_84_bad(int dataCopy)
{
    data = dataCopy;
    
    data = RAND32();
}

CWE190_Integer_Overflow__int_rand_multiply_84_bad::~CWE190_Integer_Overflow__int_rand_multiply_84_bad()
{
    if(data > 0) 
    {
        
        int result = data * 2;
        printIntLine(result);
    }
}
}
"
1405,0,CWE190_Integer_Overflow__int64_t_max_square_11.c,"    int64_t data;
    data = 0LL;
    if(globalReturnsTrue())
    {
        
        data = LLONG_MAX;
    }
    if(globalReturnsTrue())
    {
        {
            
            int64_t result = data * data;
            printLongLongLine(result);
        }
"
10620,0,CWE78_OS_Command_Injection__char_listen_socket_execl_16.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    while(1)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                data[dataLen + recvResult / sizeof(char)] = '\0';
                
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
        break;
    }
    
    
"
5616,0,CWE690_NULL_Deref_From_Return__long_calloc_68a.c,"    long * data;
    data = NULL; 
    
    data = (long *)calloc(1, sizeof(long));
    CWE690_NULL_Deref_From_Return__long_calloc_68_badDataForBadSink = data;
"
19269,0,CWE416_Use_After_Free__new_delete_array_class_10.cpp,"    TwoIntsClass * data;
    
    data = NULL;
    if(globalTrue)
    {
        data = new TwoIntsClass[100];
        {
            size_t i;
            for(i = 0; i < 100; i++)
            {
                data[i].intOne = 1;
                data[i].intTwo = 2;
            }
        }
        
        delete [] data;
    }
    if(globalTrue)
    {
        
        printIntLine(data[0].intOne);
        
"
11803,0,CWE690_NULL_Deref_From_Return__long_realloc_81_bad.cpp,"Label Definition File: CWE690_NULL_Deref_From_Return.free.label.xml
Template File: source-sinks-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 690 Unchecked Return Value To NULL Pointer
 * BadSource: realloc Allocate data using realloc()
 * Sinks:
 *    GoodSink: Check to see if the data allocation failed and if not, use data
 *    BadSink : Don't check for NULL and use data
 * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE690_NULL_Deref_From_Return__long_realloc_81.h""

namespace CWE690_NULL_Deref_From_Return__long_realloc_81
{

void CWE690_NULL_Deref_From_Return__long_realloc_81_bad::action(long * data) const
{
    
    data[0] = 5L;
    printLongLine(data[0]);
    free(data);
}

}
"
18378,0,CWE252_Unchecked_Return_Value__char_snprintf_07.c,"    if(staticFive==5)
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            
            SNPRINTF(data,100-strlen(SRC)-1, ""%s\n"", SRC);
        }
"
12516,0,CWE369_Divide_by_Zero__int_connect_socket_divide_17.c,"    int i,j;
    int data;
    
    data = -1;
    for(i = 0; i < 1; i++)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    for(j = 0; j < 1; j++)
    {
        
        printIntLine(100 / data);
"
16690,0,CWE190_Integer_Overflow__unsigned_int_max_square_18.c,"    unsigned int data;
    data = 0;
    goto source;
source:
    
    data = UINT_MAX;
    goto sink;
sink:
    {
        
        unsigned int result = data * data;
        printUnsignedLine(result);
"
10522,0,CWE190_Integer_Overflow__int_rand_multiply_13.c,"    int data;
    
    data = 0;
    if(GLOBAL_CONST_FIVE==5)
    {
        
        data = RAND32();
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        if(data > 0) 
        {
            
            int result = data * 2;
            printIntLine(result);
        }
"
9571,0,CWE78_OS_Command_Injection__char_listen_socket_system_18.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    goto source;
source:
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
"
8226,0,CWE197_Numeric_Truncation_Error__int_rand_to_char_44.c,"    int data;
    
    void (*funcPtr) (int) = badSink;
    
    data = -1;
    
    data = RAND32();
    
"
15136,1,CWE758_Undefined_Behavior__struct_malloc_use_03.c,"    if(5==5)
    {
        {
            twoIntsStruct data;
            twoIntsStruct * pointer = (twoIntsStruct *)malloc(sizeof(twoIntsStruct));
            if (pointer == NULL) {exit(-1);}
            data.intOne = 1;
            data.intTwo = 2;
            *pointer = data; 
            {
                twoIntsStruct data = *pointer;
                printIntLine(data.intOne);
                printIntLine(data.intTwo);
            }
            free(pointer);
        }
"
523,0,CWE190_Integer_Overflow__unsigned_int_max_postinc_10.c,"    unsigned int data;
    data = 0;
    if(globalTrue)
    {
        
        data = UINT_MAX;
    }
    if(globalTrue)
    {
        {
            
            data++;
            unsigned int result = data;
            printUnsignedLine(result);
        }
"
9427,0,CWE190_Integer_Overflow__short_fscanf_preinc_21.c,"    short data;
    data = 0;
    
    fscanf (stdin, ""%hd"", &data);
    badStatic = 1; 
"
2331,0,CWE590_Free_Memory_Not_on_Heap__delete_array_char_declare_04.cpp,"    char * data;
    data = NULL; 
    if(STATIC_CONST_TRUE)
    {
        {
            
            char dataBuffer[100];
            memset(dataBuffer, 'A', 100-1); 
            dataBuffer[100-1] = '\0'; 
            data = dataBuffer;
        }
    }
    printLine(data);
    
"
17757,0,CWE590_Free_Memory_Not_on_Heap__delete_long_alloca_41.cpp,"    long * data;
    data = NULL; 
    {
        
        long * dataBuffer = (long *)ALLOCA(sizeof(long));
        *dataBuffer = 5L;
        data = dataBuffer;
    }
"
17478,0,CWE457_Use_of_Uninitialized_Variable__int_array_declare_no_init_09.c,"    int * data;
    int dataUninitArray[10];
    data = dataUninitArray;
    if(GLOBAL_CONST_TRUE)
    {
        
        ; 
    }
    if(GLOBAL_CONST_TRUE)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i]);
            }
        }
"
6816,0,CWE252_Unchecked_Return_Value__char_putc_07.c,"    if(staticFive==5)
    {
        
        putc((int)'A', stdout);
"
16539,0,CWE78_OS_Command_Injection__char_console_system_34.c,"    char * data;
    CWE78_OS_Command_Injection__char_console_system_34_unionType myUnion;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
        
        size_t dataLen = strlen(data);
        
        if (100-dataLen > 1)
        {
            
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgets() */
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
"
10912,0,CWE190_Integer_Overflow__int_fscanf_postinc_65a.c,"    int data;
    
    void (*funcPtr) (int) = CWE190_Integer_Overflow__int_fscanf_postinc_65b_badSink;
    
    data = 0;
    
    fscanf(stdin, ""%d"", &data);
    
"
18026,0,CWE190_Integer_Overflow__int64_t_max_square_84_bad.cpp,"Label Definition File: CWE190_Integer_Overflow.label.xml
Template File: sources-sinks-84_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 190 Integer Overflow
 * BadSource: max Set data to the max value for int64_t
 * GoodSource: Set data to a small, non-zero number (two)
 * Sinks: square
 *    GoodSink: Ensure there will not be an overflow before squaring data
 *    BadSink : Square data, which can lead to overflow
 * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE190_Integer_Overflow__int64_t_max_square_84.h""

#include <math.h>

namespace CWE190_Integer_Overflow__int64_t_max_square_84
{
CWE190_Integer_Overflow__int64_t_max_square_84_bad::CWE190_Integer_Overflow__int64_t_max_square_84_bad(int64_t dataCopy)
{
    data = dataCopy;
    
    data = LLONG_MAX;
}

CWE190_Integer_Overflow__int64_t_max_square_84_bad::~CWE190_Integer_Overflow__int64_t_max_square_84_bad()
{
    {
        
        int64_t result = data * data;
        printLongLongLine(result);
    }
}
}
"
5780,0,CWE415_Double_Free__new_delete_array_long_32.cpp,"    long * data;
    long * *dataPtr1 = &data;
    long * *dataPtr2 = &data;
    
    data = NULL;
    {
        long * data = *dataPtr1;
        data = new long[100];
        
        delete [] data;
        *dataPtr1 = data;
    }
    {
        long * data = *dataPtr2;
        
        delete [] data;
"
4680,0,CWE190_Integer_Overflow__char_max_add_67a.c,"    char data;
    CWE190_Integer_Overflow__char_max_add_67_structType myStruct;
    data = ' ';
    
    data = CHAR_MAX;
    myStruct.structFirst = data;
"
12310,1,CWE416_Use_After_Free__return_freed_ptr_18.c,"    goto sink;
sink:
    {
        
        char * reversedString = helperGood(""GoodSink"");
        printLine(reversedString);
        /* free(reversedString);
         * This call to free() was removed because we want the tool to detect the use after free,
         * but we don't want that function to be free(). Essentially we want to avoid a double free
         */
"
16961,0,CWE563_Unused_Variable__unused_init_variable_struct_06.c,"    twoIntsStruct data;
    
    data.intOne = 0;
    data.intTwo = 0;
    if(STATIC_CONST_FIVE==5)
    {
        
        
        ; 
"
9553,0,CWE457_Use_of_Uninitialized_Variable__new_double_array_partial_init_12.cpp,"    double * data;
    data = new double[10];
    if(globalReturnsTrueOrFalse())
    {
        
        {
            int i;
            for(i=0; i<(10/2); i++)
            {
                data[i] = (double)i;
            }
        }
    }
    else
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                data[i] = (double)i;
            }
        }
    }
    if(globalReturnsTrueOrFalse())
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printDoubleLine(data[i]);
            }
        }
        
        delete [] data;
    }
    else
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                data[i] = (double)i;
            }
        }
        {
            int i;
            for(i=0; i<10; i++)
            {
                printDoubleLine(data[i]);
            }
        }
        
        delete [] data;
"
16979,0,CWE190_Integer_Overflow__short_rand_add_15.c,"    short data;
    data = 0;
    switch(6)
    {
    case 6:
        
        data = (short)RAND32();
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
    {
        
        short result = data + 1;
        printIntLine(result);
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
13416,0,CWE190_Integer_Overflow__int_fscanf_add_54a.c,"    int data;
    
    data = 0;
    
    fscanf(stdin, ""%d"", &data);
"
13595,0,CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_09.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(GLOBAL_CONST_TRUE)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                data[dataLen + recvResult / sizeof(char)] = '\0';
                
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(GLOBAL_CONST_TRUE)
    {
        {
            char dest[100] = """";
            
            SNPRINTF(dest, 100-1, data);
            printLine(dest);
        }
"
9971,0,CWE190_Integer_Overflow__char_max_square_42.c,"    char data;
    data = ' ';
    data = badSource(data);
    {
        
        char result = data * data;
        printHexCharLine(result);
"
15978,0,CWE190_Integer_Overflow__short_rand_preinc_22a.c,"    short data;
    data = 0;
    
    data = (short)RAND32();
    CWE190_Integer_Overflow__short_rand_preinc_22_badGlobal = 1; 
"
6880,0,CWE590_Free_Memory_Not_on_Heap__delete_class_alloca_82a.cpp,"    TwoIntsClass * data;
    data = NULL; 
    {
        
        TwoIntsClass * dataBuffer = (TwoIntsClass *)ALLOCA(sizeof(TwoIntsClass));
        dataBuffer->intOne = 2;
        dataBuffer->intTwo = 2;
        data = dataBuffer;
    }
    CWE590_Free_Memory_Not_on_Heap__delete_class_alloca_82_base* baseObject = new CWE590_Free_Memory_Not_on_Heap__delete_class_alloca_82_bad;
    baseObject->action(data);
"
506,0,CWE190_Integer_Overflow__int_max_multiply_33.cpp,"    int data;
    int &dataRef = data;
    
    data = 0;
    
    data = INT_MAX;
    {
        int data = dataRef;
        if(data > 0) 
        {
            
            int result = data * 2;
            printIntLine(result);
        }
"
11245,0,CWE416_Use_After_Free__new_delete_char_64a.cpp,"    char * data;
    
    data = NULL;
    data = new char;
    *data = 'A';
    
    delete data;
"
7994,0,CWE457_Use_of_Uninitialized_Variable__struct_02.c,"    twoIntsStruct data;
    if(1)
    {
        
        ; 
    }
    if(1)
    {
        
        printIntLine(data.intOne);
        printIntLine(data.intTwo);
"
13467,0,CWE252_Unchecked_Return_Value__char_fgets_12.c,"    if(globalReturnsTrueOrFalse())
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            printLine(""Please enter a string: "");
            
            fgets(data, 100, stdin);
            printLine(data);
        }
    }
    else
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            printLine(""Please enter a string: "");
            
            if (fgets(data, 100, stdin) == NULL)
            {
                printLine(""fgets failed!"");
                exit(1);
            }
            printLine(data);
        }
"
18931,1,CWE587_Assignment_of_Fixed_Address_to_Pointer__basic_02.c,"    if(0)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            
            char charStack = 'a';
            char *charPointer = &charStack;
            printHexCharLine(*charPointer);
        }
"
13446,0,CWE590_Free_Memory_Not_on_Heap__delete_array_struct_declare_45.cpp,"    twoIntsStruct * data;
    data = NULL; 
    {
        
        twoIntsStruct dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i].intOne = 1;
                dataBuffer[i].intTwo = 1;
            }
        }
        data = dataBuffer;
    }
    badData = data;
"
10651,1,CWE252_Unchecked_Return_Value__char_sscanf_04.c,"    if(STATIC_CONST_TRUE)
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            
            if (sscanf(SRC, ""%99s\0"", data) == EOF)
            {
                printLine(""sscanf failed!"");
            }
        }
"
10979,0,CWE590_Free_Memory_Not_on_Heap__free_char_alloca_12.c,"    char * data;
    data = NULL; 
    if(globalReturnsTrueOrFalse())
    {
        {
            
            char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
            memset(dataBuffer, 'A', 100-1); 
            dataBuffer[100-1] = '\0'; 
            data = dataBuffer;
        }
    }
    else
    {
        {
            
            char * dataBuffer = (char *)malloc(100*sizeof(char));
            if (dataBuffer == NULL)
            {
                printLine(""malloc() failed"");
                exit(1);
            }
            memset(dataBuffer, 'A', 100-1); 
            dataBuffer[100-1] = '\0'; 
            data = dataBuffer;
        }
    }
    printLine(data);
    
"
9817,0,CWE190_Integer_Overflow__short_max_square_65a.c,"    short data;
    
    void (*funcPtr) (short) = CWE190_Integer_Overflow__short_max_square_65b_badSink;
    data = 0;
    
    data = SHRT_MAX;
    
"
2272,0,CWE758_Undefined_Behavior__char_pointer_new_use_09.cpp,"    if(GLOBAL_CONST_TRUE)
    {
        {
            char * * pointer = new char *;
            char * data = *pointer; 
            delete pointer;
            printLine(data);
        }
"
10116,0,CWE457_Use_of_Uninitialized_Variable__int_array_malloc_partial_init_09.c,"    int * data;
    data = (int *)malloc(10*sizeof(int));
    if (data == NULL) {exit(-1);}
    if(GLOBAL_CONST_TRUE)
    {
        
        {
            int i;
            for(i=0; i<(10/2); i++)
            {
                data[i] = i;
            }
        }
    }
    if(GLOBAL_CONST_TRUE)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i]);
            }
        }
"
262,0,CWE197_Numeric_Truncation_Error__short_rand_34.c,"    short data;
    CWE197_Numeric_Truncation_Error__short_rand_34_unionType myUnion;
    
    data = -1;
    
    data = (short)RAND32();
    myUnion.unionFirst = data;
    {
        short data = myUnion.unionSecond;
        {
            
            char charData = (char)data;
            printHexCharLine(charData);
        }
"
17783,0,CWE690_NULL_Deref_From_Return__int_calloc_44.c,"    int * data;
    
    void (*funcPtr) (int *) = badSink;
    data = NULL; 
    
    data = (int *)calloc(1, sizeof(int));
    
"
11129,0,CWE369_Divide_by_Zero__int_connect_socket_divide_16.c,"    int data;
    
    data = -1;
    while(1)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
        break;
    }
    while(1)
    {
        
        printIntLine(100 / data);
        break;
"
4318,1,CWE252_Unchecked_Return_Value__char_fwrite_12.c,"    if(globalReturnsTrueOrFalse())
    {
        
        if (fwrite((char *)""string"", sizeof(char), strlen(""string""), stdout) != strlen(""string""))
        {
            printLine(""fwrite failed!"");
        }
    }
    else
    {
        
        if (fwrite((char *)""string"", sizeof(char), strlen(""string""), stdout) != strlen(""string""))
        {
            printLine(""fwrite failed!"");
        }
"
10659,0,CWE190_Integer_Overflow__int_fscanf_square_67a.c,"    int data;
    CWE190_Integer_Overflow__int_fscanf_square_67_structType myStruct;
    
    data = 0;
    
    fscanf(stdin, ""%d"", &data);
    myStruct.structFirst = data;
"
4965,0,CWE590_Free_Memory_Not_on_Heap__free_struct_alloca_52a.c,"    twoIntsStruct * data;
    data = NULL; 
    {
        
        twoIntsStruct * dataBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i].intOne = 1;
                dataBuffer[i].intTwo = 1;
            }
        }
        data = dataBuffer;
    }
"
16422,0,CWE758_Undefined_Behavior__int_pointer_alloca_use_06.c,"    if(STATIC_CONST_FIVE==5)
    {
        {
            int * * pointer = (int * *)ALLOCA(sizeof(int *));
            int * data = *pointer; 
            printIntLine(*data);
        }
"
17507,0,CWE197_Numeric_Truncation_Error__int_large_to_char_16.c,"    int data;
    
    data = -1;
    while(1)
    {
        
        data = SHRT_MAX + 5;
        break;
    }
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
17652,0,CWE457_Use_of_Uninitialized_Variable__struct_array_malloc_no_init_05.c,"    twoIntsStruct * data;
    data = (twoIntsStruct *)malloc(10*sizeof(twoIntsStruct));
    if (data == NULL) {exit(-1);}
    if(staticTrue)
    {
        
        ; 
    }
    if(staticTrue)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i].intOne);
                printIntLine(data[i].intTwo);
            }
        }
"
8427,0,CWE590_Free_Memory_Not_on_Heap__free_long_declare_51a.c,"    long * data;
    data = NULL; 
    {
        
        long dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5L;
            }
        }
        data = dataBuffer;
    }
"
2466,0,CWE369_Divide_by_Zero__int_connect_socket_divide_82a.cpp,"    int data;
    
    data = -1;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    CWE369_Divide_by_Zero__int_connect_socket_divide_82_base* baseObject = new CWE369_Divide_by_Zero__int_connect_socket_divide_82_bad;
    baseObject->action(data);
"
524,0,CWE190_Integer_Overflow__unsigned_int_rand_square_12.c,"    unsigned int data;
    data = 0;
    if(globalReturnsTrueOrFalse())
    {
        
        data = (unsigned int)RAND32();
    }
    else
    {
        
        data = 2;
    }
    if(globalReturnsTrueOrFalse())
    {
        {
            
            unsigned int result = data * data;
            printUnsignedLine(result);
        }
    }
    else
    {
        
        if (abs((long)data) < (long)sqrt((double)UINT_MAX))
        {
            unsigned int result = data * data;
            printUnsignedLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
"
7804,0,CWE369_Divide_by_Zero__float_listenSocket_02.c,"    float data;
    
    data = 0.0F;
    if(1)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = (float)atof(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(1)
    {
        {
            
            int result = (int)(100.0 / data);
            printIntLine(result);
        }
"
16060,0,CWE190_Integer_Overflow__int_max_multiply_10.c,"    int data;
    
    data = 0;
    if(globalTrue)
    {
        
        data = INT_MAX;
    }
    if(globalTrue)
    {
        if(data > 0) 
        {
            
            int result = data * 2;
            printIntLine(result);
        }
"
12252,0,CWE78_OS_Command_Injection__char_listen_socket_popen_81a.cpp,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    const CWE78_OS_Command_Injection__char_listen_socket_popen_81_base& baseObject = CWE78_OS_Command_Injection__char_listen_socket_popen_81_bad();
"
2058,0,CWE590_Free_Memory_Not_on_Heap__free_int_static_08.c,"    int * data;
    data = NULL; 
    if(staticReturnsTrue())
    {
        {
            
            static int dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5;
                }
            }
            data = dataBuffer;
        }
    }
    printIntLine(data[0]);
    
"
15178,0,CWE401_Memory_Leak__struct_twoIntsStruct_calloc_65a.c,"    struct _twoIntsStruct * data;
    
    void (*funcPtr) (struct _twoIntsStruct *) = CWE401_Memory_Leak__struct_twoIntsStruct_calloc_65b_badSink;
    data = NULL;
    
    data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));
    if (data == NULL) {exit(-1);}
    
    data[0].intOne = 0;
    data[0].intTwo = 0;
    printStructLine((twoIntsStruct *)&data[0]);
    
"
10789,0,CWE416_Use_After_Free__return_freed_ptr_16.c,"    while(1)
    {
        {
            
            char * reversedString = helperBad(""BadSink"");
            printLine(reversedString);
            /* free(reversedString);
             * This call to free() was removed because we want the tool to detect the use after free,
             * but we don't want that function to be free(). Essentially we want to avoid a double free
             */
        }
        break;
"
3677,0,CWE415_Double_Free__malloc_free_char_18.c,"    char * data;
    
    data = NULL;
    goto source;
source:
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    
    free(data);
    goto sink;
sink:
    
"
7781,0,CWE190_Integer_Overflow__char_rand_postinc_34.c,"    char data;
    CWE190_Integer_Overflow__char_rand_postinc_34_unionType myUnion;
    data = ' ';
    
    data = (char)RAND32();
    myUnion.unionFirst = data;
    {
        char data = myUnion.unionSecond;
        {
            
            data++;
            char result = data;
            printHexCharLine(result);
        }
"
1350,0,CWE252_Unchecked_Return_Value__char_fgets_16.c,"    while(1)
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            printLine(""Please enter a string: "");
            
            fgets(data, 100, stdin);
            printLine(data);
        }
        break;
"
6748,0,CWE401_Memory_Leak__new_array_twointsStruct_41.cpp,"    twoIntsStruct * data;
    data = NULL;
    
    data = new twoIntsStruct[100];
    
    data[0].intOne = 0;
    data[0].intTwo = 0;
    printStructLine(&data[0]);
"
1208,0,CWE563_Unused_Variable__unused_init_variable_long_17.c,"    int j;
    long data;
    
    data = 5L;
    for(j = 0; j < 1; j++)
    {
        
        
        ; 
"
6859,0,CWE190_Integer_Overflow__int_fscanf_multiply_72a.cpp,"    int data;
    vector<int> dataVector;
    
    data = 0;
    
    fscanf(stdin, ""%d"", &data);
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
5829,0,CWE78_OS_Command_Injection__char_listen_socket_execlp_34.c,"    char * data;
    CWE78_OS_Command_Injection__char_listen_socket_execlp_34_unionType myUnion;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    myUnion.unionFirst = data;
    {
        char * data = myUnion.unionSecond;
        /* execlp - searches for the location of the command among
         * the directories specified by the PATH environment variable */
        
        EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
"
3831,0,CWE369_Divide_by_Zero__float_zero_16.c,"    float data;
    
    data = 0.0F;
    while(1)
    {
        
        data = 0.0F;
        break;
    }
    while(1)
    {
        {
            
            int result = (int)(100.0 / data);
            printIntLine(result);
        }
        break;
"
5415,0,CWE401_Memory_Leak__int_malloc_33.cpp,"    int * data;
    int * &dataRef = data;
    data = NULL;
    
    data = (int *)malloc(100*sizeof(int));
    if (data == NULL) {exit(-1);}
    
    data[0] = 5;
    printIntLine(data[0]);
    {
        int * data = dataRef;
        
        ; 
"
10573,0,CWE401_Memory_Leak__new_twoIntsStruct_34.cpp,"    twoIntsStruct * data;
    unionType myUnion;
    data = NULL;
    
    data = new twoIntsStruct;
    
    data->intOne = 0;
    data->intTwo = 0;
    printStructLine(data);
    myUnion.unionFirst = data;
    {
        twoIntsStruct * data = myUnion.unionSecond;
        
        ; 
"
761,0,CWE590_Free_Memory_Not_on_Heap__delete_char_alloca_65a.cpp,"    char * data;
    
    void (*funcPtr) (char *) = badSink;
    data = NULL; 
    {
        
        char * dataBuffer = (char *)ALLOCA(sizeof(char));
        *dataBuffer = 'A';
        data = dataBuffer;
    }
    
"
15464,0,CWE369_Divide_by_Zero__float_rand_62a.cpp,"    float data;
    
    data = 0.0F;
    badSource(data);
    {
        
        int result = (int)(100.0 / data);
        printIntLine(result);
"
1201,0,CWE78_OS_Command_Injection__char_connect_socket_popen_42.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    data = badSource(data);
    {
        FILE *pipe;
        
        pipe = POPEN(data, ""w"");
        if (pipe != NULL)
        {
            PCLOSE(pipe);
        }
    }
}

#endif 

"
16577,1,CWE401_Memory_Leak__malloc_realloc_int_13.c,"    if(GLOBAL_CONST_FIVE!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            int * data = (int *)malloc(100*sizeof(int));
            if (data == NULL) {exit(-1);}
            int * tmpData;
            
            data[0] = 5;
            printIntLine(data[0]);
            tmpData = (int *)realloc(data, (130000)*sizeof(int));
            /* FIX: Ensure realloc() was successful before assigning data to the memory block
            * allocated with realloc() */
            if (tmpData != NULL)
            {
                data = tmpData;
                
                data[0] = 10;
                printIntLine(data[0]);
            }
            free(data);
        }
"
16502,0,CWE401_Memory_Leak__new_array_struct_twoIntsStruct_45.cpp,"    struct _twoIntsStruct * data;
    data = NULL;
    
    data = new struct _twoIntsStruct[100];
    
    data[0].intOne = 0;
    data[0].intTwo = 0;
    printStructLine((twoIntsStruct *)&data[0]);
    badData = data;
"
2620,0,CWE190_Integer_Overflow__unsigned_int_rand_postinc_64a.c,"    unsigned int data;
    data = 0;
    
    data = (unsigned int)RAND32();
"
7397,0,CWE590_Free_Memory_Not_on_Heap__delete_array_int_alloca_01.cpp,"    int * data;
    data = NULL; 
    {
        
        int * dataBuffer = (int *)ALLOCA(100*sizeof(int));
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5;
            }
        }
        data = dataBuffer;
    }
    printIntLine(data[0]);
    
"
5967,0,CWE415_Double_Free__new_delete_struct_83_bad.cpp,"Label Definition File: CWE415_Double_Free__new_delete.label.xml
Template File: sources-sinks-83_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 415 Double Free
 * BadSource:  Allocate data using new and Deallocae data using delete
 * GoodSource: Allocate data using new
 * Sinks:
 *    GoodSink: do nothing
 *    BadSink : Deallocate data using delete
 * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE415_Double_Free__new_delete_struct_83.h""

namespace CWE415_Double_Free__new_delete_struct_83
{
CWE415_Double_Free__new_delete_struct_83_bad::CWE415_Double_Free__new_delete_struct_83_bad(twoIntsStruct * dataCopy)
{
    data = dataCopy;
    data = new twoIntsStruct;
    
    delete data;
}

CWE415_Double_Free__new_delete_struct_83_bad::~CWE415_Double_Free__new_delete_struct_83_bad()
{
    
    delete data;
}
}
"
16566,0,CWE563_Unused_Variable__unused_value_int_21.c,"    int data;
    
    data = 5;
    badStatic = 1; 
"
8418,0,CWE590_Free_Memory_Not_on_Heap__delete_struct_placement_new_02.cpp,"    twoIntsStruct * data;
    data = NULL; 
    if(1)
    {
        {
            
            char buffer[sizeof(twoIntsStruct)];
            twoIntsStruct * dataBuffer = new(buffer) twoIntsStruct;
            dataBuffer->intOne = 1;
            dataBuffer->intTwo = 1;
            data = dataBuffer;
        }
    }
    printStructLine(data);
    
"
9716,0,CWE469_Use_of_Pointer_Subtraction_to_Determine_Size__char_05.c,"    if(staticTrue)
    {
        {
            char string1[] = SOURCE_STRING;
            char string2[] = SOURCE_STRING;
            char * slashInString1;
            size_t indexOfSlashInString1;
            slashInString1 = strchr(string1, '/');
            if (slashInString1 == NULL)
            {
                exit(1);
            }
            
            indexOfSlashInString1 = (size_t)(slashInString1 - string2);
            
            printUnsignedLine(indexOfSlashInString1);
        }
"
3135,0,CWE590_Free_Memory_Not_on_Heap__free_char_static_11.c,"    char * data;
    data = NULL; 
    if(globalReturnsTrue())
    {
        {
            
            static char dataBuffer[100];
            memset(dataBuffer, 'A', 100-1); 
            dataBuffer[100-1] = '\0'; 
            data = dataBuffer;
        }
    }
    printLine(data);
    
"
7876,0,CWE134_Uncontrolled_Format_String__char_console_vprintf_61a.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    data = CWE134_Uncontrolled_Format_String__char_console_vprintf_61b_badSource(data);
"
8699,0,CWE134_Uncontrolled_Format_String__char_file_snprintf_32.c,"    char * data;
    char * *dataPtr1 = &data;
    char * *dataPtr2 = &data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        char * data = *dataPtr1;
        {
            
            size_t dataLen = strlen(data);
            FILE * pFile;
            
            if (100-dataLen > 1)
            {
                pFile = fopen(FILENAME, ""r"");
                if (pFile != NULL)
                {
                    
                    if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                    {
                        printLine(""fgets() failed"");
                        
                        data[dataLen] = '\0';
                    }
                    fclose(pFile);
                }
            }
        }
        *dataPtr1 = data;
    }
    {
        char * data = *dataPtr2;
        {
            char dest[100] = """";
            
            SNPRINTF(dest, 100-1, data);
            printLine(dest);
        }
"
18341,0,CWE416_Use_After_Free__malloc_free_char_11.c,"    char * data;
    
    data = NULL;
    if(globalReturnsTrue())
    {
        data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        memset(data, 'A', 100-1);
        data[100-1] = '\0';
        
        free(data);
    }
    if(globalReturnsTrue())
    {
        
        printLine(data);
        
"
8963,0,CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_62a.cpp,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    badSource(data);
"
17935,0,CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_21.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    badStatic = 1; 
"
3725,0,CWE190_Integer_Overflow__int64_t_max_square_02.c,"    int64_t data;
    data = 0LL;
    if(1)
    {
        
        data = LLONG_MAX;
    }
    if(1)
    {
        {
            
            int64_t result = data * data;
            printLongLongLine(result);
        }
"
16816,0,CWE78_OS_Command_Injection__char_environment_popen_45.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
        
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        
        if (environment != NULL)
        {
            
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    CWE78_OS_Command_Injection__char_environment_popen_45_badData = data;
"
16008,0,CWE190_Integer_Overflow__short_rand_square_66a.c,"    short data;
    short dataArray[5];
    data = 0;
    
    data = (short)RAND32();
    
    dataArray[2] = data;
"
6247,0,CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_82a.cpp,"    size_t data;
    
    data = 0;
    
    fscanf(stdin, ""%zu"", &data);
    CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_82_base* baseObject = new CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_82_bad;
    baseObject->action(data);
"
3886,0,CWE416_Use_After_Free__new_delete_array_int64_t_64a.cpp,"    int64_t * data;
    
    data = NULL;
    data = new int64_t[100];
    {
        size_t i;
        for(i = 0; i < 100; i++)
        {
            data[i] = 5LL;
        }
    }
    
    delete [] data;
"
6317,0,CWE190_Integer_Overflow__unsigned_int_rand_multiply_31.c,"    unsigned int data;
    data = 0;
    
    data = (unsigned int)RAND32();
    {
        unsigned int dataCopy = data;
        unsigned int data = dataCopy;
        if(data > 0) 
        {
            
            unsigned int result = data * 2;
            printUnsignedLine(result);
        }
"
5523,0,CWE590_Free_Memory_Not_on_Heap__free_struct_declare_44.c,"    twoIntsStruct * data;
    
    void (*funcPtr) (twoIntsStruct *) = badSink;
    data = NULL; 
    {
        
        twoIntsStruct dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i].intOne = 1;
                dataBuffer[i].intTwo = 1;
            }
        }
        data = dataBuffer;
    }
    
"
9520,0,CWE190_Integer_Overflow__int_connect_socket_square_65a.c,"    int data;
    
    void (*funcPtr) (int) = CWE190_Integer_Overflow__int_connect_socket_square_65b_badSink;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
"
1120,0,CWE190_Integer_Overflow__int_connect_socket_postinc_03.c,"    int data;
    
    data = 0;
    if(5==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(5==5)
    {
        {
            
            data++;
            int result = data;
            printIntLine(result);
        }
"
6063,0,CWE190_Integer_Overflow__int_rand_multiply_02.c,"    int data;
    
    data = 0;
    if(1)
    {
        
        data = RAND32();
    }
    if(1)
    {
        if(data > 0) 
        {
            
            int result = data * 2;
            printIntLine(result);
        }
"
5073,0,CWE190_Integer_Overflow__int64_t_max_multiply_61a.c,"    int64_t data;
    data = 0LL;
    data = CWE190_Integer_Overflow__int64_t_max_multiply_61b_badSource(data);
    if(data > 0) 
    {
        
        int64_t result = data * 2;
        printLongLongLine(result);
"
4855,0,CWE401_Memory_Leak__malloc_realloc_int64_t_04.c,"    if(STATIC_CONST_TRUE)
    {
        {
            int64_t * data = (int64_t *)malloc(100*sizeof(int64_t));
            if (data == NULL) {exit(-1);}
            
            data[0] = 5LL;
            printLongLongLine(data[0]);
            
            data = (int64_t *)realloc(data, (130000)*sizeof(int64_t));
            if (data != NULL)
            {
                
                data[0] = 10LL;
                printLongLongLine(data[0]);
                free(data);
            }
        }
"
6123,0,CWE78_OS_Command_Injection__char_console_system_68a.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
        
        size_t dataLen = strlen(data);
        
        if (100-dataLen > 1)
        {
            
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgets() */
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
                    data[dataLen-1] = '\0';
                }
            }
            else
            {
                printLine(""fgets() failed"");
                
                data[dataLen] = '\0';
            }
        }
    }
    CWE78_OS_Command_Injection__char_console_system_68_badData = data;
"
19351,1,CWE467_Use_of_sizeof_on_Pointer_Type__int_17.c,"    int k;
    for(k = 0; k < 1; k++)
    {
        {
            int * goodInt = NULL;
            
            goodInt = (int *)malloc(sizeof(*goodInt));
            if (goodInt == NULL) {exit(-1);}
            *goodInt = 6;
            printIntLine(*goodInt);
            free(goodInt);
        }
"
12723,1,CWE758_Undefined_Behavior__double_pointer_new_use_14.cpp,"    if(globalFive!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            double * data;
            
            data = new double;
            *data = 5.0;
            double * * pointer = new double *;
            *pointer = data; 
            {
                double * data = *pointer;
                printDoubleLine(*data);
            }
            delete pointer;
        }
"
7029,0,CWE401_Memory_Leak__char_calloc_81a.cpp,"    char * data;
    data = NULL;
    
    data = (char *)calloc(100, sizeof(char));
    if (data == NULL) {exit(-1);}
    
    strcpy(data, ""A String"");
    printLine(data);
    const CWE401_Memory_Leak__char_calloc_81_base& baseObject = CWE401_Memory_Leak__char_calloc_81_bad();
"
15837,0,CWE457_Use_of_Uninitialized_Variable__double_pointer_18.c,"    double * data;
    goto source;
source:
    
    ; 
    goto sink;
sink:
    
"
1343,0,CWE563_Unused_Variable__unused_init_variable_long_18.c,"    long data;
    
    data = 5L;
    goto sink;
sink:
    
    
"
3560,0,CWE190_Integer_Overflow__int_listen_socket_add_07.c,"    int data;
    
    data = 0;
    if(staticFive==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(staticFive==5)
    {
        {
            
            int result = data + 1;
            printIntLine(result);
        }
"
15286,0,CWE590_Free_Memory_Not_on_Heap__delete_int_alloca_53a.cpp,"    int * data;
    data = NULL; 
    {
        
        int * dataBuffer = (int *)ALLOCA(sizeof(int));
        *dataBuffer = 5;
        data = dataBuffer;
    }
"
1956,0,CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_52a.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
15746,0,CWE457_Use_of_Uninitialized_Variable__double_array_declare_partial_init_15.c,"    double * data;
    double dataUninitArray[10];
    data = dataUninitArray;
    switch(6)
    {
    case 6:
        
    {
        int i;
        for(i=0; i<(10/2); i++)
        {
            data[i] = (double)i;
        }
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
        
    {
        int i;
        for(i=0; i<10; i++)
        {
            printDoubleLine(data[i]);
        }
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
9714,0,CWE690_NULL_Deref_From_Return__struct_calloc_64a.c,"    twoIntsStruct * data;
    data = NULL; 
    
    data = (twoIntsStruct *)calloc(1, sizeof(twoIntsStruct));
"
6402,0,CWE415_Double_Free__malloc_free_long_64a.c,"    long * data;
    
    data = NULL;
    data = (long *)malloc(100*sizeof(long));
    if (data == NULL) {exit(-1);}
    
    free(data);
"
10655,0,CWE190_Integer_Overflow__int64_t_max_add_32.c,"    int64_t data;
    int64_t *dataPtr1 = &data;
    int64_t *dataPtr2 = &data;
    data = 0LL;
    {
        int64_t data = *dataPtr1;
        
        data = LLONG_MAX;
        *dataPtr1 = data;
    }
    {
        int64_t data = *dataPtr2;
        {
            
            int64_t result = data + 1;
            printLongLongLine(result);
        }
"
10516,0,CWE134_Uncontrolled_Format_String__char_console_printf_11.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(globalReturnsTrue())
    {
        {
            
            size_t dataLen = strlen(data);
            
            if (100-dataLen > 1)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
                {
                    /* The next few lines remove the carriage return from the string that is
                     * inserted by fgets() */
                    dataLen = strlen(data);
                    if (dataLen > 0 && data[dataLen-1] == '\n')
                    {
                        data[dataLen-1] = '\0';
                    }
                }
                else
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
            }
        }
    }
    if(globalReturnsTrue())
    {
        
        printf(data);
"
7270,0,CWE416_Use_After_Free__new_delete_int64_t_04.cpp,"    int64_t * data;
    
    data = NULL;
    if(STATIC_CONST_TRUE)
    {
        data = new int64_t;
        *data = 5LL;
        
        delete data;
    }
    if(STATIC_CONST_TRUE)
    {
        
        printLongLongLine(*data);
        
"
5339,0,CWE758_Undefined_Behavior__int_alloca_use_13.c,"    if(GLOBAL_CONST_FIVE==5)
    {
        {
            int * pointer = (int *)ALLOCA(sizeof(int));
            int data = *pointer; 
            printIntLine(data);
        }
"
431,0,CWE369_Divide_by_Zero__int_connect_socket_modulo_62a.cpp,"    int data;
    
    data = -1;
    badSource(data);
    
"
17081,0,CWE197_Numeric_Truncation_Error__short_listen_socket_16.c,"    short data;
    
    data = -1;
    while(1)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = (short)atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
        break;
    }
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
18596,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_45.c,"    size_t data;
    
    data = 0;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = strtoul(inputBuffer, NULL, 0);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_45_badData = data;
"
14756,0,CWE197_Numeric_Truncation_Error__short_fgets_44.c,"    short data;
    
    void (*funcPtr) (short) = badSink;
    
    data = -1;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = (short)atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    
"
11539,0,CWE369_Divide_by_Zero__int_fgets_divide_16.c,"    int data;
    
    data = -1;
    while(1)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
        break;
    }
    while(1)
    {
        
        printIntLine(100 / data);
        break;
"
227,0,CWE758_Undefined_Behavior__char_pointer_alloca_use_06.c,"    if(STATIC_CONST_FIVE==5)
    {
        {
            char * * pointer = (char * *)ALLOCA(sizeof(char *));
            char * data = *pointer; 
            printLine(data);
        }
"
15161,0,CWE369_Divide_by_Zero__int_listen_socket_modulo_81_bad.cpp,"Label Definition File: CWE369_Divide_by_Zero__int.label.xml
Template File: sources-sinks-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 369 Divide by Zero
 * BadSource: listen_socket Read data using a listen socket (server side)
 * GoodSource: Non-zero
 * Sinks: modulo
 *    GoodSink: Check for zero before modulo
 *    BadSink : Modulo a constant with data
 * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE369_Divide_by_Zero__int_listen_socket_modulo_81.h""

namespace CWE369_Divide_by_Zero__int_listen_socket_modulo_81
{

void CWE369_Divide_by_Zero__int_listen_socket_modulo_81_bad::action(int data) const
{
    
    printIntLine(100 % data);
}

}
"
7093,0,CWE563_Unused_Variable__unused_init_variable_struct_73a.cpp,"    twoIntsStruct data;
    list<twoIntsStruct> dataList;
    
    data.intOne = 0;
    data.intTwo = 0;
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
6270,0,CWE590_Free_Memory_Not_on_Heap__delete_array_struct_static_68a.cpp,"    twoIntsStruct * data;
    data = NULL; 
    {
        
        static twoIntsStruct dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i].intOne = 1;
                dataBuffer[i].intTwo = 1;
            }
        }
        data = dataBuffer;
    }
    CWE590_Free_Memory_Not_on_Heap__delete_array_struct_static_68_badData = data;
"
13232,0,CWE197_Numeric_Truncation_Error__int_rand_to_char_42.c,"    int data;
    
    data = -1;
    data = badSource(data);
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
14022,0,CWE690_NULL_Deref_From_Return__int64_t_malloc_64a.c,"    int64_t * data;
    data = NULL; 
    
    data = (int64_t *)malloc(1*sizeof(int64_t));
"
19488,0,CWE416_Use_After_Free__new_delete_array_char_06.cpp,"    char * data;
    
    data = NULL;
    if(STATIC_CONST_FIVE==5)
    {
        data = new char[100];
        memset(data, 'A', 100-1);
        data[100-1] = '\0';
        
        delete [] data;
    }
    if(STATIC_CONST_FIVE==5)
    {
        
        printLine(data);
        
"
11073,0,CWE369_Divide_by_Zero__int_listen_socket_divide_43.cpp,"    int data;
    
    data = -1;
    badSource(data);
    
"
16633,0,CWE190_Integer_Overflow__int64_t_fscanf_square_84a.cpp,"    int64_t data;
    data = 0LL;
    CWE190_Integer_Overflow__int64_t_fscanf_square_84_bad * badObject = new CWE190_Integer_Overflow__int64_t_fscanf_square_84_bad(data);
"
13836,0,CWE78_OS_Command_Injection__char_file_execl_05.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(staticTrue)
    {
        {
            
            size_t dataLen = strlen(data);
            FILE * pFile;
            
            if (100-dataLen > 1)
            {
                pFile = fopen(FILENAME, ""r"");
                if (pFile != NULL)
                {
                    
                    if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                    {
                        printLine(""fgets() failed"");
                        
                        data[dataLen] = '\0';
                    }
                    fclose(pFile);
                }
            }
        }
    }
    
    
"
1081,0,CWE401_Memory_Leak__new_array_twointsStruct_18.cpp,"    twoIntsStruct * data;
    data = NULL;
    goto source;
source:
    
    data = new twoIntsStruct[100];
    
    data[0].intOne = 0;
    data[0].intTwo = 0;
    printStructLine(&data[0]);
    goto sink;
sink:
    
"
19102,0,CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_11.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(globalReturnsTrue())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET connectSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                
                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                data[dataLen + recvResult / sizeof(char)] = '\0';
                
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(globalReturnsTrue())
    {
        {
            char dest[100] = """";
            
            SNPRINTF(dest, 100-1, data);
            printLine(dest);
        }
"
12500,0,CWE401_Memory_Leak__int64_t_realloc_07.c,"    int64_t * data;
    data = NULL;
    if(staticFive==5)
    {
        
        data = (int64_t *)realloc(data, 100*sizeof(int64_t));
        if (data == NULL) {exit(-1);}
        
        data[0] = 5LL;
        printLongLongLine(data[0]);
    }
    if(staticFive==5)
    {
        
        ; 
"
5735,0,CWE190_Integer_Overflow__int_listen_socket_multiply_84a.cpp,"    int data;
    
    data = 0;
    CWE190_Integer_Overflow__int_listen_socket_multiply_84_bad * badObject = new CWE190_Integer_Overflow__int_listen_socket_multiply_84_bad(data);
"
17640,0,CWE197_Numeric_Truncation_Error__int_large_to_char_41.c,"    int data;
    
    data = -1;
    
    data = SHRT_MAX + 5;
"
2946,0,CWE190_Integer_Overflow__int_max_postinc_16.c,"    int data;
    
    data = 0;
    while(1)
    {
        
        data = INT_MAX;
        break;
    }
    while(1)
    {
        {
            
            data++;
            int result = data;
            printIntLine(result);
        }
        break;
"
3530,0,CWE590_Free_Memory_Not_on_Heap__delete_class_placement_new_18.cpp,"    TwoIntsClass * data;
    data = NULL; 
    goto source;
source:
    {
        
        char buffer[sizeof(TwoIntsClass)];
        TwoIntsClass * dataBuffer = new(buffer) TwoIntsClass;
        dataBuffer->intOne = 2;
        dataBuffer->intTwo = 2;
        data = dataBuffer;
    }
    printIntLine(data->intOne);
    
"
11506,0,CWE590_Free_Memory_Not_on_Heap__delete_long_placement_new_18.cpp,"    long * data;
    data = NULL; 
    goto source;
source:
    {
        
        char buffer[sizeof(long)];
        long * dataBuffer = new(buffer) long;
        *dataBuffer = 5L;
        data = dataBuffer;
    }
    printLongLine(*data);
    
"
11461,0,CWE369_Divide_by_Zero__float_listenSocket_10.c,"    float data;
    
    data = 0.0F;
    if(globalTrue)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = (float)atof(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(globalTrue)
    {
        {
            
            int result = (int)(100.0 / data);
            printIntLine(result);
        }
"
12475,0,CWE590_Free_Memory_Not_on_Heap__delete_array_int64_t_alloca_31.cpp,"    int64_t * data;
    data = NULL; 
    {
        
        int64_t * dataBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5LL;
            }
        }
        data = dataBuffer;
    }
    {
        int64_t * dataCopy = data;
        int64_t * data = dataCopy;
        printLongLongLine(data[0]);
        
        delete [] data;
"
6211,0,CWE78_OS_Command_Injection__char_listen_socket_execl_81_bad.cpp,"Label Definition File: CWE78_OS_Command_Injection.strings.label.xml
Template File: sources-sink-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 78 OS Command Injection
 * BadSource: listen_socket Read data using a listen socket (server side)
 * GoodSource: Fixed string
 * Sinks: execl
 *    BadSink : execute command with execl
 * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE78_OS_Command_Injection__char_listen_socket_execl_81.h""

#ifdef _WIN32
#include <process.h>
#define EXECL _execl
#else 
#define EXECL execl
#endif

namespace CWE78_OS_Command_Injection__char_listen_socket_execl_81
{

void CWE78_OS_Command_Injection__char_listen_socket_execl_81_bad::action(char * data) const
{
    
    
    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}

}
"
9203,0,CWE415_Double_Free__malloc_free_long_02.c,"    long * data;
    
    data = NULL;
    if(1)
    {
        data = (long *)malloc(100*sizeof(long));
        if (data == NULL) {exit(-1);}
        
        free(data);
    }
    if(1)
    {
        
        free(data);
"
16658,1,CWE758_Undefined_Behavior__double_pointer_alloca_use_08.c,"    if(staticReturnsTrue())
    {
        {
            double * data;
            double * * pointer = (double * *)ALLOCA(sizeof(double *));
            
            data = (double *)malloc(sizeof(double));
            if (data == NULL) {exit(-1);}
            *data = 5.0;
            *pointer = data; 
            {
                double * data = *pointer;
                printDoubleLine(*data);
            }
        }
"
14203,0,CWE134_Uncontrolled_Format_String__char_environment_vprintf_12.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(globalReturnsTrueOrFalse())
    {
        {
            
            size_t dataLen = strlen(data);
            char * environment = GETENV(ENV_VARIABLE);
            
            if (environment != NULL)
            {
                
                strncat(data+dataLen, environment, 100-dataLen-1);
            }
        }
    }
    else
    {
        
        strcpy(data, ""fixedstringtest"");
    }
    if(globalReturnsTrueOrFalse())
    {
        badVaSinkB(data, data);
    }
    else
    {
        badVaSinkG(data, data);
"
14714,0,CWE590_Free_Memory_Not_on_Heap__free_int64_t_static_08.c,"    int64_t * data;
    data = NULL; 
    if(staticReturnsTrue())
    {
        {
            
            static int64_t dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5LL;
                }
            }
            data = dataBuffer;
        }
    }
    printLongLongLine(data[0]);
    
"
7293,0,CWE590_Free_Memory_Not_on_Heap__delete_struct_alloca_09.cpp,"    twoIntsStruct * data;
    data = NULL; 
    if(GLOBAL_CONST_TRUE)
    {
        {
            
            twoIntsStruct * dataBuffer = (twoIntsStruct *)ALLOCA(sizeof(twoIntsStruct));
            dataBuffer->intOne = 1;
            dataBuffer->intTwo = 1;
            data = dataBuffer;
        }
    }
    printStructLine(data);
    
"
19380,0,CWE197_Numeric_Truncation_Error__short_rand_84_bad.cpp,"Label Definition File: CWE197_Numeric_Truncation_Error__short.label.xml
Template File: sources-sink-84_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 197 Numeric Truncation Error
 * BadSource: rand Set data to result of RAND32(), which could be negative
 * GoodSource: Less than CHAR_MAX
 * Sinks:
 *    BadSink : Convert data to a char
 * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE197_Numeric_Truncation_Error__short_rand_84.h""

namespace CWE197_Numeric_Truncation_Error__short_rand_84
{
CWE197_Numeric_Truncation_Error__short_rand_84_bad::CWE197_Numeric_Truncation_Error__short_rand_84_bad(short dataCopy)
{
    data = dataCopy;
    
    data = (short)RAND32();
}

CWE197_Numeric_Truncation_Error__short_rand_84_bad::~CWE197_Numeric_Truncation_Error__short_rand_84_bad()
{
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
    }
}
}
"
3301,0,CWE415_Double_Free__new_delete_class_10.cpp,"    TwoIntsClass * data;
    
    data = NULL;
    if(globalTrue)
    {
        data = new TwoIntsClass;
        
        delete data;
    }
    if(globalTrue)
    {
        
        delete data;
"
19527,0,CWE190_Integer_Overflow__char_max_preinc_17.c,"    int i,j;
    char data;
    data = ' ';
    for(i = 0; i < 1; i++)
    {
        
        data = CHAR_MAX;
    }
    for(j = 0; j < 1; j++)
    {
        {
            
            ++data;
            char result = data;
            printHexCharLine(result);
        }
"
8900,0,CWE197_Numeric_Truncation_Error__short_rand_74a.cpp,"    short data;
    map<int, short> dataMap;
    
    data = -1;
    
    data = (short)RAND32();
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
10636,0,CWE469_Use_of_Pointer_Subtraction_to_Determine_Size__char_10.c,"    if(globalTrue)
    {
        {
            char string1[] = SOURCE_STRING;
            char string2[] = SOURCE_STRING;
            char * slashInString1;
            size_t indexOfSlashInString1;
            slashInString1 = strchr(string1, '/');
            if (slashInString1 == NULL)
            {
                exit(1);
            }
            
            indexOfSlashInString1 = (size_t)(slashInString1 - string2);
            
            printUnsignedLine(indexOfSlashInString1);
        }
"
13293,0,CWE457_Use_of_Uninitialized_Variable__int_array_alloca_partial_init_08.c,"    int * data;
    data = (int *)ALLOCA(10*sizeof(int));
    if(staticReturnsTrue())
    {
        
        {
            int i;
            for(i=0; i<(10/2); i++)
            {
                data[i] = i;
            }
        }
    }
    if(staticReturnsTrue())
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i]);
            }
        }
"
6743,0,CWE190_Integer_Overflow__int_rand_preinc_15.c,"    int data;
    
    data = 0;
    switch(6)
    {
    case 6:
        
        data = RAND32();
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
    {
        
        ++data;
        int result = data;
        printIntLine(result);
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
1470,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_74a.cpp,"    size_t data;
    map<int, size_t> dataMap;
    
    data = 0;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = strtoul(inputBuffer, NULL, 0);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
9260,0,CWE369_Divide_by_Zero__int_connect_socket_modulo_51a.c,"    int data;
    
    data = -1;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
16989,0,CWE758_Undefined_Behavior__long_malloc_use_10.c,"    if(globalTrue)
    {
        {
            long * pointer = (long *)malloc(sizeof(long));
            if (pointer == NULL) {exit(-1);}
            long data = *pointer; 
            free(pointer);
            printLongLine(data);
        }
"
13329,0,CWE190_Integer_Overflow__short_rand_postinc_51a.c,"    short data;
    data = 0;
    
    data = (short)RAND32();
"
16320,0,CWE758_Undefined_Behavior__struct_new_use_12.cpp,"    if(globalReturnsTrueOrFalse())
    {
        {
            twoIntsStruct * pointer = new twoIntsStruct;
            twoIntsStruct data = *pointer; 
            delete pointer;
            printIntLine(data.intOne);
            printIntLine(data.intTwo);
        }
    }
    else
    {
        {
            twoIntsStruct data;
            data.intOne = 1;
            data.intTwo = 2;
            twoIntsStruct * pointer = new twoIntsStruct;
            *pointer = data; 
            {
                twoIntsStruct data = *pointer;
                printIntLine(data.intOne);
                printIntLine(data.intTwo);
            }
            delete pointer;
        }
"
12845,0,CWE190_Integer_Overflow__short_max_square_41.c,"    short data;
    data = 0;
    
    data = SHRT_MAX;
"
13507,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_18.c,"    size_t data;
    
    data = 0;
    goto source;
source:
    
    fscanf(stdin, ""%zu"", &data);
    goto sink;
sink:
    {
        char * myString;
        /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
         * for the strcpy() function to not cause a buffer overflow */
        
        if (data > strlen(HELLO_STRING))
        {
            myString = (char *)malloc(data*sizeof(char));
            if (myString == NULL) {exit(-1);}
            
            strcpy(myString, HELLO_STRING);
            printLine(myString);
            free(myString);
        }
        else
        {
            printLine(""Input is less than the length of the source string"");
        }
"
15836,0,CWE457_Use_of_Uninitialized_Variable__new_double_array_no_init_05.cpp,"    double * data;
    data = new double[10];
    if(staticTrue)
    {
        
        ; 
    }
    if(staticTrue)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printDoubleLine(data[i]);
            }
        }
        
        delete [] data;
"
2488,0,CWE401_Memory_Leak__int_calloc_72a.cpp,"    int * data;
    vector<int *> dataVector;
    data = NULL;
    
    data = (int *)calloc(100, sizeof(int));
    if (data == NULL) {exit(-1);}
    
    data[0] = 5;
    printIntLine(data[0]);
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
12821,0,CWE197_Numeric_Truncation_Error__short_fscanf_72a.cpp,"    short data;
    vector<short> dataVector;
    
    data = -1;
    
    fscanf (stdin, ""%hd"", &data);
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
2714,0,CWE416_Use_After_Free__new_delete_long_18.cpp,"    long * data;
    
    data = NULL;
    goto source;
source:
    data = new long;
    *data = 5L;
    
    delete data;
    goto sink;
sink:
    
    printLongLine(*data);
"
5198,0,CWE457_Use_of_Uninitialized_Variable__int_array_declare_partial_init_02.c,"    int * data;
    int dataUninitArray[10];
    data = dataUninitArray;
    if(1)
    {
        
        {
            int i;
            for(i=0; i<(10/2); i++)
            {
                data[i] = i;
            }
        }
    }
    if(1)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i]);
            }
        }
"
18095,0,CWE190_Integer_Overflow__int_listen_socket_multiply_81_bad.cpp,"Label Definition File: CWE190_Integer_Overflow__int.label.xml
Template File: sources-sinks-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 190 Integer Overflow
 * BadSource: listen_socket Read data using a listen socket (server side)
 * GoodSource: Set data to a small, non-zero number (two)
 * Sinks: multiply
 *    GoodSink: Ensure there will not be an overflow before multiplying data by 2
 *    BadSink : If data is positive, multiply by 2, which can cause an overflow
 * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE190_Integer_Overflow__int_listen_socket_multiply_81.h""

namespace CWE190_Integer_Overflow__int_listen_socket_multiply_81
{

void CWE190_Integer_Overflow__int_listen_socket_multiply_81_bad::action(int data) const
{
    if(data > 0) 
    {
        
        int result = data * 2;
        printIntLine(result);
    }
}

}
"
2233,0,CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_03.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(5==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET connectSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                
                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                data[dataLen + recvResult / sizeof(char)] = '\0';
                
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(5==5)
    {
        
        fprintf(stdout, data);
"
7178,0,CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_32.c,"    unsigned int data;
    unsigned int *dataPtr1 = &data;
    unsigned int *dataPtr2 = &data;
    data = 0;
    {
        unsigned int data = *dataPtr1;
        
        fscanf (stdin, ""%u"", &data);
        *dataPtr1 = data;
    }
    {
        unsigned int data = *dataPtr2;
        {
            
            ++data;
            unsigned int result = data;
            printUnsignedLine(result);
        }
"
10115,0,CWE190_Integer_Overflow__int64_t_rand_preinc_15.c,"    int64_t data;
    data = 0LL;
    switch(6)
    {
    case 6:
        
        data = (int64_t)RAND64();
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
    {
        
        ++data;
        int64_t result = data;
        printLongLongLine(result);
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
13902,0,CWE190_Integer_Overflow__unsigned_int_rand_postinc_21.c,"    unsigned int data;
    data = 0;
    
    data = (unsigned int)RAND32();
    badStatic = 1; 
"
17674,0,CWE401_Memory_Leak__new_array_TwoIntsClass_04.cpp,"    TwoIntsClass * data;
    data = NULL;
    if(STATIC_CONST_TRUE)
    {
        
        data = new TwoIntsClass[100];
        
        data[0].intOne = 0;
        data[0].intTwo = 0;
        printIntLine(data[0].intOne);
        printIntLine(data[0].intTwo);
    }
    if(STATIC_CONST_TRUE)
    {
        
        ; 
"
1005,0,CWE457_Use_of_Uninitialized_Variable__int_02.c,"    int data;
    if(1)
    {
        
        ; 
    }
    if(1)
    {
        
        printIntLine(data);
"
2378,0,CWE197_Numeric_Truncation_Error__int_large_to_short_84_bad.cpp,"Label Definition File: CWE197_Numeric_Truncation_Error__int.label.xml
Template File: sources-sink-84_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 197 Numeric Truncation Error
 * BadSource: large Set data to a number larger than SHRT_MAX
 * GoodSource: Less than CHAR_MAX
 * Sinks: to_short
 *    BadSink : Convert data to a short
 * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE197_Numeric_Truncation_Error__int_large_to_short_84.h""

namespace CWE197_Numeric_Truncation_Error__int_large_to_short_84
{
CWE197_Numeric_Truncation_Error__int_large_to_short_84_bad::CWE197_Numeric_Truncation_Error__int_large_to_short_84_bad(int dataCopy)
{
    data = dataCopy;
    
    data = SHRT_MAX + 5;
}

CWE197_Numeric_Truncation_Error__int_large_to_short_84_bad::~CWE197_Numeric_Truncation_Error__int_large_to_short_84_bad()
{
    {
        
        short shortData = (short)data;
        printShortLine(shortData);
    }
}
}
"
8004,0,CWE590_Free_Memory_Not_on_Heap__delete_int64_t_placement_new_67a.cpp,"    int64_t * data;
    structType myStruct;
    data = NULL; 
    {
        
        char buffer[sizeof(int64_t)];
        int64_t * dataBuffer = new(buffer) int64_t;
        *dataBuffer = 5LL;
        data = dataBuffer;
    }
    myStruct.structFirst = data;
"
5212,0,CWE197_Numeric_Truncation_Error__int_fscanf_to_char_72a.cpp,"    int data;
    vector<int> dataVector;
    
    data = -1;
    
    fscanf(stdin, ""%d"", &data);
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
17350,0,CWE369_Divide_by_Zero__int_rand_modulo_12.c,"    int data;
    
    data = -1;
    if(globalReturnsTrueOrFalse())
    {
        
        data = RAND32();
    }
    else
    {
        
        data = 7;
    }
    if(globalReturnsTrueOrFalse())
    {
        
        printIntLine(100 % data);
    }
    else
    {
        
        if( data != 0 )
        {
            printIntLine(100 % data);
        }
        else
        {
            printLine(""This would result in a divide by zero"");
        }
"
14427,0,CWE190_Integer_Overflow__int_max_add_62a.cpp,"    int data;
    
    data = 0;
    badSource(data);
    {
        
        int result = data + 1;
        printIntLine(result);
"
3769,0,CWE197_Numeric_Truncation_Error__int_large_to_short_15.c,"    int data;
    
    data = -1;
    switch(6)
    {
    case 6:
        
        data = SHRT_MAX + 5;
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    {
        
        short shortData = (short)data;
        printShortLine(shortData);
"
5905,0,CWE134_Uncontrolled_Format_String__char_console_printf_54a.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        
        if (100-dataLen > 1)
        {
            
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgets() */
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
                    data[dataLen-1] = '\0';
                }
            }
            else
            {
                printLine(""fgets() failed"");
                
                data[dataLen] = '\0';
            }
        }
    }
"
8116,1,CWE587_Assignment_of_Fixed_Address_to_Pointer__basic_08.c,"    if(staticReturnsFalse())
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            
            char charStack = 'a';
            char *charPointer = &charStack;
            printHexCharLine(*charPointer);
        }
"
12602,1,CWE758_Undefined_Behavior__char_new_use_09.cpp,"    if(GLOBAL_CONST_TRUE)
    {
        {
            char data;
            data = 5;
            char * pointer = new char;
            *pointer = data; 
            {
                char data = *pointer;
                printHexCharLine(data);
            }
            delete pointer;
        }
"
9638,0,CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_64a.c,"    unsigned int data;
    data = 0;
    
    fscanf (stdin, ""%u"", &data);
"
448,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_82a.cpp,"    size_t data;
    
    data = 0;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = strtoul(inputBuffer, NULL, 0);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_82_base* baseObject = new CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_82_bad;
    baseObject->action(data);
"
19290,0,CWE690_NULL_Deref_From_Return__struct_malloc_54a.c,"    twoIntsStruct * data;
    data = NULL; 
    
    data = (twoIntsStruct *)malloc(1*sizeof(twoIntsStruct));
"
5027,0,CWE401_Memory_Leak__new_array_char_12.cpp,"    char * data;
    data = NULL;
    if(globalReturnsTrueOrFalse())
    {
        
        data = new char[100];
        
        strcpy(data, ""A String"");
        printLine(data);
    }
    else
    {
        
        char dataGoodBuffer[100];
        data = dataGoodBuffer;
        
        strcpy(data, ""A String"");
        printLine(data);
    }
    if(globalReturnsTrueOrFalse())
    {
        
        ; 
    }
    else
    {
        
        delete[] data;
"
13113,0,CWE190_Integer_Overflow__char_max_postinc_66a.c,"    char data;
    char dataArray[5];
    data = ' ';
    
    data = CHAR_MAX;
    
    dataArray[2] = data;
"
7941,0,CWE469_Use_of_Pointer_Subtraction_to_Determine_Size__char_15.c,"    switch(6)
    {
    case 6:
    {
        char string1[] = SOURCE_STRING;
        char string2[] = SOURCE_STRING;
        char * slashInString1;
        size_t indexOfSlashInString1;
        slashInString1 = strchr(string1, '/');
        if (slashInString1 == NULL)
        {
            exit(1);
        }
        
        indexOfSlashInString1 = (size_t)(slashInString1 - string2);
        
        printUnsignedLine(indexOfSlashInString1);
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
2832,0,CWE190_Integer_Overflow__char_rand_square_61a.c,"    char data;
    data = ' ';
    data = CWE190_Integer_Overflow__char_rand_square_61b_badSource(data);
    {
        
        char result = data * data;
        printHexCharLine(result);
"
971,0,CWE590_Free_Memory_Not_on_Heap__free_int64_t_static_52a.c,"    int64_t * data;
    data = NULL; 
    {
        
        static int64_t dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5LL;
            }
        }
        data = dataBuffer;
    }
"
15597,0,CWE190_Integer_Overflow__char_max_square_34.c,"    char data;
    CWE190_Integer_Overflow__char_max_square_34_unionType myUnion;
    data = ' ';
    
    data = CHAR_MAX;
    myUnion.unionFirst = data;
    {
        char data = myUnion.unionSecond;
        {
            
            char result = data * data;
            printHexCharLine(result);
        }
"
6174,1,CWE758_Undefined_Behavior__int64_t_malloc_use_01.c,"    {
        int64_t data;
        int64_t * pointer = (int64_t *)malloc(sizeof(int64_t));
        if (pointer == NULL) {exit(-1);}
        data = 5LL;
        *pointer = data; 
        {
            int64_t data = *pointer;
            printLongLongLine(data);
        }
        free(pointer);
"
782,0,CWE457_Use_of_Uninitialized_Variable__twointsclass_array_new_partial_init_63a.cpp,"    TwoIntsClass * data;
    data = new TwoIntsClass[10];
    
    for(int i=0; i<(10/2); i++)
    {
        data[i].intOne = i;
        data[i].intTwo = i;
    }
"
18229,0,CWE369_Divide_by_Zero__float_rand_81a.cpp,"    float data;
    
    data = 0.0F;
    
    data = (float)RAND32();
    const CWE369_Divide_by_Zero__float_rand_81_base& baseObject = CWE369_Divide_by_Zero__float_rand_81_bad();
"
4257,0,CWE190_Integer_Overflow__char_max_postinc_21.c,"    char data;
    data = ' ';
    
    data = CHAR_MAX;
    badStatic = 1; 
"
10909,0,CWE401_Memory_Leak__struct_twoIntsStruct_malloc_84a.cpp,"    struct _twoIntsStruct * data;
    data = NULL;
    CWE401_Memory_Leak__struct_twoIntsStruct_malloc_84_bad * badObject = new CWE401_Memory_Leak__struct_twoIntsStruct_malloc_84_bad(data);
"
18777,0,CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_51a.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
4666,1,CWE476_NULL_Pointer_Dereference__binary_if_06.c,"    if(STATIC_CONST_FIVE==5)
    {
        {
            twoIntsStruct *twoIntsStructPointer = NULL;
            /* FIX: Use && in the if statement so that if the left side of the expression fails then
             * the right side will not be evaluated */
            if ((twoIntsStructPointer != NULL) && (twoIntsStructPointer->intOne == 5))
            {
                printLine(""intOne == 5"");
            }
        }
"
3059,0,CWE416_Use_After_Free__malloc_free_long_64a.c,"    long * data;
    
    data = NULL;
    data = (long *)malloc(100*sizeof(long));
    if (data == NULL) {exit(-1);}
    {
        size_t i;
        for(i = 0; i < 100; i++)
        {
            data[i] = 5L;
        }
    }
    
    free(data);
"
7014,0,CWE78_OS_Command_Injection__char_file_popen_02.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(1)
    {
        {
            
            size_t dataLen = strlen(data);
            FILE * pFile;
            
            if (100-dataLen > 1)
            {
                pFile = fopen(FILENAME, ""r"");
                if (pFile != NULL)
                {
                    
                    if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                    {
                        printLine(""fgets() failed"");
                        
                        data[dataLen] = '\0';
                    }
                    fclose(pFile);
                }
            }
        }
    }
    {
        FILE *pipe;
        
        pipe = POPEN(data, ""w"");
        if (pipe != NULL)
        {
            PCLOSE(pipe);
        }
"
19365,0,CWE134_Uncontrolled_Format_String__char_environment_printf_31.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        
        if (environment != NULL)
        {
            
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    {
        char * dataCopy = data;
        char * data = dataCopy;
        
        printf(data);
"
2910,0,CWE78_OS_Command_Injection__char_listen_socket_execlp_11.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(globalReturnsTrue())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                data[dataLen + recvResult / sizeof(char)] = '\0';
                
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    /* execlp - searches for the location of the command among
     * the directories specified by the PATH environment variable */
    
"
19091,0,CWE134_Uncontrolled_Format_String__char_environment_vprintf_11.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(globalReturnsTrue())
    {
        {
            
            size_t dataLen = strlen(data);
            char * environment = GETENV(ENV_VARIABLE);
            
            if (environment != NULL)
            {
                
                strncat(data+dataLen, environment, 100-dataLen-1);
            }
        }
    }
    if(globalReturnsTrue())
    {
        badVaSinkB(data, data);
"
4783,1,CWE758_Undefined_Behavior__int_new_use_13.cpp,"    if(GLOBAL_CONST_FIVE==5)
    {
        {
            int data;
            data = 5;
            int * pointer = new int;
            *pointer = data; 
            {
                int data = *pointer;
                printIntLine(data);
            }
            delete pointer;
        }
"
11329,0,CWE190_Integer_Overflow__int64_t_fscanf_add_68a.c,"    int64_t data;
    data = 0LL;
    
    fscanf (stdin, ""%"" SCNd64, &data);
    CWE190_Integer_Overflow__int64_t_fscanf_add_68_badData = data;
"
9932,0,CWE369_Divide_by_Zero__int_listen_socket_divide_10.c,"    int data;
    
    data = -1;
    if(globalTrue)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(globalTrue)
    {
        
        printIntLine(100 / data);
"
4444,0,CWE457_Use_of_Uninitialized_Variable__long_13.c,"    long data;
    if(GLOBAL_CONST_FIVE==5)
    {
        
        ; 
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        
        printLongLine(data);
"
10123,0,CWE190_Integer_Overflow__int_rand_square_52a.c,"    int data;
    
    data = 0;
    
    data = RAND32();
"
18782,0,CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_34.c,"    int data;
    CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_34_unionType myUnion;
    
    data = -1;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    myUnion.unionFirst = data;
    {
        int data = myUnion.unionSecond;
        {
            
            char charData = (char)data;
            printHexCharLine(charData);
        }
"
15191,0,CWE197_Numeric_Truncation_Error__int_rand_to_char_04.c,"    int data;
    
    data = -1;
    if(STATIC_CONST_TRUE)
    {
        
        data = RAND32();
    }
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
14391,0,CWE190_Integer_Overflow__int64_t_fscanf_add_82_bad.cpp,"Label Definition File: CWE190_Integer_Overflow.label.xml
Template File: sources-sinks-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 190 Integer Overflow
 * BadSource: fscanf Read data from the console using fscanf()
 * GoodSource: Set data to a small, non-zero number (two)
 * Sinks: add
 *    GoodSink: Ensure there will not be an overflow before adding 1 to data
 *    BadSink : Add 1 to data, which can cause an overflow
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE190_Integer_Overflow__int64_t_fscanf_add_82.h""

namespace CWE190_Integer_Overflow__int64_t_fscanf_add_82
{

void CWE190_Integer_Overflow__int64_t_fscanf_add_82_bad::action(int64_t data)
{
    {
        
        int64_t result = data + 1;
        printLongLongLine(result);
    }
}

}
"
11362,0,CWE190_Integer_Overflow__char_rand_multiply_07.c,"    char data;
    data = ' ';
    if(staticFive==5)
    {
        
        data = (char)RAND32();
    }
    if(staticFive==5)
    {
        if(data > 0) 
        {
            
            char result = data * 2;
            printHexCharLine(result);
        }
"
3274,0,CWE78_OS_Command_Injection__char_file_execlp_84_bad.cpp,"Label Definition File: CWE78_OS_Command_Injection.strings.label.xml
Template File: sources-sink-84_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 78 OS Command Injection
 * BadSource: file Read input from a file
 * GoodSource: Fixed string
 * Sinks: execlp
 *    BadSink : execute command with execlp
 * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE78_OS_Command_Injection__char_file_execlp_84.h""

#ifdef _WIN32
#define FILENAME ""C:\\temp\\file.txt""
#else
#define FILENAME ""/tmp/file.txt""
#endif

#ifdef _WIN32
#include <process.h>
#define EXECLP _execlp
#else 
#define EXECLP execlp
#endif

namespace CWE78_OS_Command_Injection__char_file_execlp_84
{
CWE78_OS_Command_Injection__char_file_execlp_84_bad::CWE78_OS_Command_Injection__char_file_execlp_84_bad(char * dataCopy)
{
    data = dataCopy;
    {
        
        size_t dataLen = strlen(data);
        FILE * pFile;
        
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
}

CWE78_OS_Command_Injection__char_file_execlp_84_bad::~CWE78_OS_Command_Injection__char_file_execlp_84_bad()
{
    /* execlp - searches for the location of the command among
     * the directories specified by the PATH environment variable */
    
    EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
}
"
18443,0,CWE197_Numeric_Truncation_Error__short_rand_82a.cpp,"    short data;
    
    data = -1;
    
    data = (short)RAND32();
    CWE197_Numeric_Truncation_Error__short_rand_82_base* baseObject = new CWE197_Numeric_Truncation_Error__short_rand_82_bad;
    baseObject->action(data);
"
1466,0,CWE190_Integer_Overflow__int_fscanf_square_15.c,"    int data;
    
    data = 0;
    switch(6)
    {
    case 6:
        
        fscanf(stdin, ""%d"", &data);
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
    {
        
        int result = data * data;
        printIntLine(result);
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
1234,0,CWE590_Free_Memory_Not_on_Heap__delete_array_char_static_01.cpp,"    char * data;
    data = NULL; 
    {
        
        static char dataBuffer[100];
        memset(dataBuffer, 'A', 100-1); 
        dataBuffer[100-1] = '\0'; 
        data = dataBuffer;
    }
    printLine(data);
    
"
640,0,CWE190_Integer_Overflow__char_rand_multiply_82_bad.cpp,"Label Definition File: CWE190_Integer_Overflow.label.xml
Template File: sources-sinks-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 190 Integer Overflow
 * BadSource: rand Set data to result of rand()
 * GoodSource: Set data to a small, non-zero number (two)
 * Sinks: multiply
 *    GoodSink: Ensure there will not be an overflow before multiplying data by 2
 *    BadSink : If data is positive, multiply by 2, which can cause an overflow
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE190_Integer_Overflow__char_rand_multiply_82.h""

namespace CWE190_Integer_Overflow__char_rand_multiply_82
{

void CWE190_Integer_Overflow__char_rand_multiply_82_bad::action(char data)
{
    if(data > 0) 
    {
        
        char result = data * 2;
        printHexCharLine(result);
    }
}

}
"
6232,0,CWE190_Integer_Overflow__char_max_multiply_83a.cpp,"    char data;
    data = ' ';
"
543,0,CWE401_Memory_Leak__new_array_char_18.cpp,"    char * data;
    data = NULL;
    goto source;
source:
    
    data = new char[100];
    
    strcpy(data, ""A String"");
    printLine(data);
    goto sink;
sink:
    
"
16841,0,CWE401_Memory_Leak__new_array_int64_t_63a.cpp,"    int64_t * data;
    data = NULL;
    
    data = new int64_t[100];
    
    data[0] = 5LL;
    printLongLongLine(data[0]);
"
16549,0,CWE78_OS_Command_Injection__char_connect_socket_system_68a.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    CWE78_OS_Command_Injection__char_connect_socket_system_68_badData = data;
"
14197,0,CWE190_Integer_Overflow__int_fgets_preinc_03.c,"    int data;
    
    data = 0;
    if(5==5)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    if(5==5)
    {
        {
            
            ++data;
            int result = data;
            printIntLine(result);
        }
"
17151,0,CWE590_Free_Memory_Not_on_Heap__delete_struct_static_82_bad.cpp,"Label Definition File: CWE590_Free_Memory_Not_on_Heap__delete.nonpointer.label.xml
Template File: sources-sink-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 590 Free Memory Not on Heap
 * BadSource: static Data buffer is declared static on the stack
 * GoodSource: Allocate memory on the heap
 * Sinks:
 *    BadSink : Print then free data
 * Flow Variant: 82 Data flow: data passed in a parameter to a virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE590_Free_Memory_Not_on_Heap__delete_struct_static_82.h""

namespace CWE590_Free_Memory_Not_on_Heap__delete_struct_static_82
{

void CWE590_Free_Memory_Not_on_Heap__delete_struct_static_82_bad::action(twoIntsStruct * data)
{
    printStructLine(data);
    
    delete data;
}

}
"
5439,0,CWE190_Integer_Overflow__int_fgets_postinc_42.c,"    int data;
    
    data = 0;
    data = badSource(data);
    {
        
        data++;
        int result = data;
        printIntLine(result);
"
17538,0,CWE190_Integer_Overflow__int_fgets_postinc_15.c,"    int data;
    
    data = 0;
    switch(6)
    {
    case 6:
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
    {
        
        data++;
        int result = data;
        printIntLine(result);
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
1629,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_66a.c,"    size_t data;
    size_t dataArray[5];
    
    data = 0;
    
    data = rand();
    
    dataArray[2] = data;
"
1512,0,CWE415_Double_Free__new_delete_int64_t_42.cpp,"    int64_t * data;
    
    data = NULL;
    data = badSource(data);
    
"
8020,0,CWE369_Divide_by_Zero__int_listen_socket_divide_74a.cpp,"    int data;
    map<int, int> dataMap;
    
    data = -1;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
5433,0,CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_04.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(STATIC_CONST_TRUE)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                data[dataLen + recvResult / sizeof(char)] = '\0';
                
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(STATIC_CONST_TRUE)
    {
        
        fprintf(stdout, data);
"
3595,0,CWE563_Unused_Variable__unused_value_long_84_bad.cpp,"Label Definition File: CWE563_Unused_Variable__unused_value.label.xml
Template File: sources-sinks-84_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 563 Unused Variable
 * BadSource:  Initialize data
 * GoodSource: Initialize and use data
 * Sinks:
 *    GoodSink: Use data
 *    BadSink : Initialize and use data
 * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE563_Unused_Variable__unused_value_long_84.h""

namespace CWE563_Unused_Variable__unused_value_long_84
{
CWE563_Unused_Variable__unused_value_long_84_bad::CWE563_Unused_Variable__unused_value_long_84_bad(long dataCopy)
{
    data = dataCopy;
    
    data = 5L;
}

CWE563_Unused_Variable__unused_value_long_84_bad::~CWE563_Unused_Variable__unused_value_long_84_bad()
{
    
    data = 10L;
    printLongLine(data);
}
}
"
428,0,CWE134_Uncontrolled_Format_String__char_environment_fprintf_22a.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        
        if (environment != NULL)
        {
            
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    CWE134_Uncontrolled_Format_String__char_environment_fprintf_22_badGlobal = 1; 
"
16303,0,CWE190_Integer_Overflow__char_rand_add_82_bad.cpp,"Label Definition File: CWE190_Integer_Overflow.label.xml
Template File: sources-sinks-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 190 Integer Overflow
 * BadSource: rand Set data to result of rand()
 * GoodSource: Set data to a small, non-zero number (two)
 * Sinks: add
 *    GoodSink: Ensure there will not be an overflow before adding 1 to data
 *    BadSink : Add 1 to data, which can cause an overflow
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE190_Integer_Overflow__char_rand_add_82.h""

namespace CWE190_Integer_Overflow__char_rand_add_82
{

void CWE190_Integer_Overflow__char_rand_add_82_bad::action(char data)
{
    {
        
        char result = data + 1;
        printHexCharLine(result);
    }
}

}
"
18141,0,CWE590_Free_Memory_Not_on_Heap__delete_int64_t_declare_16.cpp,"    int64_t * data;
    data = NULL; 
    while(1)
    {
        {
            
            int64_t dataBuffer;
            dataBuffer = 5LL;
            data = &dataBuffer;
        }
        break;
    }
    printLongLongLine(*data);
    
"
4937,0,CWE190_Integer_Overflow__short_max_preinc_54a.c,"    short data;
    data = 0;
    
    data = SHRT_MAX;
"
12431,0,CWE190_Integer_Overflow__short_fscanf_square_15.c,"    short data;
    data = 0;
    switch(6)
    {
    case 6:
        
        fscanf (stdin, ""%hd"", &data);
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
    {
        
        short result = data * data;
        printIntLine(result);
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
5363,0,CWE190_Integer_Overflow__char_rand_add_34.c,"    char data;
    CWE190_Integer_Overflow__char_rand_add_34_unionType myUnion;
    data = ' ';
    
    data = (char)RAND32();
    myUnion.unionFirst = data;
    {
        char data = myUnion.unionSecond;
        {
            
            char result = data + 1;
            printHexCharLine(result);
        }
"
8657,0,CWE590_Free_Memory_Not_on_Heap__delete_int_placement_new_66a.cpp,"    int * data;
    int * dataArray[5];
    data = NULL; 
    {
        
        char buffer[sizeof(int)];
        int * dataBuffer = new(buffer) int;
        *dataBuffer = 5;
        data = dataBuffer;
    }
    
    dataArray[2] = data;
"
9375,0,CWE690_NULL_Deref_From_Return__struct_calloc_04.c,"    twoIntsStruct * data;
    data = NULL; 
    
    data = (twoIntsStruct *)calloc(1, sizeof(twoIntsStruct));
    if(STATIC_CONST_TRUE)
    {
        
        data[0].intOne = 1;
        data[0].intTwo = 1;
        printStructLine(&data[0]);
        free(data);
"
352,0,CWE690_NULL_Deref_From_Return__long_malloc_62a.cpp,"    long * data;
    data = NULL; 
    badSource(data);
    
    data[0] = 5L;
    printLongLine(data[0]);
"
4299,0,CWE401_Memory_Leak__char_realloc_41.c,"    char * data;
    data = NULL;
    
    data = (char *)realloc(data, 100*sizeof(char));
    if (data == NULL) {exit(-1);}
    
    strcpy(data, ""A String"");
    printLine(data);
"
2292,0,CWE190_Integer_Overflow__int_fgets_square_31.c,"    int data;
    
    data = 0;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    {
        int dataCopy = data;
        int data = dataCopy;
        {
            
            int result = data * data;
            printIntLine(result);
        }
"
5730,0,CWE78_OS_Command_Injection__char_console_popen_04.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(STATIC_CONST_TRUE)
    {
        {
            
            size_t dataLen = strlen(data);
            
            if (100-dataLen > 1)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
                {
                    /* The next few lines remove the carriage return from the string that is
                     * inserted by fgets() */
                    dataLen = strlen(data);
"
8084,0,CWE590_Free_Memory_Not_on_Heap__delete_long_static_82_bad.cpp,"Label Definition File: CWE590_Free_Memory_Not_on_Heap__delete.nonpointer.label.xml
Template File: sources-sink-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 590 Free Memory Not on Heap
 * BadSource: static Data buffer is declared static on the stack
 * GoodSource: Allocate memory on the heap
 * Sinks:
 *    BadSink : Print then free data
 * Flow Variant: 82 Data flow: data passed in a parameter to a virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE590_Free_Memory_Not_on_Heap__delete_long_static_82.h""

namespace CWE590_Free_Memory_Not_on_Heap__delete_long_static_82
{

void CWE590_Free_Memory_Not_on_Heap__delete_long_static_82_bad::action(long * data)
{
    printLongLine(*data);
    
    delete data;
}

}
"
13369,0,CWE590_Free_Memory_Not_on_Heap__free_long_declare_12.c,"    long * data;
    data = NULL; 
    if(globalReturnsTrueOrFalse())
    {
        {
            
            long dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5L;
                }
            }
            data = dataBuffer;
        }
    }
    else
    {
        {
            
            long * dataBuffer = (long *)malloc(100*sizeof(long));
            if (dataBuffer == NULL)
            {
                printLine(""malloc() failed"");
                exit(1);
            }
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5L;
                }
            }
            data = dataBuffer;
        }
    }
    printLongLine(data[0]);
    
"
6794,0,CWE197_Numeric_Truncation_Error__int_fscanf_to_char_68a.c,"    int data;
    
    data = -1;
    
    fscanf(stdin, ""%d"", &data);
    CWE197_Numeric_Truncation_Error__int_fscanf_to_char_68_badData = data;
"
12802,0,CWE134_Uncontrolled_Format_String__char_environment_vfprintf_04.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(STATIC_CONST_TRUE)
    {
        {
            
            size_t dataLen = strlen(data);
            char * environment = GETENV(ENV_VARIABLE);
            
            if (environment != NULL)
            {
                
                strncat(data+dataLen, environment, 100-dataLen-1);
            }
        }
    }
    if(STATIC_CONST_TRUE)
    {
        badVaSinkB(data, data);
"
1601,0,CWE590_Free_Memory_Not_on_Heap__delete_char_declare_02.cpp,"    char * data;
    data = NULL; 
    if(1)
    {
        {
            
            char dataBuffer;
            dataBuffer = 'A';
            data = &dataBuffer;
        }
    }
    printHexCharLine(*data);
    
"
3730,0,CWE401_Memory_Leak__int64_t_calloc_16.c,"    int64_t * data;
    data = NULL;
    while(1)
    {
        
        data = (int64_t *)calloc(100, sizeof(int64_t));
        if (data == NULL) {exit(-1);}
        
        data[0] = 5LL;
        printLongLongLine(data[0]);
        break;
    }
    while(1)
    {
        
        ; 
        break;
"
2638,0,CWE78_OS_Command_Injection__char_file_popen_65a.c,"    char * data;
    
    void (*funcPtr) (char *) = CWE78_OS_Command_Injection__char_file_popen_65b_badSink;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
        
        size_t dataLen = strlen(data);
        FILE * pFile;
        
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
    
"
18060,0,CWE190_Integer_Overflow__unsigned_int_max_add_52a.c,"    unsigned int data;
    data = 0;
    
    data = UINT_MAX;
"
9608,1,CWE688_Function_Call_With_Incorrect_Variable_or_Reference_as_Argument__basic_11.c,"    if(globalReturnsTrue())
    {
        {
            char dest[DEST_SIZE];
            int intFive = 5;
            
            sprintf(dest, ""%d"", intFive);
            printLine(dest);
        }
"
5946,0,CWE401_Memory_Leak__int_calloc_21.c,"    int * data;
    data = NULL;
    
    data = (int *)calloc(100, sizeof(int));
    if (data == NULL) {exit(-1);}
    
    data[0] = 5;
    printIntLine(data[0]);
    badStatic = 1; 
"
13917,0,CWE415_Double_Free__malloc_free_int_44.c,"    int * data;
    
    void (*funcPtr) (int *) = badSink;
    
    data = NULL;
    data = (int *)malloc(100*sizeof(int));
    if (data == NULL) {exit(-1);}
    
    free(data);
    
"
12106,1,CWE467_Use_of_sizeof_on_Pointer_Type__char_06.c,"    if(STATIC_CONST_FIVE!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            char * goodChar = NULL;
            
            goodChar = (char *)malloc(sizeof(*goodChar));
            if (goodChar == NULL) {exit(-1);}
            *goodChar = 'G';
            printHexCharLine(*goodChar);
            free(goodChar);
        }
"
626,0,CWE590_Free_Memory_Not_on_Heap__delete_int64_t_alloca_44.cpp,"    int64_t * data;
    
    void (*funcPtr) (int64_t *) = badSink;
    data = NULL; 
    {
        
        int64_t * dataBuffer = (int64_t *)ALLOCA(sizeof(int64_t));
        *dataBuffer = 5LL;
        data = dataBuffer;
    }
    
"
773,0,CWE415_Double_Free__malloc_free_long_12.c,"    long * data;
    
    data = NULL;
    if(globalReturnsTrueOrFalse())
    {
        data = (long *)malloc(100*sizeof(long));
        if (data == NULL) {exit(-1);}
        
        free(data);
    }
    else
    {
        data = (long *)malloc(100*sizeof(long));
        if (data == NULL) {exit(-1);}
        
    }
    if(globalReturnsTrueOrFalse())
    {
        
        free(data);
    }
    else
    {
        
        
        ; 
"
13094,0,CWE563_Unused_Variable__unused_class_member_variable_01_bad.cpp," * 
 * */

#include ""std_testcase.h""

namespace CWE563_Unused_Variable__unused_class_member_variable_01
{

#ifndef OMITBAD

class BadClass
{
    public:
        BadClass()
        {
            printLine(""BadClass contructor"");
        }
        
        void printMembers() 
        {
            printIntLine(5);
        }
    
    private:
        int id; 
};

void bad()
{
    BadClass badClassObject;
    badClassObject.printMembers();
}

#endif 

} 

/* Below is the main(). It is only used when building this testcase on 
 * its own for testing or for building a binary to use in testing binary 
 * analysis tools. It is not used when compiling all the testcases as one 
 * application, which is how source code analysis tools are tested. 
 */
   
#ifdef INCLUDEMAIN

using namespace CWE563_Unused_Variable__unused_class_member_variable_01; 

int main(int argc, char * argv[])
{
    
    srand( (unsigned)time(NULL) );
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}

"
9476,0,CWE758_Undefined_Behavior__double_pointer_alloca_use_18.c,"    goto sink;
sink:
    {
        double * * pointer = (double * *)ALLOCA(sizeof(double *));
        double * data = *pointer; 
        printDoubleLine(*data);
"
18213,0,CWE590_Free_Memory_Not_on_Heap__delete_int64_t_static_16.cpp,"    int64_t * data;
    data = NULL; 
    while(1)
    {
        {
            
            static int64_t dataBuffer;
            dataBuffer = 5LL;
            data = &dataBuffer;
        }
        break;
    }
    printLongLongLine(*data);
    
"
19322,0,CWE134_Uncontrolled_Format_String__char_console_vfprintf_32.c,"    char * data;
    char * *dataPtr1 = &data;
    char * *dataPtr2 = &data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        char * data = *dataPtr1;
        {
            
            size_t dataLen = strlen(data);
            
            if (100-dataLen > 1)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
                {
                    /* The next few lines remove the carriage return from the string that is
                     * inserted by fgets() */
                    dataLen = strlen(data);
                    if (dataLen > 0 && data[dataLen-1] == '\n')
                    {
                        data[dataLen-1] = '\0';
                    }
                }
                else
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
            }
        }
        *dataPtr1 = data;
    }
    {
        char * data = *dataPtr2;
        badVaSink(data, data);
"
7738,1,CWE401_Memory_Leak__malloc_realloc_char_04.c,"    if(STATIC_CONST_TRUE)
    {
        {
            char * data = (char *)malloc(100*sizeof(char));
            if (data == NULL) {exit(-1);}
            char * tmpData;
            
            strcpy(data, ""A String"");
            printLine(data);
            tmpData = (char *)realloc(data, (130000)*sizeof(char));
            /* FIX: Ensure realloc() was successful before assigning data to the memory block
            * allocated with realloc() */
            if (tmpData != NULL)
            {
                data = tmpData;
                
                strcpy(data, ""New String"");
                printLine(data);
            }
            free(data);
        }
"
7465,0,CWE690_NULL_Deref_From_Return__fopen_22a.c,"    FILE * data;
    
    data = NULL;
    
    data = fopen(""file.txt"", ""w+"");
    CWE690_NULL_Deref_From_Return__fopen_22_badGlobal = 1; 
"
11431,0,CWE590_Free_Memory_Not_on_Heap__delete_char_alloca_16.cpp,"    char * data;
    data = NULL; 
    while(1)
    {
        {
            
            char * dataBuffer = (char *)ALLOCA(sizeof(char));
            *dataBuffer = 'A';
            data = dataBuffer;
        }
        break;
    }
    printHexCharLine(*data);
    
"
2440,0,CWE78_OS_Command_Injection__char_file_popen_84a.cpp,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    CWE78_OS_Command_Injection__char_file_popen_84_bad * badObject = new CWE78_OS_Command_Injection__char_file_popen_84_bad(data);
"
14523,0,CWE134_Uncontrolled_Format_String__char_console_fprintf_09.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(GLOBAL_CONST_TRUE)
    {
        {
            
            size_t dataLen = strlen(data);
            
            if (100-dataLen > 1)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
                {
                    /* The next few lines remove the carriage return from the string that is
                     * inserted by fgets() */
                    dataLen = strlen(data);
                    if (dataLen > 0 && data[dataLen-1] == '\n')
                    {
                        data[dataLen-1] = '\0';
                    }
                }
                else
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
            }
        }
    }
    if(GLOBAL_CONST_TRUE)
    {
        
        fprintf(stdout, data);
"
4699,0,CWE197_Numeric_Truncation_Error__int_large_to_short_61a.c,"    int data;
    
    data = -1;
    data = CWE197_Numeric_Truncation_Error__int_large_to_short_61b_badSource(data);
    {
        
        short shortData = (short)data;
        printShortLine(shortData);
"
18889,0,CWE190_Integer_Overflow__short_fscanf_preinc_06.c,"    short data;
    data = 0;
    if(STATIC_CONST_FIVE==5)
    {
        
        fscanf (stdin, ""%hd"", &data);
    }
    if(STATIC_CONST_FIVE==5)
    {
        {
            
            ++data;
            short result = data;
            printIntLine(result);
        }
"
14734,1,CWE401_Memory_Leak__malloc_realloc_struct_twoIntsStruct_07.c,"    if(staticFive!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            struct _twoIntsStruct * data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));
            if (data == NULL) {exit(-1);}
            struct _twoIntsStruct * tmpData;
            
            data[0].intOne = 0;
            data[0].intTwo = 0;
            printStructLine((twoIntsStruct *)&data[0]);
            tmpData = (struct _twoIntsStruct *)realloc(data, (130000)*sizeof(struct _twoIntsStruct));
            /* FIX: Ensure realloc() was successful before assigning data to the memory block
            * allocated with realloc() */
            if (tmpData != NULL)
            {
                data = tmpData;
                
                data[0].intOne = 1;
                data[0].intTwo = 1;
                printStructLine((twoIntsStruct *)&data[0]);
            }
            free(data);
        }
"
19017,0,CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_11.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(globalReturnsTrue())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET connectSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                
                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                data[dataLen + recvResult / sizeof(char)] = '\0';
                
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(globalReturnsTrue())
    {
        
        fprintf(stdout, data);
"
18359,0,CWE78_OS_Command_Injection__char_connect_socket_execl_33.cpp,"    char * data;
    char * &dataRef = data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
"
7666,0,CWE78_OS_Command_Injection__char_console_popen_05.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(staticTrue)
    {
        {
            
            size_t dataLen = strlen(data);
            
            if (100-dataLen > 1)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
                {
                    /* The next few lines remove the carriage return from the string that is
                     * inserted by fgets() */
                    dataLen = strlen(data);
"
16148,0,CWE690_NULL_Deref_From_Return__long_calloc_84a.cpp,"    long * data;
    data = NULL; 
    CWE690_NULL_Deref_From_Return__long_calloc_84_bad * badObject = new CWE690_NULL_Deref_From_Return__long_calloc_84_bad(data);
"
1370,0,CWE369_Divide_by_Zero__int_listen_socket_divide_73a.cpp,"    int data;
    list<int> dataList;
    
    data = -1;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
12895,0,CWE190_Integer_Overflow__char_fscanf_square_84_bad.cpp,"Label Definition File: CWE190_Integer_Overflow.label.xml
Template File: sources-sinks-84_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 190 Integer Overflow
 * BadSource: fscanf Read data from the console using fscanf()
 * GoodSource: Set data to a small, non-zero number (two)
 * Sinks: square
 *    GoodSink: Ensure there will not be an overflow before squaring data
 *    BadSink : Square data, which can lead to overflow
 * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE190_Integer_Overflow__char_fscanf_square_84.h""

#include <math.h>

namespace CWE190_Integer_Overflow__char_fscanf_square_84
{
CWE190_Integer_Overflow__char_fscanf_square_84_bad::CWE190_Integer_Overflow__char_fscanf_square_84_bad(char dataCopy)
{
    data = dataCopy;
    
    fscanf (stdin, ""%c"", &data);
}

CWE190_Integer_Overflow__char_fscanf_square_84_bad::~CWE190_Integer_Overflow__char_fscanf_square_84_bad()
{
    {
        
        char result = data * data;
        printHexCharLine(result);
    }
}
}
"
14763,0,CWE590_Free_Memory_Not_on_Heap__free_char_static_01.c,"    char * data;
    data = NULL; 
    {
        
        static char dataBuffer[100];
        memset(dataBuffer, 'A', 100-1); 
        dataBuffer[100-1] = '\0'; 
        data = dataBuffer;
    }
    printLine(data);
    
"
9068,0,CWE690_NULL_Deref_From_Return__long_calloc_64a.c,"    long * data;
    data = NULL; 
    
    data = (long *)calloc(1, sizeof(long));
"
13315,0,CWE369_Divide_by_Zero__int_zero_divide_10.c,"    int data;
    
    data = -1;
    if(globalTrue)
    {
        
        data = 0;
    }
    if(globalTrue)
    {
        
        printIntLine(100 / data);
"
16180,1,CWE476_NULL_Pointer_Dereference__binary_if_03.c,"    if(5==5)
    {
        {
            twoIntsStruct *twoIntsStructPointer = NULL;
            /* FIX: Use && in the if statement so that if the left side of the expression fails then
             * the right side will not be evaluated */
            if ((twoIntsStructPointer != NULL) && (twoIntsStructPointer->intOne == 5))
            {
                printLine(""intOne == 5"");
            }
        }
"
19422,0,CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_61a.c,"    int data;
    
    data = -1;
    data = CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_61b_badSource(data);
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
17598,0,CWE590_Free_Memory_Not_on_Heap__delete_char_static_41.cpp,"    char * data;
    data = NULL; 
    {
        
        static char dataBuffer;
        dataBuffer = 'A';
        data = &dataBuffer;
    }
"
5271,0,CWE190_Integer_Overflow__int64_t_max_postinc_04.c,"    int64_t data;
    data = 0LL;
    if(STATIC_CONST_TRUE)
    {
        
        data = LLONG_MAX;
    }
    if(STATIC_CONST_TRUE)
    {
        {
            
            data++;
            int64_t result = data;
            printLongLongLine(result);
        }
"
3177,0,CWE590_Free_Memory_Not_on_Heap__delete_array_int_alloca_14.cpp,"    int * data;
    data = NULL; 
    if(globalFive==5)
    {
        {
            
            int * dataBuffer = (int *)ALLOCA(100*sizeof(int));
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5;
                }
            }
            data = dataBuffer;
        }
    }
    printIntLine(data[0]);
    
"
18031,0,CWE690_NULL_Deref_From_Return__int_realloc_05.c,"    int * data;
    data = NULL; 
    
    data = (int *)realloc(data, 1*sizeof(int));
    if(staticTrue)
    {
        
        data[0] = 5;
        printIntLine(data[0]);
        free(data);
"
11107,0,CWE758_Undefined_Behavior__long_alloca_use_01.c,"    {
        long * pointer = (long *)ALLOCA(sizeof(long));
        long data = *pointer; 
        printLongLine(data);
"
3081,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_41.c,"    size_t data;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = strtoul(inputBuffer, NULL, 0);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
25,0,CWE134_Uncontrolled_Format_String__char_environment_vfprintf_81_bad.cpp,"Label Definition File: CWE134_Uncontrolled_Format_String.vasinks.label.xml
Template File: sources-vasinks-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 134 Uncontrolled Format String
 * BadSource: environment Read input from an environment variable
 * GoodSource: Copy a fixed string into data
 * Sinks: vfprintf
 *    GoodSink: vfprintf with a format string
 *    BadSink : vfprintf without a format string
 * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include <stdarg.h>
#include ""std_testcase.h""
#include ""CWE134_Uncontrolled_Format_String__char_environment_vfprintf_81.h""

namespace CWE134_Uncontrolled_Format_String__char_environment_vfprintf_81
{

static void badVaSink(char * data, ...)
{
    {
        va_list args;
        va_start(args, data);
        
        vfprintf(stdout, data, args);
        va_end(args);
    }
}

void CWE134_Uncontrolled_Format_String__char_environment_vfprintf_81_bad::action(char * data) const
{
    badVaSink(data, data);
}

}
"
14403,0,CWE190_Integer_Overflow__unsigned_int_max_postinc_34.c,"    unsigned int data;
    CWE190_Integer_Overflow__unsigned_int_max_postinc_34_unionType myUnion;
    data = 0;
    
    data = UINT_MAX;
    myUnion.unionFirst = data;
    {
        unsigned int data = myUnion.unionSecond;
        {
            
            data++;
            unsigned int result = data;
            printUnsignedLine(result);
        }
"
9686,0,CWE415_Double_Free__new_delete_long_44.cpp,"    long * data;
    
    void (*funcPtr) (long *) = badSink;
    
    data = NULL;
    data = new long;
    
    delete data;
    
"
18439,1,CWE252_Unchecked_Return_Value__char_putc_08.c,"    if(staticReturnsTrue())
    {
        
        if (putc((int)'A', stdout) == EOF)
        {
            printLine(""putc failed!"");
        }
"
3540,0,CWE369_Divide_by_Zero__int_zero_divide_44.c,"    int data;
    
    void (*funcPtr) (int) = badSink;
    
    data = -1;
    
    data = 0;
    
"
16029,0,CWE690_NULL_Deref_From_Return__char_malloc_81a.cpp,"    char * data;
    data = NULL; 
    
    data = (char *)malloc(20*sizeof(char));
    const CWE690_NULL_Deref_From_Return__char_malloc_81_base& baseObject = CWE690_NULL_Deref_From_Return__char_malloc_81_bad();
"
9106,0,CWE457_Use_of_Uninitialized_Variable__int_array_declare_no_init_18.c,"    int * data;
    int dataUninitArray[10];
    data = dataUninitArray;
    goto source;
source:
    
    ; 
    goto sink;
sink:
    
    {
        int i;
        for(i=0; i<10; i++)
        {
            printIntLine(data[i]);
        }
"
7443,0,CWE758_Undefined_Behavior__char_pointer_alloca_use_10.c,"    if(globalTrue)
    {
        {
            char * * pointer = (char * *)ALLOCA(sizeof(char *));
            char * data = *pointer; 
            printLine(data);
        }
"
1887,0,CWE190_Integer_Overflow__int_listen_socket_multiply_52a.c,"    int data;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
18631,0,CWE134_Uncontrolled_Format_String__char_console_fprintf_67a.c,"    char * data;
    CWE134_Uncontrolled_Format_String__char_console_fprintf_67_structType myStruct;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        
        if (100-dataLen > 1)
        {
            
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgets() */
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
                    data[dataLen-1] = '\0';
                }
            }
            else
            {
                printLine(""fgets() failed"");
                
                data[dataLen] = '\0';
            }
        }
    }
    myStruct.structFirst = data;
"
6045,0,CWE134_Uncontrolled_Format_String__char_environment_snprintf_04.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(STATIC_CONST_TRUE)
    {
        {
            
            size_t dataLen = strlen(data);
            char * environment = GETENV(ENV_VARIABLE);
            
            if (environment != NULL)
            {
                
                strncat(data+dataLen, environment, 100-dataLen-1);
            }
        }
    }
    if(STATIC_CONST_TRUE)
    {
        {
            char dest[100] = """";
            
            SNPRINTF(dest, 100-1, data);
            printLine(dest);
        }
"
8502,1,CWE688_Function_Call_With_Incorrect_Variable_or_Reference_as_Argument__basic_07.c,"    if(staticFive==5)
    {
        {
            char dest[DEST_SIZE];
            int intFive = 5;
            
            sprintf(dest, ""%d"", intFive);
            printLine(dest);
        }
"
1765,0,CWE190_Integer_Overflow__int64_t_rand_preinc_04.c,"    int64_t data;
    data = 0LL;
    if(STATIC_CONST_TRUE)
    {
        
        data = (int64_t)RAND64();
    }
    if(STATIC_CONST_TRUE)
    {
        {
            
            ++data;
            int64_t result = data;
            printLongLongLine(result);
        }
"
11325,0,CWE197_Numeric_Truncation_Error__short_rand_83_bad.cpp,"Label Definition File: CWE197_Numeric_Truncation_Error__short.label.xml
Template File: sources-sink-83_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 197 Numeric Truncation Error
 * BadSource: rand Set data to result of RAND32(), which could be negative
 * GoodSource: Less than CHAR_MAX
 * Sinks:
 *    BadSink : Convert data to a char
 * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE197_Numeric_Truncation_Error__short_rand_83.h""

namespace CWE197_Numeric_Truncation_Error__short_rand_83
{
CWE197_Numeric_Truncation_Error__short_rand_83_bad::CWE197_Numeric_Truncation_Error__short_rand_83_bad(short dataCopy)
{
    data = dataCopy;
    
    data = (short)RAND32();
}

CWE197_Numeric_Truncation_Error__short_rand_83_bad::~CWE197_Numeric_Truncation_Error__short_rand_83_bad()
{
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
    }
}
}
"
8109,0,CWE690_NULL_Deref_From_Return__int64_t_realloc_11.c,"    int64_t * data;
    data = NULL; 
    
    data = (int64_t *)realloc(data, 1*sizeof(int64_t));
    if(globalReturnsTrue())
    {
        
        data[0] = 5LL;
        printLongLongLine(data[0]);
        free(data);
"
6764,0,CWE401_Memory_Leak__int_calloc_34.c,"    int * data;
    CWE401_Memory_Leak__int_calloc_34_unionType myUnion;
    data = NULL;
    
    data = (int *)calloc(100, sizeof(int));
    if (data == NULL) {exit(-1);}
    
    data[0] = 5;
    printIntLine(data[0]);
    myUnion.unionFirst = data;
    {
        int * data = myUnion.unionSecond;
        
        ; 
"
3690,0,CWE190_Integer_Overflow__unsigned_int_rand_add_45.c,"    unsigned int data;
    data = 0;
    
    data = (unsigned int)RAND32();
    CWE190_Integer_Overflow__unsigned_int_rand_add_45_badData = data;
"
13479,0,CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_73a.cpp,"    char * data;
    list<char *> dataList;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
6999,0,CWE190_Integer_Overflow__int64_t_fscanf_square_45.c,"    int64_t data;
    data = 0LL;
    
    fscanf (stdin, ""%"" SCNd64, &data);
    CWE190_Integer_Overflow__int64_t_fscanf_square_45_badData = data;
"
19383,0,CWE590_Free_Memory_Not_on_Heap__delete_array_class_static_02.cpp,"    TwoIntsClass * data;
    data = NULL; 
    if(1)
    {
        {
            
            static TwoIntsClass dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i].intOne = 1;
                    dataBuffer[i].intTwo = 1;
                }
            }
            data = dataBuffer;
        }
    }
    printIntLine(data[0].intOne);
    
"
2208,0,CWE590_Free_Memory_Not_on_Heap__free_long_alloca_74a.cpp,"    long * data;
    map<int, long *> dataMap;
    data = NULL; 
    {
        
        long * dataBuffer = (long *)ALLOCA(100*sizeof(long));
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5L;
            }
        }
        data = dataBuffer;
    }
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
1870,0,CWE134_Uncontrolled_Format_String__char_environment_vfprintf_83_bad.cpp,"Label Definition File: CWE134_Uncontrolled_Format_String.vasinks.label.xml
Template File: sources-vasinks-83_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 134 Uncontrolled Format String
 * BadSource: environment Read input from an environment variable
 * GoodSource: Copy a fixed string into data
 * Sinks: vfprintf
 *    GoodSink: vfprintf with a format string
 *    BadSink : vfprintf without a format string
 * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack
 *
 * */
#ifndef OMITBAD

#include <stdarg.h>
#include ""std_testcase.h""
#include ""CWE134_Uncontrolled_Format_String__char_environment_vfprintf_83.h""

#define ENV_VARIABLE ""ADD""

#ifdef _WIN32
#define GETENV getenv
#else
#define GETENV getenv
#endif

namespace CWE134_Uncontrolled_Format_String__char_environment_vfprintf_83
{
CWE134_Uncontrolled_Format_String__char_environment_vfprintf_83_bad::CWE134_Uncontrolled_Format_String__char_environment_vfprintf_83_bad(char * dataCopy)
{
    data = dataCopy;
    {
        
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        
        if (environment != NULL)
        {
            
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
}

static void badVaSink(char * data, ...)
{
    {
        va_list args;
        va_start(args, data);
        
        vfprintf(stdout, data, args);
        va_end(args);
    }
}

CWE134_Uncontrolled_Format_String__char_environment_vfprintf_83_bad::~CWE134_Uncontrolled_Format_String__char_environment_vfprintf_83_bad()
{
    badVaSink(data, data);
}
}
"
6018,0,CWE190_Integer_Overflow__int_max_preinc_32.c,"    int data;
    int *dataPtr1 = &data;
    int *dataPtr2 = &data;
    
    data = 0;
    {
        int data = *dataPtr1;
        
        data = INT_MAX;
        *dataPtr1 = data;
    }
    {
        int data = *dataPtr2;
        {
            
            ++data;
            int result = data;
            printIntLine(result);
        }
"
17903,0,CWE369_Divide_by_Zero__int_zero_modulo_01.c,"    int data;
    
    data = -1;
    
    data = 0;
    
"
3930,0,CWE758_Undefined_Behavior__double_pointer_malloc_use_05.c,"    if(staticTrue)
    {
        {
            double * * pointer = (double * *)malloc(sizeof(double *));
            if (pointer == NULL) {exit(-1);}
            double * data = *pointer; 
            free(pointer);
            printDoubleLine(*data);
        }
"
1884,0,CWE190_Integer_Overflow__short_fscanf_add_01.c,"    short data;
    data = 0;
    
    fscanf (stdin, ""%hd"", &data);
    {
        
        short result = data + 1;
        printIntLine(result);
"
2173,0,CWE476_NULL_Pointer_Dereference__long_08.c,"    long * data;
    if(staticReturnsTrue())
    {
        
        data = NULL;
    }
    if(staticReturnsTrue())
    {
        
        printLongLine(*data);
"
19095,0,CWE457_Use_of_Uninitialized_Variable__long_16.c,"    long data;
    while(1)
    {
        
        ; 
        break;
    }
    while(1)
    {
        
        printLongLine(data);
        break;
"
18747,0,CWE789_Uncontrolled_Mem_Alloc__new_char_rand_15.cpp,"    size_t data;
    
    data = 0;
    switch(6)
    {
    case 6:
        
        data = rand();
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
    {
        char * myString;
        /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
         * for the strcpy() function to not cause a buffer overflow */
        
        if (data > strlen(HELLO_STRING))
        {
            myString = new char[data];
            
            strcpy(myString, HELLO_STRING);
            printLine(myString);
            delete [] myString;
        }
        else
        {
            printLine(""Input is less than the length of the source string"");
        }
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
3108,1,CWE401_Memory_Leak__malloc_realloc_int_04.c,"    if(STATIC_CONST_TRUE)
    {
        {
            int * data = (int *)malloc(100*sizeof(int));
            if (data == NULL) {exit(-1);}
            int * tmpData;
            
            data[0] = 5;
            printIntLine(data[0]);
            tmpData = (int *)realloc(data, (130000)*sizeof(int));
            /* FIX: Ensure realloc() was successful before assigning data to the memory block
            * allocated with realloc() */
            if (tmpData != NULL)
            {
                data = tmpData;
                
                data[0] = 10;
                printIntLine(data[0]);
            }
            free(data);
        }
"
14520,0,CWE401_Memory_Leak__int64_t_calloc_08.c,"    int64_t * data;
    data = NULL;
    if(staticReturnsTrue())
    {
        
        data = (int64_t *)calloc(100, sizeof(int64_t));
        if (data == NULL) {exit(-1);}
        
        data[0] = 5LL;
        printLongLongLine(data[0]);
    }
    if(staticReturnsTrue())
    {
        
        ; 
"
10929,0,CWE690_NULL_Deref_From_Return__int_realloc_64a.c,"    int * data;
    data = NULL; 
    
    data = (int *)realloc(data, 1*sizeof(int));
"
7359,0,CWE78_OS_Command_Injection__char_connect_socket_popen_64a.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
8395,0,CWE134_Uncontrolled_Format_String__char_console_printf_72a.cpp,"    char * data;
    vector<char *> dataVector;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        
        if (100-dataLen > 1)
        {
            
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgets() */
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
                    data[dataLen-1] = '\0';
                }
            }
            else
            {
                printLine(""fgets() failed"");
                
                data[dataLen] = '\0';
            }
        }
    }
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
17819,0,CWE190_Integer_Overflow__int64_t_max_multiply_21.c,"    int64_t data;
    data = 0LL;
    
    data = LLONG_MAX;
    badStatic = 1; 
"
17934,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_63a.c,"    size_t data;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = strtoul(inputBuffer, NULL, 0);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
7678,0,CWE197_Numeric_Truncation_Error__short_fgets_17.c,"    int i;
    short data;
    
    data = -1;
    for(i = 0; i < 1; i++)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                
                data = (short)atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
13271,0,CWE190_Integer_Overflow__short_fscanf_multiply_14.c,"    short data;
    data = 0;
    if(globalFive==5)
    {
        
        fscanf (stdin, ""%hd"", &data);
    }
    if(globalFive==5)
    {
        if(data > 0) 
        {
            
            short result = data * 2;
            printIntLine(result);
        }
"
8823,0,CWE563_Unused_Variable__unused_uninit_variable_int64_t_04.c,"    int64_t data;
    
    ; 
    if(STATIC_CONST_TRUE)
    {
        
        
        ; 
"
11004,0,CWE563_Unused_Variable__unused_init_variable_struct_16.c,"    twoIntsStruct data;
    
    data.intOne = 0;
    data.intTwo = 0;
    while(1)
    {
        
        
        ; 
        break;
"
14654,0,CWE415_Double_Free__new_delete_int64_t_63a.cpp,"    int64_t * data;
    
    data = NULL;
    data = new int64_t;
    
    delete data;
"
545,1,CWE688_Function_Call_With_Incorrect_Variable_or_Reference_as_Argument__basic_02.c,"    if(0)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            char dest[DEST_SIZE];
            int intFive = 5;
            
            sprintf(dest, ""%d"", intFive);
            printLine(dest);
        }
"
14699,0,CWE190_Integer_Overflow__unsigned_int_rand_postinc_51a.c,"    unsigned int data;
    data = 0;
    
    data = (unsigned int)RAND32();
"
3703,0,CWE416_Use_After_Free__malloc_free_int_16.c,"    int * data;
    
    data = NULL;
    while(1)
    {
        data = (int *)malloc(100*sizeof(int));
        if (data == NULL) {exit(-1);}
        {
            size_t i;
            for(i = 0; i < 100; i++)
            {
                data[i] = 5;
            }
        }
        
        free(data);
        break;
    }
    while(1)
    {
        
        printIntLine(data[0]);
        
        break;
"
6391,0,CWE197_Numeric_Truncation_Error__int_fscanf_to_char_65a.c,"    int data;
    
    void (*funcPtr) (int) = CWE197_Numeric_Truncation_Error__int_fscanf_to_char_65b_badSink;
    
    data = -1;
    
    fscanf(stdin, ""%d"", &data);
    
"
6479,0,CWE690_NULL_Deref_From_Return__int_calloc_41.c,"    int * data;
    data = NULL; 
    
    data = (int *)calloc(1, sizeof(int));
"
15688,0,CWE476_NULL_Pointer_Dereference__char_11.c,"    char * data;
    if(globalReturnsTrue())
    {
        
        data = NULL;
    }
    if(globalReturnsTrue())
    {
        
        
        printHexCharLine(data[0]);
"
7866,0,CWE401_Memory_Leak__char_calloc_61a.c,"    char * data;
    data = NULL;
    data = CWE401_Memory_Leak__char_calloc_61b_badSource(data);
    
"
14173,1,CWE401_Memory_Leak__malloc_realloc_int64_t_07.c,"    if(staticFive==5)
    {
        {
            int64_t * data = (int64_t *)malloc(100*sizeof(int64_t));
            if (data == NULL) {exit(-1);}
            int64_t * tmpData;
            
            data[0] = 5LL;
            printLongLongLine(data[0]);
            tmpData = (int64_t *)realloc(data, (130000)*sizeof(int64_t));
            /* FIX: Ensure realloc() was successful before assigning data to the memory block
            * allocated with realloc() */
            if (tmpData != NULL)
            {
                data = tmpData;
                
                data[0] = 10LL;
                printLongLongLine(data[0]);
            }
            free(data);
        }
"
8232,0,CWE789_Uncontrolled_Mem_Alloc__new_char_listen_socket_12.cpp,"    size_t data;
    
    data = 0;
    if(globalReturnsTrueOrFalse())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = strtoul(inputBuffer, NULL, 0);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    else
    {
        
        data = 20;
    }
    if(globalReturnsTrueOrFalse())
    {
        {
            char * myString;
            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
             * for the strcpy() function to not cause a buffer overflow */
            
            if (data > strlen(HELLO_STRING))
            {
                myString = new char[data];
                
                strcpy(myString, HELLO_STRING);
                printLine(myString);
                delete [] myString;
            }
            else
            {
                printLine(""Input is less than the length of the source string"");
            }
        }
    }
    else
    {
        {
            char * myString;
            /* FIX: Include a MAXIMUM limitation for memory allocation and a check to ensure data is large enough
             * for the strcpy() function to not cause a buffer overflow */
            
            if (data > strlen(HELLO_STRING) && data < 100)
            {
                myString = new char[data];
                
                strcpy(myString, HELLO_STRING);
                printLine(myString);
                delete [] myString;
            }
            else
            {
                printLine(""Input is less than the length of the source string or too large"");
            }
        }
"
17196,0,CWE563_Unused_Variable__unused_uninit_variable_int64_t_81a.cpp,"    int64_t data;
    
    ; 
    const CWE563_Unused_Variable__unused_uninit_variable_int64_t_81_base& baseObject = CWE563_Unused_Variable__unused_uninit_variable_int64_t_81_bad();
"
2383,0,CWE590_Free_Memory_Not_on_Heap__delete_array_long_static_11.cpp,"    long * data;
    data = NULL; 
    if(globalReturnsTrue())
    {
        {
            
            static long dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5L;
                }
            }
            data = dataBuffer;
        }
    }
    printLongLine(data[0]);
    
"
15440,0,CWE665_Improper_Initialization__char_ncat_53a.c,"    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    
    ; 
"
10428,0,CWE252_Unchecked_Return_Value__char_fputc_06.c,"    if(STATIC_CONST_FIVE==5)
    {
        
        fputc((int)'A', stdout);
"
19229,0,CWE563_Unused_Variable__unused_uninit_variable_long_82a.cpp,"    long data;
    
    ; 
    CWE563_Unused_Variable__unused_uninit_variable_long_82_base* baseObject = new CWE563_Unused_Variable__unused_uninit_variable_long_82_bad;
    baseObject->action(data);
"
9585,0,CWE190_Integer_Overflow__int64_t_max_preinc_18.c,"    int64_t data;
    data = 0LL;
    goto source;
source:
    
    data = LLONG_MAX;
    goto sink;
sink:
    {
        
        ++data;
        int64_t result = data;
        printLongLongLine(result);
"
10718,0,CWE758_Undefined_Behavior__char_pointer_malloc_use_18.c,"    goto sink;
sink:
    {
        char * * pointer = (char * *)malloc(sizeof(char *));
        if (pointer == NULL) {exit(-1);}
        char * data = *pointer; 
        free(pointer);
        printLine(data);
"
4457,0,CWE590_Free_Memory_Not_on_Heap__delete_int64_t_static_34.cpp,"    int64_t * data;
    unionType myUnion;
    data = NULL; 
    {
        
        static int64_t dataBuffer;
        dataBuffer = 5LL;
        data = &dataBuffer;
    }
    myUnion.unionFirst = data;
    {
        int64_t * data = myUnion.unionSecond;
        printLongLongLine(*data);
        
        delete data;
"
4595,0,CWE563_Unused_Variable__unused_uninit_variable_int64_t_22a.c,"    int64_t data;
    
    ; 
    CWE563_Unused_Variable__unused_uninit_variable_int64_t_22_badGlobal = 1; 
"
12964,0,CWE401_Memory_Leak__int_realloc_84a.cpp,"    int * data;
    data = NULL;
    CWE401_Memory_Leak__int_realloc_84_bad * badObject = new CWE401_Memory_Leak__int_realloc_84_bad(data);
"
4075,0,CWE590_Free_Memory_Not_on_Heap__delete_int64_t_static_41.cpp,"    int64_t * data;
    data = NULL; 
    {
        
        static int64_t dataBuffer;
        dataBuffer = 5LL;
        data = &dataBuffer;
    }
"
1193,0,CWE415_Double_Free__new_delete_class_51a.cpp,"    TwoIntsClass * data;
    
    data = NULL;
    data = new TwoIntsClass;
    
    delete data;
"
6896,0,CWE401_Memory_Leak__new_twoIntsStruct_52a.cpp,"    twoIntsStruct * data;
    data = NULL;
    
    data = new twoIntsStruct;
    
    data->intOne = 0;
    data->intTwo = 0;
    printStructLine(data);
"
4498,0,CWE134_Uncontrolled_Format_String__char_environment_vfprintf_43.cpp,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    badSource(data);
"
17463,0,CWE416_Use_After_Free__new_delete_array_class_01.cpp,"    TwoIntsClass * data;
    
    data = NULL;
    data = new TwoIntsClass[100];
    {
        size_t i;
        for(i = 0; i < 100; i++)
        {
            data[i].intOne = 1;
            data[i].intTwo = 2;
        }
    }
    
    delete [] data;
    
    printIntLine(data[0].intOne);
"
807,0,CWE590_Free_Memory_Not_on_Heap__delete_int64_t_alloca_81a.cpp,"    int64_t * data;
    data = NULL; 
    {
        
        int64_t * dataBuffer = (int64_t *)ALLOCA(sizeof(int64_t));
        *dataBuffer = 5LL;
        data = dataBuffer;
    }
    const CWE590_Free_Memory_Not_on_Heap__delete_int64_t_alloca_81_base& baseObject = CWE590_Free_Memory_Not_on_Heap__delete_int64_t_alloca_81_bad();
"
15337,0,CWE690_NULL_Deref_From_Return__long_calloc_17.c,"    int j;
    long * data;
    data = NULL; 
    
    data = (long *)calloc(1, sizeof(long));
    for(j = 0; j < 1; j++)
    {
        
        data[0] = 5L;
        printLongLine(data[0]);
        free(data);
"
788,1,CWE758_Undefined_Behavior__class_new_use_03.cpp,"    if(5!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            TwoIntsClass data;
            data.intOne = 1;
            data.intTwo = 2;
            TwoIntsClass * pointer = new TwoIntsClass;
            *pointer = data; 
            {
                TwoIntsClass data = *pointer;
                printIntLine(data.intOne);
                printIntLine(data.intTwo);
            }
            delete pointer;
        }
"
11611,0,CWE690_NULL_Deref_From_Return__struct_realloc_43.cpp,"    twoIntsStruct * data;
    data = NULL; 
    badSource(data);
    
    data[0].intOne = 1;
    data[0].intTwo = 1;
    printStructLine(&data[0]);
"
7553,0,CWE369_Divide_by_Zero__float_fscanf_15.c,"    float data;
    
    data = 0.0F;
    switch(6)
    {
    case 6:
        
        fscanf (stdin, ""%f"", &data);
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
    {
        
        int result = (int)(100.0 / data);
        printIntLine(result);
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
15804,0,CWE190_Integer_Overflow__int_rand_postinc_51a.c,"    int data;
    
    data = 0;
    
    data = RAND32();
"
10117,0,CWE190_Integer_Overflow__int_rand_preinc_65a.c,"    int data;
    
    void (*funcPtr) (int) = CWE190_Integer_Overflow__int_rand_preinc_65b_badSink;
    
    data = 0;
    
    data = RAND32();
    
"
1805,0,CWE457_Use_of_Uninitialized_Variable__struct_array_declare_no_init_43.cpp,"    twoIntsStruct * data;
    twoIntsStruct dataUninitArray[10];
    data = dataUninitArray;
    badSource(data);
    
    {
        int i;
        for(i=0; i<10; i++)
        {
            printIntLine(data[i].intOne);
            printIntLine(data[i].intTwo);
        }
"
10732,0,CWE415_Double_Free__new_delete_struct_61a.cpp,"    twoIntsStruct * data;
    
    data = NULL;
    data = badSource(data);
    
"
10074,0,CWE401_Memory_Leak__int_calloc_03.c,"    int * data;
    data = NULL;
    if(5==5)
    {
        
        data = (int *)calloc(100, sizeof(int));
        if (data == NULL) {exit(-1);}
        
        data[0] = 5;
        printIntLine(data[0]);
    }
    if(5==5)
    {
        
        ; 
"
7140,0,CWE590_Free_Memory_Not_on_Heap__delete_array_int_static_01.cpp,"    int * data;
    data = NULL; 
    {
        
        static int dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5;
            }
        }
        data = dataBuffer;
    }
    printIntLine(data[0]);
    
"
16217,0,CWE197_Numeric_Truncation_Error__int_large_to_short_83a.cpp,"    int data;
    
    data = -1;
"
4437,0,CWE590_Free_Memory_Not_on_Heap__delete_int64_t_placement_new_74a.cpp,"    int64_t * data;
    map<int, int64_t *> dataMap;
    data = NULL; 
    {
        
        char buffer[sizeof(int64_t)];
        int64_t * dataBuffer = new(buffer) int64_t;
        *dataBuffer = 5LL;
        data = dataBuffer;
    }
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
5494,0,CWE197_Numeric_Truncation_Error__int_rand_to_short_17.c,"    int i;
    int data;
    
    data = -1;
    for(i = 0; i < 1; i++)
    {
        
        data = RAND32();
    }
    {
        
        short shortData = (short)data;
        printShortLine(shortData);
"
2836,1,CWE758_Undefined_Behavior__int_alloca_use_11.c,"    if(globalReturnsTrue())
    {
        {
            int data;
            int * pointer = (int *)ALLOCA(sizeof(int));
            data = 5;
            *pointer = data; 
            {
                int data = *pointer;
                printIntLine(data);
            }
        }
"
17445,0,CWE78_OS_Command_Injection__char_listen_socket_execlp_65a.c,"    char * data;
    
    void (*funcPtr) (char *) = CWE78_OS_Command_Injection__char_listen_socket_execlp_65b_badSink;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
"
12576,0,CWE416_Use_After_Free__new_delete_array_int_08.cpp,"    int * data;
    
    data = NULL;
    if(staticReturnsTrue())
    {
        data = new int[100];
        {
            size_t i;
            for(i = 0; i < 100; i++)
            {
                data[i] = 5;
            }
        }
        
        delete [] data;
    }
    if(staticReturnsTrue())
    {
        
        printIntLine(data[0]);
        
"
18360,0,CWE369_Divide_by_Zero__int_rand_modulo_01.c,"    int data;
    
    data = -1;
    
    data = RAND32();
    
"
132,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_13.c,"    size_t data;
    
    data = 0;
    if(GLOBAL_CONST_FIVE==5)
    {
        
        fscanf(stdin, ""%zu"", &data);
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            char * myString;
            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
             * for the strcpy() function to not cause a buffer overflow */
            
            if (data > strlen(HELLO_STRING))
            {
                myString = (char *)malloc(data*sizeof(char));
                if (myString == NULL) {exit(-1);}
                
                strcpy(myString, HELLO_STRING);
                printLine(myString);
                free(myString);
            }
            else
            {
                printLine(""Input is less than the length of the source string"");
            }
        }
"
17833,1,CWE252_Unchecked_Return_Value__char_fwrite_06.c,"    if(STATIC_CONST_FIVE!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        
        if (fwrite((char *)""string"", sizeof(char), strlen(""string""), stdout) != strlen(""string""))
        {
            printLine(""fwrite failed!"");
        }
"
14993,0,CWE134_Uncontrolled_Format_String__char_file_printf_07.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(staticFive==5)
    {
        {
            
            size_t dataLen = strlen(data);
            FILE * pFile;
            
            if (100-dataLen > 1)
            {
                pFile = fopen(FILENAME, ""r"");
                if (pFile != NULL)
                {
                    
                    if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                    {
                        printLine(""fgets() failed"");
                        
                        data[dataLen] = '\0';
                    }
                    fclose(pFile);
                }
            }
        }
    }
    if(staticFive==5)
    {
        
        printf(data);
"
18076,0,CWE457_Use_of_Uninitialized_Variable__new_int_array_partial_init_05.cpp,"    int * data;
    data = new int[10];
    if(staticTrue)
    {
        
        {
            int i;
            for(i=0; i<(10/2); i++)
            {
                data[i] = i;
            }
        }
    }
    if(staticTrue)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i]);
            }
        }
        
        delete [] data;
"
12526,0,CWE415_Double_Free__new_delete_char_66a.cpp,"    char * data;
    char * dataArray[5];
    
    data = NULL;
    data = new char;
    
    delete data;
    
    dataArray[2] = data;
"
14291,0,CWE457_Use_of_Uninitialized_Variable__twointsclass_array_alloca_partial_init_13.cpp,"    TwoIntsClass * data;
    data = reinterpret_cast<TwoIntsClass *>(ALLOCA(10*sizeof(TwoIntsClass)));
    if(GLOBAL_CONST_FIVE==5)
    {
        
        for(int i=0; i<(10/2); i++)
        {
            data[i].intOne = i;
            data[i].intTwo = i;
        }
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        
        for(int i=0; i<10; i++)
        {
            printIntLine(data[i].intOne);
            printIntLine(data[i].intTwo);
        }
"
6130,0,CWE416_Use_After_Free__new_delete_array_char_02.cpp,"    char * data;
    
    data = NULL;
    if(1)
    {
        data = new char[100];
        memset(data, 'A', 100-1);
        data[100-1] = '\0';
        
        delete [] data;
    }
    if(1)
    {
        
        printLine(data);
        
"
4701,1,CWE758_Undefined_Behavior__char_pointer_new_use_13.cpp,"    if(GLOBAL_CONST_FIVE==5)
    {
        {
            char * data;
            data = ""string"";
            char * * pointer = new char *;
            *pointer = data; 
            {
                char * data = *pointer;
                printLine(data);
            }
            delete pointer;
        }
"
19010,1,CWE469_Use_of_Pointer_Subtraction_to_Determine_Size__char_14.c,"    if(globalFive==5)
    {
        {
            char string1[] = SOURCE_STRING;
            char * slashInString1;
            size_t indexOfSlashInString1;
            slashInString1 = strchr(string1, '/');
            if (slashInString1 == NULL)
            {
                exit(1);
            }
            
            indexOfSlashInString1 = (size_t)(slashInString1 - string1);
            
            printUnsignedLine(indexOfSlashInString1);
        }
"
10749,0,CWE190_Integer_Overflow__unsigned_int_max_add_13.c,"    unsigned int data;
    data = 0;
    if(GLOBAL_CONST_FIVE==5)
    {
        
        data = UINT_MAX;
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            
            unsigned int result = data + 1;
            printUnsignedLine(result);
        }
"
17070,0,CWE134_Uncontrolled_Format_String__char_console_printf_42.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    data = badSource(data);
    
"
13123,1,CWE252_Unchecked_Return_Value__char_puts_11.c,"    if(globalReturnsTrue())
    {
        
        if (PUTS(""string"") == EOF)
        {
            printLine(""puts failed!"");
        }
"
18132,0,CWE190_Integer_Overflow__int_connect_socket_multiply_64a.c,"    int data;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
2947,0,CWE134_Uncontrolled_Format_String__char_file_fprintf_07.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(staticFive==5)
    {
        {
            
            size_t dataLen = strlen(data);
            FILE * pFile;
            
            if (100-dataLen > 1)
            {
                pFile = fopen(FILENAME, ""r"");
                if (pFile != NULL)
                {
                    
                    if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                    {
                        printLine(""fgets() failed"");
                        
                        data[dataLen] = '\0';
                    }
                    fclose(pFile);
                }
            }
        }
    }
    if(staticFive==5)
    {
        
        fprintf(stdout, data);
"
17997,0,CWE190_Integer_Overflow__int_fgets_add_34.c,"    int data;
    CWE190_Integer_Overflow__int_fgets_add_34_unionType myUnion;
    
    data = 0;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    myUnion.unionFirst = data;
    {
        int data = myUnion.unionSecond;
        {
            
            int result = data + 1;
            printIntLine(result);
        }
"
11596,0,CWE457_Use_of_Uninitialized_Variable__double_array_malloc_partial_init_12.c,"    double * data;
    data = (double *)malloc(10*sizeof(double));
    if (data == NULL) {exit(-1);}
    if(globalReturnsTrueOrFalse())
    {
        
        {
            int i;
            for(i=0; i<(10/2); i++)
            {
                data[i] = (double)i;
            }
        }
    }
    else
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                data[i] = (double)i;
            }
        }
    }
    if(globalReturnsTrueOrFalse())
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printDoubleLine(data[i]);
            }
        }
    }
    else
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                data[i] = (double)i;
            }
        }
        {
            int i;
            for(i=0; i<10; i++)
            {
                printDoubleLine(data[i]);
            }
        }
"
3748,0,CWE197_Numeric_Truncation_Error__short_rand_66a.c,"    short data;
    short dataArray[5];
    
    data = -1;
    
    data = (short)RAND32();
    
    dataArray[2] = data;
"
11436,0,CWE190_Integer_Overflow__int_fgets_add_09.c,"    int data;
    
    data = 0;
    if(GLOBAL_CONST_TRUE)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    if(GLOBAL_CONST_TRUE)
    {
        {
            
            int result = data + 1;
            printIntLine(result);
        }
"
10248,0,CWE457_Use_of_Uninitialized_Variable__int_array_declare_no_init_63a.c,"    int * data;
    int dataUninitArray[10];
    data = dataUninitArray;
    
    ; 
"
5881,0,CWE134_Uncontrolled_Format_String__char_console_fprintf_03.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(5==5)
    {
        {
            
            size_t dataLen = strlen(data);
            
            if (100-dataLen > 1)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
                {
                    /* The next few lines remove the carriage return from the string that is
                     * inserted by fgets() */
                    dataLen = strlen(data);
                    if (dataLen > 0 && data[dataLen-1] == '\n')
                    {
                        data[dataLen-1] = '\0';
                    }
                }
                else
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
            }
        }
    }
    if(5==5)
    {
        
        fprintf(stdout, data);
"
2670,1,CWE758_Undefined_Behavior__struct_pointer_malloc_use_03.c,"    if(5==5)
    {
        {
            twoIntsStruct * data;
            twoIntsStruct * * pointer = (twoIntsStruct * *)malloc(sizeof(twoIntsStruct *));
            if (pointer == NULL) {exit(-1);}
            
            data = (twoIntsStruct *)malloc(sizeof(twoIntsStruct));
            if (data == NULL) {exit(-1);}
            data->intOne = 5;
            data->intTwo = 6;
            *pointer = data; 
            {
                twoIntsStruct * data = *pointer;
                printIntLine(data->intOne);
                printIntLine(data->intTwo);
            }
            free(pointer);
        }
"
10013,0,CWE197_Numeric_Truncation_Error__int_listen_socket_to_char_09.c,"    int data;
    
    data = -1;
    if(GLOBAL_CONST_TRUE)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
7133,0,CWE197_Numeric_Truncation_Error__short_rand_09.c,"    short data;
    
    data = -1;
    if(GLOBAL_CONST_TRUE)
    {
        
        data = (short)RAND32();
    }
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
813,0,CWE789_Uncontrolled_Mem_Alloc__new_char_rand_21.cpp,"    size_t data;
    
    data = 0;
    
    data = rand();
    badStatic = 1; 
"
12782,0,CWE457_Use_of_Uninitialized_Variable__double_array_malloc_partial_init_64a.c,"    double * data;
    data = (double *)malloc(10*sizeof(double));
    if (data == NULL) {exit(-1);}
    
    {
        int i;
        for(i=0; i<(10/2); i++)
        {
            data[i] = (double)i;
        }
    }
"
357,0,CWE190_Integer_Overflow__char_rand_multiply_13.c,"    char data;
    data = ' ';
    if(GLOBAL_CONST_FIVE==5)
    {
        
        data = (char)RAND32();
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        if(data > 0) 
        {
            
            char result = data * 2;
            printHexCharLine(result);
        }
"
10157,0,CWE190_Integer_Overflow__int_fscanf_multiply_51a.c,"    int data;
    
    data = 0;
    
    fscanf(stdin, ""%d"", &data);
"
9936,0,CWE401_Memory_Leak__new_TwoIntsClass_22a.cpp,"    TwoIntsClass * data;
    data = NULL;
    
    data = new TwoIntsClass;
    
    data->intOne = 0;
    data->intTwo = 0;
    printIntLine(data->intOne);
    printIntLine(data->intTwo);
    badGlobal = 1; 
"
14687,0,CWE401_Memory_Leak__new_TwoIntsClass_21.cpp,"    TwoIntsClass * data;
    data = NULL;
    
    data = new TwoIntsClass;
    
    data->intOne = 0;
    data->intTwo = 0;
    printIntLine(data->intOne);
    printIntLine(data->intTwo);
    badStatic = 1; 
"
17681,0,CWE590_Free_Memory_Not_on_Heap__free_long_alloca_02.c,"    long * data;
    data = NULL; 
    if(1)
    {
        {
            
            long * dataBuffer = (long *)ALLOCA(100*sizeof(long));
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5L;
                }
            }
            data = dataBuffer;
        }
    }
    printLongLine(data[0]);
    
"
19086,0,CWE590_Free_Memory_Not_on_Heap__delete_int_static_16.cpp,"    int * data;
    data = NULL; 
    while(1)
    {
        {
            
            static int dataBuffer;
            dataBuffer = 5;
            data = &dataBuffer;
        }
        break;
    }
    printIntLine(*data);
    
"
5255,0,CWE190_Integer_Overflow__unsigned_int_max_postinc_68a.c,"    unsigned int data;
    data = 0;
    
    data = UINT_MAX;
    CWE190_Integer_Overflow__unsigned_int_max_postinc_68_badData = data;
"
9724,0,CWE190_Integer_Overflow__unsigned_int_fscanf_square_62a.cpp,"    unsigned int data;
    data = 0;
    badSource(data);
    {
        
        unsigned int result = data * data;
        printUnsignedLine(result);
"
7599,0,CWE134_Uncontrolled_Format_String__char_connect_socket_printf_42.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    data = badSource(data);
    
"
19542,0,CWE190_Integer_Overflow__char_max_postinc_18.c,"    char data;
    data = ' ';
    goto source;
source:
    
    data = CHAR_MAX;
    goto sink;
sink:
    {
        
        data++;
        char result = data;
        printHexCharLine(result);
"
17886,0,CWE401_Memory_Leak__strdup_char_22a.c,"    char * data;
    data = NULL;
    {
        char myString[] = ""myString"";
        
        data = strdup(myString);
        
        printLine(data);
    }
    CWE401_Memory_Leak__strdup_char_22_badGlobal = 1; 
"
8488,0,CWE78_OS_Command_Injection__char_file_execlp_67a.c,"    char * data;
    CWE78_OS_Command_Injection__char_file_execlp_67_structType myStruct;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        FILE * pFile;
        
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
    myStruct.structFirst = data;
"
7913,0,CWE690_NULL_Deref_From_Return__long_realloc_13.c,"    long * data;
    data = NULL; 
    
    data = (long *)realloc(data, 1*sizeof(long));
    if(GLOBAL_CONST_FIVE==5)
    {
        
        data[0] = 5L;
        printLongLine(data[0]);
        free(data);
"
5955,0,CWE590_Free_Memory_Not_on_Heap__delete_array_struct_static_12.cpp,"    twoIntsStruct * data;
    data = NULL; 
    if(globalReturnsTrueOrFalse())
    {
        {
            
            static twoIntsStruct dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i].intOne = 1;
                    dataBuffer[i].intTwo = 1;
                }
            }
            data = dataBuffer;
        }
    }
    else
    {
        {
            
            twoIntsStruct * dataBuffer = new twoIntsStruct[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i].intOne = 1;
                    dataBuffer[i].intTwo = 1;
                }
            }
            data = dataBuffer;
        }
    }
    printStructLine(&data[0]);
    
"
17741,0,CWE190_Integer_Overflow__int64_t_fscanf_add_61a.c,"    int64_t data;
    data = 0LL;
    data = CWE190_Integer_Overflow__int64_t_fscanf_add_61b_badSource(data);
    {
        
        int64_t result = data + 1;
        printLongLongLine(result);
"
6651,0,CWE416_Use_After_Free__return_freed_ptr_10.c,"    if(globalTrue)
    {
        {
            
            char * reversedString = helperBad(""BadSink"");
            printLine(reversedString);
            /* free(reversedString);
             * This call to free() was removed because we want the tool to detect the use after free,
             * but we don't want that function to be free(). Essentially we want to avoid a double free
             */
        }
"
15847,0,CWE369_Divide_by_Zero__int_connect_socket_modulo_43.cpp,"    int data;
    
    data = -1;
    badSource(data);
    
"
14162,0,CWE78_OS_Command_Injection__char_connect_socket_execlp_51a.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
3232,1,CWE758_Undefined_Behavior__long_alloca_use_02.c,"    if(0)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            long data;
            long * pointer = (long *)ALLOCA(sizeof(long));
            data = 5L;
            *pointer = data; 
            {
                long data = *pointer;
                printLongLine(data);
            }
        }
"
3356,0,CWE590_Free_Memory_Not_on_Heap__delete_struct_declare_04.cpp,"    twoIntsStruct * data;
    data = NULL; 
    if(STATIC_CONST_TRUE)
    {
        {
            
            twoIntsStruct dataBuffer;
            dataBuffer.intOne = 1;
            dataBuffer.intTwo = 1;
            data = &dataBuffer;
        }
    }
    printStructLine(data);
    
"
17848,0,CWE469_Use_of_Pointer_Subtraction_to_Determine_Size__char_03.c,"    if(5==5)
    {
        {
            char string1[] = SOURCE_STRING;
            char string2[] = SOURCE_STRING;
            char * slashInString1;
            size_t indexOfSlashInString1;
            slashInString1 = strchr(string1, '/');
            if (slashInString1 == NULL)
            {
                exit(1);
            }
            
            indexOfSlashInString1 = (size_t)(slashInString1 - string2);
            
            printUnsignedLine(indexOfSlashInString1);
        }
"
12279,0,CWE190_Integer_Overflow__int64_t_rand_multiply_67a.c,"    int64_t data;
    CWE190_Integer_Overflow__int64_t_rand_multiply_67_structType myStruct;
    data = 0LL;
    
    data = (int64_t)RAND64();
    myStruct.structFirst = data;
"
8618,1,CWE252_Unchecked_Return_Value__char_fprintf_09.c,"    if(GLOBAL_CONST_FALSE)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        
        if (fprintf(stdout, ""%s\n"", ""string"") < 0)
        {
            printLine(""fprintf failed!"");
        }
"
17920,0,CWE415_Double_Free__malloc_free_struct_02.c,"    twoIntsStruct * data;
    
    data = NULL;
    if(1)
    {
        data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
        if (data == NULL) {exit(-1);}
        
        free(data);
    }
    if(1)
    {
        
        free(data);
"
7801,0,CWE590_Free_Memory_Not_on_Heap__delete_array_class_static_72a.cpp,"    TwoIntsClass * data;
    vector<TwoIntsClass *> dataVector;
    data = NULL; 
    {
        
        static TwoIntsClass dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i].intOne = 1;
                dataBuffer[i].intTwo = 1;
            }
        }
        data = dataBuffer;
    }
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
8120,0,CWE457_Use_of_Uninitialized_Variable__new_double_array_no_init_64a.cpp,"    double * data;
    data = new double[10];
    
    ; 
"
10356,1,CWE758_Undefined_Behavior__long_alloca_use_04.c,"    if(STATIC_CONST_FALSE)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            long data;
            long * pointer = (long *)ALLOCA(sizeof(long));
            data = 5L;
            *pointer = data; 
            {
                long data = *pointer;
                printLongLine(data);
            }
        }
"
18108,1,CWE758_Undefined_Behavior__char_new_use_17.cpp,"    int k;
    for(k = 0; k < 1; k++)
    {
        {
            char data;
            data = 5;
            char * pointer = new char;
            *pointer = data; 
            {
                char data = *pointer;
                printHexCharLine(data);
            }
            delete pointer;
        }
"
5341,0,CWE190_Integer_Overflow__int64_t_rand_add_06.c,"    int64_t data;
    data = 0LL;
    if(STATIC_CONST_FIVE==5)
    {
        
        data = (int64_t)RAND64();
    }
    if(STATIC_CONST_FIVE==5)
    {
        {
            
            int64_t result = data + 1;
            printLongLongLine(result);
        }
"
3515,0,CWE401_Memory_Leak__new_char_01.cpp,"    char * data;
    data = NULL;
    
    data = new char;
    
    *data = 'A';
    printHexCharLine(*data);
    
"
14141,0,CWE190_Integer_Overflow__unsigned_int_fscanf_square_09.c,"    unsigned int data;
    data = 0;
    if(GLOBAL_CONST_TRUE)
    {
        
        fscanf (stdin, ""%u"", &data);
    }
    if(GLOBAL_CONST_TRUE)
    {
        {
            
            unsigned int result = data * data;
            printUnsignedLine(result);
        }
"
11417,0,CWE415_Double_Free__new_delete_array_int64_t_41.cpp,"    int64_t * data;
    
    data = NULL;
    data = new int64_t[100];
    
    delete [] data;
"
9514,0,CWE190_Integer_Overflow__short_rand_add_64a.c,"    short data;
    data = 0;
    
    data = (short)RAND32();
"
10734,0,CWE369_Divide_by_Zero__float_listenSocket_45.c,"    float data;
    
    data = 0.0F;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = (float)atof(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    CWE369_Divide_by_Zero__float_listenSocket_45_badData = data;
"
9665,0,CWE590_Free_Memory_Not_on_Heap__free_int64_t_static_81a.cpp,"    int64_t * data;
    data = NULL; 
    {
        
        static int64_t dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5LL;
            }
        }
        data = dataBuffer;
    }
    const CWE590_Free_Memory_Not_on_Heap__free_int64_t_static_81_base& baseObject = CWE590_Free_Memory_Not_on_Heap__free_int64_t_static_81_bad();
"
11884,0,CWE190_Integer_Overflow__int_listen_socket_postinc_11.c,"    int data;
    
    data = 0;
    if(globalReturnsTrue())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(globalReturnsTrue())
    {
        {
            
            data++;
            int result = data;
            printIntLine(result);
        }
"
190,0,CWE190_Integer_Overflow__short_rand_preinc_44.c,"    short data;
    
    void (*funcPtr) (short) = badSink;
    data = 0;
    
    data = (short)RAND32();
    
"
1429,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_10.c,"    size_t data;
    
    data = 0;
    if(globalTrue)
    {
        
        fscanf(stdin, ""%zu"", &data);
    }
    if(globalTrue)
    {
        {
            char * myString;
            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
             * for the strcpy() function to not cause a buffer overflow */
            
            if (data > strlen(HELLO_STRING))
            {
                myString = (char *)malloc(data*sizeof(char));
                if (myString == NULL) {exit(-1);}
                
                strcpy(myString, HELLO_STRING);
                printLine(myString);
                free(myString);
            }
            else
            {
                printLine(""Input is less than the length of the source string"");
            }
        }
"
2300,0,CWE457_Use_of_Uninitialized_Variable__double_06.c,"    double data;
    if(STATIC_CONST_FIVE==5)
    {
        
        ; 
    }
    if(STATIC_CONST_FIVE==5)
    {
        
        printDoubleLine(data);
"
16598,0,CWE690_NULL_Deref_From_Return__int64_t_realloc_14.c,"    int64_t * data;
    data = NULL; 
    
    data = (int64_t *)realloc(data, 1*sizeof(int64_t));
    if(globalFive==5)
    {
        
        data[0] = 5LL;
        printLongLongLine(data[0]);
        free(data);
"
17208,0,CWE690_NULL_Deref_From_Return__long_malloc_51a.c,"    long * data;
    data = NULL; 
    
    data = (long *)malloc(1*sizeof(long));
"
14854,0,CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_66a.c,"    char * data;
    char * dataArray[5];
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
    dataArray[2] = data;
"
12813,0,CWE758_Undefined_Behavior__int_pointer_new_use_10.cpp,"    if(globalTrue)
    {
        {
            int * * pointer = new int *;
            int * data = *pointer; 
            delete pointer;
            printIntLine(*data);
        }
"
17264,0,CWE457_Use_of_Uninitialized_Variable__struct_pointer_63a.c,"    twoIntsStruct * data;
    
    ; 
"
2811,1,CWE252_Unchecked_Return_Value__char_snprintf_02.c,"    if(0)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            
            if (SNPRINTF(data,100-strlen(SRC)-1, ""%s\n"", SRC) < 0)
            {
                printLine(""snprintf failed!"");
            }
        }
"
16241,1,CWE758_Undefined_Behavior__int_alloca_use_16.c,"    while(1)
    {
        {
            int data;
            int * pointer = (int *)ALLOCA(sizeof(int));
            data = 5;
            *pointer = data; 
            {
                int data = *pointer;
                printIntLine(data);
            }
        }
        break;
"
17345,0,CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_64a.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
6502,0,CWE401_Memory_Leak__strdup_char_01.c,"    char * data;
    data = NULL;
    {
        char myString[] = ""myString"";
        
        data = strdup(myString);
        
        printLine(data);
    }
    
    
"
14812,1,CWE758_Undefined_Behavior__int64_t_alloca_use_14.c,"    if(globalFive==5)
    {
        {
            int64_t data;
            int64_t * pointer = (int64_t *)ALLOCA(sizeof(int64_t));
            data = 5LL;
            *pointer = data; 
            {
                int64_t data = *pointer;
                printLongLongLine(data);
            }
        }
"
15088,0,CWE590_Free_Memory_Not_on_Heap__free_int64_t_alloca_51a.c,"    int64_t * data;
    data = NULL; 
    {
        
        int64_t * dataBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5LL;
            }
        }
        data = dataBuffer;
    }
"
4692,0,CWE190_Integer_Overflow__int64_t_max_add_17.c,"    int i,j;
    int64_t data;
    data = 0LL;
    for(i = 0; i < 1; i++)
    {
        
        data = LLONG_MAX;
    }
    for(j = 0; j < 1; j++)
    {
        {
            
            int64_t result = data + 1;
            printLongLongLine(result);
        }
"
16700,0,CWE758_Undefined_Behavior__int_pointer_alloca_use_09.c,"    if(GLOBAL_CONST_TRUE)
    {
        {
            int * * pointer = (int * *)ALLOCA(sizeof(int *));
            int * data = *pointer; 
            printIntLine(*data);
        }
"
3518,0,CWE190_Integer_Overflow__short_max_postinc_13.c,"    short data;
    data = 0;
    if(GLOBAL_CONST_FIVE==5)
    {
        
        data = SHRT_MAX;
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            
            data++;
            short result = data;
            printIntLine(result);
        }
"
1971,0,CWE190_Integer_Overflow__int_connect_socket_postinc_53a.c,"    int data;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
2458,0,CWE590_Free_Memory_Not_on_Heap__delete_array_class_static_11.cpp,"    TwoIntsClass * data;
    data = NULL; 
    if(globalReturnsTrue())
    {
        {
            
            static TwoIntsClass dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i].intOne = 1;
                    dataBuffer[i].intTwo = 1;
                }
            }
            data = dataBuffer;
        }
    }
    printIntLine(data[0].intOne);
    
"
18050,0,CWE190_Integer_Overflow__int64_t_max_postinc_51a.c,"    int64_t data;
    data = 0LL;
    
    data = LLONG_MAX;
"
9720,0,CWE590_Free_Memory_Not_on_Heap__delete_int_static_33.cpp,"    int * data;
    int * &dataRef = data;
    data = NULL; 
    {
        
        static int dataBuffer;
        dataBuffer = 5;
        data = &dataBuffer;
    }
    {
        int * data = dataRef;
        printIntLine(*data);
        
        delete data;
"
10070,0,CWE401_Memory_Leak__char_calloc_11.c,"    char * data;
    data = NULL;
    if(globalReturnsTrue())
    {
        
        data = (char *)calloc(100, sizeof(char));
        if (data == NULL) {exit(-1);}
        
        strcpy(data, ""A String"");
        printLine(data);
    }
    if(globalReturnsTrue())
    {
        
        ; 
"
15065,0,CWE590_Free_Memory_Not_on_Heap__delete_struct_declare_32.cpp,"    twoIntsStruct * data;
    twoIntsStruct * *dataPtr1 = &data;
    twoIntsStruct * *dataPtr2 = &data;
    data = NULL; 
    {
        twoIntsStruct * data = *dataPtr1;
        {
            
            twoIntsStruct dataBuffer;
            dataBuffer.intOne = 1;
            dataBuffer.intTwo = 1;
            data = &dataBuffer;
        }
        *dataPtr1 = data;
    }
    {
        twoIntsStruct * data = *dataPtr2;
        printStructLine(data);
        
        delete data;
"
3094,1,CWE758_Undefined_Behavior__long_new_use_02.cpp,"    if(0)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            long data;
            data = 5L;
            long * pointer = new long;
            *pointer = data; 
            {
                long data = *pointer;
                printLongLine(data);
            }
            delete pointer;
        }
"
13570,0,CWE457_Use_of_Uninitialized_Variable__twointsclass_array_malloc_no_init_02.cpp,"    TwoIntsClass * data;
    data = reinterpret_cast<TwoIntsClass *>(malloc(10*sizeof(TwoIntsClass)));
    if (data == NULL) {exit(-1);}
    if(1)
    {
        
        ; 
    }
    if(1)
    {
        
        for(int i=0; i<10; i++)
        {
            printIntLine(data[i].intOne);
            printIntLine(data[i].intTwo);
        }
"
19267,0,CWE134_Uncontrolled_Format_String__char_file_fprintf_22a.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        FILE * pFile;
        
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
    CWE134_Uncontrolled_Format_String__char_file_fprintf_22_badGlobal = 1; 
"
4992,0,CWE416_Use_After_Free__new_delete_long_62a.cpp,"    long * data;
    
    data = NULL;
    badSource(data);
    
    printLongLine(*data);
"
12871,0,CWE190_Integer_Overflow__int_fscanf_multiply_53a.c,"    int data;
    
    data = 0;
    
    fscanf(stdin, ""%d"", &data);
"
14846,0,CWE252_Unchecked_Return_Value__char_remove_07.c,"    if(staticFive==5)
    {
        
        REMOVE(""removemebad.txt"");
"
13775,0,CWE190_Integer_Overflow__int_listen_socket_add_04.c,"    int data;
    
    data = 0;
    if(STATIC_CONST_TRUE)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(STATIC_CONST_TRUE)
    {
        {
            
            int result = data + 1;
            printIntLine(result);
        }
"
17263,0,CWE134_Uncontrolled_Format_String__char_file_fprintf_53a.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        FILE * pFile;
        
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
"
16589,0,CWE190_Integer_Overflow__short_fscanf_add_74a.cpp,"    short data;
    map<int, short> dataMap;
    data = 0;
    
    fscanf (stdin, ""%hd"", &data);
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
3276,0,CWE190_Integer_Overflow__char_rand_square_33.cpp,"    char data;
    char &dataRef = data;
    data = ' ';
    
    data = (char)RAND32();
    {
        char data = dataRef;
        {
            
            char result = data * data;
            printHexCharLine(result);
        }
"
18051,0,CWE457_Use_of_Uninitialized_Variable__int_array_alloca_partial_init_07.c,"    int * data;
    data = (int *)ALLOCA(10*sizeof(int));
    if(staticFive==5)
    {
        
        {
            int i;
            for(i=0; i<(10/2); i++)
            {
                data[i] = i;
            }
        }
    }
    if(staticFive==5)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i]);
            }
        }
"
4163,0,CWE590_Free_Memory_Not_on_Heap__delete_char_placement_new_03.cpp,"    char * data;
    data = NULL; 
    if(5==5)
    {
        {
            
            char buffer[sizeof(char)];
            char * dataBuffer = new(buffer) char;
            *dataBuffer = 'A';
            data = dataBuffer;
        }
    }
    printHexCharLine(*data);
    
"
553,0,CWE134_Uncontrolled_Format_String__char_environment_vprintf_73a.cpp,"    char * data;
    list<char *> dataList;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        
        if (environment != NULL)
        {
            
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
5583,0,CWE563_Unused_Variable__unused_init_variable_long_22a.c,"    long data;
    
    data = 5L;
    CWE563_Unused_Variable__unused_init_variable_long_22_badGlobal = 1; 
"
7939,0,CWE476_NULL_Pointer_Dereference__int_33.cpp,"    int * data;
    int * &dataRef = data;
    
    data = NULL;
    {
        int * data = dataRef;
        
        printIntLine(*data);
"
774,0,CWE590_Free_Memory_Not_on_Heap__delete_int64_t_alloca_54a.cpp,"    int64_t * data;
    data = NULL; 
    {
        
        int64_t * dataBuffer = (int64_t *)ALLOCA(sizeof(int64_t));
        *dataBuffer = 5LL;
        data = dataBuffer;
    }
"
19253,0,CWE590_Free_Memory_Not_on_Heap__delete_int64_t_static_81_bad.cpp,"Label Definition File: CWE590_Free_Memory_Not_on_Heap__delete.nonpointer.label.xml
Template File: sources-sink-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 590 Free Memory Not on Heap
 * BadSource: static Data buffer is declared static on the stack
 * GoodSource: Allocate memory on the heap
 * Sinks:
 *    BadSink : Print then free data
 * Flow Variant: 81 Data flow: data passed in a parameter to a virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE590_Free_Memory_Not_on_Heap__delete_int64_t_static_81.h""

namespace CWE590_Free_Memory_Not_on_Heap__delete_int64_t_static_81
{

void CWE590_Free_Memory_Not_on_Heap__delete_int64_t_static_81_bad::action(int64_t * data) const
{
    printLongLongLine(*data);
    
    delete data;
}

}
"
18433,0,CWE401_Memory_Leak__new_struct_twoIntsStruct_53a.cpp,"    struct _twoIntsStruct * data;
    data = NULL;
    
    data = new struct _twoIntsStruct;
    
    data->intOne = 0;
    data->intTwo = 0;
    printStructLine((twoIntsStruct *)data);
"
7965,0,CWE590_Free_Memory_Not_on_Heap__delete_char_alloca_45.cpp,"    char * data;
    data = NULL; 
    {
        
        char * dataBuffer = (char *)ALLOCA(sizeof(char));
        *dataBuffer = 'A';
        data = dataBuffer;
    }
    badData = data;
"
13060,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_83_bad.cpp,"Label Definition File: CWE789_Uncontrolled_Mem_Alloc__malloc.label.xml
Template File: sources-sinks-83_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: listen_socket Read data using a listen socket (server side)
 * GoodSource: Small number greater than zero
 * Sinks:
 *    GoodSink: Allocate memory with malloc() and check the size of the memory to be allocated
 *    BadSink : Allocate memory with malloc(), but incorrectly check the size of the memory to be allocated
 * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_83.h""

#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif

#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)

#define HELLO_STRING ""hello""

namespace CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_83
{
CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_83_bad::CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_83_bad(size_t dataCopy)
{
    data = dataCopy;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = strtoul(inputBuffer, NULL, 0);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
}

CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_83_bad::~CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_83_bad()
{
    {
        char * myString;
        /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
         * for the strcpy() function to not cause a buffer overflow */
        
        if (data > strlen(HELLO_STRING))
        {
            myString = (char *)malloc(data*sizeof(char));
            if (myString == NULL) {exit(-1);}
            
            strcpy(myString, HELLO_STRING);
            printLine(myString);
            free(myString);
        }
        else
        {
            printLine(""Input is less than the length of the source string"");
        }
    }
}
}
"
6134,0,CWE690_NULL_Deref_From_Return__int64_t_realloc_32.c,"    int64_t * data;
    int64_t * *dataPtr1 = &data;
    int64_t * *dataPtr2 = &data;
    data = NULL; 
    {
        int64_t * data = *dataPtr1;
        
        data = (int64_t *)realloc(data, 1*sizeof(int64_t));
        *dataPtr1 = data;
    }
    {
        int64_t * data = *dataPtr2;
        
        data[0] = 5LL;
        printLongLongLine(data[0]);
        free(data);
"
13156,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_32.c,"    size_t data;
    size_t *dataPtr1 = &data;
    size_t *dataPtr2 = &data;
    
    data = 0;
    {
        size_t data = *dataPtr1;
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = strtoul(inputBuffer, NULL, 0);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
        *dataPtr1 = data;
    }
    {
        size_t data = *dataPtr2;
        {
            char * myString;
            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
             * for the strcpy() function to not cause a buffer overflow */
            
            if (data > strlen(HELLO_STRING))
            {
                myString = (char *)malloc(data*sizeof(char));
                if (myString == NULL) {exit(-1);}
                
                strcpy(myString, HELLO_STRING);
                printLine(myString);
                free(myString);
            }
            else
            {
                printLine(""Input is less than the length of the source string"");
            }
        }
"
14507,1,CWE401_Memory_Leak__malloc_realloc_int_02.c,"    if(0)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            int * data = (int *)malloc(100*sizeof(int));
            if (data == NULL) {exit(-1);}
            int * tmpData;
            
            data[0] = 5;
            printIntLine(data[0]);
            tmpData = (int *)realloc(data, (130000)*sizeof(int));
            /* FIX: Ensure realloc() was successful before assigning data to the memory block
            * allocated with realloc() */
            if (tmpData != NULL)
            {
                data = tmpData;
                
                data[0] = 10;
                printIntLine(data[0]);
            }
            free(data);
        }
"
13781,0,CWE190_Integer_Overflow__int64_t_max_multiply_65a.c,"    int64_t data;
    
    void (*funcPtr) (int64_t) = CWE190_Integer_Overflow__int64_t_max_multiply_65b_badSink;
    data = 0LL;
    
    data = LLONG_MAX;
    
"
18980,0,CWE457_Use_of_Uninitialized_Variable__int_pointer_02.c,"    int * data;
    if(1)
    {
        
        ; 
    }
    if(1)
    {
        
        printIntLine(*data);
"
2134,0,CWE690_NULL_Deref_From_Return__struct_realloc_05.c,"    twoIntsStruct * data;
    data = NULL; 
    
    data = (twoIntsStruct *)realloc(data, 1*sizeof(twoIntsStruct));
    if(staticTrue)
    {
        
        data[0].intOne = 1;
        data[0].intTwo = 1;
        printStructLine(&data[0]);
        free(data);
"
5335,0,CWE590_Free_Memory_Not_on_Heap__delete_long_placement_new_74a.cpp,"    long * data;
    map<int, long *> dataMap;
    data = NULL; 
    {
        
        char buffer[sizeof(long)];
        long * dataBuffer = new(buffer) long;
        *dataBuffer = 5L;
        data = dataBuffer;
    }
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
8188,0,CWE590_Free_Memory_Not_on_Heap__delete_struct_alloca_68a.cpp,"    twoIntsStruct * data;
    data = NULL; 
    {
        
        twoIntsStruct * dataBuffer = (twoIntsStruct *)ALLOCA(sizeof(twoIntsStruct));
        dataBuffer->intOne = 1;
        dataBuffer->intTwo = 1;
        data = dataBuffer;
    }
    CWE590_Free_Memory_Not_on_Heap__delete_struct_alloca_68_badData = data;
"
7048,0,CWE369_Divide_by_Zero__int_connect_socket_divide_13.c,"    int data;
    
    data = -1;
    if(GLOBAL_CONST_FIVE==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        
        printIntLine(100 / data);
"
3689,1,CWE758_Undefined_Behavior__struct_pointer_alloca_use_16.c,"    while(1)
    {
        {
            twoIntsStruct * data;
            twoIntsStruct * * pointer = (twoIntsStruct * *)ALLOCA(sizeof(twoIntsStruct *));
            
            data = (twoIntsStruct *)malloc(sizeof(twoIntsStruct));
            if (data == NULL) {exit(-1);}
            data->intOne = 5;
            data->intTwo = 6;
            *pointer = data; 
            {
                twoIntsStruct * data = *pointer;
                printIntLine(data->intOne);
                printIntLine(data->intTwo);
            }
        }
        break;
"
18168,0,CWE476_NULL_Pointer_Dereference__class_44.cpp,"    TwoIntsClass * data;
    
    void (*funcPtr) (TwoIntsClass *) = badSink;
    
    data = NULL;
    
"
15029,0,CWE190_Integer_Overflow__int64_t_max_preinc_65a.c,"    int64_t data;
    
    void (*funcPtr) (int64_t) = CWE190_Integer_Overflow__int64_t_max_preinc_65b_badSink;
    data = 0LL;
    
    data = LLONG_MAX;
    
"
995,0,CWE78_OS_Command_Injection__char_file_execl_84_bad.cpp,"Label Definition File: CWE78_OS_Command_Injection.strings.label.xml
Template File: sources-sink-84_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 78 OS Command Injection
 * BadSource: file Read input from a file
 * GoodSource: Fixed string
 * Sinks: execl
 *    BadSink : execute command with execl
 * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE78_OS_Command_Injection__char_file_execl_84.h""

#ifdef _WIN32
#define FILENAME ""C:\\temp\\file.txt""
#else
#define FILENAME ""/tmp/file.txt""
#endif

#ifdef _WIN32
#include <process.h>
#define EXECL _execl
#else 
#define EXECL execl
#endif

namespace CWE78_OS_Command_Injection__char_file_execl_84
{
CWE78_OS_Command_Injection__char_file_execl_84_bad::CWE78_OS_Command_Injection__char_file_execl_84_bad(char * dataCopy)
{
    data = dataCopy;
    {
        
        size_t dataLen = strlen(data);
        FILE * pFile;
        
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
}

CWE78_OS_Command_Injection__char_file_execl_84_bad::~CWE78_OS_Command_Injection__char_file_execl_84_bad()
{
    
    
    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
}
"
15723,0,CWE590_Free_Memory_Not_on_Heap__delete_int64_t_alloca_41.cpp,"    int64_t * data;
    data = NULL; 
    {
        
        int64_t * dataBuffer = (int64_t *)ALLOCA(sizeof(int64_t));
        *dataBuffer = 5LL;
        data = dataBuffer;
    }
"
3983,0,CWE197_Numeric_Truncation_Error__short_large_15.c,"    short data;
    
    data = -1;
    switch(6)
    {
    case 6:
        
        data = CHAR_MAX + 1;
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
8692,0,CWE415_Double_Free__new_delete_array_int_11.cpp,"    int * data;
    
    data = NULL;
    if(globalReturnsTrue())
    {
        data = new int[100];
        
        delete [] data;
    }
    if(globalReturnsTrue())
    {
        
        delete [] data;
"
16133,0,CWE690_NULL_Deref_From_Return__int64_t_malloc_51a.c,"    int64_t * data;
    data = NULL; 
    
    data = (int64_t *)malloc(1*sizeof(int64_t));
"
15245,0,CWE190_Integer_Overflow__char_max_add_62a.cpp,"    char data;
    data = ' ';
    badSource(data);
    {
        
        char result = data + 1;
        printHexCharLine(result);
"
13929,0,CWE758_Undefined_Behavior__int_malloc_use_10.c,"    if(globalTrue)
    {
        {
            int * pointer = (int *)malloc(sizeof(int));
            if (pointer == NULL) {exit(-1);}
            int data = *pointer; 
            free(pointer);
            printIntLine(data);
        }
"
15671,0,CWE690_NULL_Deref_From_Return__fopen_34.c,"    FILE * data;
    CWE690_NULL_Deref_From_Return__fopen_34_unionType myUnion;
    
    data = NULL;
    
    data = fopen(""file.txt"", ""w+"");
    myUnion.unionFirst = data;
    {
        FILE * data = myUnion.unionSecond;
        
        fclose(data);
"
16946,0,CWE563_Unused_Variable__unused_value_int64_t_05.c,"    int64_t data;
    if(staticTrue)
    {
        
        data = 5LL;
    }
    if(staticTrue)
    {
        
        data = 10LL;
        printLongLongLine(data);
"
9715,0,CWE134_Uncontrolled_Format_String__char_file_printf_63a.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        FILE * pFile;
        
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
"
3847,0,CWE190_Integer_Overflow__int_listen_socket_add_09.c,"    int data;
    
    data = 0;
    if(GLOBAL_CONST_TRUE)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(GLOBAL_CONST_TRUE)
    {
        {
            
            int result = data + 1;
            printIntLine(result);
        }
"
11213,0,CWE563_Unused_Variable__unused_value_int64_t_74a.cpp,"    int64_t data;
    map<int, int64_t> dataMap;
    
    data = 5LL;
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
11355,0,CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_81a.cpp,"    unsigned int data;
    data = 0;
    
    fscanf (stdin, ""%u"", &data);
    const CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_81_base& baseObject = CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_81_bad();
"
1155,1,CWE758_Undefined_Behavior__int_pointer_new_use_02.cpp,"    if(0)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            int * data;
            
            data = new int;
            *data = 5;
            int * * pointer = new int *;
            *pointer = data; 
            {
                int * data = *pointer;
                printIntLine(*data);
            }
            delete pointer;
        }
"
12036,0,CWE190_Integer_Overflow__int64_t_max_postinc_65a.c,"    int64_t data;
    
    void (*funcPtr) (int64_t) = CWE190_Integer_Overflow__int64_t_max_postinc_65b_badSink;
    data = 0LL;
    
    data = LLONG_MAX;
    
"
14105,0,CWE587_Assignment_of_Fixed_Address_to_Pointer__basic_04.c,"    if(STATIC_CONST_TRUE)
    {
        {
            
            char *charPointer = (char*)0x400000;
            printHexCharLine(*charPointer);
        }
"
16286,0,CWE197_Numeric_Truncation_Error__int_large_to_short_09.c,"    int data;
    
    data = -1;
    if(GLOBAL_CONST_TRUE)
    {
        
        data = SHRT_MAX + 5;
    }
    {
        
        short shortData = (short)data;
        printShortLine(shortData);
"
18092,0,CWE758_Undefined_Behavior__char_alloca_use_04.c,"    if(STATIC_CONST_TRUE)
    {
        {
            char * pointer = (char *)ALLOCA(sizeof(char));
            char data = *pointer; 
            printHexCharLine(data);
        }
"
9199,1,CWE758_Undefined_Behavior__long_malloc_use_15.c,"    switch(6)
    {
    case 6:
    {
        long data;
        long * pointer = (long *)malloc(sizeof(long));
        if (pointer == NULL) {exit(-1);}
        data = 5L;
        *pointer = data; 
        {
            long data = *pointer;
            printLongLine(data);
        }
        free(pointer);
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
10367,0,CWE590_Free_Memory_Not_on_Heap__free_long_static_63a.c,"    long * data;
    data = NULL; 
    {
        
        static long dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5L;
            }
        }
        data = dataBuffer;
    }
"
19003,0,CWE190_Integer_Overflow__int64_t_rand_postinc_32.c,"    int64_t data;
    int64_t *dataPtr1 = &data;
    int64_t *dataPtr2 = &data;
    data = 0LL;
    {
        int64_t data = *dataPtr1;
        
        data = (int64_t)RAND64();
        *dataPtr1 = data;
    }
    {
        int64_t data = *dataPtr2;
        {
            
            data++;
            int64_t result = data;
            printLongLongLine(result);
        }
"
16572,0,CWE369_Divide_by_Zero__float_rand_63a.c,"    float data;
    
    data = 0.0F;
    
    data = (float)RAND32();
"
1536,0,CWE190_Integer_Overflow__short_rand_multiply_43.cpp,"    short data;
    data = 0;
    badSource(data);
    if(data > 0) 
    {
        
        short result = data * 2;
        printIntLine(result);
"
6808,0,CWE563_Unused_Variable__unused_uninit_variable_int_33.cpp,"    int data;
    int &dataRef = data;
    
    ; 
    {
        int data = dataRef;
        
        
        ; 
"
19333,1,CWE758_Undefined_Behavior__struct_pointer_alloca_use_07.c,"    if(staticFive==5)
    {
        {
            twoIntsStruct * data;
            twoIntsStruct * * pointer = (twoIntsStruct * *)ALLOCA(sizeof(twoIntsStruct *));
            
            data = (twoIntsStruct *)malloc(sizeof(twoIntsStruct));
            if (data == NULL) {exit(-1);}
            data->intOne = 5;
            data->intTwo = 6;
            *pointer = data; 
            {
                twoIntsStruct * data = *pointer;
                printIntLine(data->intOne);
                printIntLine(data->intTwo);
            }
        }
"
488,0,CWE190_Integer_Overflow__int_fscanf_square_34.c,"    int data;
    CWE190_Integer_Overflow__int_fscanf_square_34_unionType myUnion;
    
    data = 0;
    
    fscanf(stdin, ""%d"", &data);
    myUnion.unionFirst = data;
    {
        int data = myUnion.unionSecond;
        {
            
            int result = data * data;
            printIntLine(result);
        }
"
6707,0,CWE688_Function_Call_With_Incorrect_Variable_or_Reference_as_Argument__basic_09.c,"    if(GLOBAL_CONST_TRUE)
    {
        {
            char dest[DEST_SIZE];
            int intFive = 5;
            
            sprintf(dest, ""%s"", intFive);
            printLine(dest);
        }
"
6634,0,CWE134_Uncontrolled_Format_String__char_file_snprintf_83a.cpp,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
"
6424,0,CWE369_Divide_by_Zero__float_fgets_84_bad.cpp,"Label Definition File: CWE369_Divide_by_Zero__float.label.xml
Template File: sources-sinks-84_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 369 Divide by Zero
 * BadSource: fgets Read data from the console using fgets()
 * GoodSource: A hardcoded non-zero number (two)
 * Sinks:
 *    GoodSink: Check value of or near zero before dividing
 *    BadSink : Divide a constant by data
 * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE369_Divide_by_Zero__float_fgets_84.h""

#define CHAR_ARRAY_SIZE 20

namespace CWE369_Divide_by_Zero__float_fgets_84
{
CWE369_Divide_by_Zero__float_fgets_84_bad::CWE369_Divide_by_Zero__float_fgets_84_bad(float dataCopy)
{
    data = dataCopy;
    {
        char inputBuffer[CHAR_ARRAY_SIZE];
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = (float)atof(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
}

CWE369_Divide_by_Zero__float_fgets_84_bad::~CWE369_Divide_by_Zero__float_fgets_84_bad()
{
    {
        
        int result = (int)(100.0 / data);
        printIntLine(result);
    }
}
}
"
6591,1,CWE252_Unchecked_Return_Value__char_rename_03.c,"    if(5!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        
        if (RENAME(OLD_GOOD_FILE_NAME, ""newgoodfilename.txt"") != 0)
        {
            printLine(""rename failed!"");
        }
"
4931,1,CWE416_Use_After_Free__return_freed_ptr_14.c,"    if(globalFive==5)
    {
        {
            
            char * reversedString = helperGood(""GoodSink"");
            printLine(reversedString);
            /* free(reversedString);
             * This call to free() was removed because we want the tool to detect the use after free,
             * but we don't want that function to be free(). Essentially we want to avoid a double free
             */
        }
"
14582,0,CWE369_Divide_by_Zero__int_fscanf_modulo_66a.c,"    int data;
    int dataArray[5];
    
    data = -1;
    
    fscanf(stdin, ""%d"", &data);
    
    dataArray[2] = data;
"
12173,0,CWE401_Memory_Leak__struct_twoIntsStruct_realloc_08.c,"    struct _twoIntsStruct * data;
    data = NULL;
    if(staticReturnsTrue())
    {
        
        data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));
        if (data == NULL) {exit(-1);}
        
        data[0].intOne = 0;
        data[0].intTwo = 0;
        printStructLine((twoIntsStruct *)&data[0]);
    }
    if(staticReturnsTrue())
    {
        
        ; 
"
19393,0,CWE587_Assignment_of_Fixed_Address_to_Pointer__basic_10.c,"    if(globalTrue)
    {
        {
            
            char *charPointer = (char*)0x400000;
            printHexCharLine(*charPointer);
        }
"
1108,1,CWE401_Memory_Leak__malloc_realloc_twoIntsStruct_07.c,"    if(staticFive!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            twoIntsStruct * data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
            if (data == NULL) {exit(-1);}
            twoIntsStruct * tmpData;
            
            data[0].intOne = 0;
            data[0].intTwo = 0;
            printStructLine(&data[0]);
            tmpData = (twoIntsStruct *)realloc(data, (130000)*sizeof(twoIntsStruct));
            /* FIX: Ensure realloc() was successful before assigning data to the memory block
            * allocated with realloc() */
            if (tmpData != NULL)
            {
                data = tmpData;
                
                data[0].intOne = 1;
                data[0].intTwo = 1;
                printStructLine(&data[0]);
            }
            free(data);
        }
"
10049,0,CWE590_Free_Memory_Not_on_Heap__delete_array_struct_declare_82_bad.cpp,"Label Definition File: CWE590_Free_Memory_Not_on_Heap__delete_array.label.xml
Template File: sources-sink-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 590 Free Memory Not on Heap
 * BadSource: declare Data buffer is declared on the stack
 * GoodSource: Allocate memory on the heap
 * Sinks:
 *    BadSink : Print then free data
 * Flow Variant: 82 Data flow: data passed in a parameter to a virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE590_Free_Memory_Not_on_Heap__delete_array_struct_declare_82.h""

namespace CWE590_Free_Memory_Not_on_Heap__delete_array_struct_declare_82
{

void CWE590_Free_Memory_Not_on_Heap__delete_array_struct_declare_82_bad::action(twoIntsStruct * data)
{
    printStructLine(&data[0]);
    
    delete [] data;
}

}
"
1623,0,CWE190_Integer_Overflow__char_fscanf_multiply_04.c,"    char data;
    data = ' ';
    if(STATIC_CONST_TRUE)
    {
        
        fscanf (stdin, ""%c"", &data);
    }
    if(STATIC_CONST_TRUE)
    {
        if(data > 0) 
        {
            
            char result = data * 2;
            printHexCharLine(result);
        }
"
18680,0,CWE190_Integer_Overflow__int_rand_square_44.c,"    int data;
    
    void (*funcPtr) (int) = badSink;
    
    data = 0;
    
    data = RAND32();
    
"
5787,0,CWE369_Divide_by_Zero__int_fgets_divide_09.c,"    int data;
    
    data = -1;
    if(GLOBAL_CONST_TRUE)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    if(GLOBAL_CONST_TRUE)
    {
        
        printIntLine(100 / data);
"
14509,0,CWE457_Use_of_Uninitialized_Variable__twointsclass_array_new_no_init_05.cpp,"    TwoIntsClass * data;
    data = new TwoIntsClass[10];
    if(staticTrue)
    {
        
        ; 
    }
    if(staticTrue)
    {
        
        for(int i=0; i<10; i++)
        {
            printIntLine(data[i].intOne);
            printIntLine(data[i].intTwo);
        }
"
3341,0,CWE369_Divide_by_Zero__float_zero_01.c,"    float data;
    
    data = 0.0F;
    
    data = 0.0F;
    {
        
        int result = (int)(100.0 / data);
        printIntLine(result);
"
16505,0,CWE590_Free_Memory_Not_on_Heap__delete_array_int64_t_static_52a.cpp,"    int64_t * data;
    data = NULL; 
    {
        
        static int64_t dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5LL;
            }
        }
        data = dataBuffer;
    }
"
2089,0,CWE789_Uncontrolled_Mem_Alloc__new_char_connect_socket_65a.cpp,"    size_t data;
    
    void (*funcPtr) (size_t) = badSink;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = strtoul(inputBuffer, NULL, 0);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
"
11160,0,CWE563_Unused_Variable__unused_uninit_variable_long_05.c,"    long data;
    
    ; 
    if(staticTrue)
    {
        
        
        ; 
"
1340,0,CWE476_NULL_Pointer_Dereference__long_68a.c,"    long * data;
    
    data = NULL;
    CWE476_NULL_Pointer_Dereference__long_68_badData = data;
"
8775,0,CWE78_OS_Command_Injection__char_environment_execl_84_bad.cpp,"Label Definition File: CWE78_OS_Command_Injection.strings.label.xml
Template File: sources-sink-84_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 78 OS Command Injection
 * BadSource: environment Read input from an environment variable
 * GoodSource: Fixed string
 * Sinks: execl
 *    BadSink : execute command with execl
 * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE78_OS_Command_Injection__char_environment_execl_84.h""

#define ENV_VARIABLE ""ADD""

#ifdef _WIN32
#define GETENV getenv
#else
#define GETENV getenv
#endif

#ifdef _WIN32
#include <process.h>
#define EXECL _execl
#else 
#define EXECL execl
#endif

namespace CWE78_OS_Command_Injection__char_environment_execl_84
{
CWE78_OS_Command_Injection__char_environment_execl_84_bad::CWE78_OS_Command_Injection__char_environment_execl_84_bad(char * dataCopy)
{
    data = dataCopy;
    {
        
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        
        if (environment != NULL)
        {
            
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
}

CWE78_OS_Command_Injection__char_environment_execl_84_bad::~CWE78_OS_Command_Injection__char_environment_execl_84_bad()
{
    
    
    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
}
"
10818,0,CWE590_Free_Memory_Not_on_Heap__delete_char_static_65a.cpp,"    char * data;
    
    void (*funcPtr) (char *) = badSink;
    data = NULL; 
    {
        
        static char dataBuffer;
        dataBuffer = 'A';
        data = &dataBuffer;
    }
    
"
18074,0,CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_44.c,"    char * data;
    
    void (*funcPtr) (char *, ...) = badVaSink;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
"
11673,0,CWE690_NULL_Deref_From_Return__fopen_63a.c,"    FILE * data;
    
    data = NULL;
    
    data = fopen(""file.txt"", ""w+"");
"
10681,0,CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_18.cpp,"    size_t data;
    
    data = 0;
    goto source;
source:
    
    fscanf(stdin, ""%zu"", &data);
    goto sink;
sink:
    {
        char * myString;
        /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
         * for the strcpy() function to not cause a buffer overflow */
        
        if (data > strlen(HELLO_STRING))
        {
            myString = new char[data];
            
            strcpy(myString, HELLO_STRING);
            printLine(myString);
            delete [] myString;
        }
        else
        {
            printLine(""Input is less than the length of the source string"");
        }
"
3237,0,CWE415_Double_Free__new_delete_array_long_54a.cpp,"    long * data;
    
    data = NULL;
    data = new long[100];
    
    delete [] data;
"
8260,0,CWE590_Free_Memory_Not_on_Heap__delete_struct_placement_new_44.cpp,"    twoIntsStruct * data;
    
    void (*funcPtr) (twoIntsStruct *) = badSink;
    data = NULL; 
    {
        
        char buffer[sizeof(twoIntsStruct)];
        twoIntsStruct * dataBuffer = new(buffer) twoIntsStruct;
        dataBuffer->intOne = 1;
        dataBuffer->intTwo = 1;
        data = dataBuffer;
    }
    
"
7367,0,CWE190_Integer_Overflow__int64_t_fscanf_multiply_43.cpp,"    int64_t data;
    data = 0LL;
    badSource(data);
    if(data > 0) 
    {
        
        int64_t result = data * 2;
        printLongLongLine(result);
"
541,0,CWE190_Integer_Overflow__int_max_multiply_12.c,"    int data;
    
    data = 0;
    if(globalReturnsTrueOrFalse())
    {
        
        data = INT_MAX;
    }
    else
    {
        
        data = 2;
    }
    if(globalReturnsTrueOrFalse())
    {
        if(data > 0) 
        {
            
            int result = data * 2;
            printIntLine(result);
        }
    }
    else
    {
        if(data > 0) 
        {
            
            if (data < (INT_MAX/2))
            {
                int result = data * 2;
                printIntLine(result);
            }
            else
            {
                printLine(""data value is too large to perform arithmetic safely."");
            }
        }
"
6283,0,CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_41.c,"    unsigned int data;
    data = 0;
    
    fscanf (stdin, ""%u"", &data);
"
10890,0,CWE415_Double_Free__malloc_free_int_68a.c,"    int * data;
    
    data = NULL;
    data = (int *)malloc(100*sizeof(int));
    if (data == NULL) {exit(-1);}
    
    free(data);
    CWE415_Double_Free__malloc_free_int_68_badData = data;
"
18287,0,CWE457_Use_of_Uninitialized_Variable__twointsclass_array_alloca_partial_init_63a.cpp,"    TwoIntsClass * data;
    data = reinterpret_cast<TwoIntsClass *>(ALLOCA(10*sizeof(TwoIntsClass)));
    
    for(int i=0; i<(10/2); i++)
    {
        data[i].intOne = i;
        data[i].intTwo = i;
    }
"
14017,0,CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_67a.c,"    char * data;
    CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_67_structType myStruct;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    myStruct.structFirst = data;
"
14513,0,CWE197_Numeric_Truncation_Error__int_fgets_to_char_81_bad.cpp,"Label Definition File: CWE197_Numeric_Truncation_Error__int.label.xml
Template File: sources-sink-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 197 Numeric Truncation Error
 * BadSource: fgets Read data from the console using fgets()
 * GoodSource: Less than CHAR_MAX
 * Sinks: to_char
 *    BadSink : Convert data to a char
 * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE197_Numeric_Truncation_Error__int_fgets_to_char_81.h""

namespace CWE197_Numeric_Truncation_Error__int_fgets_to_char_81
{

void CWE197_Numeric_Truncation_Error__int_fgets_to_char_81_bad::action(int data) const
{
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
    }
}

}
"
2435,0,CWE401_Memory_Leak__int_malloc_02.c,"    int * data;
    data = NULL;
    if(1)
    {
        
        data = (int *)malloc(100*sizeof(int));
        if (data == NULL) {exit(-1);}
        
        data[0] = 5;
        printIntLine(data[0]);
    }
    if(1)
    {
        
        ; 
"
778,0,CWE590_Free_Memory_Not_on_Heap__free_int_declare_81a.cpp,"    int * data;
    data = NULL; 
    {
        
        int dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5;
            }
        }
        data = dataBuffer;
    }
    const CWE590_Free_Memory_Not_on_Heap__free_int_declare_81_base& baseObject = CWE590_Free_Memory_Not_on_Heap__free_int_declare_81_bad();
"
17254,0,CWE190_Integer_Overflow__int_fgets_preinc_13.c,"    int data;
    
    data = 0;
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            
            ++data;
            int result = data;
            printIntLine(result);
        }
"
11134,0,CWE457_Use_of_Uninitialized_Variable__new_int_array_no_init_11.cpp,"    int * data;
    data = new int[10];
    if(globalReturnsTrue())
    {
        
        ; 
    }
    if(globalReturnsTrue())
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i]);
            }
        }
        
        delete [] data;
"
16111,0,CWE590_Free_Memory_Not_on_Heap__free_struct_static_82a.cpp,"    twoIntsStruct * data;
    data = NULL; 
    {
        
        static twoIntsStruct dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i].intOne = 1;
                dataBuffer[i].intTwo = 1;
            }
        }
        data = dataBuffer;
    }
    CWE590_Free_Memory_Not_on_Heap__free_struct_static_82_base* baseObject = new CWE590_Free_Memory_Not_on_Heap__free_struct_static_82_bad;
    baseObject->action(data);
"
14115,0,CWE590_Free_Memory_Not_on_Heap__delete_char_declare_54a.cpp,"    char * data;
    data = NULL; 
    {
        
        char dataBuffer;
        dataBuffer = 'A';
        data = &dataBuffer;
    }
"
13912,1,CWE758_Undefined_Behavior__char_pointer_alloca_use_02.c,"    if(1)
    {
        {
            char * data;
            char * * pointer = (char * *)ALLOCA(sizeof(char *));
            data = ""string"";
            *pointer = data; 
            {
                char * data = *pointer;
                printLine(data);
            }
        }
"
19131,0,CWE590_Free_Memory_Not_on_Heap__delete_array_char_static_06.cpp,"    char * data;
    data = NULL; 
    if(STATIC_CONST_FIVE==5)
    {
        {
            
            static char dataBuffer[100];
            memset(dataBuffer, 'A', 100-1); 
            dataBuffer[100-1] = '\0'; 
            data = dataBuffer;
        }
    }
    printLine(data);
    
"
17525,1,CWE758_Undefined_Behavior__char_new_use_04.cpp,"    if(STATIC_CONST_FALSE)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            char data;
            data = 5;
            char * pointer = new char;
            *pointer = data; 
            {
                char data = *pointer;
                printHexCharLine(data);
            }
            delete pointer;
        }
"
3465,0,CWE78_OS_Command_Injection__char_console_execlp_72a.cpp,"    char * data;
    vector<char *> dataVector;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        
        if (100-dataLen > 1)
        {
            
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgets() */
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
                    data[dataLen-1] = '\0';
                }
            }
            else
            {
                printLine(""fgets() failed"");
                
                data[dataLen] = '\0';
            }
        }
    }
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
9052,1,CWE758_Undefined_Behavior__char_pointer_new_use_07.cpp,"    if(staticFive==5)
    {
        {
            char * data;
            data = ""string"";
            char * * pointer = new char *;
            *pointer = data; 
            {
                char * data = *pointer;
                printLine(data);
            }
            delete pointer;
        }
"
3936,0,CWE476_NULL_Pointer_Dereference__char_18.c,"    char * data;
    goto source;
source:
    
    data = NULL;
    goto sink;
sink:
    
    
"
15889,0,CWE190_Integer_Overflow__int_max_square_03.c,"    int data;
    
    data = 0;
    if(5==5)
    {
        
        data = INT_MAX;
    }
    if(5==5)
    {
        {
            
            int result = data * data;
            printIntLine(result);
        }
"
12109,0,CWE457_Use_of_Uninitialized_Variable__long_02.c,"    long data;
    if(1)
    {
        
        ; 
    }
    if(1)
    {
        
        printLongLine(data);
"
14585,0,CWE190_Integer_Overflow__short_max_postinc_02.c,"    short data;
    data = 0;
    if(1)
    {
        
        data = SHRT_MAX;
    }
    if(1)
    {
        {
            
            data++;
            short result = data;
            printIntLine(result);
        }
"
7466,0,CWE78_OS_Command_Injection__char_connect_socket_execlp_63a.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
405,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_14.c,"    size_t data;
    
    data = 0;
    if(globalFive==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = strtoul(inputBuffer, NULL, 0);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(globalFive==5)
    {
        {
            char * myString;
            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
             * for the strcpy() function to not cause a buffer overflow */
            
            if (data > strlen(HELLO_STRING))
            {
                myString = (char *)malloc(data*sizeof(char));
                if (myString == NULL) {exit(-1);}
                
                strcpy(myString, HELLO_STRING);
                printLine(myString);
                free(myString);
            }
            else
            {
                printLine(""Input is less than the length of the source string"");
            }
        }
"
16878,0,CWE457_Use_of_Uninitialized_Variable__int64_t_64a.c,"    int64_t data;
    
    ; 
"
9989,0,CWE78_OS_Command_Injection__char_connect_socket_execl_83_bad.cpp,"Label Definition File: CWE78_OS_Command_Injection.strings.label.xml
Template File: sources-sink-83_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 78 OS Command Injection
 * BadSource: connect_socket Read data using a connect socket (client side)
 * GoodSource: Fixed string
 * Sinks: execl
 *    BadSink : execute command with execl
 * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE78_OS_Command_Injection__char_connect_socket_execl_83.h""
"
13171,0,CWE78_OS_Command_Injection__char_console_execl_63a.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        
        if (100-dataLen > 1)
        {
            
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgets() */
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
                    data[dataLen-1] = '\0';
                }
            }
            else
            {
                printLine(""fgets() failed"");
                
                data[dataLen] = '\0';
            }
        }
    }
"
171,0,CWE690_NULL_Deref_From_Return__long_realloc_66a.c,"    long * data;
    long * dataArray[5];
    data = NULL; 
    
    data = (long *)realloc(data, 1*sizeof(long));
    
    dataArray[2] = data;
"
18785,0,CWE590_Free_Memory_Not_on_Heap__free_struct_declare_63a.c,"    twoIntsStruct * data;
    data = NULL; 
    {
        
        twoIntsStruct dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i].intOne = 1;
                dataBuffer[i].intTwo = 1;
            }
        }
        data = dataBuffer;
    }
"
13666,0,CWE457_Use_of_Uninitialized_Variable__struct_array_declare_no_init_07.c,"    twoIntsStruct * data;
    twoIntsStruct dataUninitArray[10];
    data = dataUninitArray;
    if(staticFive==5)
    {
        
        ; 
    }
    if(staticFive==5)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i].intOne);
                printIntLine(data[i].intTwo);
            }
        }
"
397,0,CWE190_Integer_Overflow__int_max_postinc_05.c,"    int data;
    
    data = 0;
    if(staticTrue)
    {
        
        data = INT_MAX;
    }
    if(staticTrue)
    {
        {
            
            data++;
            int result = data;
            printIntLine(result);
        }
"
15588,1,CWE475_Undefined_Behavior_for_Input_to_API__char_11.c,"    if(globalReturnsFalse())
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            strcpy(data, ""abcdefghijklmnopqrstuvwxyz"");
            
            memmove(data + 6, data + 4, 10*sizeof(char));
            printLine(data);
        }
"
16136,0,CWE457_Use_of_Uninitialized_Variable__double_array_malloc_no_init_15.c,"    double * data;
    data = (double *)malloc(10*sizeof(double));
    if (data == NULL) {exit(-1);}
    switch(6)
    {
    case 6:
        
        ; 
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
        
    {
        int i;
        for(i=0; i<10; i++)
        {
            printDoubleLine(data[i]);
        }
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
15842,0,CWE416_Use_After_Free__new_delete_int_02.cpp,"    int * data;
    
    data = NULL;
    if(1)
    {
        data = new int;
        *data = 5;
        
        delete data;
    }
    if(1)
    {
        
        printIntLine(*data);
        
"
2693,0,CWE590_Free_Memory_Not_on_Heap__delete_int64_t_declare_82a.cpp,"    int64_t * data;
    data = NULL; 
    {
        
        int64_t dataBuffer;
        dataBuffer = 5LL;
        data = &dataBuffer;
    }
    CWE590_Free_Memory_Not_on_Heap__delete_int64_t_declare_82_base* baseObject = new CWE590_Free_Memory_Not_on_Heap__delete_int64_t_declare_82_bad;
    baseObject->action(data);
"
2409,0,CWE197_Numeric_Truncation_Error__short_connect_socket_45.c,"    short data;
    
    data = -1;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = (short)atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    CWE197_Numeric_Truncation_Error__short_connect_socket_45_badData = data;
"
9280,0,CWE190_Integer_Overflow__short_fscanf_multiply_74a.cpp,"    short data;
    map<int, short> dataMap;
    data = 0;
    
    fscanf (stdin, ""%hd"", &data);
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
8894,0,CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_64a.c,"    unsigned int data;
    data = 0;
    
    fscanf (stdin, ""%u"", &data);
"
9895,0,CWE190_Integer_Overflow__char_max_multiply_02.c,"    char data;
    data = ' ';
    if(1)
    {
        
        data = CHAR_MAX;
    }
    if(1)
    {
        if(data > 0) 
        {
            
            char result = data * 2;
            printHexCharLine(result);
        }
"
4037,0,CWE190_Integer_Overflow__int64_t_rand_add_33.cpp,"    int64_t data;
    int64_t &dataRef = data;
    data = 0LL;
    
    data = (int64_t)RAND64();
    {
        int64_t data = dataRef;
        {
            
            int64_t result = data + 1;
            printLongLongLine(result);
        }
"
11974,0,CWE467_Use_of_sizeof_on_Pointer_Type__char_13.c,"    if(GLOBAL_CONST_FIVE==5)
    {
        {
            char * badChar = NULL;
            
            badChar = (char *)malloc(sizeof(badChar));
            if (badChar == NULL) {exit(-1);}
            *badChar = 'B';
            printHexCharLine(*badChar);
            free(badChar);
        }
"
2151,1,CWE758_Undefined_Behavior__double_pointer_alloca_use_03.c,"    if(5==5)
    {
        {
            double * data;
            double * * pointer = (double * *)ALLOCA(sizeof(double *));
            
            data = (double *)malloc(sizeof(double));
            if (data == NULL) {exit(-1);}
            *data = 5.0;
            *pointer = data; 
            {
                double * data = *pointer;
                printDoubleLine(*data);
            }
        }
"
13388,0,CWE758_Undefined_Behavior__char_pointer_new_use_14.cpp,"    if(globalFive==5)
    {
        {
            char * * pointer = new char *;
            char * data = *pointer; 
            delete pointer;
            printLine(data);
        }
"
10445,0,CWE190_Integer_Overflow__int_listen_socket_add_12.c,"    int data;
    
    data = 0;
    if(globalReturnsTrueOrFalse())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    else
    {
        
        data = 2;
    }
    if(globalReturnsTrueOrFalse())
    {
        {
            
            int result = data + 1;
            printIntLine(result);
        }
    }
    else
    {
        
        if (data < INT_MAX)
        {
            int result = data + 1;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
"
11014,0,CWE190_Integer_Overflow__char_rand_square_14.c,"    char data;
    data = ' ';
    if(globalFive==5)
    {
        
        data = (char)RAND32();
    }
    if(globalFive==5)
    {
        {
            
            char result = data * data;
            printHexCharLine(result);
        }
"
11021,1,CWE467_Use_of_sizeof_on_Pointer_Type__char_03.c,"    if(5!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            char * goodChar = NULL;
            
            goodChar = (char *)malloc(sizeof(*goodChar));
            if (goodChar == NULL) {exit(-1);}
            *goodChar = 'G';
            printHexCharLine(*goodChar);
            free(goodChar);
        }
"
15515,0,CWE789_Uncontrolled_Mem_Alloc__new_char_rand_81a.cpp,"    size_t data;
    
    data = 0;
    
    data = rand();
    const CWE789_Uncontrolled_Mem_Alloc__new_char_rand_81_base& o = CWE789_Uncontrolled_Mem_Alloc__new_char_rand_81_bad();
"
69,1,CWE758_Undefined_Behavior__class_pointer_new_use_15.cpp,"    switch(6)
    {
    case 6:
    {
        TwoIntsClass * data;
        
        data = new TwoIntsClass;
        data->intOne = 5;
        data->intTwo = 6;
        TwoIntsClass * * pointer = new TwoIntsClass *;
        *pointer = data; 
        {
            TwoIntsClass * data = *pointer;
            printIntLine(data->intOne);
            printIntLine(data->intTwo);
        }
        delete pointer;
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
10772,0,CWE134_Uncontrolled_Format_String__char_console_vfprintf_09.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(GLOBAL_CONST_TRUE)
    {
        {
            
            size_t dataLen = strlen(data);
            
            if (100-dataLen > 1)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
                {
                    /* The next few lines remove the carriage return from the string that is
                     * inserted by fgets() */
                    dataLen = strlen(data);
                    if (dataLen > 0 && data[dataLen-1] == '\n')
                    {
                        data[dataLen-1] = '\0';
                    }
                }
                else
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
            }
        }
    }
    if(GLOBAL_CONST_TRUE)
    {
        badVaSinkB(data, data);
"
16608,0,CWE190_Integer_Overflow__int64_t_rand_square_34.c,"    int64_t data;
    CWE190_Integer_Overflow__int64_t_rand_square_34_unionType myUnion;
    data = 0LL;
    
    data = (int64_t)RAND64();
    myUnion.unionFirst = data;
    {
        int64_t data = myUnion.unionSecond;
        {
            
            int64_t result = data * data;
            printLongLongLine(result);
        }
"
19182,0,CWE197_Numeric_Truncation_Error__short_rand_12.c,"    short data;
    
    data = -1;
    if(globalReturnsTrueOrFalse())
    {
        
        data = (short)RAND32();
    }
    else
    {
        
        data = CHAR_MAX-5;
    }
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
6129,1,CWE758_Undefined_Behavior__int64_t_alloca_use_07.c,"    if(staticFive!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            int64_t data;
            int64_t * pointer = (int64_t *)ALLOCA(sizeof(int64_t));
            data = 5LL;
            *pointer = data; 
            {
                int64_t data = *pointer;
                printLongLongLine(data);
            }
        }
"
15918,0,CWE415_Double_Free__new_delete_array_int64_t_01.cpp,"    int64_t * data;
    
    data = NULL;
    data = new int64_t[100];
    
    delete [] data;
    
"
7633,0,CWE190_Integer_Overflow__int_fscanf_add_66a.c,"    int data;
    int dataArray[5];
    
    data = 0;
    
    fscanf(stdin, ""%d"", &data);
    
    dataArray[2] = data;
"
17770,0,CWE590_Free_Memory_Not_on_Heap__delete_char_alloca_41.cpp,"    char * data;
    data = NULL; 
    {
        
        char * dataBuffer = (char *)ALLOCA(sizeof(char));
        *dataBuffer = 'A';
        data = dataBuffer;
    }
"
10913,0,CWE590_Free_Memory_Not_on_Heap__delete_char_placement_new_51a.cpp,"    char * data;
    data = NULL; 
    {
        
        char buffer[sizeof(char)];
        char * dataBuffer = new(buffer) char;
        *dataBuffer = 'A';
        data = dataBuffer;
    }
"
13814,0,CWE197_Numeric_Truncation_Error__short_fgets_84_bad.cpp,"Label Definition File: CWE197_Numeric_Truncation_Error__short.label.xml
Template File: sources-sink-84_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 197 Numeric Truncation Error
 * BadSource: fgets Read data from the console using fgets()
 * GoodSource: Less than CHAR_MAX
 * Sinks:
 *    BadSink : Convert data to a char
 * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE197_Numeric_Truncation_Error__short_fgets_84.h""


#define CHAR_ARRAY_SIZE 8

namespace CWE197_Numeric_Truncation_Error__short_fgets_84
{
CWE197_Numeric_Truncation_Error__short_fgets_84_bad::CWE197_Numeric_Truncation_Error__short_fgets_84_bad(short dataCopy)
{
    data = dataCopy;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = (short)atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
}

CWE197_Numeric_Truncation_Error__short_fgets_84_bad::~CWE197_Numeric_Truncation_Error__short_fgets_84_bad()
{
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
    }
}
}
"
9270,0,CWE590_Free_Memory_Not_on_Heap__free_long_declare_05.c,"    long * data;
    data = NULL; 
    if(staticTrue)
    {
        {
            
            long dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5L;
                }
            }
            data = dataBuffer;
        }
    }
    printLongLine(data[0]);
    
"
14430,0,CWE197_Numeric_Truncation_Error__short_connect_socket_43.cpp,"    short data;
    
    data = -1;
    badSource(data);
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
6721,0,CWE476_NULL_Pointer_Dereference__int_21.c,"    int * data;
    
    data = NULL;
    badStatic = 1; 
"
15086,0,CWE401_Memory_Leak__malloc_realloc_twoIntsStruct_03.c,"    if(5==5)
    {
        {
            twoIntsStruct * data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
            if (data == NULL) {exit(-1);}
            
            data[0].intOne = 0;
            data[0].intTwo = 0;
            printStructLine(&data[0]);
            
            data = (twoIntsStruct *)realloc(data, (130000)*sizeof(twoIntsStruct));
            if (data != NULL)
            {
                
                data[0].intOne = 1;
                data[0].intTwo = 1;
                printStructLine(&data[0]);
                free(data);
            }
        }
"
11807,1,CWE758_Undefined_Behavior__int_new_use_11.cpp,"    if(globalReturnsFalse())
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            int data;
            data = 5;
            int * pointer = new int;
            *pointer = data; 
            {
                int data = *pointer;
                printIntLine(data);
            }
            delete pointer;
        }
"
1804,0,CWE590_Free_Memory_Not_on_Heap__free_char_alloca_34.c,"    char * data;
    CWE590_Free_Memory_Not_on_Heap__free_char_alloca_34_unionType myUnion;
    data = NULL; 
    {
        
        char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
        memset(dataBuffer, 'A', 100-1); 
        dataBuffer[100-1] = '\0'; 
        data = dataBuffer;
    }
    myUnion.unionFirst = data;
    {
        char * data = myUnion.unionSecond;
        printLine(data);
        
        free(data);
"
3635,0,CWE401_Memory_Leak__malloc_realloc_twoIntsStruct_14.c,"    if(globalFive==5)
    {
        {
            twoIntsStruct * data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
            if (data == NULL) {exit(-1);}
            
            data[0].intOne = 0;
            data[0].intTwo = 0;
            printStructLine(&data[0]);
            
            data = (twoIntsStruct *)realloc(data, (130000)*sizeof(twoIntsStruct));
            if (data != NULL)
            {
                
                data[0].intOne = 1;
                data[0].intTwo = 1;
                printStructLine(&data[0]);
                free(data);
            }
        }
"
16355,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_05.c,"    size_t data;
    
    data = 0;
    if(staticTrue)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = strtoul(inputBuffer, NULL, 0);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(staticTrue)
    {
        {
            char * myString;
            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
             * for the strcpy() function to not cause a buffer overflow */
            
            if (data > strlen(HELLO_STRING))
            {
                myString = (char *)malloc(data*sizeof(char));
                if (myString == NULL) {exit(-1);}
                
                strcpy(myString, HELLO_STRING);
                printLine(myString);
                free(myString);
            }
            else
            {
                printLine(""Input is less than the length of the source string"");
            }
        }
"
14367,1,CWE758_Undefined_Behavior__long_new_use_05.cpp,"    if(staticFalse)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            long data;
            data = 5L;
            long * pointer = new long;
            *pointer = data; 
            {
                long data = *pointer;
                printLongLine(data);
            }
            delete pointer;
        }
"
5656,0,CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_21.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    badStatic = 1; 
"
9049,0,CWE134_Uncontrolled_Format_String__char_file_snprintf_66a.c,"    char * data;
    char * dataArray[5];
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        FILE * pFile;
        
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
    
    dataArray[2] = data;
"
17275,1,CWE758_Undefined_Behavior__long_new_use_18.cpp,"    goto sink;
sink:
    {
        long data;
        data = 5L;
        long * pointer = new long;
        *pointer = data; 
        {
            long data = *pointer;
            printLongLine(data);
        }
        delete pointer;
"
17190,1,CWE688_Function_Call_With_Incorrect_Variable_or_Reference_as_Argument__basic_14.c,"    if(globalFive!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            char dest[DEST_SIZE];
            int intFive = 5;
            
            sprintf(dest, ""%d"", intFive);
            printLine(dest);
        }
"
2478,0,CWE369_Divide_by_Zero__int_zero_divide_15.c,"    int data;
    
    data = -1;
    switch(6)
    {
    case 6:
        
        data = 0;
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
        
        printIntLine(100 / data);
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
1132,0,CWE369_Divide_by_Zero__float_fgets_44.c,"    float data;
    
    void (*funcPtr) (float) = badSink;
    
    data = 0.0F;
    {
        char inputBuffer[CHAR_ARRAY_SIZE];
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = (float)atof(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    
"
17385,0,CWE190_Integer_Overflow__unsigned_int_fscanf_add_32.c,"    unsigned int data;
    unsigned int *dataPtr1 = &data;
    unsigned int *dataPtr2 = &data;
    data = 0;
    {
        unsigned int data = *dataPtr1;
        
        fscanf (stdin, ""%u"", &data);
        *dataPtr1 = data;
    }
    {
        unsigned int data = *dataPtr2;
        {
            
            unsigned int result = data + 1;
            printUnsignedLine(result);
        }
"
12194,0,CWE252_Unchecked_Return_Value__char_fwrite_13.c,"    if(GLOBAL_CONST_FIVE==5)
    {
        
        fwrite((char *)""string"", sizeof(char), strlen(""string""), stdout);
"
10234,0,CWE401_Memory_Leak__int_malloc_09.c,"    int * data;
    data = NULL;
    if(GLOBAL_CONST_TRUE)
    {
        
        data = (int *)malloc(100*sizeof(int));
        if (data == NULL) {exit(-1);}
        
        data[0] = 5;
        printIntLine(data[0]);
    }
    if(GLOBAL_CONST_TRUE)
    {
        
        ; 
"
860,0,CWE401_Memory_Leak__new_int64_t_12.cpp,"    int64_t * data;
    data = NULL;
    if(globalReturnsTrueOrFalse())
    {
        
        data = new int64_t;
        
        *data = 5LL;
        printLongLongLine(*data);
    }
    else
    {
        
        int64_t dataGoodBuffer;
        data = &dataGoodBuffer;
        
        *data = 5LL;
        printLongLongLine(*data);
    }
    if(globalReturnsTrueOrFalse())
    {
        
        ; 
    }
    else
    {
        
        delete data;
"
9910,0,CWE590_Free_Memory_Not_on_Heap__delete_int_static_82a.cpp,"    int * data;
    data = NULL; 
    {
        
        static int dataBuffer;
        dataBuffer = 5;
        data = &dataBuffer;
    }
    CWE590_Free_Memory_Not_on_Heap__delete_int_static_82_base* baseObject = new CWE590_Free_Memory_Not_on_Heap__delete_int_static_82_bad;
    baseObject->action(data);
"
414,0,CWE134_Uncontrolled_Format_String__char_console_snprintf_31.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        
        if (100-dataLen > 1)
        {
            
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgets() */
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
                    data[dataLen-1] = '\0';
                }
            }
            else
            {
                printLine(""fgets() failed"");
                
                data[dataLen] = '\0';
            }
        }
    }
    {
        char * dataCopy = data;
        char * data = dataCopy;
        {
            char dest[100] = """";
            
            SNPRINTF(dest, 100-1, data);
            printLine(dest);
        }
"
13608,0,CWE457_Use_of_Uninitialized_Variable__double_array_alloca_no_init_03.c,"    double * data;
    data = (double *)ALLOCA(10*sizeof(double));
    if(5==5)
    {
        
        ; 
    }
    if(5==5)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printDoubleLine(data[i]);
            }
        }
"
3326,0,CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_04.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(STATIC_CONST_TRUE)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET connectSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                
                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                data[dataLen + recvResult / sizeof(char)] = '\0';
                
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(STATIC_CONST_TRUE)
    {
        badVaSinkB(data, data);
"
16439,0,CWE590_Free_Memory_Not_on_Heap__delete_int64_t_static_53a.cpp,"    int64_t * data;
    data = NULL; 
    {
        
        static int64_t dataBuffer;
        dataBuffer = 5LL;
        data = &dataBuffer;
    }
"
2522,0,CWE78_OS_Command_Injection__char_console_popen_73a.cpp,"    char * data;
    list<char *> dataList;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
        
        size_t dataLen = strlen(data);
        
        if (100-dataLen > 1)
        {
            
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgets() */
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
                    data[dataLen-1] = '\0';
                }
            }
            else
            {
                printLine(""fgets() failed"");
                
                data[dataLen] = '\0';
            }
        }
    }
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
589,0,CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_83_bad.cpp,"Label Definition File: CWE197_Numeric_Truncation_Error__int.label.xml
Template File: sources-sink-83_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 197 Numeric Truncation Error
 * BadSource: connect_socket Read data using a connect socket (client side)
 * GoodSource: Less than CHAR_MAX
 * Sinks: to_char
 *    BadSink : Convert data to a char
 * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_83.h""

#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif

#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)

namespace CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_83
{
CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_83_bad::CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_83_bad(int dataCopy)
{
    data = dataCopy;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
}

CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_83_bad::~CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_83_bad()
{
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
    }
}
}
"
17318,0,CWE190_Integer_Overflow__unsigned_int_max_preinc_65a.c,"    unsigned int data;
    
    void (*funcPtr) (unsigned int) = CWE190_Integer_Overflow__unsigned_int_max_preinc_65b_badSink;
    data = 0;
    
    data = UINT_MAX;
    
"
4541,0,CWE369_Divide_by_Zero__float_listenSocket_82_bad.cpp,"Label Definition File: CWE369_Divide_by_Zero__float.label.xml
Template File: sources-sinks-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 369 Divide by Zero
 * BadSource: listenSocket Read data using a listen socket (server side)
 * GoodSource: A hardcoded non-zero number (two)
 * Sinks:
 *    GoodSink: Check value of or near zero before dividing
 *    BadSink : Divide a constant by data
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE369_Divide_by_Zero__float_listenSocket_82.h""

namespace CWE369_Divide_by_Zero__float_listenSocket_82
{

void CWE369_Divide_by_Zero__float_listenSocket_82_bad::action(float data)
{
    {
        
        int result = (int)(100.0 / data);
        printIntLine(result);
    }
}

}
"
13214,0,CWE401_Memory_Leak__new_array_twointsStruct_72a.cpp,"    twoIntsStruct * data;
    vector<twoIntsStruct *> dataVector;
    data = NULL;
    
    data = new twoIntsStruct[100];
    
    data[0].intOne = 0;
    data[0].intTwo = 0;
    printStructLine(&data[0]);
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
5674,0,CWE190_Integer_Overflow__int_fgets_postinc_02.c,"    int data;
    
    data = 0;
    if(1)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    if(1)
    {
        {
            
            data++;
            int result = data;
            printIntLine(result);
        }
"
534,1,CWE476_NULL_Pointer_Dereference__null_check_after_deref_17.c,"    int k;
    for(k = 0; k < 1; k++)
    {
        {
            int *intPointer = NULL;
            intPointer = (int *)malloc(sizeof(int));
            *intPointer = 5;
            printIntLine(*intPointer);
            
            *intPointer = 10;
            printIntLine(*intPointer);
        }
"
13998,0,CWE758_Undefined_Behavior__no_return_01.c,"    int intBad = helperBad();
"
1317,0,CWE690_NULL_Deref_From_Return__int_realloc_32.c,"    int * data;
    int * *dataPtr1 = &data;
    int * *dataPtr2 = &data;
    data = NULL; 
    {
        int * data = *dataPtr1;
        
        data = (int *)realloc(data, 1*sizeof(int));
        *dataPtr1 = data;
    }
    {
        int * data = *dataPtr2;
        
        data[0] = 5;
        printIntLine(data[0]);
        free(data);
"
2718,0,CWE563_Unused_Variable__unused_uninit_variable_int_18.c,"    int data;
    
    ; 
    goto sink;
sink:
    
    
"
28,0,CWE590_Free_Memory_Not_on_Heap__delete_struct_alloca_06.cpp,"    twoIntsStruct * data;
    data = NULL; 
    if(STATIC_CONST_FIVE==5)
    {
        {
            
            twoIntsStruct * dataBuffer = (twoIntsStruct *)ALLOCA(sizeof(twoIntsStruct));
            dataBuffer->intOne = 1;
            dataBuffer->intTwo = 1;
            data = dataBuffer;
        }
    }
    printStructLine(data);
    
"
16056,0,CWE415_Double_Free__malloc_free_char_04.c,"    char * data;
    
    data = NULL;
    if(STATIC_CONST_TRUE)
    {
        data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        
        free(data);
    }
    if(STATIC_CONST_TRUE)
    {
        
        free(data);
"
5702,0,CWE563_Unused_Variable__unused_init_variable_char_22a.c,"    char data;
    
    data = 'C';
    CWE563_Unused_Variable__unused_init_variable_char_22_badGlobal = 1; 
"
14419,0,CWE590_Free_Memory_Not_on_Heap__free_int_declare_03.c,"    int * data;
    data = NULL; 
    if(5==5)
    {
        {
            
            int dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5;
                }
            }
            data = dataBuffer;
        }
    }
    printIntLine(data[0]);
    
"
14496,0,CWE476_NULL_Pointer_Dereference__deref_after_check_15.c,"    switch(6)
    {
    case 6:
    {
        
        int *intPointer = NULL;
        if (intPointer == NULL)
        {
            printIntLine(*intPointer);
        }
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
19067,0,CWE78_OS_Command_Injection__char_listen_socket_system_74a.cpp,"    char * data;
    map<int, char *> dataMap;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
10056,0,CWE758_Undefined_Behavior__struct_new_use_09.cpp,"    if(GLOBAL_CONST_TRUE)
    {
        {
            twoIntsStruct * pointer = new twoIntsStruct;
            twoIntsStruct data = *pointer; 
            delete pointer;
            printIntLine(data.intOne);
            printIntLine(data.intTwo);
        }
"
12562,0,CWE457_Use_of_Uninitialized_Variable__double_array_alloca_partial_init_18.c,"    double * data;
    data = (double *)ALLOCA(10*sizeof(double));
    goto source;
source:
    
    {
        int i;
        for(i=0; i<(10/2); i++)
        {
            data[i] = (double)i;
        }
    }
    goto sink;
sink:
    
    {
        int i;
        for(i=0; i<10; i++)
        {
            printDoubleLine(data[i]);
        }
"
4710,0,CWE590_Free_Memory_Not_on_Heap__delete_array_long_static_32.cpp,"    long * data;
    long * *dataPtr1 = &data;
    long * *dataPtr2 = &data;
    data = NULL; 
    {
        long * data = *dataPtr1;
        {
            
            static long dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5L;
                }
            }
            data = dataBuffer;
        }
        *dataPtr1 = data;
    }
    {
        long * data = *dataPtr2;
        printLongLine(data[0]);
        
        delete [] data;
"
1838,0,CWE590_Free_Memory_Not_on_Heap__delete_struct_declare_13.cpp,"    twoIntsStruct * data;
    data = NULL; 
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            
            twoIntsStruct dataBuffer;
            dataBuffer.intOne = 1;
            dataBuffer.intTwo = 1;
            data = &dataBuffer;
        }
    }
    printStructLine(data);
    
"
1478,0,CWE416_Use_After_Free__malloc_free_int64_t_13.c,"    int64_t * data;
    
    data = NULL;
    if(GLOBAL_CONST_FIVE==5)
    {
        data = (int64_t *)malloc(100*sizeof(int64_t));
        if (data == NULL) {exit(-1);}
        {
            size_t i;
            for(i = 0; i < 100; i++)
            {
                data[i] = 5LL;
            }
        }
        
        free(data);
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        
        printLongLongLine(data[0]);
        
"
2555,0,CWE134_Uncontrolled_Format_String__char_listen_socket_printf_01.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
"
19396,0,CWE563_Unused_Variable__unused_uninit_variable_int_13.c,"    int data;
    
    ; 
    if(GLOBAL_CONST_FIVE==5)
    {
        
        
        ; 
"
12990,0,CWE401_Memory_Leak__int_realloc_62a.cpp,"    int * data;
    data = NULL;
    badSource(data);
    
"
4127,0,CWE590_Free_Memory_Not_on_Heap__delete_array_int64_t_declare_53a.cpp,"    int64_t * data;
    data = NULL; 
    {
        
        int64_t dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5LL;
            }
        }
        data = dataBuffer;
    }
"
4890,0,CWE252_Unchecked_Return_Value__char_rename_12.c,"    if(globalReturnsTrueOrFalse())
    {
        
        RENAME(OLD_BAD_FILE_NAME, ""newbadfilename.txt"");
    }
    else
    {
        
        if (RENAME(OLD_GOOD_FILE_NAME, ""newgoodfilename.txt"") != 0)
        {
            printLine(""rename failed!"");
        }
"
2659,0,CWE590_Free_Memory_Not_on_Heap__free_struct_static_06.c,"    twoIntsStruct * data;
    data = NULL; 
    if(STATIC_CONST_FIVE==5)
    {
        {
            
            static twoIntsStruct dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i].intOne = 1;
                    dataBuffer[i].intTwo = 1;
                }
            }
            data = dataBuffer;
        }
    }
    printStructLine(&data[0]);
    
"
8843,0,CWE134_Uncontrolled_Format_String__char_console_vfprintf_72a.cpp,"    char * data;
    vector<char *> dataVector;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        
        if (100-dataLen > 1)
        {
            
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgets() */
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
                    data[dataLen-1] = '\0';
                }
            }
            else
            {
                printLine(""fgets() failed"");
                
                data[dataLen] = '\0';
            }
        }
    }
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
2207,0,CWE690_NULL_Deref_From_Return__int64_t_calloc_07.c,"    int64_t * data;
    data = NULL; 
    
    data = (int64_t *)calloc(1, sizeof(int64_t));
    if(staticFive==5)
    {
        
        data[0] = 5LL;
        printLongLongLine(data[0]);
        free(data);
"
2712,0,CWE197_Numeric_Truncation_Error__int_fgets_to_char_06.c,"    int data;
    
    data = -1;
    if(STATIC_CONST_FIVE==5)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
14881,0,CWE190_Integer_Overflow__int_fscanf_preinc_11.c,"    int data;
    
    data = 0;
    if(globalReturnsTrue())
    {
        
        fscanf(stdin, ""%d"", &data);
    }
    if(globalReturnsTrue())
    {
        {
            
            ++data;
            int result = data;
            printIntLine(result);
        }
"
16058,0,CWE369_Divide_by_Zero__float_fgets_13.c,"    float data;
    
    data = 0.0F;
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE];
            
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                
                data = (float)atof(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            
            int result = (int)(100.0 / data);
            printIntLine(result);
        }
"
16424,0,CWE563_Unused_Variable__unused_value_int64_t_18.c,"    int64_t data;
    goto source;
source:
    
    data = 5LL;
    goto sink;
sink:
    
    data = 10LL;
"
10970,0,CWE416_Use_After_Free__new_delete_array_int_10.cpp,"    int * data;
    
    data = NULL;
    if(globalTrue)
    {
        data = new int[100];
        {
            size_t i;
            for(i = 0; i < 100; i++)
            {
                data[i] = 5;
            }
        }
        
        delete [] data;
    }
    if(globalTrue)
    {
        
        printIntLine(data[0]);
        
"
13527,0,CWE134_Uncontrolled_Format_String__char_console_fprintf_83a.cpp,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
"
10961,0,CWE590_Free_Memory_Not_on_Heap__delete_array_int64_t_declare_54a.cpp,"    int64_t * data;
    data = NULL; 
    {
        
        int64_t dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5LL;
            }
        }
        data = dataBuffer;
    }
"
3550,0,CWE401_Memory_Leak__new_char_73a.cpp,"    char * data;
    list<char *> dataList;
    data = NULL;
    
    data = new char;
    
    *data = 'A';
    printHexCharLine(*data);
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
1229,0,CWE401_Memory_Leak__new_array_char_63a.cpp,"    char * data;
    data = NULL;
    
    data = new char[100];
    
    strcpy(data, ""A String"");
    printLine(data);
"
8402,0,CWE590_Free_Memory_Not_on_Heap__delete_char_placement_new_08.cpp,"    char * data;
    data = NULL; 
    if(staticReturnsTrue())
    {
        {
            
            char buffer[sizeof(char)];
            char * dataBuffer = new(buffer) char;
            *dataBuffer = 'A';
            data = dataBuffer;
        }
    }
    printHexCharLine(*data);
    
"
13992,0,CWE401_Memory_Leak__int64_t_calloc_42.c,"    int64_t * data;
    data = NULL;
    data = badSource(data);
    
"
10948,1,CWE758_Undefined_Behavior__struct_pointer_malloc_use_06.c,"    if(STATIC_CONST_FIVE==5)
    {
        {
            twoIntsStruct * data;
            twoIntsStruct * * pointer = (twoIntsStruct * *)malloc(sizeof(twoIntsStruct *));
            if (pointer == NULL) {exit(-1);}
            
            data = (twoIntsStruct *)malloc(sizeof(twoIntsStruct));
            if (data == NULL) {exit(-1);}
            data->intOne = 5;
            data->intTwo = 6;
            *pointer = data; 
            {
                twoIntsStruct * data = *pointer;
                printIntLine(data->intOne);
                printIntLine(data->intTwo);
            }
            free(pointer);
        }
"
2288,0,CWE563_Unused_Variable__unused_init_variable_int64_t_81a.cpp,"    int64_t data;
    
    data = 5LL;
    const CWE563_Unused_Variable__unused_init_variable_int64_t_81_base& baseObject = CWE563_Unused_Variable__unused_init_variable_int64_t_81_bad();
"
16443,1,CWE758_Undefined_Behavior__class_pointer_new_use_17.cpp,"    int k;
    for(k = 0; k < 1; k++)
    {
        {
            TwoIntsClass * data;
            
            data = new TwoIntsClass;
            data->intOne = 5;
            data->intTwo = 6;
            TwoIntsClass * * pointer = new TwoIntsClass *;
            *pointer = data; 
            {
                TwoIntsClass * data = *pointer;
                printIntLine(data->intOne);
                printIntLine(data->intTwo);
            }
            delete pointer;
        }
"
10235,0,CWE190_Integer_Overflow__short_fscanf_square_31.c,"    short data;
    data = 0;
    
    fscanf (stdin, ""%hd"", &data);
    {
        short dataCopy = data;
        short data = dataCopy;
        {
            
            short result = data * data;
            printIntLine(result);
        }
"
17713,0,CWE190_Integer_Overflow__char_rand_multiply_12.c,"    char data;
    data = ' ';
    if(globalReturnsTrueOrFalse())
    {
        
        data = (char)RAND32();
    }
    else
    {
        
        data = 2;
    }
    if(globalReturnsTrueOrFalse())
    {
        if(data > 0) 
        {
            
            char result = data * 2;
            printHexCharLine(result);
        }
    }
    else
    {
        if(data > 0) 
        {
            
            if (data < (CHAR_MAX/2))
            {
                char result = data * 2;
                printHexCharLine(result);
            }
            else
            {
                printLine(""data value is too large to perform arithmetic safely."");
            }
        }
"
8548,0,CWE190_Integer_Overflow__unsigned_int_fscanf_square_64a.c,"    unsigned int data;
    data = 0;
    
    fscanf (stdin, ""%u"", &data);
"
4472,0,CWE190_Integer_Overflow__char_max_add_81_bad.cpp,"Label Definition File: CWE190_Integer_Overflow.label.xml
Template File: sources-sinks-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 190 Integer Overflow
 * BadSource: max Set data to the max value for char
 * GoodSource: Set data to a small, non-zero number (two)
 * Sinks: add
 *    GoodSink: Ensure there will not be an overflow before adding 1 to data
 *    BadSink : Add 1 to data, which can cause an overflow
 * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE190_Integer_Overflow__char_max_add_81.h""

namespace CWE190_Integer_Overflow__char_max_add_81
{

void CWE190_Integer_Overflow__char_max_add_81_bad::action(char data) const
{
    {
        
        char result = data + 1;
        printHexCharLine(result);
    }
}

}
"
237,0,CWE190_Integer_Overflow__char_rand_multiply_09.c,"    char data;
    data = ' ';
    if(GLOBAL_CONST_TRUE)
    {
        
        data = (char)RAND32();
    }
    if(GLOBAL_CONST_TRUE)
    {
        if(data > 0) 
        {
            
            char result = data * 2;
            printHexCharLine(result);
        }
"
1687,0,CWE415_Double_Free__new_delete_array_long_67a.cpp,"    long * data;
    structType myStruct;
    
    data = NULL;
    data = new long[100];
    
    delete [] data;
    myStruct.structFirst = data;
"
6088,1,CWE758_Undefined_Behavior__long_alloca_use_11.c,"    if(globalReturnsFalse())
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            long data;
            long * pointer = (long *)ALLOCA(sizeof(long));
            data = 5L;
            *pointer = data; 
            {
                long data = *pointer;
                printLongLine(data);
            }
        }
"
11055,0,CWE590_Free_Memory_Not_on_Heap__delete_array_struct_declare_10.cpp,"    twoIntsStruct * data;
    data = NULL; 
    if(globalTrue)
    {
        {
            
            twoIntsStruct dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i].intOne = 1;
                    dataBuffer[i].intTwo = 1;
                }
            }
            data = dataBuffer;
        }
    }
    printStructLine(&data[0]);
    
"
12087,0,CWE369_Divide_by_Zero__float_connect_socket_63a.c,"    float data;
    
    data = 0.0F;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = (float)atof(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
4800,0,CWE676_Use_of_Potentially_Dangerous_Function__basic_13.cpp,"    if(GLOBAL_CONST_FIVE==5)
    {
        {
            char charBuffer[CHAR_BUFFER_SIZE];
            
            
            cin >> charBuffer;
            charBuffer[CHAR_BUFFER_SIZE-1] = '\0';
            printLine(charBuffer);
        }
"
15620,0,CWE369_Divide_by_Zero__int_fgets_divide_08.c,"    int data;
    
    data = -1;
    if(staticReturnsTrue())
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    if(staticReturnsTrue())
    {
        
        printIntLine(100 / data);
"
10530,0,CWE457_Use_of_Uninitialized_Variable__new_struct_array_partial_init_18.cpp,"    twoIntsStruct * data;
    data = new twoIntsStruct[10];
    goto source;
source:
    
    {
        int i;
        for(i=0; i<(10/2); i++)
        {
            data[i].intOne = i;
            data[i].intTwo = i;
        }
    }
    goto sink;
sink:
    
    {
        int i;
        for(i=0; i<10; i++)
        {
            printIntLine(data[i].intOne);
            printIntLine(data[i].intTwo);
        }
    }
    
"
5080,1,CWE758_Undefined_Behavior__struct_alloca_use_07.c,"    if(staticFive==5)
    {
        {
            twoIntsStruct data;
            twoIntsStruct * pointer = (twoIntsStruct *)ALLOCA(sizeof(twoIntsStruct));
            data.intOne = 1;
            data.intTwo = 2;
            *pointer = data; 
            {
                twoIntsStruct data = *pointer;
                printIntLine(data.intOne);
                printIntLine(data.intTwo);
            }
        }
"
18860,1,CWE758_Undefined_Behavior__int64_t_new_use_06.cpp,"    if(STATIC_CONST_FIVE==5)
    {
        {
            int64_t data;
            data = 5LL;
            int64_t * pointer = new int64_t;
            *pointer = data; 
            {
                int64_t data = *pointer;
                printLongLongLine(data);
            }
            delete pointer;
        }
"
2497,0,CWE78_OS_Command_Injection__char_file_execlp_61a.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    data = CWE78_OS_Command_Injection__char_file_execlp_61b_badSource(data);
    /* execlp - searches for the location of the command among
     * the directories specified by the PATH environment variable */
    
"
7357,0,CWE197_Numeric_Truncation_Error__int_listen_socket_to_char_34.c,"    int data;
    CWE197_Numeric_Truncation_Error__int_listen_socket_to_char_34_unionType myUnion;
    
    data = -1;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    myUnion.unionFirst = data;
    {
        int data = myUnion.unionSecond;
        {
            
            char charData = (char)data;
            printHexCharLine(charData);
        }
"
18758,0,CWE190_Integer_Overflow__char_fscanf_square_81a.cpp,"    char data;
    data = ' ';
    
    fscanf (stdin, ""%c"", &data);
    const CWE190_Integer_Overflow__char_fscanf_square_81_base& baseObject = CWE190_Integer_Overflow__char_fscanf_square_81_bad();
"
15156,0,CWE190_Integer_Overflow__int_listen_socket_postinc_05.c,"    int data;
    
    data = 0;
    if(staticTrue)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(staticTrue)
    {
        {
            
            data++;
            int result = data;
            printIntLine(result);
        }
"
12186,0,CWE457_Use_of_Uninitialized_Variable__int64_t_12.c,"    int64_t data;
    if(globalReturnsTrueOrFalse())
    {
        
        ; 
    }
    else
    {
        
        data = 5LL;
    }
    if(globalReturnsTrueOrFalse())
    {
        
        printLongLongLine(data);
    }
    else
    {
        
        data = 5LL;
        printLongLongLine(data);
"
1984,1,CWE252_Unchecked_Return_Value__char_fprintf_05.c,"    if(staticTrue)
    {
        
        if (fprintf(stdout, ""%s\n"", ""string"") < 0)
        {
            printLine(""fprintf failed!"");
        }
"
9050,0,CWE190_Integer_Overflow__unsigned_int_rand_add_16.c,"    unsigned int data;
    data = 0;
    while(1)
    {
        
        data = (unsigned int)RAND32();
        break;
    }
    while(1)
    {
        {
            
            unsigned int result = data + 1;
            printUnsignedLine(result);
        }
        break;
"
15307,0,CWE78_OS_Command_Injection__char_environment_popen_13.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            
            size_t dataLen = strlen(data);
            char * environment = GETENV(ENV_VARIABLE);
            
            if (environment != NULL)
            {
                
                strncat(data+dataLen, environment, 100-dataLen-1);
            }
        }
    }
    {
        FILE *pipe;
        
        pipe = POPEN(data, ""w"");
        if (pipe != NULL)
        {
            PCLOSE(pipe);
        }
"
11846,1,CWE758_Undefined_Behavior__long_alloca_use_12.c,"    if(globalReturnsTrueOrFalse())
    {
        {
            long data;
            long * pointer = (long *)ALLOCA(sizeof(long));
            data = 5L;
            *pointer = data; 
            {
                long data = *pointer;
                printLongLine(data);
            }
        }
    }
    else
    {
        {
            long data;
            long * pointer = (long *)ALLOCA(sizeof(long));
            data = 5L;
            *pointer = data; 
            {
                long data = *pointer;
                printLongLine(data);
            }
        }
"
646,0,CWE190_Integer_Overflow__int64_t_rand_multiply_41.c,"    int64_t data;
    data = 0LL;
    
    data = (int64_t)RAND64();
"
11980,0,CWE590_Free_Memory_Not_on_Heap__free_int64_t_static_16.c,"    int64_t * data;
    data = NULL; 
    while(1)
    {
        {
            
            static int64_t dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5LL;
                }
            }
            data = dataBuffer;
        }
        break;
    }
    printLongLongLine(data[0]);
    
"
6551,0,CWE563_Unused_Variable__unused_init_variable_int_33.cpp,"    int data;
    int &dataRef = data;
    
    data = 5;
    {
        int data = dataRef;
        
        
        ; 
"
9507,0,CWE197_Numeric_Truncation_Error__int_large_to_char_06.c,"    int data;
    
    data = -1;
    if(STATIC_CONST_FIVE==5)
    {
        
        data = SHRT_MAX + 5;
    }
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
8487,0,CWE416_Use_After_Free__new_delete_array_char_43.cpp,"    char * data;
    
    data = NULL;
    badSource(data);
    
    printLine(data);
"
1625,0,CWE457_Use_of_Uninitialized_Variable__double_array_declare_no_init_02.c,"    double * data;
    double dataUninitArray[10];
    data = dataUninitArray;
    if(1)
    {
        
        ; 
    }
    if(1)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printDoubleLine(data[i]);
            }
        }
"
12552,0,CWE590_Free_Memory_Not_on_Heap__delete_array_struct_alloca_32.cpp,"    twoIntsStruct * data;
    twoIntsStruct * *dataPtr1 = &data;
    twoIntsStruct * *dataPtr2 = &data;
    data = NULL; 
    {
        twoIntsStruct * data = *dataPtr1;
        {
            
            twoIntsStruct * dataBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i].intOne = 1;
                    dataBuffer[i].intTwo = 1;
                }
            }
            data = dataBuffer;
        }
        *dataPtr1 = data;
    }
    {
        twoIntsStruct * data = *dataPtr2;
        printStructLine(&data[0]);
        
        delete [] data;
"
5669,1,CWE252_Unchecked_Return_Value__char_fscanf_02.c,"    if(1)
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            
            if (fscanf(stdin, ""%99s\0"", data) == EOF)
            {
                printLine(""fscanf failed!"");
            }
        }
"
15838,0,CWE562_Return_of_Stack_Variable_Address__return_buf_01.c,
16960,0,CWE590_Free_Memory_Not_on_Heap__delete_char_static_64a.cpp,"    char * data;
    data = NULL; 
    {
        
        static char dataBuffer;
        dataBuffer = 'A';
        data = &dataBuffer;
    }
"
9265,0,CWE401_Memory_Leak__int64_t_malloc_43.cpp,"    int64_t * data;
    data = NULL;
    badSource(data);
    
"
5884,0,CWE134_Uncontrolled_Format_String__char_environment_snprintf_34.c,"    char * data;
    CWE134_Uncontrolled_Format_String__char_environment_snprintf_34_unionType myUnion;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        
        if (environment != NULL)
        {
            
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    myUnion.unionFirst = data;
    {
        char * data = myUnion.unionSecond;
        {
            char dest[100] = """";
            
            SNPRINTF(dest, 100-1, data);
            printLine(dest);
        }
"
18794,0,CWE401_Memory_Leak__malloc_realloc_int64_t_18.c,"    goto sink;
sink:
    {
        int64_t * data = (int64_t *)malloc(100*sizeof(int64_t));
        if (data == NULL) {exit(-1);}
        
        data[0] = 5LL;
        printLongLongLine(data[0]);
        
        data = (int64_t *)realloc(data, (130000)*sizeof(int64_t));
        if (data != NULL)
        {
            
            data[0] = 10LL;
            printLongLongLine(data[0]);
            free(data);
        }
"
15580,0,CWE590_Free_Memory_Not_on_Heap__delete_array_char_declare_73a.cpp,"    char * data;
    list<char *> dataList;
    data = NULL; 
    {
        
        char dataBuffer[100];
        memset(dataBuffer, 'A', 100-1); 
        dataBuffer[100-1] = '\0'; 
        data = dataBuffer;
    }
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
257,0,CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_84a.cpp,"    size_t data;
    
    data = 0;
    CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_84_bad * badObject = new CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_84_bad(data);
"
13469,0,CWE190_Integer_Overflow__int_max_preinc_03.c,"    int data;
    
    data = 0;
    if(5==5)
    {
        
        data = INT_MAX;
    }
    if(5==5)
    {
        {
            
            ++data;
            int result = data;
            printIntLine(result);
        }
"
17417,0,CWE78_OS_Command_Injection__char_listen_socket_execl_15.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    switch(6)
    {
    case 6:
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    
    
"
531,0,CWE690_NULL_Deref_From_Return__int64_t_realloc_45.c,"    int64_t * data;
    data = NULL; 
    
    data = (int64_t *)realloc(data, 1*sizeof(int64_t));
    CWE690_NULL_Deref_From_Return__int64_t_realloc_45_badData = data;
"
12848,1,CWE401_Memory_Leak__malloc_realloc_struct_twoIntsStruct_16.c,"    while(1)
    {
        {
            struct _twoIntsStruct * data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));
            if (data == NULL) {exit(-1);}
            struct _twoIntsStruct * tmpData;
            
            data[0].intOne = 0;
            data[0].intTwo = 0;
            printStructLine((twoIntsStruct *)&data[0]);
            tmpData = (struct _twoIntsStruct *)realloc(data, (130000)*sizeof(struct _twoIntsStruct));
            /* FIX: Ensure realloc() was successful before assigning data to the memory block
            * allocated with realloc() */
            if (tmpData != NULL)
            {
                data = tmpData;
                
                data[0].intOne = 1;
                data[0].intTwo = 1;
                printStructLine((twoIntsStruct *)&data[0]);
            }
            free(data);
        }
        break;
"
15743,1,CWE758_Undefined_Behavior__struct_new_use_14.cpp,"    if(globalFive==5)
    {
        {
            twoIntsStruct data;
            data.intOne = 1;
            data.intTwo = 2;
            twoIntsStruct * pointer = new twoIntsStruct;
            *pointer = data; 
            {
                twoIntsStruct data = *pointer;
                printIntLine(data.intOne);
                printIntLine(data.intTwo);
            }
            delete pointer;
        }
"
14716,0,CWE476_NULL_Pointer_Dereference__struct_14.c,"    twoIntsStruct * data;
    if(globalFive==5)
    {
        
        data = NULL;
    }
    if(globalFive==5)
    {
        
        printIntLine(data->intOne);
"
9533,0,CWE415_Double_Free__new_delete_int_34.cpp,"    int * data;
    unionType myUnion;
    
    data = NULL;
    data = new int;
    
    delete data;
    myUnion.unionFirst = data;
    {
        int * data = myUnion.unionSecond;
        
        delete data;
"
18091,0,CWE78_OS_Command_Injection__char_console_system_14.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(globalFive==5)
    {
        {
            
            size_t dataLen = strlen(data);
            
            if (100-dataLen > 1)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
                {
                    /* The next few lines remove the carriage return from the string that is
                     * inserted by fgets() */
                    dataLen = strlen(data);
"
82,0,CWE190_Integer_Overflow__int64_t_fscanf_preinc_12.c,"    int64_t data;
    data = 0LL;
    if(globalReturnsTrueOrFalse())
    {
        
        fscanf (stdin, ""%"" SCNd64, &data);
    }
    else
    {
        
        data = 2;
    }
    if(globalReturnsTrueOrFalse())
    {
        {
            
            ++data;
            int64_t result = data;
            printLongLongLine(result);
        }
    }
    else
    {
        
        if (data < LLONG_MAX)
        {
            ++data;
            int64_t result = data;
            printLongLongLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
"
6734,0,CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_53a.c,"    unsigned int data;
    data = 0;
    
    fscanf (stdin, ""%u"", &data);
"
6689,0,CWE590_Free_Memory_Not_on_Heap__free_long_declare_74a.cpp,"    long * data;
    map<int, long *> dataMap;
    data = NULL; 
    {
        
        long dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5L;
            }
        }
        data = dataBuffer;
    }
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
14912,0,CWE78_OS_Command_Injection__char_listen_socket_system_61a.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    data = CWE78_OS_Command_Injection__char_listen_socket_system_61b_badSource(data);
    
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
"
15869,0,CWE758_Undefined_Behavior__struct_alloca_use_13.c,"    if(GLOBAL_CONST_FIVE==5)
    {
        {
            twoIntsStruct * pointer = (twoIntsStruct *)ALLOCA(sizeof(twoIntsStruct));
            twoIntsStruct data = *pointer; 
            printIntLine(data.intOne);
            printIntLine(data.intTwo);
        }
"
4626,0,CWE401_Memory_Leak__int_realloc_68a.c,"    int * data;
    data = NULL;
    
    data = (int *)realloc(data, 100*sizeof(int));
    if (data == NULL) {exit(-1);}
    
    data[0] = 5;
    printIntLine(data[0]);
    CWE401_Memory_Leak__int_realloc_68_badData = data;
"
16166,0,CWE690_NULL_Deref_From_Return__int64_t_malloc_84a.cpp,"    int64_t * data;
    data = NULL; 
    CWE690_NULL_Deref_From_Return__int64_t_malloc_84_bad * badObject = new CWE690_NULL_Deref_From_Return__int64_t_malloc_84_bad(data);
"
11829,0,CWE78_OS_Command_Injection__char_environment_execlp_08.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(staticReturnsTrue())
    {
        {
            
            size_t dataLen = strlen(data);
            char * environment = GETENV(ENV_VARIABLE);
            
            if (environment != NULL)
            {
                
                strncat(data+dataLen, environment, 100-dataLen-1);
            }
        }
    }
    /* execlp - searches for the location of the command among
     * the directories specified by the PATH environment variable */
    
"
18752,0,CWE197_Numeric_Truncation_Error__int_fgets_to_char_62a.cpp,"    int data;
    
    data = -1;
    badSource(data);
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
17343,0,CWE190_Integer_Overflow__int_connect_socket_square_04.c,"    int data;
    
    data = 0;
    if(STATIC_CONST_TRUE)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(STATIC_CONST_TRUE)
    {
        {
            
            int result = data * data;
            printIntLine(result);
        }
"
14577,0,CWE252_Unchecked_Return_Value__char_fputc_03.c,"    if(5==5)
    {
        
        fputc((int)'A', stdout);
"
6758,0,CWE690_NULL_Deref_From_Return__char_calloc_42.c,"    char * data;
    data = NULL; 
    data = badSource(data);
    
    strcpy(data, ""Initialize"");
    printLine(data);
"
19372,0,CWE590_Free_Memory_Not_on_Heap__delete_array_long_static_54a.cpp,"    long * data;
    data = NULL; 
    {
        
        static long dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5L;
            }
        }
        data = dataBuffer;
    }
"
1487,0,CWE190_Integer_Overflow__int_fgets_multiply_08.c,"    int data;
    
    data = 0;
    if(staticReturnsTrue())
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    if(staticReturnsTrue())
    {
        if(data > 0) 
        {
            
            int result = data * 2;
            printIntLine(result);
        }
"
11778,0,CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_01.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
17771,0,CWE401_Memory_Leak__new_TwoIntsClass_11.cpp,"    TwoIntsClass * data;
    data = NULL;
    if(globalReturnsTrue())
    {
        
        data = new TwoIntsClass;
        
        data->intOne = 0;
        data->intTwo = 0;
        printIntLine(data->intOne);
        printIntLine(data->intTwo);
    }
    if(globalReturnsTrue())
    {
        
        ; 
"
10520,0,CWE190_Integer_Overflow__char_fscanf_add_82a.cpp,"    char data;
    data = ' ';
    
    fscanf (stdin, ""%c"", &data);
    CWE190_Integer_Overflow__char_fscanf_add_82_base* baseObject = new CWE190_Integer_Overflow__char_fscanf_add_82_bad;
    baseObject->action(data);
"
6348,0,CWE369_Divide_by_Zero__int_rand_modulo_82a.cpp,"    int data;
    
    data = -1;
    
    data = RAND32();
    CWE369_Divide_by_Zero__int_rand_modulo_82_base* baseObject = new CWE369_Divide_by_Zero__int_rand_modulo_82_bad;
    baseObject->action(data);
"
13210,1,CWE416_Use_After_Free__return_freed_ptr_03.c,"    if(5!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            
            char * reversedString = helperGood(""GoodSink"");
            printLine(reversedString);
            /* free(reversedString);
             * This call to free() was removed because we want the tool to detect the use after free,
             * but we don't want that function to be free(). Essentially we want to avoid a double free
             */
        }
"
8076,0,CWE457_Use_of_Uninitialized_Variable__twointsclass_array_declare_no_init_15.cpp,"    TwoIntsClass * data;
    TwoIntsClass dataUninitArray[10];
    data = dataUninitArray;
    switch(6)
    {
    case 6:
        
        ; 
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
        
        for(int i=0; i<10; i++)
        {
            printIntLine(data[i].intOne);
            printIntLine(data[i].intTwo);
        }
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
15125,0,CWE401_Memory_Leak__malloc_realloc_char_02.c,"    if(1)
    {
        {
            char * data = (char *)malloc(100*sizeof(char));
            if (data == NULL) {exit(-1);}
            
            strcpy(data, ""A String"");
            printLine(data);
            
            data = (char *)realloc(data, (130000)*sizeof(char));
            if (data != NULL)
            {
                
                strcpy(data, ""New String"");
                printLine(data);
                free(data);
            }
        }
"
3030,0,CWE369_Divide_by_Zero__float_rand_82_bad.cpp,"Label Definition File: CWE369_Divide_by_Zero__float.label.xml
Template File: sources-sinks-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 369 Divide by Zero
 * BadSource: rand Set data to result of RAND32(), which may be zero
 * GoodSource: A hardcoded non-zero number (two)
 * Sinks:
 *    GoodSink: Check value of or near zero before dividing
 *    BadSink : Divide a constant by data
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE369_Divide_by_Zero__float_rand_82.h""

namespace CWE369_Divide_by_Zero__float_rand_82
{

void CWE369_Divide_by_Zero__float_rand_82_bad::action(float data)
{
    {
        
        int result = (int)(100.0 / data);
        printIntLine(result);
    }
}

}
"
17407,0,CWE415_Double_Free__malloc_free_struct_81a.cpp,"    twoIntsStruct * data;
    
    data = NULL;
    data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
    if (data == NULL) {exit(-1);}
    
    free(data);
    const CWE415_Double_Free__malloc_free_struct_81_base& baseObject = CWE415_Double_Free__malloc_free_struct_81_bad();
"
14901,0,CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_34.c,"    char * data;
    CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_34_unionType myUnion;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    myUnion.unionFirst = data;
    {
        char * data = myUnion.unionSecond;
        {
            char dest[100] = """";
            
            SNPRINTF(dest, 100-1, data);
            printLine(dest);
        }
"
14859,0,CWE457_Use_of_Uninitialized_Variable__double_array_alloca_no_init_07.c,"    double * data;
    data = (double *)ALLOCA(10*sizeof(double));
    if(staticFive==5)
    {
        
        ; 
    }
    if(staticFive==5)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printDoubleLine(data[i]);
            }
        }
"
18695,0,CWE190_Integer_Overflow__char_fscanf_add_67a.c,"    char data;
    CWE190_Integer_Overflow__char_fscanf_add_67_structType myStruct;
    data = ' ';
    
    fscanf (stdin, ""%c"", &data);
    myStruct.structFirst = data;
"
11319,0,CWE690_NULL_Deref_From_Return__int64_t_realloc_21.c,"    int64_t * data;
    data = NULL; 
    
    data = (int64_t *)realloc(data, 1*sizeof(int64_t));
    badStatic = 1; 
"
1312,1,CWE758_Undefined_Behavior__int_malloc_use_11.c,"    if(globalReturnsTrue())
    {
        {
            int data;
            int * pointer = (int *)malloc(sizeof(int));
            if (pointer == NULL) {exit(-1);}
            data = 5;
            *pointer = data; 
            {
                int data = *pointer;
                printIntLine(data);
            }
            free(pointer);
        }
"
10291,0,CWE190_Integer_Overflow__int_rand_preinc_61a.c,"    int data;
    
    data = 0;
    data = CWE190_Integer_Overflow__int_rand_preinc_61b_badSource(data);
    {
        
        ++data;
        int result = data;
        printIntLine(result);
"
8758,0,CWE590_Free_Memory_Not_on_Heap__delete_array_long_static_06.cpp,"    long * data;
    data = NULL; 
    if(STATIC_CONST_FIVE==5)
    {
        {
            
            static long dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5L;
                }
            }
            data = dataBuffer;
        }
    }
    printLongLine(data[0]);
    
"
2857,0,CWE690_NULL_Deref_From_Return__char_malloc_45.c,"    char * data;
    data = NULL; 
    
    data = (char *)malloc(20*sizeof(char));
    CWE690_NULL_Deref_From_Return__char_malloc_45_badData = data;
"
5156,1,CWE469_Use_of_Pointer_Subtraction_to_Determine_Size__char_17.c,"    int k;
    for(k = 0; k < 1; k++)
    {
        {
            char string1[] = SOURCE_STRING;
            char * slashInString1;
            size_t indexOfSlashInString1;
            slashInString1 = strchr(string1, '/');
            if (slashInString1 == NULL)
            {
                exit(1);
            }
            
            indexOfSlashInString1 = (size_t)(slashInString1 - string1);
            
            printUnsignedLine(indexOfSlashInString1);
        }
"
17367,0,CWE590_Free_Memory_Not_on_Heap__delete_array_class_alloca_31.cpp,"    TwoIntsClass * data;
    data = NULL; 
    {
        
        TwoIntsClass * dataBuffer = (TwoIntsClass *)ALLOCA(100*sizeof(TwoIntsClass));
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i].intOne = 1;
                dataBuffer[i].intTwo = 1;
            }
        }
        data = dataBuffer;
    }
    {
        TwoIntsClass * dataCopy = data;
        TwoIntsClass * data = dataCopy;
        printIntLine(data[0].intOne);
        
        delete [] data;
"
2706,0,CWE78_OS_Command_Injection__char_listen_socket_execlp_66a.c,"    char * data;
    char * dataArray[5];
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
    dataArray[2] = data;
"
3248,0,CWE369_Divide_by_Zero__int_connect_socket_modulo_83a.cpp,"    int data;
    
    data = -1;
"
4192,0,CWE190_Integer_Overflow__int_fgets_postinc_16.c,"    int data;
    
    data = 0;
    while(1)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
        break;
    }
    while(1)
    {
        {
            
            data++;
            int result = data;
            printIntLine(result);
        }
        break;
"
5980,0,CWE197_Numeric_Truncation_Error__short_fscanf_64a.c,"    short data;
    
    data = -1;
    
    fscanf (stdin, ""%hd"", &data);
"
3500,0,CWE590_Free_Memory_Not_on_Heap__delete_int_static_45.cpp,"    int * data;
    data = NULL; 
    {
        
        static int dataBuffer;
        dataBuffer = 5;
        data = &dataBuffer;
    }
    badData = data;
"
15079,0,CWE190_Integer_Overflow__int64_t_fscanf_add_33.cpp,"    int64_t data;
    int64_t &dataRef = data;
    data = 0LL;
    
    fscanf (stdin, ""%"" SCNd64, &data);
    {
        int64_t data = dataRef;
        {
            
            int64_t result = data + 1;
            printLongLongLine(result);
        }
"
7459,0,CWE401_Memory_Leak__new_char_67a.cpp,"    char * data;
    structType myStruct;
    data = NULL;
    
    data = new char;
    
    *data = 'A';
    printHexCharLine(*data);
    myStruct.structFirst = data;
"
15147,0,CWE190_Integer_Overflow__int_rand_square_73a.cpp,"    int data;
    list<int> dataList;
    
    data = 0;
    
    data = RAND32();
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
14289,0,CWE563_Unused_Variable__unused_init_variable_char_10.c,"    char data;
    
    data = 'C';
    if(globalTrue)
    {
        
        
        ; 
"
9561,1,CWE469_Use_of_Pointer_Subtraction_to_Determine_Size__char_13.c,"    if(GLOBAL_CONST_FIVE==5)
    {
        {
            char string1[] = SOURCE_STRING;
            char * slashInString1;
            size_t indexOfSlashInString1;
            slashInString1 = strchr(string1, '/');
            if (slashInString1 == NULL)
            {
                exit(1);
            }
            
            indexOfSlashInString1 = (size_t)(slashInString1 - string1);
            
            printUnsignedLine(indexOfSlashInString1);
        }
"
7416,0,CWE190_Integer_Overflow__int64_t_rand_add_53a.c,"    int64_t data;
    data = 0LL;
    
    data = (int64_t)RAND64();
"
18770,0,CWE252_Unchecked_Return_Value__char_fread_01.c,"    {
        /* By initializing dataBuffer, we ensure this will not be the
         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
        char dataBuffer[100] = """";
        char * data = dataBuffer;
        
        fread((char *)data, sizeof(char), (size_t)(100-1), stdin);
"
15861,0,CWE401_Memory_Leak__twoIntsStruct_realloc_09.c,"    twoIntsStruct * data;
    data = NULL;
    if(GLOBAL_CONST_TRUE)
    {
        
        data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));
        if (data == NULL) {exit(-1);}
        
        data[0].intOne = 0;
        data[0].intTwo = 0;
        printStructLine(&data[0]);
    }
    if(GLOBAL_CONST_TRUE)
    {
        
        ; 
"
14478,0,CWE134_Uncontrolled_Format_String__char_console_fprintf_08.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(staticReturnsTrue())
    {
        {
            
            size_t dataLen = strlen(data);
            
            if (100-dataLen > 1)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
                {
                    /* The next few lines remove the carriage return from the string that is
                     * inserted by fgets() */
                    dataLen = strlen(data);
                    if (dataLen > 0 && data[dataLen-1] == '\n')
                    {
                        data[dataLen-1] = '\0';
                    }
                }
                else
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
            }
        }
    }
    if(staticReturnsTrue())
    {
        
        fprintf(stdout, data);
"
16021,0,CWE190_Integer_Overflow__short_rand_preinc_06.c,"    short data;
    data = 0;
    if(STATIC_CONST_FIVE==5)
    {
        
        data = (short)RAND32();
    }
    if(STATIC_CONST_FIVE==5)
    {
        {
            
            ++data;
            short result = data;
            printIntLine(result);
        }
"
14376,0,CWE401_Memory_Leak__int_malloc_74a.cpp,"    int * data;
    map<int, int *> dataMap;
    data = NULL;
    
    data = (int *)malloc(100*sizeof(int));
    if (data == NULL) {exit(-1);}
    
    data[0] = 5;
    printIntLine(data[0]);
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
4540,0,CWE190_Integer_Overflow__char_max_postinc_08.c,"    char data;
    data = ' ';
    if(staticReturnsTrue())
    {
        
        data = CHAR_MAX;
    }
    if(staticReturnsTrue())
    {
        {
            
            data++;
            char result = data;
            printHexCharLine(result);
        }
"
14892,0,CWE690_NULL_Deref_From_Return__char_realloc_31.c,"    char * data;
    data = NULL; 
    
    data = (char *)realloc(data, 20*sizeof(char));
    {
        char * dataCopy = data;
        char * data = dataCopy;
        
        strcpy(data, ""Initialize"");
        printLine(data);
        free(data);
"
2226,0,CWE134_Uncontrolled_Format_String__char_console_vprintf_83a.cpp,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
"
4251,0,CWE590_Free_Memory_Not_on_Heap__delete_array_long_alloca_15.cpp,"    long * data;
    data = NULL; 
    switch(6)
    {
    case 6:
    {
        
        long * dataBuffer = (long *)ALLOCA(100*sizeof(long));
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5L;
            }
        }
        data = dataBuffer;
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    printLongLine(data[0]);
    
"
11020,0,CWE78_OS_Command_Injection__char_connect_socket_execlp_31.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
"
19465,0,CWE590_Free_Memory_Not_on_Heap__delete_class_declare_81_bad.cpp,"Label Definition File: CWE590_Free_Memory_Not_on_Heap__delete.nonpointer.label.xml
Template File: sources-sink-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 590 Free Memory Not on Heap
 * BadSource: declare Data buffer is declared on the stack
 * GoodSource: Allocate memory on the heap
 * Sinks:
 *    BadSink : Print then free data
 * Flow Variant: 81 Data flow: data passed in a parameter to a virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE590_Free_Memory_Not_on_Heap__delete_class_declare_81.h""

namespace CWE590_Free_Memory_Not_on_Heap__delete_class_declare_81
{

void CWE590_Free_Memory_Not_on_Heap__delete_class_declare_81_bad::action(TwoIntsClass * data) const
{
    printIntLine(data->intOne);
    
    delete data;
}

}
"
6005,0,CWE190_Integer_Overflow__int_max_multiply_74a.cpp,"    int data;
    map<int, int> dataMap;
    
    data = 0;
    
    data = INT_MAX;
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
16184,0,CWE190_Integer_Overflow__int64_t_max_square_62a.cpp,"    int64_t data;
    data = 0LL;
    badSource(data);
    {
        
        int64_t result = data * data;
        printLongLongLine(result);
"
8151,0,CWE416_Use_After_Free__new_delete_long_16.cpp,"    long * data;
    
    data = NULL;
    while(1)
    {
        data = new long;
        *data = 5L;
        
        delete data;
        break;
    }
    while(1)
    {
        
        printLongLine(*data);
        
        break;
"
9794,0,CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_13.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(GLOBAL_CONST_FIVE==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                data[dataLen + recvResult / sizeof(char)] = '\0';
                
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        badVaSinkB(data, data);
"
9626,0,CWE415_Double_Free__new_delete_array_int64_t_83a.cpp,"    int64_t * data;
    
    data = NULL;
"
4231,0,CWE401_Memory_Leak__char_malloc_33.cpp,"    char * data;
    char * &dataRef = data;
    data = NULL;
    
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    
    strcpy(data, ""A String"");
    printLine(data);
    {
        char * data = dataRef;
        
        ; 
"
6605,0,CWE563_Unused_Variable__unused_init_variable_struct_74a.cpp,"    twoIntsStruct data;
    map<int, twoIntsStruct> dataMap;
    
    data.intOne = 0;
    data.intTwo = 0;
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
11787,0,CWE401_Memory_Leak__twoIntsStruct_malloc_18.c,"    twoIntsStruct * data;
    data = NULL;
    goto source;
source:
    
    data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
    if (data == NULL) {exit(-1);}
    
    data[0].intOne = 0;
    data[0].intTwo = 0;
    printStructLine(&data[0]);
    goto sink;
sink:
    
"
388,0,CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_22a.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_22_badGlobal = 1; 
"
2594,0,CWE401_Memory_Leak__char_realloc_84a.cpp,"    char * data;
    data = NULL;
    CWE401_Memory_Leak__char_realloc_84_bad * badObject = new CWE401_Memory_Leak__char_realloc_84_bad(data);
"
16912,0,CWE563_Unused_Variable__unused_value_int_72a.cpp,"    int data;
    vector<int> dataVector;
    
    data = 5;
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
5878,0,CWE190_Integer_Overflow__int64_t_rand_postinc_14.c,"    int64_t data;
    data = 0LL;
    if(globalFive==5)
    {
        
        data = (int64_t)RAND64();
    }
    if(globalFive==5)
    {
        {
            
            data++;
            int64_t result = data;
            printLongLongLine(result);
        }
"
18629,1,CWE758_Undefined_Behavior__struct_alloca_use_05.c,"    if(staticTrue)
    {
        {
            twoIntsStruct data;
            twoIntsStruct * pointer = (twoIntsStruct *)ALLOCA(sizeof(twoIntsStruct));
            data.intOne = 1;
            data.intTwo = 2;
            *pointer = data; 
            {
                twoIntsStruct data = *pointer;
                printIntLine(data.intOne);
                printIntLine(data.intTwo);
            }
        }
"
3668,0,CWE590_Free_Memory_Not_on_Heap__delete_class_declare_15.cpp,"    TwoIntsClass * data;
    data = NULL; 
    switch(6)
    {
    case 6:
    {
        
        TwoIntsClass dataBuffer;
        dataBuffer.intOne = 1;
        dataBuffer.intTwo = 1;
        data = &dataBuffer;
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    printIntLine(data->intOne);
    
"
13251,1,CWE467_Use_of_sizeof_on_Pointer_Type__int_02.c,"    if(1)
    {
        {
            int * goodInt = NULL;
            
            goodInt = (int *)malloc(sizeof(*goodInt));
            if (goodInt == NULL) {exit(-1);}
            *goodInt = 6;
            printIntLine(*goodInt);
            free(goodInt);
        }
"
14677,0,CWE690_NULL_Deref_From_Return__fopen_07.c,"    FILE * data;
    
    data = NULL;
    
    data = fopen(""file.txt"", ""w+"");
    if(staticFive==5)
    {
        
        fclose(data);
"
5266,0,CWE415_Double_Free__new_delete_array_long_82_bad.cpp,"Label Definition File: CWE415_Double_Free__new_delete_array.label.xml
Template File: sources-sinks-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 415 Double Free
 * BadSource:  Allocate data using new and Deallocae data using delete
 * GoodSource: Allocate data using new
 * Sinks:
 *    GoodSink: do nothing
 *    BadSink : Deallocate data using delete
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE415_Double_Free__new_delete_array_long_82.h""

namespace CWE415_Double_Free__new_delete_array_long_82
{

void CWE415_Double_Free__new_delete_array_long_82_bad::action(long * data)
{
    
    delete [] data;
}

}
"
17925,0,CWE190_Integer_Overflow__char_fscanf_square_73a.cpp,"    char data;
    list<char> dataList;
    data = ' ';
    
    fscanf (stdin, ""%c"", &data);
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
9685,0,CWE476_NULL_Pointer_Dereference__long_41.c,"    long * data;
    
    data = NULL;
"
7805,0,CWE476_NULL_Pointer_Dereference__int_52a.c,"    int * data;
    
    data = NULL;
"
15404,0,CWE190_Integer_Overflow__int64_t_fscanf_square_54a.c,"    int64_t data;
    data = 0LL;
    
    fscanf (stdin, ""%"" SCNd64, &data);
"
5301,0,CWE78_OS_Command_Injection__char_listen_socket_execlp_01.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    /* execlp - searches for the location of the command among
     * the directories specified by the PATH environment variable */
    
"
12712,0,CWE252_Unchecked_Return_Value__char_fgets_04.c,"    if(STATIC_CONST_TRUE)
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            printLine(""Please enter a string: "");
            
            fgets(data, 100, stdin);
            printLine(data);
        }
"
13873,0,CWE197_Numeric_Truncation_Error__short_connect_socket_64a.c,"    short data;
    
    data = -1;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = (short)atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
4500,1,CWE415_Double_Free__no_copy_const_01_good1.cpp,"    GoodClass goodClassObject(""One"");

    
    GoodClass goodClassObjectCopy(goodClassObject);

"
2142,0,CWE590_Free_Memory_Not_on_Heap__delete_int_static_02.cpp,"    int * data;
    data = NULL; 
    if(1)
    {
        {
            
            static int dataBuffer;
            dataBuffer = 5;
            data = &dataBuffer;
        }
    }
    printIntLine(*data);
    
"
16235,1,CWE758_Undefined_Behavior__int64_t_malloc_use_03.c,"    if(5==5)
    {
        {
            int64_t data;
            int64_t * pointer = (int64_t *)malloc(sizeof(int64_t));
            if (pointer == NULL) {exit(-1);}
            data = 5LL;
            *pointer = data; 
            {
                int64_t data = *pointer;
                printLongLongLine(data);
            }
            free(pointer);
        }
"
2195,0,CWE134_Uncontrolled_Format_String__char_console_vfprintf_54a.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        
        if (100-dataLen > 1)
        {
            
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgets() */
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
                    data[dataLen-1] = '\0';
                }
            }
            else
            {
                printLine(""fgets() failed"");
                
                data[dataLen] = '\0';
            }
        }
    }
"
80,1,CWE758_Undefined_Behavior__int64_t_alloca_use_15.c,"    switch(5)
    {
    case 6:
        
        printLine(""Benign, fixed string"");
        break;
    default:
    {
        int64_t data;
        int64_t * pointer = (int64_t *)ALLOCA(sizeof(int64_t));
        data = 5LL;
        *pointer = data; 
        {
            int64_t data = *pointer;
            printLongLongLine(data);
        }
    }
    break;
"
16508,0,CWE190_Integer_Overflow__int64_t_rand_preinc_10.c,"    int64_t data;
    data = 0LL;
    if(globalTrue)
    {
        
        data = (int64_t)RAND64();
    }
    if(globalTrue)
    {
        {
            
            ++data;
            int64_t result = data;
            printLongLongLine(result);
        }
"
6245,0,CWE190_Integer_Overflow__short_max_postinc_31.c,"    short data;
    data = 0;
    
    data = SHRT_MAX;
    {
        short dataCopy = data;
        short data = dataCopy;
        {
            
            data++;
            short result = data;
            printIntLine(result);
        }
"
10396,1,CWE252_Unchecked_Return_Value__char_puts_04.c,"    if(STATIC_CONST_TRUE)
    {
        
        if (PUTS(""string"") == EOF)
        {
            printLine(""puts failed!"");
        }
"
14648,0,CWE190_Integer_Overflow__int_connect_socket_square_54a.c,"    int data;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
7494,0,CWE78_OS_Command_Injection__char_connect_socket_execl_67a.c,"    char * data;
    CWE78_OS_Command_Injection__char_connect_socket_execl_67_structType myStruct;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    myStruct.structFirst = data;
"
2697,0,CWE457_Use_of_Uninitialized_Variable__int_array_declare_partial_init_17.c,"    int i,j;
    int * data;
    int dataUninitArray[10];
    data = dataUninitArray;
    for(i = 0; i < 1; i++)
    {
        
        {
            int i;
            for(i=0; i<(10/2); i++)
            {
                data[i] = i;
            }
        }
    }
    for(j = 0; j < 1; j++)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i]);
            }
        }
"
39,0,CWE690_NULL_Deref_From_Return__long_calloc_06.c,"    long * data;
    data = NULL; 
    
    data = (long *)calloc(1, sizeof(long));
    if(STATIC_CONST_FIVE==5)
    {
        
        data[0] = 5L;
        printLongLine(data[0]);
        free(data);
"
13470,0,CWE590_Free_Memory_Not_on_Heap__free_int64_t_declare_34.c,"    int64_t * data;
    CWE590_Free_Memory_Not_on_Heap__free_int64_t_declare_34_unionType myUnion;
    data = NULL; 
    {
        
        int64_t dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5LL;
            }
        }
        data = dataBuffer;
    }
    myUnion.unionFirst = data;
    {
        int64_t * data = myUnion.unionSecond;
        printLongLongLine(data[0]);
        
        free(data);
"
11310,0,CWE690_NULL_Deref_From_Return__int64_t_realloc_72a.cpp,"    int64_t * data;
    vector<int64_t *> dataVector;
    data = NULL; 
    
    data = (int64_t *)realloc(data, 1*sizeof(int64_t));
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
8818,0,CWE563_Unused_Variable__unused_init_variable_long_83_bad.cpp,"Label Definition File: CWE563_Unused_Variable__unused_init_variable.label.xml
Template File: source-sinks-83_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 563 Unused Variable
 * BadSource:  Initialize data
 * Sinks:
 *    GoodSink: Use data
 *    BadSink : do nothing
 * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE563_Unused_Variable__unused_init_variable_long_83.h""

namespace CWE563_Unused_Variable__unused_init_variable_long_83
{
CWE563_Unused_Variable__unused_init_variable_long_83_bad::CWE563_Unused_Variable__unused_init_variable_long_83_bad(long dataCopy)
{
    data = dataCopy;
    
    data = 5L;
}

CWE563_Unused_Variable__unused_init_variable_long_83_bad::~CWE563_Unused_Variable__unused_init_variable_long_83_bad()
{
    
    
    ; 
}
}
"
18698,0,CWE590_Free_Memory_Not_on_Heap__free_char_static_44.c,"    char * data;
    
    void (*funcPtr) (char *) = badSink;
    data = NULL; 
    {
        
        static char dataBuffer[100];
        memset(dataBuffer, 'A', 100-1); 
        dataBuffer[100-1] = '\0'; 
        data = dataBuffer;
    }
    
"
8776,0,CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_54a.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
855,1,CWE758_Undefined_Behavior__int_alloca_use_07.c,"    if(staticFive==5)
    {
        {
            int data;
            int * pointer = (int *)ALLOCA(sizeof(int));
            data = 5;
            *pointer = data; 
            {
                int data = *pointer;
                printIntLine(data);
            }
        }
"
8575,0,CWE197_Numeric_Truncation_Error__int_connect_socket_to_short_52a.c,"    int data;
    
    data = -1;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
17832,0,CWE758_Undefined_Behavior__class_new_use_03.cpp,"    if(5==5)
    {
        {
            TwoIntsClass * pointer = new TwoIntsClass;
            TwoIntsClass data = *pointer; 
            delete pointer;
            printIntLine(data.intOne);
            printIntLine(data.intTwo);
        }
"
14431,0,CWE401_Memory_Leak__new_int_66a.cpp,"    int * data;
    int * dataArray[5];
    data = NULL;
    
    data = new int;
    
    *data = 5;
    printIntLine(*data);
    
    dataArray[2] = data;
"
2784,0,CWE415_Double_Free__new_delete_long_51a.cpp,"    long * data;
    
    data = NULL;
    data = new long;
    
    delete data;
"
17672,1,CWE467_Use_of_sizeof_on_Pointer_Type__char_13.c,"    if(GLOBAL_CONST_FIVE!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            char * goodChar = NULL;
            
            goodChar = (char *)malloc(sizeof(*goodChar));
            if (goodChar == NULL) {exit(-1);}
            *goodChar = 'G';
            printHexCharLine(*goodChar);
            free(goodChar);
        }
"
4469,0,CWE190_Integer_Overflow__char_fscanf_add_13.c,"    char data;
    data = ' ';
    if(GLOBAL_CONST_FIVE==5)
    {
        
        fscanf (stdin, ""%c"", &data);
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            
            char result = data + 1;
            printHexCharLine(result);
        }
"
12095,0,CWE78_OS_Command_Injection__char_console_execl_22a.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    CWE78_OS_Command_Injection__char_console_execl_22_badGlobal = 1; 
    data = CWE78_OS_Command_Injection__char_console_execl_22_badSource(data);
    
    
    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}

#endif 

#ifndef OMITGOOD


int CWE78_OS_Command_Injection__char_console_execl_22_goodG2B1Global = 0;
int CWE78_OS_Command_Injection__char_console_execl_22_goodG2B2Global = 0;
"
3319,0,CWE590_Free_Memory_Not_on_Heap__free_struct_declare_04.c,"    twoIntsStruct * data;
    data = NULL; 
    if(STATIC_CONST_TRUE)
    {
        {
            
            twoIntsStruct dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i].intOne = 1;
                    dataBuffer[i].intTwo = 1;
                }
            }
            data = dataBuffer;
        }
    }
    printStructLine(&data[0]);
    
"
14365,0,CWE78_OS_Command_Injection__char_environment_popen_11.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(globalReturnsTrue())
    {
        {
            
            size_t dataLen = strlen(data);
            char * environment = GETENV(ENV_VARIABLE);
            
            if (environment != NULL)
            {
                
                strncat(data+dataLen, environment, 100-dataLen-1);
            }
        }
    }
    {
        FILE *pipe;
        
        pipe = POPEN(data, ""w"");
        if (pipe != NULL)
        {
            PCLOSE(pipe);
        }
"
14004,0,CWE758_Undefined_Behavior__int64_t_new_use_06.cpp,"    if(STATIC_CONST_FIVE==5)
    {
        {
            int64_t * pointer = new int64_t;
            int64_t data = *pointer; 
            delete pointer;
            printLongLongLine(data);
        }
"
18062,0,CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_33.cpp,"    unsigned int data;
    unsigned int &dataRef = data;
    data = 0;
    
    fscanf (stdin, ""%u"", &data);
    {
        unsigned int data = dataRef;
        if(data > 0) 
        {
            
            unsigned int result = data * 2;
            printUnsignedLine(result);
        }
"
13320,0,CWE190_Integer_Overflow__int64_t_fscanf_add_03.c,"    int64_t data;
    data = 0LL;
    if(5==5)
    {
        
        fscanf (stdin, ""%"" SCNd64, &data);
    }
    if(5==5)
    {
        {
            
            int64_t result = data + 1;
            printLongLongLine(result);
        }
"
13677,0,CWE590_Free_Memory_Not_on_Heap__delete_long_placement_new_67a.cpp,"    long * data;
    structType myStruct;
    data = NULL; 
    {
        
        char buffer[sizeof(long)];
        long * dataBuffer = new(buffer) long;
        *dataBuffer = 5L;
        data = dataBuffer;
    }
    myStruct.structFirst = data;
"
14344,0,CWE415_Double_Free__malloc_free_long_15.c,"    long * data;
    
    data = NULL;
    switch(6)
    {
    case 6:
        data = (long *)malloc(100*sizeof(long));
        if (data == NULL) {exit(-1);}
        
        free(data);
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
        
        free(data);
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
1961,0,CWE369_Divide_by_Zero__int_connect_socket_divide_81a.cpp,"    int data;
    
    data = -1;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    const CWE369_Divide_by_Zero__int_connect_socket_divide_81_base& baseObject = CWE369_Divide_by_Zero__int_connect_socket_divide_81_bad();
"
7368,0,CWE590_Free_Memory_Not_on_Heap__delete_char_placement_new_17.cpp,"    int i;
    char * data;
    data = NULL; 
    for(i = 0; i < 1; i++)
    {
        {
            
            char buffer[sizeof(char)];
            char * dataBuffer = new(buffer) char;
            *dataBuffer = 'A';
            data = dataBuffer;
        }
    }
    printHexCharLine(*data);
    
"
9044,0,CWE190_Integer_Overflow__short_rand_add_62a.cpp,"    short data;
    data = 0;
    badSource(data);
    {
        
        short result = data + 1;
        printIntLine(result);
"
6457,0,CWE78_OS_Command_Injection__char_console_system_61a.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    data = CWE78_OS_Command_Injection__char_console_system_61b_badSource(data);
    
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
    }
}

#endif 

#ifndef OMITGOOD


"
12648,0,CWE590_Free_Memory_Not_on_Heap__free_long_static_67a.c,"    long * data;
    CWE590_Free_Memory_Not_on_Heap__free_long_static_67_structType myStruct;
    data = NULL; 
    {
        
        static long dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5L;
            }
        }
        data = dataBuffer;
    }
    myStruct.structFirst = data;
"
2495,0,CWE78_OS_Command_Injection__char_environment_execlp_72a.cpp,"    char * data;
    vector<char *> dataVector;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        
        if (environment != NULL)
        {
            
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
18638,0,CWE190_Integer_Overflow__int64_t_fscanf_add_06.c,"    int64_t data;
    data = 0LL;
    if(STATIC_CONST_FIVE==5)
    {
        
        fscanf (stdin, ""%"" SCNd64, &data);
    }
    if(STATIC_CONST_FIVE==5)
    {
        {
            
            int64_t result = data + 1;
            printLongLongLine(result);
        }
"
2184,0,CWE563_Unused_Variable__unused_value_int_16.c,"    int data;
    while(1)
    {
        
        data = 5;
        break;
    }
    while(1)
    {
        
        data = 10;
        printIntLine(data);
        break;
"
12870,0,CWE690_NULL_Deref_From_Return__int_malloc_84_bad.cpp,"Label Definition File: CWE690_NULL_Deref_From_Return.free.label.xml
Template File: source-sinks-84_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 690 Unchecked Return Value To NULL Pointer
 * BadSource: malloc Allocate data using malloc()
 * Sinks:
 *    GoodSink: Check to see if the data allocation failed and if not, use data
 *    BadSink : Don't check for NULL and use data
 * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE690_NULL_Deref_From_Return__int_malloc_84.h""

namespace CWE690_NULL_Deref_From_Return__int_malloc_84
{
CWE690_NULL_Deref_From_Return__int_malloc_84_bad::CWE690_NULL_Deref_From_Return__int_malloc_84_bad(int * dataCopy)
{
    data = dataCopy;
    
    data = (int *)malloc(1*sizeof(int));
}

CWE690_NULL_Deref_From_Return__int_malloc_84_bad::~CWE690_NULL_Deref_From_Return__int_malloc_84_bad()
{
    
    data[0] = 5;
    printIntLine(data[0]);
    free(data);
}
}
"
9915,0,CWE416_Use_After_Free__malloc_free_long_15.c,"    long * data;
    
    data = NULL;
    switch(6)
    {
    case 6:
        data = (long *)malloc(100*sizeof(long));
        if (data == NULL) {exit(-1);}
        {
            size_t i;
            for(i = 0; i < 100; i++)
            {
                data[i] = 5L;
            }
        }
        
        free(data);
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
        
        printLongLine(data[0]);
        
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
7702,0,CWE590_Free_Memory_Not_on_Heap__free_int64_t_alloca_73a.cpp,"    int64_t * data;
    list<int64_t *> dataList;
    data = NULL; 
    {
        
        int64_t * dataBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5LL;
            }
        }
        data = dataBuffer;
    }
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
14624,0,CWE401_Memory_Leak__char_malloc_41.c,"    char * data;
    data = NULL;
    
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    
    strcpy(data, ""A String"");
    printLine(data);
"
8835,0,CWE690_NULL_Deref_From_Return__int_malloc_54a.c,"    int * data;
    data = NULL; 
    
    data = (int *)malloc(1*sizeof(int));
"
10869,1,CWE401_Memory_Leak__malloc_realloc_char_06.c,"    if(STATIC_CONST_FIVE!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            char * data = (char *)malloc(100*sizeof(char));
            if (data == NULL) {exit(-1);}
            char * tmpData;
            
            strcpy(data, ""A String"");
            printLine(data);
            tmpData = (char *)realloc(data, (130000)*sizeof(char));
            /* FIX: Ensure realloc() was successful before assigning data to the memory block
            * allocated with realloc() */
            if (tmpData != NULL)
            {
                data = tmpData;
                
                strcpy(data, ""New String"");
                printLine(data);
            }
            free(data);
        }
"
13222,0,CWE78_OS_Command_Injection__char_connect_socket_system_32.c,"    char * data;
    char * *dataPtr1 = &data;
    char * *dataPtr2 = &data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
        char * data = *dataPtr1;
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET connectSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
"
15964,1,CWE252_Unchecked_Return_Value__char_putc_13.c,"    if(GLOBAL_CONST_FIVE!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        
        if (putc((int)'A', stdout) == EOF)
        {
            printLine(""putc failed!"");
        }
"
8679,0,CWE758_Undefined_Behavior__long_alloca_use_03.c,"    if(5==5)
    {
        {
            long * pointer = (long *)ALLOCA(sizeof(long));
            long data = *pointer; 
            printLongLine(data);
        }
"
8829,1,CWE252_Unchecked_Return_Value__char_fputc_15.c,"    switch(5)
    {
    case 6:
        
        printLine(""Benign, fixed string"");
        break;
    default:
        
        if (fputc((int)'A', stdout) == EOF)
        {
            printLine(""fputc failed!"");
        }
        break;
"
8266,0,CWE457_Use_of_Uninitialized_Variable__int_array_malloc_partial_init_18.c,"    int * data;
    data = (int *)malloc(10*sizeof(int));
    if (data == NULL) {exit(-1);}
    goto source;
source:
    
    {
        int i;
        for(i=0; i<(10/2); i++)
        {
            data[i] = i;
        }
    }
    goto sink;
sink:
    
    {
        int i;
        for(i=0; i<10; i++)
        {
            printIntLine(data[i]);
        }
"
10995,0,CWE369_Divide_by_Zero__int_fscanf_divide_84a.cpp,"    int data;
    
    data = -1;
    CWE369_Divide_by_Zero__int_fscanf_divide_84_bad * badObject = new CWE369_Divide_by_Zero__int_fscanf_divide_84_bad(data);
"
11467,0,CWE690_NULL_Deref_From_Return__long_malloc_16.c,"    long * data;
    data = NULL; 
    
    data = (long *)malloc(1*sizeof(long));
    while(1)
    {
        
        data[0] = 5L;
        printLongLine(data[0]);
        free(data);
        break;
"
18828,0,CWE78_OS_Command_Injection__char_file_execl_53a.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        FILE * pFile;
        
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
"
7011,0,CWE690_NULL_Deref_From_Return__int64_t_calloc_08.c,"    int64_t * data;
    data = NULL; 
    
    data = (int64_t *)calloc(1, sizeof(int64_t));
    if(staticReturnsTrue())
    {
        
        data[0] = 5LL;
        printLongLongLine(data[0]);
        free(data);
"
13299,0,CWE190_Integer_Overflow__int_max_preinc_63a.c,"    int data;
    
    data = 0;
    
    data = INT_MAX;
"
12028,0,CWE134_Uncontrolled_Format_String__char_console_vprintf_82_bad.cpp,"Label Definition File: CWE134_Uncontrolled_Format_String.vasinks.label.xml
Template File: sources-vasinks-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 134 Uncontrolled Format String
 * BadSource: console Read input from the console
 * GoodSource: Copy a fixed string into data
 * Sinks: vprintf
 *    GoodSink: vprintf with a format string
 *    BadSink : vprintf without a format string
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include <stdarg.h>
#include ""std_testcase.h""
#include ""CWE134_Uncontrolled_Format_String__char_console_vprintf_82.h""

namespace CWE134_Uncontrolled_Format_String__char_console_vprintf_82
{

static void badVaSink(char * data, ...)
{
    {
        va_list args;
        va_start(args, data);
        
        vprintf(data, args);
        va_end(args);
    }
}

void CWE134_Uncontrolled_Format_String__char_console_vprintf_82_bad::action(char * data)
{
    badVaSink(data, data);
}

}
"
5657,0,CWE197_Numeric_Truncation_Error__int_listen_socket_to_char_81_bad.cpp,"Label Definition File: CWE197_Numeric_Truncation_Error__int.label.xml
Template File: sources-sink-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 197 Numeric Truncation Error
 * BadSource: listen_socket Read data using a listen socket (server side)
 * GoodSource: Less than CHAR_MAX
 * Sinks: to_char
 *    BadSink : Convert data to a char
 * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE197_Numeric_Truncation_Error__int_listen_socket_to_char_81.h""

namespace CWE197_Numeric_Truncation_Error__int_listen_socket_to_char_81
{

void CWE197_Numeric_Truncation_Error__int_listen_socket_to_char_81_bad::action(int data) const
{
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
    }
}

}
"
16409,0,CWE78_OS_Command_Injection__char_file_execl_82_bad.cpp,"Label Definition File: CWE78_OS_Command_Injection.strings.label.xml
Template File: sources-sink-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 78 OS Command Injection
 * BadSource: file Read input from a file
 * GoodSource: Fixed string
 * Sinks: execl
 *    BadSink : execute command with execl
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE78_OS_Command_Injection__char_file_execl_82.h""

#ifdef _WIN32
#include <process.h>
#define EXECL _execl
#else 
#define EXECL execl
#endif

namespace CWE78_OS_Command_Injection__char_file_execl_82
{

void CWE78_OS_Command_Injection__char_file_execl_82_bad::action(char * data)
{
    
    
    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}

}
"
10900,0,CWE758_Undefined_Behavior__struct_malloc_use_05.c,"    if(staticTrue)
    {
        {
            twoIntsStruct * pointer = (twoIntsStruct *)malloc(sizeof(twoIntsStruct));
            if (pointer == NULL) {exit(-1);}
            twoIntsStruct data = *pointer; 
            free(pointer);
            printIntLine(data.intOne);
            printIntLine(data.intTwo);
        }
"
6269,0,CWE190_Integer_Overflow__int_connect_socket_multiply_06.c,"    int data;
    
    data = 0;
    if(STATIC_CONST_FIVE==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(STATIC_CONST_FIVE==5)
    {
        if(data > 0) 
        {
            
            int result = data * 2;
            printIntLine(result);
        }
"
5441,0,CWE369_Divide_by_Zero__int_listen_socket_modulo_17.c,"    int i,j;
    int data;
    
    data = -1;
    for(i = 0; i < 1; i++)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    for(j = 0; j < 1; j++)
    {
        
        printIntLine(100 % data);
"
3925,0,CWE134_Uncontrolled_Format_String__char_console_printf_06.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(STATIC_CONST_FIVE==5)
    {
        {
            
            size_t dataLen = strlen(data);
            
            if (100-dataLen > 1)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
                {
                    /* The next few lines remove the carriage return from the string that is
                     * inserted by fgets() */
                    dataLen = strlen(data);
                    if (dataLen > 0 && data[dataLen-1] == '\n')
                    {
                        data[dataLen-1] = '\0';
                    }
                }
                else
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
            }
        }
    }
    if(STATIC_CONST_FIVE==5)
    {
        
        printf(data);
"
3450,0,CWE590_Free_Memory_Not_on_Heap__delete_int_static_10.cpp,"    int * data;
    data = NULL; 
    if(globalTrue)
    {
        {
            
            static int dataBuffer;
            dataBuffer = 5;
            data = &dataBuffer;
        }
    }
    printIntLine(*data);
    
"
15450,0,CWE590_Free_Memory_Not_on_Heap__delete_array_char_alloca_65a.cpp,"    char * data;
    
    void (*funcPtr) (char *) = badSink;
    data = NULL; 
    {
        
        char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
        memset(dataBuffer, 'A', 100-1); 
        dataBuffer[100-1] = '\0'; 
        data = dataBuffer;
    }
    
"
19241,0,CWE78_OS_Command_Injection__char_console_system_33.cpp,"    char * data;
    char * &dataRef = data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
        
        size_t dataLen = strlen(data);
        
        if (100-dataLen > 1)
        {
            
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgets() */
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
"
18143,0,CWE190_Integer_Overflow__int64_t_fscanf_square_05.c,"    int64_t data;
    data = 0LL;
    if(staticTrue)
    {
        
        fscanf (stdin, ""%"" SCNd64, &data);
    }
    if(staticTrue)
    {
        {
            
            int64_t result = data * data;
            printLongLongLine(result);
        }
"
9738,0,CWE197_Numeric_Truncation_Error__int_fscanf_to_char_52a.c,"    int data;
    
    data = -1;
    
    fscanf(stdin, ""%d"", &data);
"
8921,0,CWE457_Use_of_Uninitialized_Variable__double_62a.cpp,"    double data;
    badSource(data);
    
"
16362,0,CWE401_Memory_Leak__new_TwoIntsClass_51a.cpp,"    TwoIntsClass * data;
    data = NULL;
    
    data = new TwoIntsClass;
    
    data->intOne = 0;
    data->intTwo = 0;
    printIntLine(data->intOne);
    printIntLine(data->intTwo);
"
7753,0,CWE415_Double_Free__new_delete_array_int_44.cpp,"    int * data;
    
    void (*funcPtr) (int *) = badSink;
    
    data = NULL;
    data = new int[100];
    
    delete [] data;
    
"
9620,0,CWE190_Integer_Overflow__int_fscanf_postinc_02.c,"    int data;
    
    data = 0;
    if(1)
    {
        
        fscanf(stdin, ""%d"", &data);
    }
    if(1)
    {
        {
            
            data++;
            int result = data;
            printIntLine(result);
        }
"
718,0,CWE190_Integer_Overflow__char_fscanf_square_11.c,"    char data;
    data = ' ';
    if(globalReturnsTrue())
    {
        
        fscanf (stdin, ""%c"", &data);
    }
    if(globalReturnsTrue())
    {
        {
            
            char result = data * data;
            printHexCharLine(result);
        }
"
14281,0,CWE78_OS_Command_Injection__char_file_execl_32.c,"    char * data;
    char * *dataPtr1 = &data;
    char * *dataPtr2 = &data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        char * data = *dataPtr1;
        {
            
            size_t dataLen = strlen(data);
            FILE * pFile;
            
            if (100-dataLen > 1)
            {
                pFile = fopen(FILENAME, ""r"");
                if (pFile != NULL)
                {
                    
                    if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                    {
                        printLine(""fgets() failed"");
                        
                        data[dataLen] = '\0';
                    }
                    fclose(pFile);
                }
            }
        }
        *dataPtr1 = data;
    }
    {
        char * data = *dataPtr2;
        
        
        EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
"
135,0,CWE590_Free_Memory_Not_on_Heap__free_struct_alloca_16.c,"    twoIntsStruct * data;
    data = NULL; 
    while(1)
    {
        {
            
            twoIntsStruct * dataBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i].intOne = 1;
                    dataBuffer[i].intTwo = 1;
                }
            }
            data = dataBuffer;
        }
        break;
    }
    printStructLine(&data[0]);
    
"
1138,0,CWE369_Divide_by_Zero__int_fscanf_divide_64a.c,"    int data;
    
    data = -1;
    
    fscanf(stdin, ""%d"", &data);
"
11923,1,CWE401_Memory_Leak__malloc_realloc_int64_t_15.c,"    switch(5)
    {
    case 6:
        
        printLine(""Benign, fixed string"");
        break;
    default:
    {
        int64_t * data = (int64_t *)malloc(100*sizeof(int64_t));
        if (data == NULL) {exit(-1);}
        int64_t * tmpData;
        
        data[0] = 5LL;
        printLongLongLine(data[0]);
        tmpData = (int64_t *)realloc(data, (130000)*sizeof(int64_t));
        /* FIX: Ensure realloc() was successful before assigning data to the memory block
        * allocated with realloc() */
        if (tmpData != NULL)
        {
            data = tmpData;
            
            data[0] = 10LL;
            printLongLongLine(data[0]);
        }
        free(data);
    }
    break;
"
3774,0,CWE758_Undefined_Behavior__double_pointer_alloca_use_13.c,"    if(GLOBAL_CONST_FIVE==5)
    {
        {
            double * * pointer = (double * *)ALLOCA(sizeof(double *));
            double * data = *pointer; 
            printDoubleLine(*data);
        }
"
16343,0,CWE190_Integer_Overflow__char_max_add_18.c,"    char data;
    data = ' ';
    goto source;
source:
    
    data = CHAR_MAX;
    goto sink;
sink:
    {
        
        char result = data + 1;
        printHexCharLine(result);
"
11797,1,CWE401_Memory_Leak__malloc_realloc_char_09.c,"    if(GLOBAL_CONST_TRUE)
    {
        {
            char * data = (char *)malloc(100*sizeof(char));
            if (data == NULL) {exit(-1);}
            char * tmpData;
            
            strcpy(data, ""A String"");
            printLine(data);
            tmpData = (char *)realloc(data, (130000)*sizeof(char));
            /* FIX: Ensure realloc() was successful before assigning data to the memory block
            * allocated with realloc() */
            if (tmpData != NULL)
            {
                data = tmpData;
                
                strcpy(data, ""New String"");
                printLine(data);
            }
            free(data);
        }
"
13126,0,CWE190_Integer_Overflow__unsigned_int_rand_add_74a.cpp,"    unsigned int data;
    map<int, unsigned int> dataMap;
    data = 0;
    
    data = (unsigned int)RAND32();
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
4790,0,CWE197_Numeric_Truncation_Error__int_large_to_char_81a.cpp,"    int data;
    
    data = -1;
    
    data = SHRT_MAX + 5;
    const CWE197_Numeric_Truncation_Error__int_large_to_char_81_base& baseObject = CWE197_Numeric_Truncation_Error__int_large_to_char_81_bad();
"
14480,0,CWE665_Improper_Initialization__char_cat_42.c,"    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    data = badSource(data);
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        
        strcat(data, source);
        printLine(data);
"
13906,0,CWE190_Integer_Overflow__int_rand_square_62a.cpp,"    int data;
    
    data = 0;
    badSource(data);
    {
        
        int result = data * data;
        printIntLine(result);
"
17937,0,CWE369_Divide_by_Zero__int_connect_socket_divide_64a.c,"    int data;
    
    data = -1;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
14030,0,CWE401_Memory_Leak__new_array_TwoIntsClass_18.cpp,"    TwoIntsClass * data;
    data = NULL;
    goto source;
source:
    
    data = new TwoIntsClass[100];
    
    data[0].intOne = 0;
    data[0].intTwo = 0;
    printIntLine(data[0].intOne);
    printIntLine(data[0].intTwo);
    goto sink;
sink:
    
"
7150,0,CWE134_Uncontrolled_Format_String__char_environment_printf_02.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(1)
    {
        {
            
            size_t dataLen = strlen(data);
            char * environment = GETENV(ENV_VARIABLE);
            
            if (environment != NULL)
            {
                
                strncat(data+dataLen, environment, 100-dataLen-1);
            }
        }
    }
    if(1)
    {
        
        printf(data);
"
15357,0,CWE134_Uncontrolled_Format_String__char_file_vprintf_14.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(globalFive==5)
    {
        {
            
            size_t dataLen = strlen(data);
            FILE * pFile;
            
            if (100-dataLen > 1)
            {
                pFile = fopen(FILENAME, ""r"");
                if (pFile != NULL)
                {
                    
                    if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                    {
                        printLine(""fgets() failed"");
                        
                        data[dataLen] = '\0';
                    }
                    fclose(pFile);
                }
            }
        }
    }
    if(globalFive==5)
    {
        badVaSinkB(data, data);
"
7564,0,CWE690_NULL_Deref_From_Return__int64_t_malloc_81a.cpp,"    int64_t * data;
    data = NULL; 
    
    data = (int64_t *)malloc(1*sizeof(int64_t));
    const CWE690_NULL_Deref_From_Return__int64_t_malloc_81_base& baseObject = CWE690_NULL_Deref_From_Return__int64_t_malloc_81_bad();
"
14183,0,CWE134_Uncontrolled_Format_String__char_file_vprintf_43.cpp,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    badSource(data);
"
3375,0,CWE134_Uncontrolled_Format_String__char_console_vfprintf_08.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(staticReturnsTrue())
    {
        {
            
            size_t dataLen = strlen(data);
            
            if (100-dataLen > 1)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
                {
                    /* The next few lines remove the carriage return from the string that is
                     * inserted by fgets() */
                    dataLen = strlen(data);
                    if (dataLen > 0 && data[dataLen-1] == '\n')
                    {
                        data[dataLen-1] = '\0';
                    }
                }
                else
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
            }
        }
    }
    if(staticReturnsTrue())
    {
        badVaSinkB(data, data);
"
54,0,CWE190_Integer_Overflow__short_rand_add_22a.c,"    short data;
    data = 0;
    
    data = (short)RAND32();
    CWE190_Integer_Overflow__short_rand_add_22_badGlobal = 1; 
"
2370,0,CWE190_Integer_Overflow__int_fscanf_multiply_84a.cpp,"    int data;
    
    data = 0;
    CWE190_Integer_Overflow__int_fscanf_multiply_84_bad * badObject = new CWE190_Integer_Overflow__int_fscanf_multiply_84_bad(data);
"
10847,0,CWE190_Integer_Overflow__unsigned_int_fscanf_square_51a.c,"    unsigned int data;
    data = 0;
    
    fscanf (stdin, ""%u"", &data);
"
13769,0,CWE590_Free_Memory_Not_on_Heap__delete_array_int64_t_static_18.cpp,"    int64_t * data;
    data = NULL; 
    goto source;
source:
    {
        
        static int64_t dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5LL;
            }
        }
        data = dataBuffer;
    }
    printLongLongLine(data[0]);
    
"
10976,0,CWE401_Memory_Leak__new_array_struct_twoIntsStruct_66a.cpp,"    struct _twoIntsStruct * data;
    struct _twoIntsStruct * dataArray[5];
    data = NULL;
    
    data = new struct _twoIntsStruct[100];
    
    data[0].intOne = 0;
    data[0].intTwo = 0;
    printStructLine((twoIntsStruct *)&data[0]);
    
    dataArray[2] = data;
"
3139,0,CWE190_Integer_Overflow__int64_t_rand_square_09.c,"    int64_t data;
    data = 0LL;
    if(GLOBAL_CONST_TRUE)
    {
        
        data = (int64_t)RAND64();
    }
    if(GLOBAL_CONST_TRUE)
    {
        {
            
            int64_t result = data * data;
            printLongLongLine(result);
        }
"
4188,0,CWE78_OS_Command_Injection__char_environment_execlp_82_bad.cpp,"Label Definition File: CWE78_OS_Command_Injection.strings.label.xml
Template File: sources-sink-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 78 OS Command Injection
 * BadSource: environment Read input from an environment variable
 * GoodSource: Fixed string
 * Sinks: execlp
 *    BadSink : execute command with execlp
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE78_OS_Command_Injection__char_environment_execlp_82.h""

#ifdef _WIN32
#include <process.h>
#define EXECLP _execlp
#else 
#define EXECLP execlp
#endif

namespace CWE78_OS_Command_Injection__char_environment_execlp_82
{

void CWE78_OS_Command_Injection__char_environment_execlp_82_bad::action(char * data)
{
    /* execlp - searches for the location of the command among
     * the directories specified by the PATH environment variable */
    
    EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}

}
"
6543,1,CWE758_Undefined_Behavior__struct_pointer_malloc_use_06.c,"    if(STATIC_CONST_FIVE!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            twoIntsStruct * data;
            twoIntsStruct * * pointer = (twoIntsStruct * *)malloc(sizeof(twoIntsStruct *));
            if (pointer == NULL) {exit(-1);}
            
            data = (twoIntsStruct *)malloc(sizeof(twoIntsStruct));
            if (data == NULL) {exit(-1);}
            data->intOne = 5;
            data->intTwo = 6;
            *pointer = data; 
            {
                twoIntsStruct * data = *pointer;
                printIntLine(data->intOne);
                printIntLine(data->intTwo);
            }
            free(pointer);
        }
"
12520,0,CWE401_Memory_Leak__new_twoIntsStruct_72a.cpp,"    twoIntsStruct * data;
    vector<twoIntsStruct *> dataVector;
    data = NULL;
    
    data = new twoIntsStruct;
    
    data->intOne = 0;
    data->intTwo = 0;
    printStructLine(data);
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
10033,0,CWE134_Uncontrolled_Format_String__char_file_vprintf_63a.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        FILE * pFile;
        
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
"
12068,0,CWE590_Free_Memory_Not_on_Heap__delete_array_int64_t_declare_68a.cpp,"    int64_t * data;
    data = NULL; 
    {
        
        int64_t dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5LL;
            }
        }
        data = dataBuffer;
    }
    CWE590_Free_Memory_Not_on_Heap__delete_array_int64_t_declare_68_badData = data;
"
15331,1,CWE758_Undefined_Behavior__int_pointer_new_use_01.cpp,"    {
        int * data;
        
        data = new int;
        *data = 5;
        int * * pointer = new int *;
        *pointer = data; 
        {
            int * data = *pointer;
            printIntLine(*data);
        }
        delete pointer;
"
13344,0,CWE690_NULL_Deref_From_Return__int64_t_malloc_16.c,"    int64_t * data;
    data = NULL; 
    
    data = (int64_t *)malloc(1*sizeof(int64_t));
    while(1)
    {
        
        data[0] = 5LL;
        printLongLongLine(data[0]);
        free(data);
        break;
"
11765,0,CWE190_Integer_Overflow__int_fscanf_add_34.c,"    int data;
    CWE190_Integer_Overflow__int_fscanf_add_34_unionType myUnion;
    
    data = 0;
    
    fscanf(stdin, ""%d"", &data);
    myUnion.unionFirst = data;
    {
        int data = myUnion.unionSecond;
        {
            
            int result = data + 1;
            printIntLine(result);
        }
"
2494,0,CWE190_Integer_Overflow__unsigned_int_max_square_82a.cpp,"    unsigned int data;
    data = 0;
    
    data = UINT_MAX;
    CWE190_Integer_Overflow__unsigned_int_max_square_82_base* baseObject = new CWE190_Integer_Overflow__unsigned_int_max_square_82_bad;
    baseObject->action(data);
"
12601,0,CWE590_Free_Memory_Not_on_Heap__delete_char_static_06.cpp,"    char * data;
    data = NULL; 
    if(STATIC_CONST_FIVE==5)
    {
        {
            
            static char dataBuffer;
            dataBuffer = 'A';
            data = &dataBuffer;
        }
    }
    printHexCharLine(*data);
    
"
13200,0,CWE197_Numeric_Truncation_Error__int_fscanf_to_char_83_bad.cpp,"Label Definition File: CWE197_Numeric_Truncation_Error__int.label.xml
Template File: sources-sink-83_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 197 Numeric Truncation Error
 * BadSource: fscanf Read data from the console using fscanf()
 * GoodSource: Less than CHAR_MAX
 * Sinks: to_char
 *    BadSink : Convert data to a char
 * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE197_Numeric_Truncation_Error__int_fscanf_to_char_83.h""

namespace CWE197_Numeric_Truncation_Error__int_fscanf_to_char_83
{
CWE197_Numeric_Truncation_Error__int_fscanf_to_char_83_bad::CWE197_Numeric_Truncation_Error__int_fscanf_to_char_83_bad(int dataCopy)
{
    data = dataCopy;
    
    fscanf(stdin, ""%d"", &data);
}

CWE197_Numeric_Truncation_Error__int_fscanf_to_char_83_bad::~CWE197_Numeric_Truncation_Error__int_fscanf_to_char_83_bad()
{
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
    }
}
}
"
18634,0,CWE690_NULL_Deref_From_Return__int64_t_malloc_83a.cpp,"    int64_t * data;
    data = NULL; 
"
792,0,CWE590_Free_Memory_Not_on_Heap__delete_array_struct_declare_16.cpp,"    twoIntsStruct * data;
    data = NULL; 
    while(1)
    {
        {
            
            twoIntsStruct dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i].intOne = 1;
                    dataBuffer[i].intTwo = 1;
                }
            }
            data = dataBuffer;
        }
        break;
    }
    printStructLine(&data[0]);
    
"
4592,0,CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_64a.cpp,"    size_t data;
    
    data = 0;
    
    fscanf(stdin, ""%zu"", &data);
"
5477,0,CWE190_Integer_Overflow__int_max_add_01.c,"    int data;
    
    data = 0;
    
    data = INT_MAX;
    {
        
        int result = data + 1;
        printIntLine(result);
"
14039,0,CWE190_Integer_Overflow__unsigned_int_fscanf_add_83_bad.cpp,"Label Definition File: CWE190_Integer_Overflow.label.xml
Template File: sources-sinks-83_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 190 Integer Overflow
 * BadSource: fscanf Read data from the console using fscanf()
 * GoodSource: Set data to a small, non-zero number (two)
 * Sinks: add
 *    GoodSink: Ensure there will not be an overflow before adding 1 to data
 *    BadSink : Add 1 to data, which can cause an overflow
 * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE190_Integer_Overflow__unsigned_int_fscanf_add_83.h""

namespace CWE190_Integer_Overflow__unsigned_int_fscanf_add_83
{
CWE190_Integer_Overflow__unsigned_int_fscanf_add_83_bad::CWE190_Integer_Overflow__unsigned_int_fscanf_add_83_bad(unsigned int dataCopy)
{
    data = dataCopy;
    
    fscanf (stdin, ""%u"", &data);
}

CWE190_Integer_Overflow__unsigned_int_fscanf_add_83_bad::~CWE190_Integer_Overflow__unsigned_int_fscanf_add_83_bad()
{
    {
        
        unsigned int result = data + 1;
        printUnsignedLine(result);
    }
}
}
"
18078,0,CWE252_Unchecked_Return_Value__char_sscanf_03.c,"    if(5==5)
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            
            sscanf(SRC, ""%99s\0"", data);
        }
"
13092,0,CWE415_Double_Free__new_delete_array_class_18.cpp,"    TwoIntsClass * data;
    
    data = NULL;
    goto source;
source:
    data = new TwoIntsClass[100];
    
    delete [] data;
    goto sink;
sink:
    
"
8142,0,CWE690_NULL_Deref_From_Return__fopen_66a.c,"    FILE * data;
    FILE * dataArray[5];
    
    data = NULL;
    
    data = fopen(""file.txt"", ""w+"");
    
    dataArray[2] = data;
"
3077,0,CWE401_Memory_Leak__int64_t_realloc_84a.cpp,"    int64_t * data;
    data = NULL;
    CWE401_Memory_Leak__int64_t_realloc_84_bad * badObject = new CWE401_Memory_Leak__int64_t_realloc_84_bad(data);
"
5871,0,CWE590_Free_Memory_Not_on_Heap__delete_array_int_alloca_81_bad.cpp,"Label Definition File: CWE590_Free_Memory_Not_on_Heap__delete_array.label.xml
Template File: sources-sink-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 590 Free Memory Not on Heap
 * BadSource: alloca Data buffer is allocated on the stack with alloca()
 * GoodSource: Allocate memory on the heap
 * Sinks:
 *    BadSink : Print then free data
 * Flow Variant: 81 Data flow: data passed in a parameter to a virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE590_Free_Memory_Not_on_Heap__delete_array_int_alloca_81.h""

namespace CWE590_Free_Memory_Not_on_Heap__delete_array_int_alloca_81
{

void CWE590_Free_Memory_Not_on_Heap__delete_array_int_alloca_81_bad::action(int * data) const
{
    printIntLine(data[0]);
    
    delete [] data;
}

}
"
6635,0,CWE590_Free_Memory_Not_on_Heap__delete_struct_alloca_54a.cpp,"    twoIntsStruct * data;
    data = NULL; 
    {
        
        twoIntsStruct * dataBuffer = (twoIntsStruct *)ALLOCA(sizeof(twoIntsStruct));
        dataBuffer->intOne = 1;
        dataBuffer->intTwo = 1;
        data = dataBuffer;
    }
"
10256,0,CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_81_bad.cpp,"Label Definition File: CWE134_Uncontrolled_Format_String.label.xml
Template File: sources-sinks-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 134 Uncontrolled Format String
 * BadSource: connect_socket Read data using a connect socket (client side)
 * GoodSource: Copy a fixed string into data
 * Sinks: snprintf
 *    GoodSink: snprintf with ""%s"" as the third argument and data as the fourth
 *    BadSink : snprintf with data as the third argument
 * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_81.h""

#ifdef _WIN32
#define SNPRINTF _snprintf
#else
#define SNPRINTF snprintf
#endif

namespace CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_81
{

void CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_81_bad::action(char * data) const
{
    {
        char dest[100] = """";
        
        SNPRINTF(dest, 100-1, data);
        printLine(dest);
    }
}

}
"
19515,0,CWE190_Integer_Overflow__char_rand_add_06.c,"    char data;
    data = ' ';
    if(STATIC_CONST_FIVE==5)
    {
        
        data = (char)RAND32();
    }
    if(STATIC_CONST_FIVE==5)
    {
        {
            
            char result = data + 1;
            printHexCharLine(result);
        }
"
9996,0,CWE590_Free_Memory_Not_on_Heap__delete_array_char_alloca_82_bad.cpp,"Label Definition File: CWE590_Free_Memory_Not_on_Heap__delete_array.label.xml
Template File: sources-sink-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 590 Free Memory Not on Heap
 * BadSource: alloca Data buffer is allocated on the stack with alloca()
 * GoodSource: Allocate memory on the heap
 * Sinks:
 *    BadSink : Print then free data
 * Flow Variant: 82 Data flow: data passed in a parameter to a virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE590_Free_Memory_Not_on_Heap__delete_array_char_alloca_82.h""

namespace CWE590_Free_Memory_Not_on_Heap__delete_array_char_alloca_82
{

void CWE590_Free_Memory_Not_on_Heap__delete_array_char_alloca_82_bad::action(char * data)
{
    printLine(data);
    
    delete [] data;
}

}
"
15127,0,CWE78_OS_Command_Injection__char_listen_socket_execl_13.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(GLOBAL_CONST_FIVE==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                data[dataLen + recvResult / sizeof(char)] = '\0';
                
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    
    
"
14468,0,CWE78_OS_Command_Injection__char_console_execlp_16.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    while(1)
    {
        {
            
            size_t dataLen = strlen(data);
            
            if (100-dataLen > 1)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
                {
                    /* The next few lines remove the carriage return from the string that is
                     * inserted by fgets() */
                    dataLen = strlen(data);
"
3932,0,CWE134_Uncontrolled_Format_String__char_console_fprintf_17.c,"    int i,j;
    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    for(i = 0; i < 1; i++)
    {
        {
            
            size_t dataLen = strlen(data);
            
            if (100-dataLen > 1)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
                {
                    /* The next few lines remove the carriage return from the string that is
                     * inserted by fgets() */
                    dataLen = strlen(data);
                    if (dataLen > 0 && data[dataLen-1] == '\n')
                    {
                        data[dataLen-1] = '\0';
                    }
                }
                else
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
            }
        }
    }
    for(j = 0; j < 1; j++)
    {
        
        fprintf(stdout, data);
"
5567,0,CWE78_OS_Command_Injection__char_listen_socket_execl_44.c,"    char * data;
    
    void (*funcPtr) (char *) = badSink;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
"
11658,0,CWE369_Divide_by_Zero__int_zero_divide_42.c,"    int data;
    
    data = -1;
    data = badSource(data);
    
"
6157,0,CWE190_Integer_Overflow__short_max_preinc_61a.c,"    short data;
    data = 0;
    data = CWE190_Integer_Overflow__short_max_preinc_61b_badSource(data);
    {
        
        ++data;
        short result = data;
        printIntLine(result);
"
13795,0,CWE190_Integer_Overflow__int_fscanf_add_22a.c,"    int data;
    
    data = 0;
    
    fscanf(stdin, ""%d"", &data);
    CWE190_Integer_Overflow__int_fscanf_add_22_badGlobal = 1; 
"
1896,0,CWE416_Use_After_Free__new_delete_array_struct_01.cpp,"    twoIntsStruct * data;
    
    data = NULL;
    data = new twoIntsStruct[100];
    {
        size_t i;
        for(i = 0; i < 100; i++)
        {
            data[i].intOne = 1;
            data[i].intTwo = 2;
        }
    }
    
    delete [] data;
    
    printStructLine(&data[0]);
"
5865,0,CWE197_Numeric_Truncation_Error__int_rand_to_char_45.c,"    int data;
    
    data = -1;
    
    data = RAND32();
    CWE197_Numeric_Truncation_Error__int_rand_to_char_45_badData = data;
"
17649,0,CWE197_Numeric_Truncation_Error__int_listen_socket_to_char_33.cpp,"    int data;
    int &dataRef = data;
    
    data = -1;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    {
        int data = dataRef;
        {
            
            char charData = (char)data;
            printHexCharLine(charData);
        }
"
12549,0,CWE690_NULL_Deref_From_Return__long_realloc_10.c,"    long * data;
    data = NULL; 
    
    data = (long *)realloc(data, 1*sizeof(long));
    if(globalTrue)
    {
        
        data[0] = 5L;
        printLongLine(data[0]);
        free(data);
"
10879,1,CWE252_Unchecked_Return_Value__char_fgets_10.c,"    if(globalTrue)
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            printLine(""Please enter a string: "");
            
            if (fgets(data, 100, stdin) == NULL)
            {
                printLine(""fgets failed!"");
                exit(1);
            }
            printLine(data);
        }
"
12241,0,CWE190_Integer_Overflow__char_rand_add_09.c,"    char data;
    data = ' ';
    if(GLOBAL_CONST_TRUE)
    {
        
        data = (char)RAND32();
    }
    if(GLOBAL_CONST_TRUE)
    {
        {
            
            char result = data + 1;
            printHexCharLine(result);
        }
"
12705,0,CWE401_Memory_Leak__int64_t_calloc_81_bad.cpp,"Label Definition File: CWE401_Memory_Leak.c.label.xml
Template File: sources-sinks-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 401 Memory Leak
 * BadSource: calloc Allocate data using calloc()
 * GoodSource: Allocate data on the stack
 * Sinks:
 *    GoodSink: call free() on data
 *    BadSink : no deallocation of data
 * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE401_Memory_Leak__int64_t_calloc_81.h""

namespace CWE401_Memory_Leak__int64_t_calloc_81
{

void CWE401_Memory_Leak__int64_t_calloc_81_bad::action(int64_t * data) const
{
    
    ; 
}

}
"
1758,0,CWE590_Free_Memory_Not_on_Heap__delete_array_int_static_11.cpp,"    int * data;
    data = NULL; 
    if(globalReturnsTrue())
    {
        {
            
            static int dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5;
                }
            }
            data = dataBuffer;
        }
    }
    printIntLine(data[0]);
    
"
4885,0,CWE190_Integer_Overflow__char_max_add_61a.c,"    char data;
    data = ' ';
    data = CWE190_Integer_Overflow__char_max_add_61b_badSource(data);
    {
        
        char result = data + 1;
        printHexCharLine(result);
"
14842,0,CWE401_Memory_Leak__new_int_15.cpp,"    int * data;
    data = NULL;
    switch(6)
    {
    case 6:
        
        data = new int;
        
        *data = 5;
        printIntLine(*data);
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
        
        ; 
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
17662,0,CWE190_Integer_Overflow__int64_t_max_multiply_72a.cpp,"    int64_t data;
    vector<int64_t> dataVector;
    data = 0LL;
    
    data = LLONG_MAX;
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
1323,0,CWE401_Memory_Leak__new_array_char_21.cpp,"    char * data;
    data = NULL;
    
    data = new char[100];
    
    strcpy(data, ""A String"");
    printLine(data);
    badStatic = 1; 
"
6286,0,CWE590_Free_Memory_Not_on_Heap__delete_class_static_06.cpp,"    TwoIntsClass * data;
    data = NULL; 
    if(STATIC_CONST_FIVE==5)
    {
        {
            
            static TwoIntsClass dataBuffer;
            dataBuffer.intOne = 1;
            dataBuffer.intTwo = 1;
            data = &dataBuffer;
        }
    }
    printIntLine(data->intOne);
    
"
6919,0,CWE190_Integer_Overflow__int_rand_square_43.cpp,"    int data;
    
    data = 0;
    badSource(data);
    {
        
        int result = data * data;
        printIntLine(result);
"
15377,0,CWE190_Integer_Overflow__int_connect_socket_square_32.c,"    int data;
    int *dataPtr1 = &data;
    int *dataPtr2 = &data;
    
    data = 0;
    {
        int data = *dataPtr1;
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
        *dataPtr1 = data;
    }
    {
        int data = *dataPtr2;
        {
            
            int result = data * data;
            printIntLine(result);
        }
"
7024,0,CWE190_Integer_Overflow__int_fscanf_preinc_13.c,"    int data;
    
    data = 0;
    if(GLOBAL_CONST_FIVE==5)
    {
        
        fscanf(stdin, ""%d"", &data);
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            
            ++data;
            int result = data;
            printIntLine(result);
        }
"
6789,0,CWE401_Memory_Leak__twoIntsStruct_calloc_32.c,"    twoIntsStruct * data;
    twoIntsStruct * *dataPtr1 = &data;
    twoIntsStruct * *dataPtr2 = &data;
    data = NULL;
    {
        twoIntsStruct * data = *dataPtr1;
        
        data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));
        if (data == NULL) {exit(-1);}
        
        data[0].intOne = 0;
        data[0].intTwo = 0;
        printStructLine(&data[0]);
        *dataPtr1 = data;
    }
    {
        twoIntsStruct * data = *dataPtr2;
        
        ; 
"
3257,0,CWE590_Free_Memory_Not_on_Heap__delete_array_char_static_82_bad.cpp,"Label Definition File: CWE590_Free_Memory_Not_on_Heap__delete_array.label.xml
Template File: sources-sink-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 590 Free Memory Not on Heap
 * BadSource: static Data buffer is declared static on the stack
 * GoodSource: Allocate memory on the heap
 * Sinks:
 *    BadSink : Print then free data
 * Flow Variant: 82 Data flow: data passed in a parameter to a virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE590_Free_Memory_Not_on_Heap__delete_array_char_static_82.h""

namespace CWE590_Free_Memory_Not_on_Heap__delete_array_char_static_82
{

void CWE590_Free_Memory_Not_on_Heap__delete_array_char_static_82_bad::action(char * data)
{
    printLine(data);
    
    delete [] data;
}

}
"
11592,1,CWE416_Use_After_Free__return_freed_ptr_01.c,"    {
        
        char * reversedString = helperGood(""GoodSink"");
        printLine(reversedString);
        /* free(reversedString);
         * This call to free() was removed because we want the tool to detect the use after free,
         * but we don't want that function to be free(). Essentially we want to avoid a double free
         */
"
6447,1,CWE467_Use_of_sizeof_on_Pointer_Type__short_10.c,"    if(globalTrue)
    {
        {
            short * goodShort = NULL;
            
            goodShort = (short *)malloc(sizeof(*goodShort));
            if (goodShort == NULL) {exit(-1);}
            *goodShort = 6;
            printShortLine(*goodShort);
            free(goodShort);
        }
"
11473,0,CWE190_Integer_Overflow__int64_t_rand_postinc_31.c,"    int64_t data;
    data = 0LL;
    
    data = (int64_t)RAND64();
    {
        int64_t dataCopy = data;
        int64_t data = dataCopy;
        {
            
            data++;
            int64_t result = data;
            printLongLongLine(result);
        }
"
19551,0,CWE690_NULL_Deref_From_Return__int64_t_realloc_43.cpp,"    int64_t * data;
    data = NULL; 
    badSource(data);
    
    data[0] = 5LL;
    printLongLongLine(data[0]);
"
12688,1,CWE758_Undefined_Behavior__int_alloca_use_05.c,"    if(staticTrue)
    {
        {
            int data;
            int * pointer = (int *)ALLOCA(sizeof(int));
            data = 5;
            *pointer = data; 
            {
                int data = *pointer;
                printIntLine(data);
            }
        }
"
3240,0,CWE590_Free_Memory_Not_on_Heap__delete_int_declare_51a.cpp,"    int * data;
    data = NULL; 
    {
        
        int dataBuffer;
        dataBuffer = 5;
        data = &dataBuffer;
    }
"
3035,0,CWE690_NULL_Deref_From_Return__long_malloc_15.c,"    long * data;
    data = NULL; 
    
    data = (long *)malloc(1*sizeof(long));
    switch(6)
    {
    case 6:
        
        data[0] = 5L;
        printLongLine(data[0]);
        free(data);
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
18415,0,CWE690_NULL_Deref_From_Return__long_malloc_07.c,"    long * data;
    data = NULL; 
    
    data = (long *)malloc(1*sizeof(long));
    if(staticFive==5)
    {
        
        data[0] = 5L;
        printLongLine(data[0]);
        free(data);
"
13373,0,CWE590_Free_Memory_Not_on_Heap__delete_array_class_alloca_17.cpp,"    int i;
    TwoIntsClass * data;
    data = NULL; 
    for(i = 0; i < 1; i++)
    {
        {
            
            TwoIntsClass * dataBuffer = (TwoIntsClass *)ALLOCA(100*sizeof(TwoIntsClass));
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i].intOne = 1;
                    dataBuffer[i].intTwo = 1;
                }
            }
            data = dataBuffer;
        }
    }
    printIntLine(data[0].intOne);
    
"
1125,0,CWE197_Numeric_Truncation_Error__int_listen_socket_to_short_32.c,"    int data;
    int *dataPtr1 = &data;
    int *dataPtr2 = &data;
    
    data = -1;
    {
        int data = *dataPtr1;
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
        *dataPtr1 = data;
    }
    {
        int data = *dataPtr2;
        {
            
            short shortData = (short)data;
            printShortLine(shortData);
        }
"
3797,1,CWE587_Assignment_of_Fixed_Address_to_Pointer__basic_05.c,"    if(staticFalse)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            
            char charStack = 'a';
            char *charPointer = &charStack;
            printHexCharLine(*charPointer);
        }
"
11054,0,CWE758_Undefined_Behavior__char_pointer_alloca_use_01.c,"    {
        char * * pointer = (char * *)ALLOCA(sizeof(char *));
        char * data = *pointer; 
        printLine(data);
"
3640,0,CWE190_Integer_Overflow__unsigned_int_max_add_66a.c,"    unsigned int data;
    unsigned int dataArray[5];
    data = 0;
    
    data = UINT_MAX;
    
    dataArray[2] = data;
"
14124,0,CWE190_Integer_Overflow__char_max_square_62a.cpp,"    char data;
    data = ' ';
    badSource(data);
    {
        
        char result = data * data;
        printHexCharLine(result);
"
18750,0,CWE457_Use_of_Uninitialized_Variable__new_struct_array_no_init_08.cpp,"    twoIntsStruct * data;
    data = new twoIntsStruct[10];
    if(staticReturnsTrue())
    {
        
        ; 
    }
    if(staticReturnsTrue())
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i].intOne);
                printIntLine(data[i].intTwo);
            }
        }
        
        delete [] data;
"
8870,0,CWE190_Integer_Overflow__int64_t_rand_multiply_84_bad.cpp,"Label Definition File: CWE190_Integer_Overflow.label.xml
Template File: sources-sinks-84_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 190 Integer Overflow
 * BadSource: rand Set data to result of rand()
 * GoodSource: Set data to a small, non-zero number (two)
 * Sinks: multiply
 *    GoodSink: Ensure there will not be an overflow before multiplying data by 2
 *    BadSink : If data is positive, multiply by 2, which can cause an overflow
 * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE190_Integer_Overflow__int64_t_rand_multiply_84.h""

namespace CWE190_Integer_Overflow__int64_t_rand_multiply_84
{
CWE190_Integer_Overflow__int64_t_rand_multiply_84_bad::CWE190_Integer_Overflow__int64_t_rand_multiply_84_bad(int64_t dataCopy)
{
    data = dataCopy;
    
    data = (int64_t)RAND64();
}

CWE190_Integer_Overflow__int64_t_rand_multiply_84_bad::~CWE190_Integer_Overflow__int64_t_rand_multiply_84_bad()
{
    if(data > 0) 
    {
        
        int64_t result = data * 2;
        printLongLongLine(result);
    }
}
}
"
1802,0,CWE190_Integer_Overflow__char_fscanf_add_41.c,"    char data;
    data = ' ';
    
    fscanf (stdin, ""%c"", &data);
"
10812,0,CWE78_OS_Command_Injection__char_connect_socket_execlp_43.cpp,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    badSource(data);
    /* execlp - searches for the location of the command among
     * the directories specified by the PATH environment variable */
    
    EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}

#endif 

#ifndef OMITGOOD


static void goodG2BSource(char * &data)
{
"
7495,1,CWE401_Memory_Leak__virtual_destructor_01_good1.cpp,"    GoodBaseClass * baseClassObject = new GoodDerivedClass(""GoodClass"");

"
14569,1,CWE416_Use_After_Free__return_freed_ptr_17.c,"    int k;
    for(k = 0; k < 1; k++)
    {
        {
            
            char * reversedString = helperGood(""GoodSink"");
            printLine(reversedString);
            /* free(reversedString);
             * This call to free() was removed because we want the tool to detect the use after free,
             * but we don't want that function to be free(). Essentially we want to avoid a double free
             */
        }
"
7364,0,CWE401_Memory_Leak__new_char_16.cpp,"    char * data;
    data = NULL;
    while(1)
    {
        
        data = new char;
        
        *data = 'A';
        printHexCharLine(*data);
        break;
    }
    while(1)
    {
        
        ; 
        break;
"
7003,0,CWE416_Use_After_Free__new_delete_long_15.cpp,"    long * data;
    
    data = NULL;
    switch(6)
    {
    case 6:
        data = new long;
        *data = 5L;
        
        delete data;
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
        
        printLongLine(*data);
        
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
15700,0,CWE415_Double_Free__malloc_free_int_83a.cpp,"    int * data;
    
    data = NULL;
"
7405,0,CWE590_Free_Memory_Not_on_Heap__delete_array_struct_declare_14.cpp,"    twoIntsStruct * data;
    data = NULL; 
    if(globalFive==5)
    {
        {
            
            twoIntsStruct dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i].intOne = 1;
                    dataBuffer[i].intTwo = 1;
                }
            }
            data = dataBuffer;
        }
    }
    printStructLine(&data[0]);
    
"
13568,0,CWE690_NULL_Deref_From_Return__long_calloc_63a.c,"    long * data;
    data = NULL; 
    
    data = (long *)calloc(1, sizeof(long));
"
152,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_72a.cpp,"    size_t data;
    vector<size_t> dataVector;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = strtoul(inputBuffer, NULL, 0);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
10015,0,CWE590_Free_Memory_Not_on_Heap__delete_struct_declare_64a.cpp,"    twoIntsStruct * data;
    data = NULL; 
    {
        
        twoIntsStruct dataBuffer;
        dataBuffer.intOne = 1;
        dataBuffer.intTwo = 1;
        data = &dataBuffer;
    }
"
3970,1,CWE758_Undefined_Behavior__struct_malloc_use_03.c,"    if(5!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            twoIntsStruct data;
            twoIntsStruct * pointer = (twoIntsStruct *)malloc(sizeof(twoIntsStruct));
            if (pointer == NULL) {exit(-1);}
            data.intOne = 1;
            data.intTwo = 2;
            *pointer = data; 
            {
                twoIntsStruct data = *pointer;
                printIntLine(data.intOne);
                printIntLine(data.intTwo);
            }
            free(pointer);
        }
"
13657,0,CWE457_Use_of_Uninitialized_Variable__int64_t_02.c,"    int64_t data;
    if(1)
    {
        
        ; 
    }
    if(1)
    {
        
        printLongLongLine(data);
"
2680,0,CWE457_Use_of_Uninitialized_Variable__struct_array_malloc_partial_init_08.c,"    twoIntsStruct * data;
    data = (twoIntsStruct *)malloc(10*sizeof(twoIntsStruct));
    if (data == NULL) {exit(-1);}
    if(staticReturnsTrue())
    {
        
        {
            int i;
            for(i=0; i<(10/2); i++)
            {
                data[i].intOne = i;
                data[i].intTwo = i;
            }
        }
    }
    if(staticReturnsTrue())
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i].intOne);
                printIntLine(data[i].intTwo);
            }
        }
"
11604,0,CWE590_Free_Memory_Not_on_Heap__delete_array_class_alloca_09.cpp,"    TwoIntsClass * data;
    data = NULL; 
    if(GLOBAL_CONST_TRUE)
    {
        {
            
            TwoIntsClass * dataBuffer = (TwoIntsClass *)ALLOCA(100*sizeof(TwoIntsClass));
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i].intOne = 1;
                    dataBuffer[i].intTwo = 1;
                }
            }
            data = dataBuffer;
        }
    }
    printIntLine(data[0].intOne);
    
"
9654,0,CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_44.c,"    char * data;
    
    void (*funcPtr) (char *) = badSink;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
"
10838,0,CWE590_Free_Memory_Not_on_Heap__delete_struct_placement_new_82_bad.cpp,"Label Definition File: CWE590_Free_Memory_Not_on_Heap__delete.pointer.label.xml
Template File: sources-sink-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 590 Free Memory Not on Heap
 * BadSource: placement_new Data buffer is declared on the stack
 * GoodSource: Allocate memory on the heap
 * Sinks:
 *    BadSink : Print then free data
 * Flow Variant: 82 Data flow: data passed in a parameter to a virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE590_Free_Memory_Not_on_Heap__delete_struct_placement_new_82.h""

namespace CWE590_Free_Memory_Not_on_Heap__delete_struct_placement_new_82
{

void CWE590_Free_Memory_Not_on_Heap__delete_struct_placement_new_82_bad::action(twoIntsStruct * data)
{
    printStructLine(data);
    
    delete data;
}

}
"
14562,1,CWE758_Undefined_Behavior__struct_alloca_use_12.c,"    if(globalReturnsTrueOrFalse())
    {
        {
            twoIntsStruct data;
            twoIntsStruct * pointer = (twoIntsStruct *)ALLOCA(sizeof(twoIntsStruct));
            data.intOne = 1;
            data.intTwo = 2;
            *pointer = data; 
            {
                twoIntsStruct data = *pointer;
                printIntLine(data.intOne);
                printIntLine(data.intTwo);
            }
        }
    }
    else
    {
        {
            twoIntsStruct data;
            twoIntsStruct * pointer = (twoIntsStruct *)ALLOCA(sizeof(twoIntsStruct));
            data.intOne = 1;
            data.intTwo = 2;
            *pointer = data; 
            {
                twoIntsStruct data = *pointer;
                printIntLine(data.intOne);
                printIntLine(data.intTwo);
            }
        }
"
13048,1,CWE758_Undefined_Behavior__class_pointer_new_use_12.cpp,"    if(globalReturnsTrueOrFalse())
    {
        {
            TwoIntsClass * data;
            
            data = new TwoIntsClass;
            data->intOne = 5;
            data->intTwo = 6;
            TwoIntsClass * * pointer = new TwoIntsClass *;
            *pointer = data; 
            {
                TwoIntsClass * data = *pointer;
                printIntLine(data->intOne);
                printIntLine(data->intTwo);
            }
            delete pointer;
        }
    }
    else
    {
        {
            TwoIntsClass * data;
            
            data = new TwoIntsClass;
            data->intOne = 5;
            data->intTwo = 6;
            TwoIntsClass * * pointer = new TwoIntsClass *;
            *pointer = data; 
            {
                TwoIntsClass * data = *pointer;
                printIntLine(data->intOne);
                printIntLine(data->intTwo);
            }
            delete pointer;
        }
"
17411,0,CWE590_Free_Memory_Not_on_Heap__delete_long_placement_new_04.cpp,"    long * data;
    data = NULL; 
    if(STATIC_CONST_TRUE)
    {
        {
            
            char buffer[sizeof(long)];
            long * dataBuffer = new(buffer) long;
            *dataBuffer = 5L;
            data = dataBuffer;
        }
    }
    printLongLine(*data);
    
"
2418,1,CWE401_Memory_Leak__malloc_realloc_int64_t_12.c,"    if(globalReturnsTrueOrFalse())
    {
        {
            int64_t * data = (int64_t *)malloc(100*sizeof(int64_t));
            if (data == NULL) {exit(-1);}
            int64_t * tmpData;
            
            data[0] = 5LL;
            printLongLongLine(data[0]);
            tmpData = (int64_t *)realloc(data, (130000)*sizeof(int64_t));
            /* FIX: Ensure realloc() was successful before assigning data to the memory block
            * allocated with realloc() */
            if (tmpData != NULL)
            {
                data = tmpData;
                
                data[0] = 10LL;
                printLongLongLine(data[0]);
            }
            free(data);
        }
    }
    else
    {
        {
            int64_t * data = (int64_t *)malloc(100*sizeof(int64_t));
            if (data == NULL) {exit(-1);}
            int64_t * tmpData;
            
            data[0] = 5LL;
            printLongLongLine(data[0]);
            tmpData = (int64_t *)realloc(data, (130000)*sizeof(int64_t));
            /* FIX: Ensure realloc() was successful before assigning data to the memory block
            * allocated with realloc() */
            if (tmpData != NULL)
            {
                data = tmpData;
                
                data[0] = 10LL;
                printLongLongLine(data[0]);
            }
            free(data);
        }
"
14292,0,CWE590_Free_Memory_Not_on_Heap__delete_struct_declare_81a.cpp,"    twoIntsStruct * data;
    data = NULL; 
    {
        
        twoIntsStruct dataBuffer;
        dataBuffer.intOne = 1;
        dataBuffer.intTwo = 1;
        data = &dataBuffer;
    }
    const CWE590_Free_Memory_Not_on_Heap__delete_struct_declare_81_base& baseObject = CWE590_Free_Memory_Not_on_Heap__delete_struct_declare_81_bad();
"
15798,0,CWE190_Integer_Overflow__char_fscanf_postinc_34.c,"    char data;
    CWE190_Integer_Overflow__char_fscanf_postinc_34_unionType myUnion;
    data = ' ';
    
    fscanf (stdin, ""%c"", &data);
    myUnion.unionFirst = data;
    {
        char data = myUnion.unionSecond;
        {
            
            data++;
            char result = data;
            printHexCharLine(result);
        }
"
15107,0,CWE190_Integer_Overflow__int_connect_socket_square_31.c,"    int data;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    {
        int dataCopy = data;
        int data = dataCopy;
        {
            
            int result = data * data;
            printIntLine(result);
        }
"
14947,0,CWE401_Memory_Leak__malloc_realloc_int_01.c,"    {
        int * data = (int *)malloc(100*sizeof(int));
        if (data == NULL) {exit(-1);}
        
        data[0] = 5;
        printIntLine(data[0]);
        
        data = (int *)realloc(data, (130000)*sizeof(int));
        if (data != NULL)
        {
            
            data[0] = 10;
            printIntLine(data[0]);
            free(data);
        }
"
5379,0,CWE401_Memory_Leak__new_array_twointsStruct_67a.cpp,"    twoIntsStruct * data;
    structType myStruct;
    data = NULL;
    
    data = new twoIntsStruct[100];
    
    data[0].intOne = 0;
    data[0].intTwo = 0;
    printStructLine(&data[0]);
    myStruct.structFirst = data;
"
233,0,CWE590_Free_Memory_Not_on_Heap__delete_array_int64_t_alloca_15.cpp,"    int64_t * data;
    data = NULL; 
    switch(6)
    {
    case 6:
    {
        
        int64_t * dataBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5LL;
            }
        }
        data = dataBuffer;
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    printLongLongLine(data[0]);
    
"
11133,0,CWE369_Divide_by_Zero__float_listenSocket_21.c,"    float data;
    
    data = 0.0F;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = (float)atof(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    badStatic = 1; 
"
18651,1,CWE758_Undefined_Behavior__struct_malloc_use_14.c,"    if(globalFive!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            twoIntsStruct data;
            twoIntsStruct * pointer = (twoIntsStruct *)malloc(sizeof(twoIntsStruct));
            if (pointer == NULL) {exit(-1);}
            data.intOne = 1;
            data.intTwo = 2;
            *pointer = data; 
            {
                twoIntsStruct data = *pointer;
                printIntLine(data.intOne);
                printIntLine(data.intTwo);
            }
            free(pointer);
        }
"
19224,0,CWE134_Uncontrolled_Format_String__char_file_snprintf_43.cpp,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    badSource(data);
    {
        char dest[100] = """";
        
        SNPRINTF(dest, 100-1, data);
        printLine(dest);
"
11811,0,CWE590_Free_Memory_Not_on_Heap__delete_long_declare_06.cpp,"    long * data;
    data = NULL; 
    if(STATIC_CONST_FIVE==5)
    {
        {
            
            long dataBuffer;
            dataBuffer = 5L;
            data = &dataBuffer;
        }
    }
    printLongLine(*data);
    
"
18660,0,CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_13.c,"    unsigned int data;
    data = 0;
    if(GLOBAL_CONST_FIVE==5)
    {
        
        fscanf (stdin, ""%u"", &data);
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            
            data++;
            unsigned int result = data;
            printUnsignedLine(result);
        }
"
8632,0,CWE190_Integer_Overflow__char_max_add_83a.cpp,"    char data;
    data = ' ';
"
10381,0,CWE401_Memory_Leak__new_array_int64_t_66a.cpp,"    int64_t * data;
    int64_t * dataArray[5];
    data = NULL;
    
    data = new int64_t[100];
    
    data[0] = 5LL;
    printLongLongLine(data[0]);
    
    dataArray[2] = data;
"
10136,0,CWE369_Divide_by_Zero__int_rand_divide_83_bad.cpp,"Label Definition File: CWE369_Divide_by_Zero__int.label.xml
Template File: sources-sinks-83_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 369 Divide by Zero
 * BadSource: rand Set data to result of rand(), which may be zero
 * GoodSource: Non-zero
 * Sinks: divide
 *    GoodSink: Check for zero before dividing
 *    BadSink : Divide a constant by data
 * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE369_Divide_by_Zero__int_rand_divide_83.h""

namespace CWE369_Divide_by_Zero__int_rand_divide_83
{
CWE369_Divide_by_Zero__int_rand_divide_83_bad::CWE369_Divide_by_Zero__int_rand_divide_83_bad(int dataCopy)
{
    data = dataCopy;
    
    data = RAND32();
}

CWE369_Divide_by_Zero__int_rand_divide_83_bad::~CWE369_Divide_by_Zero__int_rand_divide_83_bad()
{
    
    printIntLine(100 / data);
}
}
"
10538,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_33.cpp,"    size_t data;
    size_t &dataRef = data;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = strtoul(inputBuffer, NULL, 0);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    {
        size_t data = dataRef;
        {
            char * myString;
            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
             * for the strcpy() function to not cause a buffer overflow */
            
            if (data > strlen(HELLO_STRING))
            {
                myString = (char *)malloc(data*sizeof(char));
                if (myString == NULL) {exit(-1);}
                
                strcpy(myString, HELLO_STRING);
                printLine(myString);
                free(myString);
            }
            else
            {
                printLine(""Input is less than the length of the source string"");
            }
        }
"
13792,0,CWE78_OS_Command_Injection__char_environment_execlp_44.c,"    char * data;
    
    void (*funcPtr) (char *) = badSink;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        
        if (environment != NULL)
        {
            
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    
"
10297,0,CWE416_Use_After_Free__new_delete_array_int64_t_07.cpp,"    int64_t * data;
    
    data = NULL;
    if(staticFive==5)
    {
        data = new int64_t[100];
        {
            size_t i;
            for(i = 0; i < 100; i++)
            {
                data[i] = 5LL;
            }
        }
        
        delete [] data;
    }
    if(staticFive==5)
    {
        
        printLongLongLine(data[0]);
        
"
1992,0,CWE416_Use_After_Free__malloc_free_long_11.c,"    long * data;
    
    data = NULL;
    if(globalReturnsTrue())
    {
        data = (long *)malloc(100*sizeof(long));
        if (data == NULL) {exit(-1);}
        {
            size_t i;
            for(i = 0; i < 100; i++)
            {
                data[i] = 5L;
            }
        }
        
        free(data);
    }
    if(globalReturnsTrue())
    {
        
        printLongLine(data[0]);
        
"
4673,0,CWE789_Uncontrolled_Mem_Alloc__new_char_fgets_33.cpp,"    size_t data;
    size_t &dataRef = data;
    
    data = 0;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = strtoul(inputBuffer, NULL, 0);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    {
        size_t data = dataRef;
        {
            char * myString;
            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
             * for the strcpy() function to not cause a buffer overflow */
            
            if (data > strlen(HELLO_STRING))
            {
                myString = new char[data];
                
                strcpy(myString, HELLO_STRING);
                printLine(myString);
                delete [] myString;
            }
            else
            {
                printLine(""Input is less than the length of the source string"");
            }
        }
"
15288,0,CWE401_Memory_Leak__new_int64_t_68a.cpp,"    int64_t * data;
    data = NULL;
    
    data = new int64_t;
    
    *data = 5LL;
    printLongLongLine(*data);
    badData = data;
"
13075,0,CWE590_Free_Memory_Not_on_Heap__delete_array_char_declare_17.cpp,"    int i;
    char * data;
    data = NULL; 
    for(i = 0; i < 1; i++)
    {
        {
            
            char dataBuffer[100];
            memset(dataBuffer, 'A', 100-1); 
            dataBuffer[100-1] = '\0'; 
            data = dataBuffer;
        }
    }
    printLine(data);
    
"
18568,0,CWE590_Free_Memory_Not_on_Heap__free_long_declare_72a.cpp,"    long * data;
    vector<long *> dataVector;
    data = NULL; 
    {
        
        long dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5L;
            }
        }
        data = dataBuffer;
    }
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
7358,1,CWE758_Undefined_Behavior__long_malloc_use_16.c,"    while(1)
    {
        {
            long data;
            long * pointer = (long *)malloc(sizeof(long));
            if (pointer == NULL) {exit(-1);}
            data = 5L;
            *pointer = data; 
            {
                long data = *pointer;
                printLongLine(data);
            }
            free(pointer);
        }
        break;
"
6998,0,CWE78_OS_Command_Injection__char_environment_system_67a.c,"    char * data;
    CWE78_OS_Command_Injection__char_environment_system_67_structType myStruct;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
        
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        
        if (environment != NULL)
        {
            
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    myStruct.structFirst = data;
"
5417,0,CWE190_Integer_Overflow__short_fscanf_postinc_64a.c,"    short data;
    data = 0;
    
    fscanf (stdin, ""%hd"", &data);
"
6194,0,CWE78_OS_Command_Injection__char_listen_socket_system_11.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(globalReturnsTrue())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                data[dataLen + recvResult / sizeof(char)] = '\0';
                
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
"
18611,0,CWE758_Undefined_Behavior__struct_new_use_16.cpp,"    while(1)
    {
        {
            twoIntsStruct * pointer = new twoIntsStruct;
            twoIntsStruct data = *pointer; 
            delete pointer;
            printIntLine(data.intOne);
            printIntLine(data.intTwo);
        }
        break;
"
13726,0,CWE190_Integer_Overflow__short_max_square_22a.c,"    short data;
    data = 0;
    
    data = SHRT_MAX;
    CWE190_Integer_Overflow__short_max_square_22_badGlobal = 1; 
"
7907,0,CWE590_Free_Memory_Not_on_Heap__free_long_alloca_10.c,"    long * data;
    data = NULL; 
    if(globalTrue)
    {
        {
            
            long * dataBuffer = (long *)ALLOCA(100*sizeof(long));
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5L;
                }
            }
            data = dataBuffer;
        }
    }
    printLongLine(data[0]);
    
"
9868,0,CWE415_Double_Free__new_delete_long_68a.cpp,"    long * data;
    
    data = NULL;
    data = new long;
    
    delete data;
    badData = data;
"
4140,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_45.c,"    size_t data;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = strtoul(inputBuffer, NULL, 0);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_45_badData = data;
"
6055,0,CWE690_NULL_Deref_From_Return__fopen_33.cpp,"    FILE * data;
    FILE * &dataRef = data;
    
    data = NULL;
    
    data = fopen(""file.txt"", ""w+"");
    {
        FILE * data = dataRef;
        
        fclose(data);
"
14956,0,CWE457_Use_of_Uninitialized_Variable__double_array_alloca_partial_init_04.c,"    double * data;
    data = (double *)ALLOCA(10*sizeof(double));
    if(STATIC_CONST_TRUE)
    {
        
        {
            int i;
            for(i=0; i<(10/2); i++)
            {
                data[i] = (double)i;
            }
        }
    }
    if(STATIC_CONST_TRUE)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printDoubleLine(data[i]);
            }
        }
"
14625,0,CWE190_Integer_Overflow__int64_t_max_postinc_12.c,"    int64_t data;
    data = 0LL;
    if(globalReturnsTrueOrFalse())
    {
        
        data = LLONG_MAX;
    }
    else
    {
        
        data = 2;
    }
    if(globalReturnsTrueOrFalse())
    {
        {
            
            data++;
            int64_t result = data;
            printLongLongLine(result);
        }
    }
    else
    {
        
        if (data < LLONG_MAX)
        {
            data++;
            int64_t result = data;
            printLongLongLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
"
15352,0,CWE134_Uncontrolled_Format_String__char_listen_socket_printf_41.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
12205,0,CWE190_Integer_Overflow__unsigned_int_rand_preinc_10.c,"    unsigned int data;
    data = 0;
    if(globalTrue)
    {
        
        data = (unsigned int)RAND32();
    }
    if(globalTrue)
    {
        {
            
            ++data;
            unsigned int result = data;
            printUnsignedLine(result);
        }
"
12317,0,CWE190_Integer_Overflow__short_rand_postinc_17.c,"    int i,j;
    short data;
    data = 0;
    for(i = 0; i < 1; i++)
    {
        
        data = (short)RAND32();
    }
    for(j = 0; j < 1; j++)
    {
        {
            
            data++;
            short result = data;
            printIntLine(result);
        }
"
3501,0,CWE590_Free_Memory_Not_on_Heap__free_char_declare_68a.c,"    char * data;
    data = NULL; 
    {
        
        char dataBuffer[100];
        memset(dataBuffer, 'A', 100-1); 
        dataBuffer[100-1] = '\0'; 
        data = dataBuffer;
    }
    CWE590_Free_Memory_Not_on_Heap__free_char_declare_68_badData = data;
"
14976,0,CWE590_Free_Memory_Not_on_Heap__delete_array_long_declare_08.cpp,"    long * data;
    data = NULL; 
    if(staticReturnsTrue())
    {
        {
            
            long dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5L;
                }
            }
            data = dataBuffer;
        }
    }
    printLongLine(data[0]);
    
"
11917,0,CWE190_Integer_Overflow__int64_t_fscanf_postinc_31.c,"    int64_t data;
    data = 0LL;
    
    fscanf (stdin, ""%"" SCNd64, &data);
    {
        int64_t dataCopy = data;
        int64_t data = dataCopy;
        {
            
            data++;
            int64_t result = data;
            printLongLongLine(result);
        }
"
18716,0,CWE590_Free_Memory_Not_on_Heap__delete_array_int64_t_alloca_16.cpp,"    int64_t * data;
    data = NULL; 
    while(1)
    {
        {
            
            int64_t * dataBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5LL;
                }
            }
            data = dataBuffer;
        }
        break;
    }
    printLongLongLine(data[0]);
    
"
3082,0,CWE190_Integer_Overflow__unsigned_int_max_multiply_82_bad.cpp,"Label Definition File: CWE190_Integer_Overflow.label.xml
Template File: sources-sinks-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 190 Integer Overflow
 * BadSource: max Set data to the max value for unsigned int
 * GoodSource: Set data to a small, non-zero number (two)
 * Sinks: multiply
 *    GoodSink: Ensure there will not be an overflow before multiplying data by 2
 *    BadSink : If data is positive, multiply by 2, which can cause an overflow
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE190_Integer_Overflow__unsigned_int_max_multiply_82.h""

namespace CWE190_Integer_Overflow__unsigned_int_max_multiply_82
{

void CWE190_Integer_Overflow__unsigned_int_max_multiply_82_bad::action(unsigned int data)
{
    if(data > 0) 
    {
        
        unsigned int result = data * 2;
        printUnsignedLine(result);
    }
}

}
"
12427,1,CWE758_Undefined_Behavior__char_pointer_malloc_use_05.c,"    if(staticFalse)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            char * data;
            char * * pointer = (char * *)malloc(sizeof(char *));
            if (pointer == NULL) {exit(-1);}
            data = ""string"";
            *pointer = data; 
            {
                char * data = *pointer;
                printLine(data);
            }
            free(pointer);
        }
"
8785,0,CWE758_Undefined_Behavior__int64_t_malloc_use_18.c,"    goto sink;
sink:
    {
        int64_t * pointer = (int64_t *)malloc(sizeof(int64_t));
        if (pointer == NULL) {exit(-1);}
        int64_t data = *pointer; 
        free(pointer);
        printLongLongLine(data);
"
17466,0,CWE134_Uncontrolled_Format_String__char_file_vprintf_84a.cpp,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    CWE134_Uncontrolled_Format_String__char_file_vprintf_84_bad * badObject = new CWE134_Uncontrolled_Format_String__char_file_vprintf_84_bad(data);
"
15934,0,CWE590_Free_Memory_Not_on_Heap__delete_int64_t_declare_04.cpp,"    int64_t * data;
    data = NULL; 
    if(STATIC_CONST_TRUE)
    {
        {
            
            int64_t dataBuffer;
            dataBuffer = 5LL;
            data = &dataBuffer;
        }
    }
    printLongLongLine(*data);
    
"
209,0,CWE590_Free_Memory_Not_on_Heap__delete_array_class_declare_12.cpp,"    TwoIntsClass * data;
    data = NULL; 
    if(globalReturnsTrueOrFalse())
    {
        {
            
            TwoIntsClass dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i].intOne = 1;
                    dataBuffer[i].intTwo = 1;
                }
            }
            data = dataBuffer;
        }
    }
    else
    {
        {
            
            TwoIntsClass * dataBuffer = new TwoIntsClass[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i].intOne = 1;
                    dataBuffer[i].intTwo = 1;
                }
            }
            data = dataBuffer;
        }
    }
    printIntLine(data[0].intOne);
    
"
9767,1,CWE252_Unchecked_Return_Value__char_putchar_17.c,"    int k;
    for(k = 0; k < 1; k++)
    {
        
        if (putchar((int)'A') == EOF)
        {
            printLine(""putchar failed!"");
        }
"
11928,0,CWE563_Unused_Variable__unused_init_variable_int64_t_83a.cpp,"    int64_t data;
"
11292,0,CWE401_Memory_Leak__char_realloc_15.c,"    char * data;
    data = NULL;
    switch(6)
    {
    case 6:
        
        data = (char *)realloc(data, 100*sizeof(char));
        if (data == NULL) {exit(-1);}
        
        strcpy(data, ""A String"");
        printLine(data);
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
        
        ; 
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
5581,1,CWE252_Unchecked_Return_Value__char_sscanf_13.c,"    if(GLOBAL_CONST_FIVE!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            
            if (sscanf(SRC, ""%99s\0"", data) == EOF)
            {
                printLine(""sscanf failed!"");
            }
        }
"
3981,0,CWE190_Integer_Overflow__unsigned_int_rand_multiply_16.c,"    unsigned int data;
    data = 0;
    while(1)
    {
        
        data = (unsigned int)RAND32();
        break;
    }
    while(1)
    {
        if(data > 0) 
        {
            
            unsigned int result = data * 2;
            printUnsignedLine(result);
        }
        break;
"
10470,0,CWE690_NULL_Deref_From_Return__char_realloc_82_bad.cpp,"Label Definition File: CWE690_NULL_Deref_From_Return.free.label.xml
Template File: source-sinks-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 690 Unchecked Return Value To NULL Pointer
 * BadSource: realloc Allocate data using realloc()
 * Sinks:
 *    GoodSink: Check to see if the data allocation failed and if not, use data
 *    BadSink : Don't check for NULL and use data
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE690_NULL_Deref_From_Return__char_realloc_82.h""

namespace CWE690_NULL_Deref_From_Return__char_realloc_82
{

void CWE690_NULL_Deref_From_Return__char_realloc_82_bad::action(char * data)
{
    
    strcpy(data, ""Initialize"");
    printLine(data);
    free(data);
}

}
"
5350,0,CWE457_Use_of_Uninitialized_Variable__int_array_alloca_no_init_14.c,"    int * data;
    data = (int *)ALLOCA(10*sizeof(int));
    if(globalFive==5)
    {
        
        ; 
    }
    if(globalFive==5)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i]);
            }
        }
"
12481,0,CWE457_Use_of_Uninitialized_Variable__new_int_array_no_init_05.cpp,"    int * data;
    data = new int[10];
    if(staticTrue)
    {
        
        ; 
    }
    if(staticTrue)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i]);
            }
        }
        
        delete [] data;
"
15189,0,CWE457_Use_of_Uninitialized_Variable__new_int_array_partial_init_16.cpp,"    int * data;
    data = new int[10];
    while(1)
    {
        
        {
            int i;
            for(i=0; i<(10/2); i++)
            {
                data[i] = i;
            }
        }
        break;
    }
    while(1)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i]);
            }
        }
        
        delete [] data;
        break;
"
6863,0,CWE401_Memory_Leak__char_realloc_67a.c,"    char * data;
    CWE401_Memory_Leak__char_realloc_67_structType myStruct;
    data = NULL;
    
    data = (char *)realloc(data, 100*sizeof(char));
    if (data == NULL) {exit(-1);}
    
    strcpy(data, ""A String"");
    printLine(data);
    myStruct.structFirst = data;
"
7219,0,CWE190_Integer_Overflow__unsigned_int_max_add_72a.cpp,"    unsigned int data;
    vector<unsigned int> dataVector;
    data = 0;
    
    data = UINT_MAX;
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
12260,0,CWE78_OS_Command_Injection__char_listen_socket_system_64a.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
1606,0,CWE401_Memory_Leak__int_malloc_67a.c,"    int * data;
    CWE401_Memory_Leak__int_malloc_67_structType myStruct;
    data = NULL;
    
    data = (int *)malloc(100*sizeof(int));
    if (data == NULL) {exit(-1);}
    
    data[0] = 5;
    printIntLine(data[0]);
    myStruct.structFirst = data;
"
16352,0,CWE369_Divide_by_Zero__int_fgets_divide_02.c,"    int data;
    
    data = -1;
    if(1)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    if(1)
    {
        
        printIntLine(100 / data);
"
11156,0,CWE369_Divide_by_Zero__int_fscanf_divide_33.cpp,"    int data;
    int &dataRef = data;
    
    data = -1;
    
    fscanf(stdin, ""%d"", &data);
    {
        int data = dataRef;
        
        printIntLine(100 / data);
"
12488,0,CWE190_Integer_Overflow__short_fscanf_add_42.c,"    short data;
    data = 0;
    data = badSource(data);
    {
        
        short result = data + 1;
        printIntLine(result);
"
15264,0,CWE78_OS_Command_Injection__char_console_execl_61a.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    data = CWE78_OS_Command_Injection__char_console_execl_61b_badSource(data);
    
    
    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}

#endif 

#ifndef OMITGOOD


char * CWE78_OS_Command_Injection__char_console_execl_61b_goodG2BSource(char * data);

static void goodG2B()
"
15354,0,CWE190_Integer_Overflow__short_fscanf_square_12.c,"    short data;
    data = 0;
    if(globalReturnsTrueOrFalse())
    {
        
        fscanf (stdin, ""%hd"", &data);
    }
    else
    {
        
        data = 2;
    }
    if(globalReturnsTrueOrFalse())
    {
        {
            
            short result = data * data;
            printIntLine(result);
        }
    }
    else
    {
        
        if (abs((long)data) <= (long)sqrt((double)SHRT_MAX))
        {
            short result = data * data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
"
19064,1,CWE252_Unchecked_Return_Value__char_fscanf_10.c,"    if(globalTrue)
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            
            if (fscanf(stdin, ""%99s\0"", data) == EOF)
            {
                printLine(""fscanf failed!"");
            }
        }
"
19531,0,CWE190_Integer_Overflow__int_fgets_square_18.c,"    int data;
    
    data = 0;
    goto source;
source:
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    goto sink;
sink:
    {
        
        int result = data * data;
        printIntLine(result);
"
15228,0,CWE401_Memory_Leak__new_TwoIntsClass_02.cpp,"    TwoIntsClass * data;
    data = NULL;
    if(1)
    {
        
        data = new TwoIntsClass;
        
        data->intOne = 0;
        data->intTwo = 0;
        printIntLine(data->intOne);
        printIntLine(data->intTwo);
    }
    if(1)
    {
        
        ; 
"
8842,0,CWE190_Integer_Overflow__unsigned_int_max_postinc_07.c,"    unsigned int data;
    data = 0;
    if(staticFive==5)
    {
        
        data = UINT_MAX;
    }
    if(staticFive==5)
    {
        {
            
            data++;
            unsigned int result = data;
            printUnsignedLine(result);
        }
"
5525,0,CWE190_Integer_Overflow__short_max_square_68a.c,"    short data;
    data = 0;
    
    data = SHRT_MAX;
    CWE190_Integer_Overflow__short_max_square_68_badData = data;
"
14824,0,CWE369_Divide_by_Zero__int_zero_divide_31.c,"    int data;
    
    data = -1;
    
    data = 0;
    {
        int dataCopy = data;
        int data = dataCopy;
        
        printIntLine(100 / data);
"
7501,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_33.cpp,"    size_t data;
    size_t &dataRef = data;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = strtoul(inputBuffer, NULL, 0);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    {
        size_t data = dataRef;
        {
            char * myString;
            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
             * for the strcpy() function to not cause a buffer overflow */
            
            if (data > strlen(HELLO_STRING))
            {
                myString = (char *)malloc(data*sizeof(char));
                if (myString == NULL) {exit(-1);}
                
                strcpy(myString, HELLO_STRING);
                printLine(myString);
                free(myString);
            }
            else
            {
                printLine(""Input is less than the length of the source string"");
            }
        }
"
8093,0,CWE688_Function_Call_With_Incorrect_Variable_or_Reference_as_Argument__basic_02.c,"    if(1)
    {
        {
            char dest[DEST_SIZE];
            int intFive = 5;
            
            sprintf(dest, ""%s"", intFive);
            printLine(dest);
        }
"
18811,1,CWE758_Undefined_Behavior__char_alloca_use_03.c,"    if(5!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            char data;
            char * pointer = (char *)ALLOCA(sizeof(char));
            data = 5;
            *pointer = data; 
            {
                char data = *pointer;
                printHexCharLine(data);
            }
        }
"
10257,0,CWE134_Uncontrolled_Format_String__char_console_fprintf_01.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        
        if (100-dataLen > 1)
        {
            
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgets() */
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
                    data[dataLen-1] = '\0';
                }
            }
            else
            {
                printLine(""fgets() failed"");
                
                data[dataLen] = '\0';
            }
        }
    }
    
"
9233,0,CWE690_NULL_Deref_From_Return__long_realloc_84a.cpp,"    long * data;
    data = NULL; 
    CWE690_NULL_Deref_From_Return__long_realloc_84_bad * badObject = new CWE690_NULL_Deref_From_Return__long_realloc_84_bad(data);
"
6310,1,CWE476_NULL_Pointer_Dereference__deref_after_check_11.c,"    if(globalReturnsFalse())
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            
            int *intPointer = NULL;
            if (intPointer == NULL)
            {
                printLine(""pointer is NULL"");
            }
        }
"
16840,0,CWE190_Integer_Overflow__unsigned_int_rand_postinc_44.c,"    unsigned int data;
    
    void (*funcPtr) (unsigned int) = badSink;
    data = 0;
    
    data = (unsigned int)RAND32();
    
"
14948,0,CWE78_OS_Command_Injection__char_environment_execl_64a.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        
        if (environment != NULL)
        {
            
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
"
18681,0,CWE416_Use_After_Free__malloc_free_char_09.c,"    char * data;
    
    data = NULL;
    if(GLOBAL_CONST_TRUE)
    {
        data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        memset(data, 'A', 100-1);
        data[100-1] = '\0';
        
        free(data);
    }
    if(GLOBAL_CONST_TRUE)
    {
        
        printLine(data);
        
"
10263,0,CWE78_OS_Command_Injection__char_connect_socket_execlp_08.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(staticReturnsTrue())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET connectSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
"
19258,1,CWE476_NULL_Pointer_Dereference__deref_after_check_07.c,"    if(staticFive==5)
    {
        {
            
            int *intPointer = NULL;
            if (intPointer == NULL)
            {
                printLine(""pointer is NULL"");
            }
        }
"
13942,1,CWE469_Use_of_Pointer_Subtraction_to_Determine_Size__char_04.c,"    if(STATIC_CONST_FALSE)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            char string1[] = SOURCE_STRING;
            char * slashInString1;
            size_t indexOfSlashInString1;
            slashInString1 = strchr(string1, '/');
            if (slashInString1 == NULL)
            {
                exit(1);
            }
            
            indexOfSlashInString1 = (size_t)(slashInString1 - string1);
            
            printUnsignedLine(indexOfSlashInString1);
        }
"
3469,1,CWE252_Unchecked_Return_Value__char_fputc_03.c,"    if(5==5)
    {
        
        if (fputc((int)'A', stdout) == EOF)
        {
            printLine(""fputc failed!"");
        }
"
6536,0,CWE78_OS_Command_Injection__char_listen_socket_system_05.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(staticTrue)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                data[dataLen + recvResult / sizeof(char)] = '\0';
                
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
"
4833,0,CWE190_Integer_Overflow__unsigned_int_rand_square_32.c,"    unsigned int data;
    unsigned int *dataPtr1 = &data;
    unsigned int *dataPtr2 = &data;
    data = 0;
    {
        unsigned int data = *dataPtr1;
        
        data = (unsigned int)RAND32();
        *dataPtr1 = data;
    }
    {
        unsigned int data = *dataPtr2;
        {
            
            unsigned int result = data * data;
            printUnsignedLine(result);
        }
"
18977,1,CWE758_Undefined_Behavior__char_malloc_use_05.c,"    if(staticFalse)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            char data;
            char * pointer = (char *)malloc(sizeof(char));
            if (pointer == NULL) {exit(-1);}
            data = 5;
            *pointer = data; 
            {
                char data = *pointer;
                printHexCharLine(data);
            }
            free(pointer);
        }
"
9462,0,CWE190_Integer_Overflow__unsigned_int_max_multiply_17.c,"    int i,j;
    unsigned int data;
    data = 0;
    for(i = 0; i < 1; i++)
    {
        
        data = UINT_MAX;
    }
    for(j = 0; j < 1; j++)
    {
        if(data > 0) 
        {
            
            unsigned int result = data * 2;
            printUnsignedLine(result);
        }
"
11425,1,CWE416_Use_After_Free__return_freed_ptr_03.c,"    if(5==5)
    {
        {
            
            char * reversedString = helperGood(""GoodSink"");
            printLine(reversedString);
            /* free(reversedString);
             * This call to free() was removed because we want the tool to detect the use after free,
             * but we don't want that function to be free(). Essentially we want to avoid a double free
             */
        }
"
3313,0,CWE369_Divide_by_Zero__int_fgets_divide_17.c,"    int i,j;
    int data;
    
    data = -1;
    for(i = 0; i < 1; i++)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    for(j = 0; j < 1; j++)
    {
        
        printIntLine(100 / data);
"
17136,0,CWE590_Free_Memory_Not_on_Heap__free_char_declare_01.c,"    char * data;
    data = NULL; 
    {
        
        char dataBuffer[100];
        memset(dataBuffer, 'A', 100-1); 
        dataBuffer[100-1] = '\0'; 
        data = dataBuffer;
    }
    printLine(data);
    
"
16913,0,CWE190_Integer_Overflow__char_rand_add_18.c,"    char data;
    data = ' ';
    goto source;
source:
    
    data = (char)RAND32();
    goto sink;
sink:
    {
        
        char result = data + 1;
        printHexCharLine(result);
"
932,0,CWE78_OS_Command_Injection__char_connect_socket_execl_66a.c,"    char * data;
    char * dataArray[5];
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
    dataArray[2] = data;
"
3639,0,CWE197_Numeric_Truncation_Error__int_fgets_to_char_08.c,"    int data;
    
    data = -1;
    if(staticReturnsTrue())
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
304,0,CWE401_Memory_Leak__new_char_02.cpp,"    char * data;
    data = NULL;
    if(1)
    {
        
        data = new char;
        
        *data = 'A';
        printHexCharLine(*data);
    }
    if(1)
    {
        
        ; 
"
9394,0,CWE758_Undefined_Behavior__int64_t_alloca_use_13.c,"    if(GLOBAL_CONST_FIVE==5)
    {
        {
            int64_t * pointer = (int64_t *)ALLOCA(sizeof(int64_t));
            int64_t data = *pointer; 
            printLongLongLine(data);
        }
"
11038,0,CWE190_Integer_Overflow__short_max_multiply_72a.cpp,"    short data;
    vector<short> dataVector;
    data = 0;
    
    data = SHRT_MAX;
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
14887,0,CWE190_Integer_Overflow__int_fgets_square_07.c,"    int data;
    
    data = 0;
    if(staticFive==5)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    if(staticFive==5)
    {
        {
            
            int result = data * data;
            printIntLine(result);
        }
"
13260,0,CWE197_Numeric_Truncation_Error__int_large_to_char_54a.c,"    int data;
    
    data = -1;
    
    data = SHRT_MAX + 5;
"
15078,0,CWE476_NULL_Pointer_Dereference__long_45.c,"    long * data;
    
    data = NULL;
    CWE476_NULL_Pointer_Dereference__long_45_badData = data;
"
12147,1,CWE252_Unchecked_Return_Value__char_puts_18.c,"    goto sink;
sink:
    
    if (PUTS(""string"") == EOF)
    {
        printLine(""puts failed!"");
"
11465,0,CWE416_Use_After_Free__new_delete_int_07.cpp,"    int * data;
    
    data = NULL;
    if(staticFive==5)
    {
        data = new int;
        *data = 5;
        
        delete data;
    }
    if(staticFive==5)
    {
        
        printIntLine(*data);
        
"
14383,0,CWE690_NULL_Deref_From_Return__fopen_64a.c,"    FILE * data;
    
    data = NULL;
    
    data = fopen(""file.txt"", ""w+"");
"
17342,0,CWE416_Use_After_Free__new_delete_struct_01.cpp,"    twoIntsStruct * data;
    
    data = NULL;
    data = new twoIntsStruct;
    data->intOne = 1;
    data->intTwo = 2;
    
    delete data;
    
    printStructLine(data);
"
12268,1,CWE758_Undefined_Behavior__int_pointer_alloca_use_02.c,"    if(1)
    {
        {
            int * data;
            int * * pointer = (int * *)ALLOCA(sizeof(int *));
            
            data = (int *)malloc(sizeof(int));
            if (data == NULL) {exit(-1);}
            *data = 5;
            *pointer = data; 
            {
                int * data = *pointer;
                printIntLine(*data);
            }
        }
"
3517,0,CWE78_OS_Command_Injection__char_environment_execlp_05.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(staticTrue)
    {
        {
            
            size_t dataLen = strlen(data);
            char * environment = GETENV(ENV_VARIABLE);
            
            if (environment != NULL)
            {
                
                strncat(data+dataLen, environment, 100-dataLen-1);
            }
        }
    }
    /* execlp - searches for the location of the command among
     * the directories specified by the PATH environment variable */
    
"
5496,0,CWE78_OS_Command_Injection__char_file_execlp_64a.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        FILE * pFile;
        
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
"
11372,0,CWE758_Undefined_Behavior__int_malloc_use_17.c,"    int j;
    for(j = 0; j < 1; j++)
    {
        {
            int * pointer = (int *)malloc(sizeof(int));
            if (pointer == NULL) {exit(-1);}
            int data = *pointer; 
            free(pointer);
            printIntLine(data);
        }
"
2266,0,CWE563_Unused_Variable__unused_value_int64_t_07.c,"    int64_t data;
    if(staticFive==5)
    {
        
        data = 5LL;
    }
    if(staticFive==5)
    {
        
        data = 10LL;
        printLongLongLine(data);
"
2471,0,CWE590_Free_Memory_Not_on_Heap__delete_array_char_static_72a.cpp,"    char * data;
    vector<char *> dataVector;
    data = NULL; 
    {
        
        static char dataBuffer[100];
        memset(dataBuffer, 'A', 100-1); 
        dataBuffer[100-1] = '\0'; 
        data = dataBuffer;
    }
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
14266,0,CWE197_Numeric_Truncation_Error__short_connect_socket_15.c,"    short data;
    
    data = -1;
    switch(6)
    {
    case 6:
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = (short)atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
10668,0,CWE665_Improper_Initialization__char_ncat_64a.c,"    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    
    ; 
"
7660,0,CWE190_Integer_Overflow__char_rand_preinc_44.c,"    char data;
    
    void (*funcPtr) (char) = badSink;
    data = ' ';
    
    data = (char)RAND32();
    
"
10953,0,CWE190_Integer_Overflow__short_max_preinc_15.c,"    short data;
    data = 0;
    switch(6)
    {
    case 6:
        
        data = SHRT_MAX;
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
    {
        
        ++data;
        short result = data;
        printIntLine(result);
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
19530,0,CWE563_Unused_Variable__unused_init_variable_int64_t_15.c,"    int64_t data;
    
    data = 5LL;
    switch(6)
    {
    case 6:
        
        
        ; 
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
14401,0,CWE457_Use_of_Uninitialized_Variable__twointsclass_array_declare_partial_init_09.cpp,"    TwoIntsClass * data;
    TwoIntsClass dataUninitArray[10];
    data = dataUninitArray;
    if(GLOBAL_CONST_TRUE)
    {
        
        for(int i=0; i<(10/2); i++)
        {
            data[i].intOne = i;
            data[i].intTwo = i;
        }
    }
    if(GLOBAL_CONST_TRUE)
    {
        
        for(int i=0; i<10; i++)
        {
            printIntLine(data[i].intOne);
            printIntLine(data[i].intTwo);
        }
"
6812,0,CWE197_Numeric_Truncation_Error__int_rand_to_char_61a.c,"    int data;
    
    data = -1;
    data = CWE197_Numeric_Truncation_Error__int_rand_to_char_61b_badSource(data);
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
10966,0,CWE190_Integer_Overflow__char_max_multiply_61a.c,"    char data;
    data = ' ';
    data = CWE190_Integer_Overflow__char_max_multiply_61b_badSource(data);
    if(data > 0) 
    {
        
        char result = data * 2;
        printHexCharLine(result);
"
6507,0,CWE369_Divide_by_Zero__int_zero_modulo_18.c,"    int data;
    
    data = -1;
    goto source;
source:
    
    data = 0;
    goto sink;
sink:
    
"
5117,0,CWE190_Integer_Overflow__int64_t_rand_add_64a.c,"    int64_t data;
    data = 0LL;
    
    data = (int64_t)RAND64();
"
11371,0,CWE416_Use_After_Free__new_delete_array_long_18.cpp,"    long * data;
    
    data = NULL;
    goto source;
source:
    data = new long[100];
    {
        size_t i;
        for(i = 0; i < 100; i++)
        {
            data[i] = 5L;
        }
    }
    
    delete [] data;
    goto sink;
sink:
    
    printLongLine(data[0]);
"
15034,0,CWE78_OS_Command_Injection__char_file_system_53a.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
        
        size_t dataLen = strlen(data);
        FILE * pFile;
        
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
"
6030,0,CWE190_Integer_Overflow__int64_t_max_add_82a.cpp,"    int64_t data;
    data = 0LL;
    
    data = LLONG_MAX;
    CWE190_Integer_Overflow__int64_t_max_add_82_base* baseObject = new CWE190_Integer_Overflow__int64_t_max_add_82_bad;
    baseObject->action(data);
"
11553,0,CWE416_Use_After_Free__malloc_free_int_64a.c,"    int * data;
    
    data = NULL;
    data = (int *)malloc(100*sizeof(int));
    if (data == NULL) {exit(-1);}
    {
        size_t i;
        for(i = 0; i < 100; i++)
        {
            data[i] = 5;
        }
    }
    
    free(data);
"
8112,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_02.c,"    size_t data;
    
    data = 0;
    if(1)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = strtoul(inputBuffer, NULL, 0);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(1)
    {
        {
            char * myString;
            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
             * for the strcpy() function to not cause a buffer overflow */
            
            if (data > strlen(HELLO_STRING))
            {
                myString = (char *)malloc(data*sizeof(char));
                if (myString == NULL) {exit(-1);}
                
                strcpy(myString, HELLO_STRING);
                printLine(myString);
                free(myString);
            }
            else
            {
                printLine(""Input is less than the length of the source string"");
            }
        }
"
9856,0,CWE134_Uncontrolled_Format_String__char_connect_socket_printf_17.c,"    int i,j;
    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    for(i = 0; i < 1; i++)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET connectSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                
                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                data[dataLen + recvResult / sizeof(char)] = '\0';
                
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    for(j = 0; j < 1; j++)
    {
        
        printf(data);
"
5007,0,CWE190_Integer_Overflow__int64_t_fscanf_square_18.c,"    int64_t data;
    data = 0LL;
    goto source;
source:
    
    fscanf (stdin, ""%"" SCNd64, &data);
    goto sink;
sink:
    {
        
        int64_t result = data * data;
        printLongLongLine(result);
"
13040,0,CWE590_Free_Memory_Not_on_Heap__delete_struct_placement_new_06.cpp,"    twoIntsStruct * data;
    data = NULL; 
    if(STATIC_CONST_FIVE==5)
    {
        {
            
            char buffer[sizeof(twoIntsStruct)];
            twoIntsStruct * dataBuffer = new(buffer) twoIntsStruct;
            dataBuffer->intOne = 1;
            dataBuffer->intTwo = 1;
            data = dataBuffer;
        }
    }
    printStructLine(data);
    
"
8174,0,CWE467_Use_of_sizeof_on_Pointer_Type__char_08.c,"    if(staticReturnsTrue())
    {
        {
            char * badChar = NULL;
            
            badChar = (char *)malloc(sizeof(badChar));
            if (badChar == NULL) {exit(-1);}
            *badChar = 'B';
            printHexCharLine(*badChar);
            free(badChar);
        }
"
17366,0,CWE197_Numeric_Truncation_Error__int_rand_to_char_63a.c,"    int data;
    
    data = -1;
    
    data = RAND32();
"
7785,1,CWE758_Undefined_Behavior__long_alloca_use_18.c,"    goto sink;
sink:
    {
        long data;
        long * pointer = (long *)ALLOCA(sizeof(long));
        data = 5L;
        *pointer = data; 
        {
            long data = *pointer;
            printLongLine(data);
        }
"
3213,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_45.c,"    size_t data;
    
    data = 0;
    
    fscanf(stdin, ""%zu"", &data);
    CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_45_badData = data;
"
18560,0,CWE457_Use_of_Uninitialized_Variable__int_array_malloc_no_init_07.c,"    int * data;
    data = (int *)malloc(10*sizeof(int));
    if (data == NULL) {exit(-1);}
    if(staticFive==5)
    {
        
        ; 
    }
    if(staticFive==5)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i]);
            }
        }
"
1800,0,CWE476_NULL_Pointer_Dereference__char_08.c,"    char * data;
    if(staticReturnsTrue())
    {
        
        data = NULL;
    }
    if(staticReturnsTrue())
    {
        
        
        printHexCharLine(data[0]);
"
7172,0,CWE190_Integer_Overflow__char_fscanf_multiply_21.c,"    char data;
    data = ' ';
    
    fscanf (stdin, ""%c"", &data);
    badStatic = 1; 
"
19050,0,CWE401_Memory_Leak__int64_t_calloc_82_bad.cpp,"Label Definition File: CWE401_Memory_Leak.c.label.xml
Template File: sources-sinks-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 401 Memory Leak
 * BadSource: calloc Allocate data using calloc()
 * GoodSource: Allocate data on the stack
 * Sinks:
 *    GoodSink: call free() on data
 *    BadSink : no deallocation of data
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE401_Memory_Leak__int64_t_calloc_82.h""

namespace CWE401_Memory_Leak__int64_t_calloc_82
{

void CWE401_Memory_Leak__int64_t_calloc_82_bad::action(int64_t * data)
{
    
    ; 
}

}
"
4268,0,CWE401_Memory_Leak__malloc_realloc_int64_t_03.c,"    if(5==5)
    {
        {
            int64_t * data = (int64_t *)malloc(100*sizeof(int64_t));
            if (data == NULL) {exit(-1);}
            
            data[0] = 5LL;
            printLongLongLine(data[0]);
            
            data = (int64_t *)realloc(data, (130000)*sizeof(int64_t));
            if (data != NULL)
            {
                
                data[0] = 10LL;
                printLongLongLine(data[0]);
                free(data);
            }
        }
"
17003,0,CWE457_Use_of_Uninitialized_Variable__twointsclass_array_declare_no_init_64a.cpp,"    TwoIntsClass * data;
    TwoIntsClass dataUninitArray[10];
    data = dataUninitArray;
    
    ; 
"
17386,0,CWE590_Free_Memory_Not_on_Heap__free_int64_t_declare_63a.c,"    int64_t * data;
    data = NULL; 
    {
        
        int64_t dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5LL;
            }
        }
        data = dataBuffer;
    }
"
339,0,CWE190_Integer_Overflow__int_connect_socket_postinc_32.c,"    int data;
    int *dataPtr1 = &data;
    int *dataPtr2 = &data;
    
    data = 0;
    {
        int data = *dataPtr1;
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
        *dataPtr1 = data;
    }
    {
        int data = *dataPtr2;
        {
            
            data++;
            int result = data;
            printIntLine(result);
        }
"
8132,0,CWE401_Memory_Leak__int_malloc_83_bad.cpp,"Label Definition File: CWE401_Memory_Leak.c.label.xml
Template File: sources-sinks-83_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 401 Memory Leak
 * BadSource: malloc Allocate data using malloc()
 * GoodSource: Allocate data on the stack
 * Sinks:
 *    GoodSink: call free() on data
 *    BadSink : no deallocation of data
 * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE401_Memory_Leak__int_malloc_83.h""

namespace CWE401_Memory_Leak__int_malloc_83
{
CWE401_Memory_Leak__int_malloc_83_bad::CWE401_Memory_Leak__int_malloc_83_bad(int * dataCopy)
{
    data = dataCopy;
    
    data = (int *)malloc(100*sizeof(int));
    if (data == NULL) {exit(-1);}
    
    data[0] = 5;
    printIntLine(data[0]);
}

CWE401_Memory_Leak__int_malloc_83_bad::~CWE401_Memory_Leak__int_malloc_83_bad()
{
    
    ; 
}
}
"
13076,0,CWE78_OS_Command_Injection__char_console_system_83_bad.cpp,"Label Definition File: CWE78_OS_Command_Injection.one_string.label.xml
Template File: sources-sink-83_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 78 OS Command Injection
 * BadSource: console Read input from the console
 * GoodSource: Fixed string
 * Sinks: system
 *    BadSink : Execute command in data using system()
 * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE78_OS_Command_Injection__char_console_system_83.h""
"
17153,0,CWE758_Undefined_Behavior__long_new_use_03.cpp,"    if(5==5)
    {
        {
            long * pointer = new long;
            long data = *pointer; 
            delete pointer;
            printLongLine(data);
        }
"
634,0,CWE252_Unchecked_Return_Value__char_rename_10.c,"    if(globalTrue)
    {
        
        RENAME(OLD_BAD_FILE_NAME, ""newbadfilename.txt"");
"
17158,0,CWE457_Use_of_Uninitialized_Variable__struct_array_alloca_partial_init_11.c,"    twoIntsStruct * data;
    data = (twoIntsStruct *)ALLOCA(10*sizeof(twoIntsStruct));
    if(globalReturnsTrue())
    {
        
        {
            int i;
            for(i=0; i<(10/2); i++)
            {
                data[i].intOne = i;
                data[i].intTwo = i;
            }
        }
    }
    if(globalReturnsTrue())
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i].intOne);
                printIntLine(data[i].intTwo);
            }
        }
"
17830,0,CWE190_Integer_Overflow__int_rand_add_11.c,"    int data;
    
    data = 0;
    if(globalReturnsTrue())
    {
        
        data = RAND32();
    }
    if(globalReturnsTrue())
    {
        {
            
            int result = data + 1;
            printIntLine(result);
        }
"
6771,0,CWE401_Memory_Leak__int64_t_malloc_13.c,"    int64_t * data;
    data = NULL;
    if(GLOBAL_CONST_FIVE==5)
    {
        
        data = (int64_t *)malloc(100*sizeof(int64_t));
        if (data == NULL) {exit(-1);}
        
        data[0] = 5LL;
        printLongLongLine(data[0]);
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        
        ; 
"
19167,0,CWE78_OS_Command_Injection__char_environment_system_16.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    while(1)
    {
        {
            
            size_t dataLen = strlen(data);
            char * environment = GETENV(ENV_VARIABLE);
            
            if (environment != NULL)
            {
                
                strncat(data+dataLen, environment, 100-dataLen-1);
            }
        }
        break;
    }
    
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
"
15823,0,CWE190_Integer_Overflow__char_rand_preinc_61a.c,"    char data;
    data = ' ';
    data = CWE190_Integer_Overflow__char_rand_preinc_61b_badSource(data);
    {
        
        ++data;
        char result = data;
        printHexCharLine(result);
"
6971,0,CWE457_Use_of_Uninitialized_Variable__struct_pointer_01.c,"    twoIntsStruct * data;
    
    ; 
    
    printIntLine(data->intOne);
"
15094,0,CWE416_Use_After_Free__return_freed_ptr_13.c,"    if(GLOBAL_CONST_FIVE==5)
    {
        {
            
            char * reversedString = helperBad(""BadSink"");
            printLine(reversedString);
            /* free(reversedString);
             * This call to free() was removed because we want the tool to detect the use after free,
             * but we don't want that function to be free(). Essentially we want to avoid a double free
             */
        }
"
8967,0,CWE690_NULL_Deref_From_Return__long_realloc_09.c,"    long * data;
    data = NULL; 
    
    data = (long *)realloc(data, 1*sizeof(long));
    if(GLOBAL_CONST_TRUE)
    {
        
        data[0] = 5L;
        printLongLine(data[0]);
        free(data);
"
12046,0,CWE590_Free_Memory_Not_on_Heap__delete_array_int64_t_static_05.cpp,"    int64_t * data;
    data = NULL; 
    if(staticTrue)
    {
        {
            
            static int64_t dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5LL;
                }
            }
            data = dataBuffer;
        }
    }
    printLongLongLine(data[0]);
    
"
142,0,CWE190_Integer_Overflow__int_connect_socket_multiply_12.c,"    int data;
    
    data = 0;
    if(globalReturnsTrueOrFalse())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    else
    {
        
        data = 2;
    }
    if(globalReturnsTrueOrFalse())
    {
        if(data > 0) 
        {
            
            int result = data * 2;
            printIntLine(result);
        }
    }
    else
    {
        if(data > 0) 
        {
            
            if (data < (INT_MAX/2))
            {
                int result = data * 2;
                printIntLine(result);
            }
            else
            {
                printLine(""data value is too large to perform arithmetic safely."");
            }
        }
"
1032,0,CWE789_Uncontrolled_Mem_Alloc__new_char_fgets_15.cpp,"    size_t data;
    
    data = 0;
    switch(6)
    {
    case 6:
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = strtoul(inputBuffer, NULL, 0);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
    {
        char * myString;
        /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
         * for the strcpy() function to not cause a buffer overflow */
        
        if (data > strlen(HELLO_STRING))
        {
            myString = new char[data];
            
            strcpy(myString, HELLO_STRING);
            printLine(myString);
            delete [] myString;
        }
        else
        {
            printLine(""Input is less than the length of the source string"");
        }
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
5566,0,CWE590_Free_Memory_Not_on_Heap__free_struct_static_65a.c,"    twoIntsStruct * data;
    
    void (*funcPtr) (twoIntsStruct *) = CWE590_Free_Memory_Not_on_Heap__free_struct_static_65b_badSink;
    data = NULL; 
    {
        
        static twoIntsStruct dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i].intOne = 1;
                dataBuffer[i].intTwo = 1;
            }
        }
        data = dataBuffer;
    }
    
"
10873,0,CWE401_Memory_Leak__struct_twoIntsStruct_calloc_67a.c,"    struct _twoIntsStruct * data;
    CWE401_Memory_Leak__struct_twoIntsStruct_calloc_67_structType myStruct;
    data = NULL;
    
    data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));
    if (data == NULL) {exit(-1);}
    
    data[0].intOne = 0;
    data[0].intTwo = 0;
    printStructLine((twoIntsStruct *)&data[0]);
    myStruct.structFirst = data;
"
1831,0,CWE197_Numeric_Truncation_Error__int_large_to_short_81a.cpp,"    int data;
    
    data = -1;
    
    data = SHRT_MAX + 5;
    const CWE197_Numeric_Truncation_Error__int_large_to_short_81_base& baseObject = CWE197_Numeric_Truncation_Error__int_large_to_short_81_bad();
"
3707,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_44.c,"    size_t data;
    
    void (*funcPtr) (size_t) = badSink;
    
    data = 0;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = strtoul(inputBuffer, NULL, 0);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    
"
4475,0,CWE190_Integer_Overflow__short_rand_preinc_18.c,"    short data;
    data = 0;
    goto source;
source:
    
    data = (short)RAND32();
    goto sink;
sink:
    {
        
        ++data;
        short result = data;
        printIntLine(result);
"
4555,0,CWE401_Memory_Leak__char_realloc_68a.c,"    char * data;
    data = NULL;
    
    data = (char *)realloc(data, 100*sizeof(char));
    if (data == NULL) {exit(-1);}
    
    strcpy(data, ""A String"");
    printLine(data);
    CWE401_Memory_Leak__char_realloc_68_badData = data;
"
7861,0,CWE758_Undefined_Behavior__int_new_use_10.cpp,"    if(globalTrue)
    {
        {
            int * pointer = new int;
            int data = *pointer; 
            delete pointer;
            printIntLine(data);
        }
"
9091,0,CWE190_Integer_Overflow__int64_t_max_square_51a.c,"    int64_t data;
    data = 0LL;
    
    data = LLONG_MAX;
"
12632,0,CWE190_Integer_Overflow__int64_t_fscanf_add_01.c,"    int64_t data;
    data = 0LL;
    
    fscanf (stdin, ""%"" SCNd64, &data);
    {
        
        int64_t result = data + 1;
        printLongLongLine(result);
"
12659,0,CWE590_Free_Memory_Not_on_Heap__delete_array_int_static_65a.cpp,"    int * data;
    
    void (*funcPtr) (int *) = badSink;
    data = NULL; 
    {
        
        static int dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5;
            }
        }
        data = dataBuffer;
    }
    
"
7845,0,CWE401_Memory_Leak__new_array_int_54a.cpp,"    int * data;
    data = NULL;
    
    data = new int[100];
    
    data[0] = 5;
    printIntLine(data[0]);
"
11951,0,CWE590_Free_Memory_Not_on_Heap__delete_array_long_static_18.cpp,"    long * data;
    data = NULL; 
    goto source;
source:
    {
        
        static long dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5L;
            }
        }
        data = dataBuffer;
    }
    printLongLine(data[0]);
    
"
4752,0,CWE78_OS_Command_Injection__char_environment_popen_31.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
        
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        
        if (environment != NULL)
        {
            
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    {
        char * dataCopy = data;
        char * data = dataCopy;
        {
            FILE *pipe;
            
            pipe = POPEN(data, ""w"");
            if (pipe != NULL)
            {
                PCLOSE(pipe);
            }
        }
"
9804,0,CWE789_Uncontrolled_Mem_Alloc__new_char_listen_socket_64a.cpp,"    size_t data;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = strtoul(inputBuffer, NULL, 0);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
952,0,CWE563_Unused_Variable__unused_uninit_variable_struct_74a.cpp,"    twoIntsStruct data;
    map<int, twoIntsStruct> dataMap;
    
    ; 
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
13511,0,CWE789_Uncontrolled_Mem_Alloc__new_char_rand_10.cpp,"    size_t data;
    
    data = 0;
    if(globalTrue)
    {
        
        data = rand();
    }
    if(globalTrue)
    {
        {
            char * myString;
            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
             * for the strcpy() function to not cause a buffer overflow */
            
            if (data > strlen(HELLO_STRING))
            {
                myString = new char[data];
                
                strcpy(myString, HELLO_STRING);
                printLine(myString);
                delete [] myString;
            }
            else
            {
                printLine(""Input is less than the length of the source string"");
            }
        }
"
2868,1,CWE758_Undefined_Behavior__char_pointer_new_use_12.cpp,"    if(globalReturnsTrueOrFalse())
    {
        {
            char * data;
            data = ""string"";
            char * * pointer = new char *;
            *pointer = data; 
            {
                char * data = *pointer;
                printLine(data);
            }
            delete pointer;
        }
    }
    else
    {
        {
            char * data;
            data = ""string"";
            char * * pointer = new char *;
            *pointer = data; 
            {
                char * data = *pointer;
                printLine(data);
            }
            delete pointer;
        }
"
2736,0,CWE415_Double_Free__new_delete_array_struct_84a.cpp,"    twoIntsStruct * data;
    
    data = NULL;
    CWE415_Double_Free__new_delete_array_struct_84_bad * badObject = new CWE415_Double_Free__new_delete_array_struct_84_bad(data);
"
1763,0,CWE415_Double_Free__new_delete_array_struct_41.cpp,"    twoIntsStruct * data;
    
    data = NULL;
    data = new twoIntsStruct[100];
    
    delete [] data;
"
13311,0,CWE590_Free_Memory_Not_on_Heap__delete_int64_t_static_74a.cpp,"    int64_t * data;
    map<int, int64_t *> dataMap;
    data = NULL; 
    {
        
        static int64_t dataBuffer;
        dataBuffer = 5LL;
        data = &dataBuffer;
    }
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
596,0,CWE401_Memory_Leak__twoIntsStruct_realloc_44.c,"    twoIntsStruct * data;
    
    void (*funcPtr) (twoIntsStruct *) = badSink;
    data = NULL;
    
    data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));
    if (data == NULL) {exit(-1);}
    
    data[0].intOne = 0;
    data[0].intTwo = 0;
    printStructLine(&data[0]);
    
"
5627,0,CWE690_NULL_Deref_From_Return__int_calloc_54a.c,"    int * data;
    data = NULL; 
    
    data = (int *)calloc(1, sizeof(int));
"
2408,0,CWE190_Integer_Overflow__int_fscanf_postinc_68a.c,"    int data;
    
    data = 0;
    
    fscanf(stdin, ""%d"", &data);
    CWE190_Integer_Overflow__int_fscanf_postinc_68_badData = data;
"
18826,0,CWE590_Free_Memory_Not_on_Heap__delete_array_long_static_09.cpp,"    long * data;
    data = NULL; 
    if(GLOBAL_CONST_TRUE)
    {
        {
            
            static long dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5L;
                }
            }
            data = dataBuffer;
        }
    }
    printLongLine(data[0]);
    
"
18260,0,CWE590_Free_Memory_Not_on_Heap__delete_class_alloca_52a.cpp,"    TwoIntsClass * data;
    data = NULL; 
    {
        
        TwoIntsClass * dataBuffer = (TwoIntsClass *)ALLOCA(sizeof(TwoIntsClass));
        dataBuffer->intOne = 2;
        dataBuffer->intTwo = 2;
        data = dataBuffer;
    }
"
334,0,CWE190_Integer_Overflow__char_rand_square_43.cpp,"    char data;
    data = ' ';
    badSource(data);
    {
        
        char result = data * data;
        printHexCharLine(result);
"
17585,0,CWE78_OS_Command_Injection__char_environment_execl_33.cpp,"    char * data;
    char * &dataRef = data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        
        if (environment != NULL)
        {
            
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    {
        char * data = dataRef;
        
        
        EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
"
13923,0,CWE197_Numeric_Truncation_Error__int_fscanf_to_short_81a.cpp,"    int data;
    
    data = -1;
    
    fscanf(stdin, ""%d"", &data);
    const CWE197_Numeric_Truncation_Error__int_fscanf_to_short_81_base& baseObject = CWE197_Numeric_Truncation_Error__int_fscanf_to_short_81_bad();
"
18199,0,CWE690_NULL_Deref_From_Return__char_malloc_02.c,"    char * data;
    data = NULL; 
    
    data = (char *)malloc(20*sizeof(char));
    if(1)
    {
        
        strcpy(data, ""Initialize"");
        printLine(data);
        free(data);
"
16078,0,CWE590_Free_Memory_Not_on_Heap__free_struct_alloca_12.c,"    twoIntsStruct * data;
    data = NULL; 
    if(globalReturnsTrueOrFalse())
    {
        {
            
            twoIntsStruct * dataBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i].intOne = 1;
                    dataBuffer[i].intTwo = 1;
                }
            }
            data = dataBuffer;
        }
    }
    else
    {
        {
            
            twoIntsStruct * dataBuffer = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
            if (dataBuffer == NULL)
            {
                printLine(""malloc() failed"");
                exit(1);
            }
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i].intOne = 1;
                    dataBuffer[i].intTwo = 1;
                }
            }
            data = dataBuffer;
        }
    }
    printStructLine(&data[0]);
    
"
15282,0,CWE197_Numeric_Truncation_Error__int_listen_socket_to_short_21.c,"    int data;
    
    data = -1;
    badStatic = 1; 
    data = badSource(data);
    {
        
        short shortData = (short)data;
        printShortLine(shortData);
"
11493,0,CWE78_OS_Command_Injection__char_environment_execl_11.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(globalReturnsTrue())
    {
        {
            
            size_t dataLen = strlen(data);
            char * environment = GETENV(ENV_VARIABLE);
            
            if (environment != NULL)
            {
                
                strncat(data+dataLen, environment, 100-dataLen-1);
            }
        }
    }
    
    
"
4036,0,CWE134_Uncontrolled_Format_String__char_environment_fprintf_08.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(staticReturnsTrue())
    {
        {
            
            size_t dataLen = strlen(data);
            char * environment = GETENV(ENV_VARIABLE);
            
            if (environment != NULL)
            {
                
                strncat(data+dataLen, environment, 100-dataLen-1);
            }
        }
    }
    if(staticReturnsTrue())
    {
        
        fprintf(stdout, data);
"
12231,0,CWE78_OS_Command_Injection__char_file_system_11.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(globalReturnsTrue())
    {
        {
            
            size_t dataLen = strlen(data);
            FILE * pFile;
            
            if (100-dataLen > 1)
            {
                pFile = fopen(FILENAME, ""r"");
                if (pFile != NULL)
                {
                    
                    if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                    {
                        printLine(""fgets() failed"");
                        
                        data[dataLen] = '\0';
                    }
                    fclose(pFile);
                }
            }
        }
    }
    
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
"
4650,0,CWE252_Unchecked_Return_Value__char_fprintf_08.c,"    if(staticReturnsTrue())
    {
        
        fprintf(stdout, ""%s\n"", ""string"");
"
3804,0,CWE190_Integer_Overflow__int_max_square_81_bad.cpp,"Label Definition File: CWE190_Integer_Overflow__int.label.xml
Template File: sources-sinks-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 190 Integer Overflow
 * BadSource: max Set data to the max value for int
 * GoodSource: Set data to a small, non-zero number (two)
 * Sinks: square
 *    GoodSink: Ensure there will not be an overflow before squaring data
 *    BadSink : Square data, which can lead to overflow
 * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE190_Integer_Overflow__int_max_square_81.h""

#include <math.h>

namespace CWE190_Integer_Overflow__int_max_square_81
{

void CWE190_Integer_Overflow__int_max_square_81_bad::action(int data) const
{
    {
        
        int result = data * data;
        printIntLine(result);
    }
}

}
"
15615,0,CWE78_OS_Command_Injection__char_connect_socket_system_62a.cpp,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    badSource(data);
    
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
    }
}

#endif 

#ifndef OMITGOOD


"
16358,0,CWE401_Memory_Leak__struct_twoIntsStruct_calloc_82_bad.cpp,"Label Definition File: CWE401_Memory_Leak.c.label.xml
Template File: sources-sinks-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 401 Memory Leak
 * BadSource: calloc Allocate data using calloc()
 * GoodSource: Allocate data on the stack
 * Sinks:
 *    GoodSink: call free() on data
 *    BadSink : no deallocation of data
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE401_Memory_Leak__struct_twoIntsStruct_calloc_82.h""

namespace CWE401_Memory_Leak__struct_twoIntsStruct_calloc_82
{

void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_82_bad::action(struct _twoIntsStruct * data)
{
    
    ; 
}

}
"
9011,0,CWE190_Integer_Overflow__int64_t_fscanf_square_82a.cpp,"    int64_t data;
    data = 0LL;
    
    fscanf (stdin, ""%"" SCNd64, &data);
    CWE190_Integer_Overflow__int64_t_fscanf_square_82_base* baseObject = new CWE190_Integer_Overflow__int64_t_fscanf_square_82_bad;
    baseObject->action(data);
"
10513,0,CWE590_Free_Memory_Not_on_Heap__delete_int_placement_new_05.cpp,"    int * data;
    data = NULL; 
    if(staticTrue)
    {
        {
            
            char buffer[sizeof(int)];
            int * dataBuffer = new(buffer) int;
            *dataBuffer = 5;
            data = dataBuffer;
        }
    }
    printIntLine(*data);
    
"
6980,0,CWE78_OS_Command_Injection__char_console_execl_13.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            
            size_t dataLen = strlen(data);
            
            if (100-dataLen > 1)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
                {
                    /* The next few lines remove the carriage return from the string that is
                     * inserted by fgets() */
                    dataLen = strlen(data);
"
12852,0,CWE590_Free_Memory_Not_on_Heap__delete_long_static_52a.cpp,"    long * data;
    data = NULL; 
    {
        
        static long dataBuffer;
        dataBuffer = 5L;
        data = &dataBuffer;
    }
"
15493,0,CWE590_Free_Memory_Not_on_Heap__delete_array_long_alloca_64a.cpp,"    long * data;
    data = NULL; 
    {
        
        long * dataBuffer = (long *)ALLOCA(100*sizeof(long));
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5L;
            }
        }
        data = dataBuffer;
    }
"
17167,0,CWE758_Undefined_Behavior__int_pointer_malloc_use_01.c,"    {
        int * * pointer = (int * *)malloc(sizeof(int *));
        if (pointer == NULL) {exit(-1);}
        int * data = *pointer; 
        free(pointer);
        printIntLine(*data);
"
8708,0,CWE190_Integer_Overflow__int_fgets_square_66a.c,"    int data;
    int dataArray[5];
    
    data = 0;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    
    dataArray[2] = data;
"
2755,0,CWE416_Use_After_Free__malloc_free_long_17.c,"    int i,j;
    long * data;
    
    data = NULL;
    for(i = 0; i < 1; i++)
    {
        data = (long *)malloc(100*sizeof(long));
        if (data == NULL) {exit(-1);}
        {
            size_t i;
            for(i = 0; i < 100; i++)
            {
                data[i] = 5L;
            }
        }
        
        free(data);
    }
    for(j = 0; j < 1; j++)
    {
        
        printLongLine(data[0]);
        
"
5831,0,CWE789_Uncontrolled_Mem_Alloc__new_char_rand_17.cpp,"    int i,j;
    size_t data;
    
    data = 0;
    for(i = 0; i < 1; i++)
    {
        
        data = rand();
    }
    for(j = 0; j < 1; j++)
    {
        {
            char * myString;
            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
             * for the strcpy() function to not cause a buffer overflow */
            
            if (data > strlen(HELLO_STRING))
            {
                myString = new char[data];
                
                strcpy(myString, HELLO_STRING);
                printLine(myString);
                delete [] myString;
            }
            else
            {
                printLine(""Input is less than the length of the source string"");
            }
        }
"
10338,0,CWE690_NULL_Deref_From_Return__int_calloc_07.c,"    int * data;
    data = NULL; 
    
    data = (int *)calloc(1, sizeof(int));
    if(staticFive==5)
    {
        
        data[0] = 5;
        printIntLine(data[0]);
        free(data);
"
5303,0,CWE190_Integer_Overflow__int64_t_max_square_84a.cpp,"    int64_t data;
    data = 0LL;
    CWE190_Integer_Overflow__int64_t_max_square_84_bad * badObject = new CWE190_Integer_Overflow__int64_t_max_square_84_bad(data);
"
5323,0,CWE665_Improper_Initialization__char_cat_03.c,"    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    if(5==5)
    {
        
        ; 
    }
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        
        strcat(data, source);
        printLine(data);
"
10598,1,CWE475_Undefined_Behavior_for_Input_to_API__char_04.c,"    if(STATIC_CONST_FALSE)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            strcpy(data, ""abcdefghijklmnopqrstuvwxyz"");
            
            memmove(data + 6, data + 4, 10*sizeof(char));
            printLine(data);
        }
"
8176,0,CWE590_Free_Memory_Not_on_Heap__delete_char_declare_15.cpp,"    char * data;
    data = NULL; 
    switch(6)
    {
    case 6:
    {
        
        char dataBuffer;
        dataBuffer = 'A';
        data = &dataBuffer;
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    printHexCharLine(*data);
    
"
1480,0,CWE134_Uncontrolled_Format_String__char_console_vprintf_42.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    data = badSource(data);
"
11628,0,CWE190_Integer_Overflow__int_fgets_square_61a.c,"    int data;
    
    data = 0;
    data = CWE190_Integer_Overflow__int_fgets_square_61b_badSource(data);
    {
        
        int result = data * data;
        printIntLine(result);
"
4078,0,CWE401_Memory_Leak__int_calloc_02.c,"    int * data;
    data = NULL;
    if(1)
    {
        
        data = (int *)calloc(100, sizeof(int));
        if (data == NULL) {exit(-1);}
        
        data[0] = 5;
        printIntLine(data[0]);
    }
    if(1)
    {
        
        ; 
"
13712,0,CWE369_Divide_by_Zero__float_fgets_72a.cpp,"    float data;
    vector<float> dataVector;
    
    data = 0.0F;
    {
        char inputBuffer[CHAR_ARRAY_SIZE];
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = (float)atof(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
6322,0,CWE415_Double_Free__malloc_free_int_04.c,"    int * data;
    
    data = NULL;
    if(STATIC_CONST_TRUE)
    {
        data = (int *)malloc(100*sizeof(int));
        if (data == NULL) {exit(-1);}
        
        free(data);
    }
    if(STATIC_CONST_TRUE)
    {
        
        free(data);
"
993,0,CWE416_Use_After_Free__new_delete_array_class_11.cpp,"    TwoIntsClass * data;
    
    data = NULL;
    if(globalReturnsTrue())
    {
        data = new TwoIntsClass[100];
        {
            size_t i;
            for(i = 0; i < 100; i++)
            {
                data[i].intOne = 1;
                data[i].intTwo = 2;
            }
        }
        
        delete [] data;
    }
    if(globalReturnsTrue())
    {
        
        printIntLine(data[0].intOne);
        
"
5281,0,CWE415_Double_Free__malloc_free_long_52a.c,"    long * data;
    
    data = NULL;
    data = (long *)malloc(100*sizeof(long));
    if (data == NULL) {exit(-1);}
    
    free(data);
"
8897,0,CWE190_Integer_Overflow__int_max_square_64a.c,"    int data;
    
    data = 0;
    
    data = INT_MAX;
"
1553,0,CWE190_Integer_Overflow__short_rand_add_84_bad.cpp,"Label Definition File: CWE190_Integer_Overflow.label.xml
Template File: sources-sinks-84_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 190 Integer Overflow
 * BadSource: rand Set data to result of rand()
 * GoodSource: Set data to a small, non-zero number (two)
 * Sinks: add
 *    GoodSink: Ensure there will not be an overflow before adding 1 to data
 *    BadSink : Add 1 to data, which can cause an overflow
 * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE190_Integer_Overflow__short_rand_add_84.h""

namespace CWE190_Integer_Overflow__short_rand_add_84
{
CWE190_Integer_Overflow__short_rand_add_84_bad::CWE190_Integer_Overflow__short_rand_add_84_bad(short dataCopy)
{
    data = dataCopy;
    
    data = (short)RAND32();
}

CWE190_Integer_Overflow__short_rand_add_84_bad::~CWE190_Integer_Overflow__short_rand_add_84_bad()
{
    {
        
        short result = data + 1;
        printIntLine(result);
    }
}
}
"
14107,0,CWE590_Free_Memory_Not_on_Heap__free_int_alloca_06.c,"    int * data;
    data = NULL; 
    if(STATIC_CONST_FIVE==5)
    {
        {
            
            int * dataBuffer = (int *)ALLOCA(100*sizeof(int));
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5;
                }
            }
            data = dataBuffer;
        }
    }
    printIntLine(data[0]);
    
"
11675,0,CWE369_Divide_by_Zero__float_fscanf_31.c,"    float data;
    
    data = 0.0F;
    
    fscanf (stdin, ""%f"", &data);
    {
        float dataCopy = data;
        float data = dataCopy;
        {
            
            int result = (int)(100.0 / data);
            printIntLine(result);
        }
"
4869,1,CWE476_NULL_Pointer_Dereference__null_check_after_deref_06.c,"    if(STATIC_CONST_FIVE==5)
    {
        {
            int *intPointer = NULL;
            intPointer = (int *)malloc(sizeof(int));
            *intPointer = 5;
            printIntLine(*intPointer);
            
            *intPointer = 10;
            printIntLine(*intPointer);
        }
"
15237,0,CWE190_Integer_Overflow__short_fscanf_square_14.c,"    short data;
    data = 0;
    if(globalFive==5)
    {
        
        fscanf (stdin, ""%hd"", &data);
    }
    if(globalFive==5)
    {
        {
            
            short result = data * data;
            printIntLine(result);
        }
"
19192,0,CWE415_Double_Free__malloc_free_long_32.c,"    long * data;
    long * *dataPtr1 = &data;
    long * *dataPtr2 = &data;
    
    data = NULL;
    {
        long * data = *dataPtr1;
        data = (long *)malloc(100*sizeof(long));
        if (data == NULL) {exit(-1);}
        
        free(data);
        *dataPtr1 = data;
    }
    {
        long * data = *dataPtr2;
        
        free(data);
"
1453,0,CWE590_Free_Memory_Not_on_Heap__delete_array_class_declare_54a.cpp,"    TwoIntsClass * data;
    data = NULL; 
    {
        
        TwoIntsClass dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i].intOne = 1;
                dataBuffer[i].intTwo = 1;
            }
        }
        data = dataBuffer;
    }
"
12931,0,CWE190_Integer_Overflow__char_fscanf_square_83_bad.cpp,"Label Definition File: CWE190_Integer_Overflow.label.xml
Template File: sources-sinks-83_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 190 Integer Overflow
 * BadSource: fscanf Read data from the console using fscanf()
 * GoodSource: Set data to a small, non-zero number (two)
 * Sinks: square
 *    GoodSink: Ensure there will not be an overflow before squaring data
 *    BadSink : Square data, which can lead to overflow
 * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE190_Integer_Overflow__char_fscanf_square_83.h""

#include <math.h>

namespace CWE190_Integer_Overflow__char_fscanf_square_83
{
CWE190_Integer_Overflow__char_fscanf_square_83_bad::CWE190_Integer_Overflow__char_fscanf_square_83_bad(char dataCopy)
{
    data = dataCopy;
    
    fscanf (stdin, ""%c"", &data);
}

CWE190_Integer_Overflow__char_fscanf_square_83_bad::~CWE190_Integer_Overflow__char_fscanf_square_83_bad()
{
    {
        
        char result = data * data;
        printHexCharLine(result);
    }
}
}
"
324,0,CWE590_Free_Memory_Not_on_Heap__delete_array_int_alloca_41.cpp,"    int * data;
    data = NULL; 
    {
        
        int * dataBuffer = (int *)ALLOCA(100*sizeof(int));
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5;
            }
        }
        data = dataBuffer;
    }
"
1725,0,CWE590_Free_Memory_Not_on_Heap__delete_int_alloca_52a.cpp,"    int * data;
    data = NULL; 
    {
        
        int * dataBuffer = (int *)ALLOCA(sizeof(int));
        *dataBuffer = 5;
        data = dataBuffer;
    }
"
9437,0,CWE415_Double_Free__new_delete_class_15.cpp,"    TwoIntsClass * data;
    
    data = NULL;
    switch(6)
    {
    case 6:
        data = new TwoIntsClass;
        
        delete data;
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
        
        delete data;
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
5489,0,CWE197_Numeric_Truncation_Error__int_rand_to_char_66a.c,"    int data;
    int dataArray[5];
    
    data = -1;
    
    data = RAND32();
    
    dataArray[2] = data;
"
3566,0,CWE190_Integer_Overflow__short_fscanf_postinc_07.c,"    short data;
    data = 0;
    if(staticFive==5)
    {
        
        fscanf (stdin, ""%hd"", &data);
    }
    if(staticFive==5)
    {
        {
            
            data++;
            short result = data;
            printIntLine(result);
        }
"
7456,1,CWE758_Undefined_Behavior__char_pointer_malloc_use_11.c,"    if(globalReturnsTrue())
    {
        {
            char * data;
            char * * pointer = (char * *)malloc(sizeof(char *));
            if (pointer == NULL) {exit(-1);}
            data = ""string"";
            *pointer = data; 
            {
                char * data = *pointer;
                printLine(data);
            }
            free(pointer);
        }
"
15645,0,CWE197_Numeric_Truncation_Error__short_connect_socket_21.c,"    short data;
    
    data = -1;
    badStatic = 1; 
    data = badSource(data);
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
4604,0,CWE476_NULL_Pointer_Dereference__class_41.cpp,"    TwoIntsClass * data;
    
    data = NULL;
"
15188,0,CWE369_Divide_by_Zero__int_zero_modulo_42.c,"    int data;
    
    data = -1;
    data = badSource(data);
    
"
7929,0,CWE415_Double_Free__malloc_free_int_82_bad.cpp,"Label Definition File: CWE415_Double_Free__malloc_free.label.xml
Template File: sources-sinks-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 415 Double Free
 * BadSource:  Allocate data using malloc() and Deallocate data using free()
 * GoodSource: Allocate data using malloc()
 * Sinks:
 *    GoodSink: do nothing
 *    BadSink : Deallocate data using free()
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE415_Double_Free__malloc_free_int_82.h""

namespace CWE415_Double_Free__malloc_free_int_82
{

void CWE415_Double_Free__malloc_free_int_82_bad::action(int * data)
{
    
    free(data);
}

}
"
19177,0,CWE789_Uncontrolled_Mem_Alloc__new_char_connect_socket_82_bad.cpp,"Label Definition File: CWE789_Uncontrolled_Mem_Alloc__new.label.xml
Template File: sources-sinks-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: connect_socket Read data using a connect socket (client side)
 * GoodSource: Small number greater than zero
 * Sinks:
 *    GoodSink: Allocate memory with new [] and check the size of the memory to be allocated
 *    BadSink : Allocate memory with new [], but incorrectly check the size of the memory to be allocated
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE789_Uncontrolled_Mem_Alloc__new_char_connect_socket_82.h""

#define HELLO_STRING ""hello""

namespace CWE789_Uncontrolled_Mem_Alloc__new_char_connect_socket_82
{

void CWE789_Uncontrolled_Mem_Alloc__new_char_connect_socket_82_bad::action(size_t data)
{
    {
        char * myString;
        /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
         * for the strcpy() function to not cause a buffer overflow */
        
        if (data > strlen(HELLO_STRING))
        {
            myString = new char[data];
            
            strcpy(myString, HELLO_STRING);
            printLine(myString);
            delete [] myString;
        }
        else
        {
            printLine(""Input is less than the length of the source string"");
        }
    }
}

}
"
17486,1,CWE416_Use_After_Free__return_freed_ptr_05.c,"    if(staticFalse)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            
            char * reversedString = helperGood(""GoodSink"");
            printLine(reversedString);
            /* free(reversedString);
             * This call to free() was removed because we want the tool to detect the use after free,
             * but we don't want that function to be free(). Essentially we want to avoid a double free
             */
        }
"
13278,0,CWE401_Memory_Leak__struct_twoIntsStruct_realloc_43.cpp,"    struct _twoIntsStruct * data;
    data = NULL;
    badSource(data);
    
"
14499,0,CWE415_Double_Free__new_delete_char_13.cpp,"    char * data;
    
    data = NULL;
    if(GLOBAL_CONST_FIVE==5)
    {
        data = new char;
        
        delete data;
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        
        delete data;
"
3299,0,CWE590_Free_Memory_Not_on_Heap__delete_char_placement_new_10.cpp,"    char * data;
    data = NULL; 
    if(globalTrue)
    {
        {
            
            char buffer[sizeof(char)];
            char * dataBuffer = new(buffer) char;
            *dataBuffer = 'A';
            data = dataBuffer;
        }
    }
    printHexCharLine(*data);
    
"
9368,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_61a.c,"    size_t data;
    
    data = 0;
    data = CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_61b_badSource(data);
    {
        char * myString;
        /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
         * for the strcpy() function to not cause a buffer overflow */
        
        if (data > strlen(HELLO_STRING))
        {
            myString = (char *)malloc(data*sizeof(char));
            if (myString == NULL) {exit(-1);}
            
            strcpy(myString, HELLO_STRING);
            printLine(myString);
            free(myString);
        }
        else
        {
            printLine(""Input is less than the length of the source string"");
        }
"
8129,0,CWE590_Free_Memory_Not_on_Heap__delete_array_int64_t_declare_73a.cpp,"    int64_t * data;
    list<int64_t *> dataList;
    data = NULL; 
    {
        
        int64_t dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5LL;
            }
        }
        data = dataBuffer;
    }
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
2351,0,CWE78_OS_Command_Injection__char_console_system_02.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(1)
    {
        {
            
            size_t dataLen = strlen(data);
            
            if (100-dataLen > 1)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
                {
                    /* The next few lines remove the carriage return from the string that is
                     * inserted by fgets() */
                    dataLen = strlen(data);
"
2262,0,CWE590_Free_Memory_Not_on_Heap__free_int_alloca_02.c,"    int * data;
    data = NULL; 
    if(1)
    {
        {
            
            int * dataBuffer = (int *)ALLOCA(100*sizeof(int));
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5;
                }
            }
            data = dataBuffer;
        }
    }
    printIntLine(data[0]);
    
"
10945,0,CWE190_Integer_Overflow__int64_t_max_multiply_07.c,"    int64_t data;
    data = 0LL;
    if(staticFive==5)
    {
        
        data = LLONG_MAX;
    }
    if(staticFive==5)
    {
        if(data > 0) 
        {
            
            int64_t result = data * 2;
            printLongLongLine(result);
        }
"
1440,0,CWE590_Free_Memory_Not_on_Heap__free_char_static_10.c,"    char * data;
    data = NULL; 
    if(globalTrue)
    {
        {
            
            static char dataBuffer[100];
            memset(dataBuffer, 'A', 100-1); 
            dataBuffer[100-1] = '\0'; 
            data = dataBuffer;
        }
    }
    printLine(data);
    
"
16363,0,CWE197_Numeric_Truncation_Error__int_fscanf_to_char_64a.c,"    int data;
    
    data = -1;
    
    fscanf(stdin, ""%d"", &data);
"
3612,0,CWE401_Memory_Leak__int64_t_malloc_81_bad.cpp,"Label Definition File: CWE401_Memory_Leak.c.label.xml
Template File: sources-sinks-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 401 Memory Leak
 * BadSource: malloc Allocate data using malloc()
 * GoodSource: Allocate data on the stack
 * Sinks:
 *    GoodSink: call free() on data
 *    BadSink : no deallocation of data
 * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE401_Memory_Leak__int64_t_malloc_81.h""

namespace CWE401_Memory_Leak__int64_t_malloc_81
{

void CWE401_Memory_Leak__int64_t_malloc_81_bad::action(int64_t * data) const
{
    
    ; 
}

}
"
11699,0,CWE590_Free_Memory_Not_on_Heap__delete_class_static_41.cpp,"    TwoIntsClass * data;
    data = NULL; 
    {
        
        static TwoIntsClass dataBuffer;
        dataBuffer.intOne = 1;
        dataBuffer.intTwo = 1;
        data = &dataBuffer;
    }
"
11843,0,CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_62a.cpp,"    unsigned int data;
    data = 0;
    badSource(data);
    if(data > 0) 
    {
        
        unsigned int result = data * 2;
        printUnsignedLine(result);
"
18975,0,CWE190_Integer_Overflow__int_rand_postinc_15.c,"    int data;
    
    data = 0;
    switch(6)
    {
    case 6:
        
        data = RAND32();
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
    {
        
        data++;
        int result = data;
        printIntLine(result);
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
13054,1,CWE467_Use_of_sizeof_on_Pointer_Type__char_17.c,"    int k;
    for(k = 0; k < 1; k++)
    {
        {
            char * goodChar = NULL;
            
            goodChar = (char *)malloc(sizeof(*goodChar));
            if (goodChar == NULL) {exit(-1);}
            *goodChar = 'G';
            printHexCharLine(*goodChar);
            free(goodChar);
        }
"
13974,0,CWE78_OS_Command_Injection__char_listen_socket_execl_82_bad.cpp,"Label Definition File: CWE78_OS_Command_Injection.strings.label.xml
Template File: sources-sink-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 78 OS Command Injection
 * BadSource: listen_socket Read data using a listen socket (server side)
 * GoodSource: Fixed string
 * Sinks: execl
 *    BadSink : execute command with execl
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE78_OS_Command_Injection__char_listen_socket_execl_82.h""

#ifdef _WIN32
#include <process.h>
#define EXECL _execl
#else 
#define EXECL execl
#endif

namespace CWE78_OS_Command_Injection__char_listen_socket_execl_82
{

void CWE78_OS_Command_Injection__char_listen_socket_execl_82_bad::action(char * data)
{
    
    
    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}

}
"
8480,0,CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_16.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    while(1)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                data[dataLen + recvResult / sizeof(char)] = '\0';
                
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
        break;
    }
    while(1)
    {
        badVaSinkB(data, data);
        break;
"
18375,0,CWE690_NULL_Deref_From_Return__int_malloc_09.c,"    int * data;
    data = NULL; 
    
    data = (int *)malloc(1*sizeof(int));
    if(GLOBAL_CONST_TRUE)
    {
        
        data[0] = 5;
        printIntLine(data[0]);
        free(data);
"
6319,0,CWE134_Uncontrolled_Format_String__char_console_printf_74a.cpp,"    char * data;
    map<int, char *> dataMap;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        
        if (100-dataLen > 1)
        {
            
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgets() */
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
                    data[dataLen-1] = '\0';
                }
            }
            else
            {
                printLine(""fgets() failed"");
                
                data[dataLen] = '\0';
            }
        }
    }
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
12235,0,CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_09.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(GLOBAL_CONST_TRUE)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                data[dataLen + recvResult / sizeof(char)] = '\0';
                
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(GLOBAL_CONST_TRUE)
    {
        badVaSinkB(data, data);
"
6737,0,CWE134_Uncontrolled_Format_String__char_file_printf_34.c,"    char * data;
    CWE134_Uncontrolled_Format_String__char_file_printf_34_unionType myUnion;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        FILE * pFile;
        
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
    myUnion.unionFirst = data;
    {
        char * data = myUnion.unionSecond;
        
        printf(data);
"
15696,0,CWE190_Integer_Overflow__int_rand_square_02.c,"    int data;
    
    data = 0;
    if(1)
    {
        
        data = RAND32();
    }
    if(1)
    {
        {
            
            int result = data * data;
            printIntLine(result);
        }
"
1459,0,CWE590_Free_Memory_Not_on_Heap__delete_int64_t_declare_01.cpp,"    int64_t * data;
    data = NULL; 
    {
        
        int64_t dataBuffer;
        dataBuffer = 5LL;
        data = &dataBuffer;
    }
    printLongLongLine(*data);
    
"
7391,0,CWE401_Memory_Leak__twoIntsStruct_realloc_21.c,"    twoIntsStruct * data;
    data = NULL;
    
    data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));
    if (data == NULL) {exit(-1);}
    
    data[0].intOne = 0;
    data[0].intTwo = 0;
    printStructLine(&data[0]);
    badStatic = 1; 
"
5203,0,CWE401_Memory_Leak__twoIntsStruct_calloc_53a.c,"    twoIntsStruct * data;
    data = NULL;
    
    data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));
    if (data == NULL) {exit(-1);}
    
    data[0].intOne = 0;
    data[0].intTwo = 0;
    printStructLine(&data[0]);
"
16306,0,CWE190_Integer_Overflow__char_rand_multiply_10.c,"    char data;
    data = ' ';
    if(globalTrue)
    {
        
        data = (char)RAND32();
    }
    if(globalTrue)
    {
        if(data > 0) 
        {
            
            char result = data * 2;
            printHexCharLine(result);
        }
"
507,0,CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_10.c,"    int data;
    
    data = -1;
    if(globalTrue)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
10170,0,CWE401_Memory_Leak__new_array_char_73a.cpp,"    char * data;
    list<char *> dataList;
    data = NULL;
    
    data = new char[100];
    
    strcpy(data, ""A String"");
    printLine(data);
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
12766,0,CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_61a.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    data = CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_61b_badSource(data);
"
8494,0,CWE197_Numeric_Truncation_Error__short_rand_68a.c,"    short data;
    
    data = -1;
    
    data = (short)RAND32();
    CWE197_Numeric_Truncation_Error__short_rand_68_badData = data;
"
7056,0,CWE78_OS_Command_Injection__char_console_execlp_81a.cpp,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        
        if (100-dataLen > 1)
        {
            
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgets() */
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
                    data[dataLen-1] = '\0';
                }
            }
            else
            {
                printLine(""fgets() failed"");
                
                data[dataLen] = '\0';
            }
        }
    }
    const CWE78_OS_Command_Injection__char_console_execlp_81_base& baseObject = CWE78_OS_Command_Injection__char_console_execlp_81_bad();
"
5696,0,CWE401_Memory_Leak__new_array_int64_t_67a.cpp,"    int64_t * data;
    structType myStruct;
    data = NULL;
    
    data = new int64_t[100];
    
    data[0] = 5LL;
    printLongLongLine(data[0]);
    myStruct.structFirst = data;
"
17301,0,CWE190_Integer_Overflow__unsigned_int_fscanf_square_22a.c,"    unsigned int data;
    data = 0;
    
    fscanf (stdin, ""%u"", &data);
    CWE190_Integer_Overflow__unsigned_int_fscanf_square_22_badGlobal = 1; 
"
2101,0,CWE590_Free_Memory_Not_on_Heap__delete_struct_static_12.cpp,"    twoIntsStruct * data;
    data = NULL; 
    if(globalReturnsTrueOrFalse())
    {
        {
            
            static twoIntsStruct dataBuffer;
            dataBuffer.intOne = 1;
            dataBuffer.intTwo = 1;
            data = &dataBuffer;
        }
    }
    else
    {
        {
            
            twoIntsStruct * dataBuffer = new twoIntsStruct;
            dataBuffer->intOne = 2;
            dataBuffer->intTwo = 2;
            data = dataBuffer;
        }
    }
    printStructLine(data);
    
"
19543,0,CWE78_OS_Command_Injection__char_listen_socket_popen_31.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    {
        char * dataCopy = data;
        char * data = dataCopy;
        {
            FILE *pipe;
            
            pipe = POPEN(data, ""w"");
            if (pipe != NULL)
            {
                PCLOSE(pipe);
            }
        }
"
10138,0,CWE369_Divide_by_Zero__int_fscanf_divide_07.c,"    int data;
    
    data = -1;
    if(staticFive==5)
    {
        
        fscanf(stdin, ""%d"", &data);
    }
    if(staticFive==5)
    {
        
        printIntLine(100 / data);
"
14816,0,CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_01.c,"    unsigned int data;
    data = 0;
    
    fscanf (stdin, ""%u"", &data);
    {
        
        data++;
        unsigned int result = data;
        printUnsignedLine(result);
"
6629,0,CWE690_NULL_Deref_From_Return__int_realloc_81_bad.cpp,"Label Definition File: CWE690_NULL_Deref_From_Return.free.label.xml
Template File: source-sinks-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 690 Unchecked Return Value To NULL Pointer
 * BadSource: realloc Allocate data using realloc()
 * Sinks:
 *    GoodSink: Check to see if the data allocation failed and if not, use data
 *    BadSink : Don't check for NULL and use data
 * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE690_NULL_Deref_From_Return__int_realloc_81.h""

namespace CWE690_NULL_Deref_From_Return__int_realloc_81
{

void CWE690_NULL_Deref_From_Return__int_realloc_81_bad::action(int * data) const
{
    
    data[0] = 5;
    printIntLine(data[0]);
    free(data);
}

}
"
15683,0,CWE190_Integer_Overflow__short_rand_square_34.c,"    short data;
    CWE190_Integer_Overflow__short_rand_square_34_unionType myUnion;
    data = 0;
    
    data = (short)RAND32();
    myUnion.unionFirst = data;
    {
        short data = myUnion.unionSecond;
        {
            
            short result = data * data;
            printIntLine(result);
        }
"
7981,0,CWE590_Free_Memory_Not_on_Heap__delete_class_declare_45.cpp,"    TwoIntsClass * data;
    data = NULL; 
    {
        
        TwoIntsClass dataBuffer;
        dataBuffer.intOne = 1;
        dataBuffer.intTwo = 1;
        data = &dataBuffer;
    }
    badData = data;
"
10557,0,CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_12.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(globalReturnsTrueOrFalse())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                data[dataLen + recvResult / sizeof(char)] = '\0';
                
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    else
    {
        
        strcpy(data, ""fixedstringtest"");
    }
    if(globalReturnsTrueOrFalse())
    {
        {
            char dest[100] = """";
            
            SNPRINTF(dest, 100-1, data);
            printLine(dest);
        }
    }
    else
    {
        {
            char dest[100] = """";
            
            SNPRINTF(dest, 100-1, ""%s"", data);
            printLine(dest);
        }
"
16093,1,CWE758_Undefined_Behavior__char_new_use_07.cpp,"    if(staticFive==5)
    {
        {
            char data;
            data = 5;
            char * pointer = new char;
            *pointer = data; 
            {
                char data = *pointer;
                printHexCharLine(data);
            }
            delete pointer;
        }
"
4361,0,CWE134_Uncontrolled_Format_String__char_file_fprintf_62a.cpp,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    badSource(data);
    
"
12513,0,CWE590_Free_Memory_Not_on_Heap__delete_array_class_static_73a.cpp,"    TwoIntsClass * data;
    list<TwoIntsClass *> dataList;
    data = NULL; 
    {
        
        static TwoIntsClass dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i].intOne = 1;
                dataBuffer[i].intTwo = 1;
            }
        }
        data = dataBuffer;
    }
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
3986,0,CWE190_Integer_Overflow__int64_t_max_add_73a.cpp,"    int64_t data;
    list<int64_t> dataList;
    data = 0LL;
    
    data = LLONG_MAX;
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
4928,0,CWE401_Memory_Leak__int_realloc_61a.c,"    int * data;
    data = NULL;
    data = CWE401_Memory_Leak__int_realloc_61b_badSource(data);
    
"
1352,0,CWE369_Divide_by_Zero__int_fgets_modulo_45.c,"    int data;
    
    data = -1;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    CWE369_Divide_by_Zero__int_fgets_modulo_45_badData = data;
"
12415,0,CWE190_Integer_Overflow__char_rand_add_63a.c,"    char data;
    data = ' ';
    
    data = (char)RAND32();
"
10407,0,CWE590_Free_Memory_Not_on_Heap__delete_struct_static_68a.cpp,"    twoIntsStruct * data;
    data = NULL; 
    {
        
        static twoIntsStruct dataBuffer;
        dataBuffer.intOne = 1;
        dataBuffer.intTwo = 1;
        data = &dataBuffer;
    }
    CWE590_Free_Memory_Not_on_Heap__delete_struct_static_68_badData = data;
"
11959,1,CWE758_Undefined_Behavior__struct_pointer_alloca_use_10.c,"    if(globalTrue)
    {
        {
            twoIntsStruct * data;
            twoIntsStruct * * pointer = (twoIntsStruct * *)ALLOCA(sizeof(twoIntsStruct *));
            
            data = (twoIntsStruct *)malloc(sizeof(twoIntsStruct));
            if (data == NULL) {exit(-1);}
            data->intOne = 5;
            data->intTwo = 6;
            *pointer = data; 
            {
                twoIntsStruct * data = *pointer;
                printIntLine(data->intOne);
                printIntLine(data->intTwo);
            }
        }
"
6118,0,CWE690_NULL_Deref_From_Return__int64_t_malloc_84_bad.cpp,"Label Definition File: CWE690_NULL_Deref_From_Return.free.label.xml
Template File: source-sinks-84_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 690 Unchecked Return Value To NULL Pointer
 * BadSource: malloc Allocate data using malloc()
 * Sinks:
 *    GoodSink: Check to see if the data allocation failed and if not, use data
 *    BadSink : Don't check for NULL and use data
 * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE690_NULL_Deref_From_Return__int64_t_malloc_84.h""

namespace CWE690_NULL_Deref_From_Return__int64_t_malloc_84
{
CWE690_NULL_Deref_From_Return__int64_t_malloc_84_bad::CWE690_NULL_Deref_From_Return__int64_t_malloc_84_bad(int64_t * dataCopy)
{
    data = dataCopy;
    
    data = (int64_t *)malloc(1*sizeof(int64_t));
}

CWE690_NULL_Deref_From_Return__int64_t_malloc_84_bad::~CWE690_NULL_Deref_From_Return__int64_t_malloc_84_bad()
{
    
    data[0] = 5LL;
    printLongLongLine(data[0]);
    free(data);
}
}
"
18170,0,CWE190_Integer_Overflow__int_max_multiply_73a.cpp,"    int data;
    list<int> dataList;
    
    data = 0;
    
    data = INT_MAX;
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
3830,0,CWE197_Numeric_Truncation_Error__int_listen_socket_to_short_31.c,"    int data;
    
    data = -1;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    {
        int dataCopy = data;
        int data = dataCopy;
        {
            
            short shortData = (short)data;
            printShortLine(shortData);
        }
"
8939,0,CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_68a.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_68_badData = data;
"
13215,1,CWE758_Undefined_Behavior__int_malloc_use_16.c,"    while(1)
    {
        {
            int data;
            int * pointer = (int *)malloc(sizeof(int));
            if (pointer == NULL) {exit(-1);}
            data = 5;
            *pointer = data; 
            {
                int data = *pointer;
                printIntLine(data);
            }
            free(pointer);
        }
        break;
"
7007,0,CWE190_Integer_Overflow__int_fscanf_postinc_51a.c,"    int data;
    
    data = 0;
    
    fscanf(stdin, ""%d"", &data);
"
2922,0,CWE690_NULL_Deref_From_Return__int64_t_calloc_16.c,"    int64_t * data;
    data = NULL; 
    
    data = (int64_t *)calloc(1, sizeof(int64_t));
    while(1)
    {
        
        data[0] = 5LL;
        printLongLongLine(data[0]);
        free(data);
        break;
"
2588,0,CWE416_Use_After_Free__malloc_free_struct_01.c,"    twoIntsStruct * data;
    
    data = NULL;
    data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
    if (data == NULL) {exit(-1);}
    {
        size_t i;
        for(i = 0; i < 100; i++)
        {
            data[i].intOne = 1;
            data[i].intTwo = 2;
        }
    }
    
    free(data);
    
    printStructLine(&data[0]);
"
1094,0,CWE369_Divide_by_Zero__int_zero_modulo_06.c,"    int data;
    
    data = -1;
    if(STATIC_CONST_FIVE==5)
    {
        
        data = 0;
    }
    if(STATIC_CONST_FIVE==5)
    {
        
        printIntLine(100 % data);
"
16177,0,CWE197_Numeric_Truncation_Error__int_fscanf_to_char_22a.c,"    int data;
    
    data = -1;
    CWE197_Numeric_Truncation_Error__int_fscanf_to_char_22_badGlobal = 1; 
    data = CWE197_Numeric_Truncation_Error__int_fscanf_to_char_22_badSource(data);
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
7563,0,CWE590_Free_Memory_Not_on_Heap__free_struct_alloca_65a.c,"    twoIntsStruct * data;
    
    void (*funcPtr) (twoIntsStruct *) = CWE590_Free_Memory_Not_on_Heap__free_struct_alloca_65b_badSink;
    data = NULL; 
    {
        
        twoIntsStruct * dataBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i].intOne = 1;
                dataBuffer[i].intTwo = 1;
            }
        }
        data = dataBuffer;
    }
    
"
18274,0,CWE416_Use_After_Free__new_delete_array_int64_t_43.cpp,"    int64_t * data;
    
    data = NULL;
    badSource(data);
    
    printLongLongLine(data[0]);
"
12334,0,CWE190_Integer_Overflow__int_rand_multiply_18.c,"    int data;
    
    data = 0;
    goto source;
source:
    
    data = RAND32();
    goto sink;
sink:
    if(data > 0) 
    {
        
        int result = data * 2;
        printIntLine(result);
"
7531,0,CWE190_Integer_Overflow__char_fscanf_multiply_72a.cpp,"    char data;
    vector<char> dataVector;
    data = ' ';
    
    fscanf (stdin, ""%c"", &data);
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
14853,0,CWE190_Integer_Overflow__int_fscanf_add_72a.cpp,"    int data;
    vector<int> dataVector;
    
    data = 0;
    
    fscanf(stdin, ""%d"", &data);
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
16079,0,CWE252_Unchecked_Return_Value__char_fread_12.c,"    if(globalReturnsTrueOrFalse())
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            
            fread((char *)data, sizeof(char), (size_t)(100-1), stdin);
        }
    }
    else
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            
            if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) != 100-1)
            {
                printLine(""fread failed!"");
            }
        }
"
15541,0,CWE476_NULL_Pointer_Dereference__deref_after_check_17.c,"    int j;
    for(j = 0; j < 1; j++)
    {
        {
            
            int *intPointer = NULL;
            if (intPointer == NULL)
            {
                printIntLine(*intPointer);
            }
        }
"
11697,1,CWE758_Undefined_Behavior__double_pointer_malloc_use_18.c,"    goto sink;
sink:
    {
        double * data;
        double * * pointer = (double * *)malloc(sizeof(double *));
        if (pointer == NULL) {exit(-1);}
        
        data = (double *)malloc(sizeof(double));
        if (data == NULL) {exit(-1);}
        *data = 5.0;
        *pointer = data; 
        {
            double * data = *pointer;
            printDoubleLine(*data);
        }
        free(pointer);
"
1921,0,CWE590_Free_Memory_Not_on_Heap__delete_struct_declare_06.cpp,"    twoIntsStruct * data;
    data = NULL; 
    if(STATIC_CONST_FIVE==5)
    {
        {
            
            twoIntsStruct dataBuffer;
            dataBuffer.intOne = 1;
            dataBuffer.intTwo = 1;
            data = &dataBuffer;
        }
    }
    printStructLine(data);
    
"
1506,0,CWE369_Divide_by_Zero__float_connect_socket_41.c,"    float data;
    
    data = 0.0F;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = (float)atof(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
8462,0,CWE587_Assignment_of_Fixed_Address_to_Pointer__basic_02.c,"    if(1)
    {
        {
            
            char *charPointer = (char*)0x400000;
            printHexCharLine(*charPointer);
        }
"
679,0,CWE590_Free_Memory_Not_on_Heap__delete_array_char_alloca_64a.cpp,"    char * data;
    data = NULL; 
    {
        
        char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
        memset(dataBuffer, 'A', 100-1); 
        dataBuffer[100-1] = '\0'; 
        data = dataBuffer;
    }
"
1950,0,CWE415_Double_Free__malloc_free_int64_t_31.c,"    int64_t * data;
    
    data = NULL;
    data = (int64_t *)malloc(100*sizeof(int64_t));
    if (data == NULL) {exit(-1);}
    
    free(data);
    {
        int64_t * dataCopy = data;
        int64_t * data = dataCopy;
        
        free(data);
"
5467,0,CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_82a.cpp,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_82_base* baseObject = new CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_82_bad;
    baseObject->action(data);
"
12799,0,CWE401_Memory_Leak__new_array_int_41.cpp,"    int * data;
    data = NULL;
    
    data = new int[100];
    
    data[0] = 5;
    printIntLine(data[0]);
"
14784,0,CWE690_NULL_Deref_From_Return__long_calloc_05.c,"    long * data;
    data = NULL; 
    
    data = (long *)calloc(1, sizeof(long));
    if(staticTrue)
    {
        
        data[0] = 5L;
        printLongLine(data[0]);
        free(data);
"
12170,0,CWE415_Double_Free__malloc_free_struct_61a.c,"    twoIntsStruct * data;
    
    data = NULL;
    data = CWE415_Double_Free__malloc_free_struct_61b_badSource(data);
    
"
13004,0,CWE590_Free_Memory_Not_on_Heap__delete_struct_declare_45.cpp,"    twoIntsStruct * data;
    data = NULL; 
    {
        
        twoIntsStruct dataBuffer;
        dataBuffer.intOne = 1;
        dataBuffer.intTwo = 1;
        data = &dataBuffer;
    }
    badData = data;
"
5484,0,CWE190_Integer_Overflow__char_max_square_07.c,"    char data;
    data = ' ';
    if(staticFive==5)
    {
        
        data = CHAR_MAX;
    }
    if(staticFive==5)
    {
        {
            
            char result = data * data;
            printHexCharLine(result);
        }
"
290,0,CWE590_Free_Memory_Not_on_Heap__delete_array_char_declare_66a.cpp,"    char * data;
    char * dataArray[5];
    data = NULL; 
    {
        
        char dataBuffer[100];
        memset(dataBuffer, 'A', 100-1); 
        dataBuffer[100-1] = '\0'; 
        data = dataBuffer;
    }
    
    dataArray[2] = data;
"
9663,0,CWE190_Integer_Overflow__unsigned_int_max_square_16.c,"    unsigned int data;
    data = 0;
    while(1)
    {
        
        data = UINT_MAX;
        break;
    }
    while(1)
    {
        {
            
            unsigned int result = data * data;
            printUnsignedLine(result);
        }
        break;
"
15545,0,CWE415_Double_Free__new_delete_array_char_82_bad.cpp,"Label Definition File: CWE415_Double_Free__new_delete_array.label.xml
Template File: sources-sinks-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 415 Double Free
 * BadSource:  Allocate data using new and Deallocae data using delete
 * GoodSource: Allocate data using new
 * Sinks:
 *    GoodSink: do nothing
 *    BadSink : Deallocate data using delete
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE415_Double_Free__new_delete_array_char_82.h""

namespace CWE415_Double_Free__new_delete_array_char_82
{

void CWE415_Double_Free__new_delete_array_char_82_bad::action(char * data)
{
    
    delete [] data;
}

}
"
6600,1,CWE758_Undefined_Behavior__int_alloca_use_03.c,"    if(5==5)
    {
        {
            int data;
            int * pointer = (int *)ALLOCA(sizeof(int));
            data = 5;
            *pointer = data; 
            {
                int data = *pointer;
                printIntLine(data);
            }
        }
"
7995,0,CWE590_Free_Memory_Not_on_Heap__delete_class_static_34.cpp,"    TwoIntsClass * data;
    unionType myUnion;
    data = NULL; 
    {
        
        static TwoIntsClass dataBuffer;
        dataBuffer.intOne = 1;
        dataBuffer.intTwo = 1;
        data = &dataBuffer;
    }
    myUnion.unionFirst = data;
    {
        TwoIntsClass * data = myUnion.unionSecond;
        printIntLine(data->intOne);
        
        delete data;
"
7218,0,CWE190_Integer_Overflow__int_fgets_add_18.c,"    int data;
    
    data = 0;
    goto source;
source:
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    goto sink;
sink:
    {
        
        int result = data + 1;
        printIntLine(result);
"
6378,0,CWE78_OS_Command_Injection__char_console_popen_45.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
        
        size_t dataLen = strlen(data);
        
        if (100-dataLen > 1)
        {
            
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgets() */
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
"
467,0,CWE190_Integer_Overflow__short_max_preinc_63a.c,"    short data;
    data = 0;
    
    data = SHRT_MAX;
"
4083,0,CWE190_Integer_Overflow__int_connect_socket_square_13.c,"    int data;
    
    data = 0;
    if(GLOBAL_CONST_FIVE==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            
            int result = data * data;
            printIntLine(result);
        }
"
8475,0,CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_21.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    badStatic = 1; 
"
10885,0,CWE134_Uncontrolled_Format_String__char_console_snprintf_72a.cpp,"    char * data;
    vector<char *> dataVector;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        
        if (100-dataLen > 1)
        {
            
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgets() */
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
                    data[dataLen-1] = '\0';
                }
            }
            else
            {
                printLine(""fgets() failed"");
                
                data[dataLen] = '\0';
            }
        }
    }
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
15046,0,CWE415_Double_Free__malloc_free_struct_62a.cpp,"    twoIntsStruct * data;
    
    data = NULL;
    badSource(data);
    
"
9689,0,CWE789_Uncontrolled_Mem_Alloc__new_char_rand_07.cpp,"    size_t data;
    
    data = 0;
    if(staticFive==5)
    {
        
        data = rand();
    }
    if(staticFive==5)
    {
        {
            char * myString;
            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
             * for the strcpy() function to not cause a buffer overflow */
            
            if (data > strlen(HELLO_STRING))
            {
                myString = new char[data];
                
                strcpy(myString, HELLO_STRING);
                printLine(myString);
                delete [] myString;
            }
            else
            {
                printLine(""Input is less than the length of the source string"");
            }
        }
"
2541,1,CWE252_Unchecked_Return_Value__char_fscanf_01.c,"    {
        /* By initializing dataBuffer, we ensure this will not be the
         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
        char dataBuffer[100] = """";
        char * data = dataBuffer;
        
        if (fscanf(stdin, ""%99s\0"", data) == EOF)
        {
            printLine(""fscanf failed!"");
        }
"
1538,1,CWE758_Undefined_Behavior__int_pointer_new_use_07.cpp,"    if(staticFive!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            int * data;
            
            data = new int;
            *data = 5;
            int * * pointer = new int *;
            *pointer = data; 
            {
                int * data = *pointer;
                printIntLine(*data);
            }
            delete pointer;
        }
"
13782,0,CWE190_Integer_Overflow__int_listen_socket_multiply_08.c,"    int data;
    
    data = 0;
    if(staticReturnsTrue())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(staticReturnsTrue())
    {
        if(data > 0) 
        {
            
            int result = data * 2;
            printIntLine(result);
        }
"
15093,0,CWE590_Free_Memory_Not_on_Heap__free_long_static_13.c,"    long * data;
    data = NULL; 
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            
            static long dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5L;
                }
            }
            data = dataBuffer;
        }
    }
    printLongLine(data[0]);
    
"
18025,0,CWE401_Memory_Leak__new_struct_twoIntsStruct_14.cpp,"    struct _twoIntsStruct * data;
    data = NULL;
    if(globalFive==5)
    {
        
        data = new struct _twoIntsStruct;
        
        data->intOne = 0;
        data->intTwo = 0;
        printStructLine((twoIntsStruct *)data);
    }
    if(globalFive==5)
    {
        
        ; 
"
7684,0,CWE190_Integer_Overflow__int_listen_socket_postinc_16.c,"    int data;
    
    data = 0;
    while(1)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
        break;
    }
    while(1)
    {
        {
            
            data++;
            int result = data;
            printIntLine(result);
        }
        break;
"
9558,0,CWE190_Integer_Overflow__int_fgets_postinc_65a.c,"    int data;
    
    void (*funcPtr) (int) = CWE190_Integer_Overflow__int_fgets_postinc_65b_badSink;
    
    data = 0;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    
"
10387,0,CWE590_Free_Memory_Not_on_Heap__delete_char_placement_new_02.cpp,"    char * data;
    data = NULL; 
    if(1)
    {
        {
            
            char buffer[sizeof(char)];
            char * dataBuffer = new(buffer) char;
            *dataBuffer = 'A';
            data = dataBuffer;
        }
    }
    printHexCharLine(*data);
    
"
13147,0,CWE401_Memory_Leak__new_array_twointsStruct_10.cpp,"    twoIntsStruct * data;
    data = NULL;
    if(globalTrue)
    {
        
        data = new twoIntsStruct[100];
        
        data[0].intOne = 0;
        data[0].intTwo = 0;
        printStructLine(&data[0]);
    }
    if(globalTrue)
    {
        
        ; 
"
8764,0,CWE690_NULL_Deref_From_Return__int_malloc_06.c,"    int * data;
    data = NULL; 
    
    data = (int *)malloc(1*sizeof(int));
    if(STATIC_CONST_FIVE==5)
    {
        
        data[0] = 5;
        printIntLine(data[0]);
        free(data);
"
6113,0,CWE758_Undefined_Behavior__struct_alloca_use_18.c,"    goto sink;
sink:
    {
        twoIntsStruct * pointer = (twoIntsStruct *)ALLOCA(sizeof(twoIntsStruct));
        twoIntsStruct data = *pointer; 
        printIntLine(data.intOne);
        printIntLine(data.intTwo);
"
5151,0,CWE457_Use_of_Uninitialized_Variable__twointsclass_array_declare_partial_init_62a.cpp,"    TwoIntsClass * data;
    TwoIntsClass dataUninitArray[10];
    data = dataUninitArray;
    badSource(data);
    
    for(int i=0; i<10; i++)
    {
        printIntLine(data[i].intOne);
        printIntLine(data[i].intTwo);
"
18253,0,CWE190_Integer_Overflow__int64_t_rand_square_33.cpp,"    int64_t data;
    int64_t &dataRef = data;
    data = 0LL;
    
    data = (int64_t)RAND64();
    {
        int64_t data = dataRef;
        {
            
            int64_t result = data * data;
            printLongLongLine(result);
        }
"
8507,0,CWE665_Improper_Initialization__char_cat_53a.c,"    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    
    ; 
"
13973,0,CWE190_Integer_Overflow__int_connect_socket_add_16.c,"    int data;
    
    data = 0;
    while(1)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
        break;
    }
    while(1)
    {
        {
            
            int result = data + 1;
            printIntLine(result);
        }
        break;
"
8497,0,CWE457_Use_of_Uninitialized_Variable__double_array_malloc_partial_init_15.c,"    double * data;
    data = (double *)malloc(10*sizeof(double));
    if (data == NULL) {exit(-1);}
    switch(6)
    {
    case 6:
        
    {
        int i;
        for(i=0; i<(10/2); i++)
        {
            data[i] = (double)i;
        }
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
        
    {
        int i;
        for(i=0; i<10; i++)
        {
            printDoubleLine(data[i]);
        }
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
3860,0,CWE190_Integer_Overflow__int_fgets_square_03.c,"    int data;
    
    data = 0;
    if(5==5)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    if(5==5)
    {
        {
            
            int result = data * data;
            printIntLine(result);
        }
"
12439,0,CWE401_Memory_Leak__new_array_TwoIntsClass_41.cpp,"    TwoIntsClass * data;
    data = NULL;
    
    data = new TwoIntsClass[100];
    
    data[0].intOne = 0;
    data[0].intTwo = 0;
    printIntLine(data[0].intOne);
    printIntLine(data[0].intTwo);
"
8461,0,CWE78_OS_Command_Injection__char_connect_socket_execl_06.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(STATIC_CONST_FIVE==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET connectSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
"
15593,1,CWE758_Undefined_Behavior__struct_pointer_alloca_use_06.c,"    if(STATIC_CONST_FIVE!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            twoIntsStruct * data;
            twoIntsStruct * * pointer = (twoIntsStruct * *)ALLOCA(sizeof(twoIntsStruct *));
            
            data = (twoIntsStruct *)malloc(sizeof(twoIntsStruct));
            if (data == NULL) {exit(-1);}
            data->intOne = 5;
            data->intTwo = 6;
            *pointer = data; 
            {
                twoIntsStruct * data = *pointer;
                printIntLine(data->intOne);
                printIntLine(data->intTwo);
            }
        }
"
613,0,CWE401_Memory_Leak__new_array_twointsStruct_53a.cpp,"    twoIntsStruct * data;
    data = NULL;
    
    data = new twoIntsStruct[100];
    
    data[0].intOne = 0;
    data[0].intTwo = 0;
    printStructLine(&data[0]);
"
15794,0,CWE190_Integer_Overflow__int64_t_rand_square_84a.cpp,"    int64_t data;
    data = 0LL;
    CWE190_Integer_Overflow__int64_t_rand_square_84_bad * badObject = new CWE190_Integer_Overflow__int64_t_rand_square_84_bad(data);
"
7619,0,CWE190_Integer_Overflow__short_max_postinc_16.c,"    short data;
    data = 0;
    while(1)
    {
        
        data = SHRT_MAX;
        break;
    }
    while(1)
    {
        {
            
            data++;
            short result = data;
            printIntLine(result);
        }
        break;
"
12748,1,CWE467_Use_of_sizeof_on_Pointer_Type__char_08.c,"    if(staticReturnsFalse())
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            char * goodChar = NULL;
            
            goodChar = (char *)malloc(sizeof(*goodChar));
            if (goodChar == NULL) {exit(-1);}
            *goodChar = 'G';
            printHexCharLine(*goodChar);
            free(goodChar);
        }
"
18147,0,CWE190_Integer_Overflow__short_fscanf_postinc_18.c,"    short data;
    data = 0;
    goto source;
source:
    
    fscanf (stdin, ""%hd"", &data);
    goto sink;
sink:
    {
        
        data++;
        short result = data;
        printIntLine(result);
"
7657,1,CWE758_Undefined_Behavior__int_new_use_08.cpp,"    if(staticReturnsTrue())
    {
        {
            int data;
            data = 5;
            int * pointer = new int;
            *pointer = data; 
            {
                int data = *pointer;
                printIntLine(data);
            }
            delete pointer;
        }
"
3052,1,CWE758_Undefined_Behavior__struct_pointer_new_use_05.cpp,"    if(staticFalse)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            twoIntsStruct * data;
            
            data = new twoIntsStruct;
            data->intOne = 5;
            data->intTwo = 6;
            twoIntsStruct * * pointer = new twoIntsStruct *;
            *pointer = data; 
            {
                twoIntsStruct * data = *pointer;
                printIntLine(data->intOne);
                printIntLine(data->intTwo);
            }
            delete pointer;
        }
"
14543,0,CWE416_Use_After_Free__new_delete_char_12.cpp,"    char * data;
    
    data = NULL;
    if(globalReturnsTrueOrFalse())
    {
        data = new char;
        *data = 'A';
        
        delete data;
    }
    else
    {
        data = new char;
        *data = 'A';
        
    }
    if(globalReturnsTrueOrFalse())
    {
        
        printHexCharLine(*data);
        
    }
    else
    {
        
        
        
        ; 
"
8813,0,CWE401_Memory_Leak__malloc_realloc_twoIntsStruct_16.c,"    while(1)
    {
        {
            twoIntsStruct * data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
            if (data == NULL) {exit(-1);}
            
            data[0].intOne = 0;
            data[0].intTwo = 0;
            printStructLine(&data[0]);
            
            data = (twoIntsStruct *)realloc(data, (130000)*sizeof(twoIntsStruct));
            if (data != NULL)
            {
                
                data[0].intOne = 1;
                data[0].intTwo = 1;
                printStructLine(&data[0]);
                free(data);
            }
        }
        break;
"
10309,0,CWE190_Integer_Overflow__int_fscanf_multiply_83a.cpp,"    int data;
    
    data = 0;
"
14428,0,CWE134_Uncontrolled_Format_String__char_environment_vfprintf_62a.cpp,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    badSource(data);
"
16287,0,CWE78_OS_Command_Injection__char_console_popen_66a.c,"    char * data;
    char * dataArray[5];
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
        
        size_t dataLen = strlen(data);
        
        if (100-dataLen > 1)
        {
            
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgets() */
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
                    data[dataLen-1] = '\0';
                }
            }
            else
            {
                printLine(""fgets() failed"");
                
                data[dataLen] = '\0';
            }
        }
    }
    
    dataArray[2] = data;
"
3586,0,CWE415_Double_Free__new_delete_array_class_08.cpp,"    TwoIntsClass * data;
    
    data = NULL;
    if(staticReturnsTrue())
    {
        data = new TwoIntsClass[100];
        
        delete [] data;
    }
    if(staticReturnsTrue())
    {
        
        delete [] data;
"
16849,0,CWE190_Integer_Overflow__char_max_multiply_52a.c,"    char data;
    data = ' ';
    
    data = CHAR_MAX;
"
13028,1,CWE252_Unchecked_Return_Value__char_rename_02.c,"    if(1)
    {
        
        if (RENAME(OLD_GOOD_FILE_NAME, ""newgoodfilename.txt"") != 0)
        {
            printLine(""rename failed!"");
        }
"
4522,0,CWE369_Divide_by_Zero__float_listenSocket_43.cpp,"    float data;
    
    data = 0.0F;
    badSource(data);
    {
        
        int result = (int)(100.0 / data);
        printIntLine(result);
"
1113,0,CWE190_Integer_Overflow__char_rand_postinc_15.c,"    char data;
    data = ' ';
    switch(6)
    {
    case 6:
        
        data = (char)RAND32();
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
    {
        
        data++;
        char result = data;
        printHexCharLine(result);
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
13411,0,CWE476_NULL_Pointer_Dereference__int_06.c,"    int * data;
    if(STATIC_CONST_FIVE==5)
    {
        
        data = NULL;
    }
    if(STATIC_CONST_FIVE==5)
    {
        
        printIntLine(*data);
"
10120,0,CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_63a.c,"    int data;
    
    data = -1;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
12393,0,CWE190_Integer_Overflow__short_rand_multiply_62a.cpp,"    short data;
    data = 0;
    badSource(data);
    if(data > 0) 
    {
        
        short result = data * 2;
        printIntLine(result);
"
16506,0,CWE476_NULL_Pointer_Dereference__int64_t_66a.c,"    int64_t * data;
    int64_t * dataArray[5];
    
    data = NULL;
    
    dataArray[2] = data;
"
10550,0,CWE134_Uncontrolled_Format_String__char_file_vprintf_82_bad.cpp,"Label Definition File: CWE134_Uncontrolled_Format_String.vasinks.label.xml
Template File: sources-vasinks-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 134 Uncontrolled Format String
 * BadSource: file Read input from a file
 * GoodSource: Copy a fixed string into data
 * Sinks: vprintf
 *    GoodSink: vprintf with a format string
 *    BadSink : vprintf without a format string
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include <stdarg.h>
#include ""std_testcase.h""
#include ""CWE134_Uncontrolled_Format_String__char_file_vprintf_82.h""

namespace CWE134_Uncontrolled_Format_String__char_file_vprintf_82
{

static void badVaSink(char * data, ...)
{
    {
        va_list args;
        va_start(args, data);
        
        vprintf(data, args);
        va_end(args);
    }
}

void CWE134_Uncontrolled_Format_String__char_file_vprintf_82_bad::action(char * data)
{
    badVaSink(data, data);
}

}
"
5495,0,CWE457_Use_of_Uninitialized_Variable__twointsclass_43.cpp,"    TwoIntsClass data;
    badSource(data);
    
    printIntLine(data.intOne);
"
18191,1,CWE758_Undefined_Behavior__struct_alloca_use_10.c,"    if(globalTrue)
    {
        {
            twoIntsStruct data;
            twoIntsStruct * pointer = (twoIntsStruct *)ALLOCA(sizeof(twoIntsStruct));
            data.intOne = 1;
            data.intTwo = 2;
            *pointer = data; 
            {
                twoIntsStruct data = *pointer;
                printIntLine(data.intOne);
                printIntLine(data.intTwo);
            }
        }
"
15256,0,CWE476_NULL_Pointer_Dereference__long_17.c,"    int i,j;
    long * data;
    for(i = 0; i < 1; i++)
    {
        
        data = NULL;
    }
    for(j = 0; j < 1; j++)
    {
        
        printLongLine(*data);
"
13085,1,CWE252_Unchecked_Return_Value__char_fputs_10.c,"    if(globalTrue)
    {
        
        if (fputs(""string"", stdout) == EOF)
        {
            printLine(""fputs failed!"");
        }
"
11609,0,CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_81_bad.cpp,"Label Definition File: CWE197_Numeric_Truncation_Error__int.label.xml
Template File: sources-sink-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 197 Numeric Truncation Error
 * BadSource: connect_socket Read data using a connect socket (client side)
 * GoodSource: Less than CHAR_MAX
 * Sinks: to_char
 *    BadSink : Convert data to a char
 * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_81.h""

namespace CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_81
{

void CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_81_bad::action(int data) const
{
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
    }
}

}
"
14589,1,CWE252_Unchecked_Return_Value__char_scanf_03.c,"    if(5==5)
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            
            if (scanf(""%99s\0"", data) == EOF)
            {
                printLine(""scanf failed!"");
            }
        }
"
14493,0,CWE190_Integer_Overflow__unsigned_int_fscanf_add_82_bad.cpp,"Label Definition File: CWE190_Integer_Overflow.label.xml
Template File: sources-sinks-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 190 Integer Overflow
 * BadSource: fscanf Read data from the console using fscanf()
 * GoodSource: Set data to a small, non-zero number (two)
 * Sinks: add
 *    GoodSink: Ensure there will not be an overflow before adding 1 to data
 *    BadSink : Add 1 to data, which can cause an overflow
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE190_Integer_Overflow__unsigned_int_fscanf_add_82.h""

namespace CWE190_Integer_Overflow__unsigned_int_fscanf_add_82
{

void CWE190_Integer_Overflow__unsigned_int_fscanf_add_82_bad::action(unsigned int data)
{
    {
        
        unsigned int result = data + 1;
        printUnsignedLine(result);
    }
}

}
"
3819,0,CWE369_Divide_by_Zero__float_fgets_17.c,"    int i,j;
    float data;
    
    data = 0.0F;
    for(i = 0; i < 1; i++)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE];
            
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                
                data = (float)atof(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    for(j = 0; j < 1; j++)
    {
        {
            
            int result = (int)(100.0 / data);
            printIntLine(result);
        }
"
11893,0,CWE590_Free_Memory_Not_on_Heap__delete_array_struct_static_44.cpp,"    twoIntsStruct * data;
    
    void (*funcPtr) (twoIntsStruct *) = badSink;
    data = NULL; 
    {
        
        static twoIntsStruct dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i].intOne = 1;
                dataBuffer[i].intTwo = 1;
            }
        }
        data = dataBuffer;
    }
    
"
1013,0,CWE190_Integer_Overflow__int_fgets_postinc_51a.c,"    int data;
    
    data = 0;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
"
8978,0,CWE369_Divide_by_Zero__int_fgets_divide_31.c,"    int data;
    
    data = -1;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    {
        int dataCopy = data;
        int data = dataCopy;
        
        printIntLine(100 / data);
"
4283,0,CWE401_Memory_Leak__new_array_char_14.cpp,"    char * data;
    data = NULL;
    if(globalFive==5)
    {
        
        data = new char[100];
        
        strcpy(data, ""A String"");
        printLine(data);
    }
    if(globalFive==5)
    {
        
        ; 
"
6719,0,CWE190_Integer_Overflow__short_max_multiply_66a.c,"    short data;
    short dataArray[5];
    data = 0;
    
    data = SHRT_MAX;
    
    dataArray[2] = data;
"
10467,0,CWE197_Numeric_Truncation_Error__int_listen_socket_to_short_07.c,"    int data;
    
    data = -1;
    if(staticFive==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    {
        
        short shortData = (short)data;
        printShortLine(shortData);
"
13888,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_42.c,"    size_t data;
    
    data = 0;
    data = badSource(data);
    {
        char * myString;
        /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
         * for the strcpy() function to not cause a buffer overflow */
        
        if (data > strlen(HELLO_STRING))
        {
            myString = (char *)malloc(data*sizeof(char));
            if (myString == NULL) {exit(-1);}
            
            strcpy(myString, HELLO_STRING);
            printLine(myString);
            free(myString);
        }
        else
        {
            printLine(""Input is less than the length of the source string"");
        }
"
13494,0,CWE690_NULL_Deref_From_Return__int64_t_realloc_84_bad.cpp,"Label Definition File: CWE690_NULL_Deref_From_Return.free.label.xml
Template File: source-sinks-84_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 690 Unchecked Return Value To NULL Pointer
 * BadSource: realloc Allocate data using realloc()
 * Sinks:
 *    GoodSink: Check to see if the data allocation failed and if not, use data
 *    BadSink : Don't check for NULL and use data
 * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE690_NULL_Deref_From_Return__int64_t_realloc_84.h""

namespace CWE690_NULL_Deref_From_Return__int64_t_realloc_84
{
CWE690_NULL_Deref_From_Return__int64_t_realloc_84_bad::CWE690_NULL_Deref_From_Return__int64_t_realloc_84_bad(int64_t * dataCopy)
{
    data = dataCopy;
    
    data = (int64_t *)realloc(data, 1*sizeof(int64_t));
}

CWE690_NULL_Deref_From_Return__int64_t_realloc_84_bad::~CWE690_NULL_Deref_From_Return__int64_t_realloc_84_bad()
{
    
    data[0] = 5LL;
    printLongLongLine(data[0]);
    free(data);
}
}
"
14712,0,CWE190_Integer_Overflow__short_rand_square_61a.c,"    short data;
    data = 0;
    data = CWE190_Integer_Overflow__short_rand_square_61b_badSource(data);
    {
        
        short result = data * data;
        printIntLine(result);
"
16707,0,CWE190_Integer_Overflow__int_connect_socket_multiply_66a.c,"    int data;
    int dataArray[5];
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
    dataArray[2] = data;
"
4878,0,CWE401_Memory_Leak__char_calloc_33.cpp,"    char * data;
    char * &dataRef = data;
    data = NULL;
    
    data = (char *)calloc(100, sizeof(char));
    if (data == NULL) {exit(-1);}
    
    strcpy(data, ""A String"");
    printLine(data);
    {
        char * data = dataRef;
        
        ; 
"
2343,0,CWE476_NULL_Pointer_Dereference__int_68a.c,"    int * data;
    
    data = NULL;
    CWE476_NULL_Pointer_Dereference__int_68_badData = data;
"
2426,0,CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_15.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    switch(6)
    {
    case 6:
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
        
        fprintf(stdout, data);
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
15475,0,CWE415_Double_Free__malloc_free_int64_t_08.c,"    int64_t * data;
    
    data = NULL;
    if(staticReturnsTrue())
    {
        data = (int64_t *)malloc(100*sizeof(int64_t));
        if (data == NULL) {exit(-1);}
        
        free(data);
    }
    if(staticReturnsTrue())
    {
        
        free(data);
"
7464,0,CWE758_Undefined_Behavior__char_pointer_new_use_13.cpp,"    if(GLOBAL_CONST_FIVE==5)
    {
        {
            char * * pointer = new char *;
            char * data = *pointer; 
            delete pointer;
            printLine(data);
        }
"
6320,0,CWE369_Divide_by_Zero__int_zero_modulo_32.c,"    int data;
    int *dataPtr1 = &data;
    int *dataPtr2 = &data;
    
    data = -1;
    {
        int data = *dataPtr1;
        
        data = 0;
        *dataPtr1 = data;
    }
    {
        int data = *dataPtr2;
        
        printIntLine(100 % data);
"
2765,0,CWE190_Integer_Overflow__int_connect_socket_add_31.c,"    int data;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    {
        int dataCopy = data;
        int data = dataCopy;
        {
            
            int result = data + 1;
            printIntLine(result);
        }
"
15538,0,CWE78_OS_Command_Injection__char_listen_socket_popen_72a.cpp,"    char * data;
    vector<char *> dataVector;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
13534,0,CWE190_Integer_Overflow__char_max_postinc_61a.c,"    char data;
    data = ' ';
    data = CWE190_Integer_Overflow__char_max_postinc_61b_badSource(data);
    {
        
        data++;
        char result = data;
        printHexCharLine(result);
"
11459,0,CWE401_Memory_Leak__int_malloc_68a.c,"    int * data;
    data = NULL;
    
    data = (int *)malloc(100*sizeof(int));
    if (data == NULL) {exit(-1);}
    
    data[0] = 5;
    printIntLine(data[0]);
    CWE401_Memory_Leak__int_malloc_68_badData = data;
"
15044,0,CWE563_Unused_Variable__unused_init_variable_struct_15.c,"    twoIntsStruct data;
    
    data.intOne = 0;
    data.intTwo = 0;
    switch(6)
    {
    case 6:
        
        
        ; 
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
12421,0,CWE590_Free_Memory_Not_on_Heap__delete_char_declare_67a.cpp,"    char * data;
    structType myStruct;
    data = NULL; 
    {
        
        char dataBuffer;
        dataBuffer = 'A';
        data = &dataBuffer;
    }
    myStruct.structFirst = data;
"
18706,0,CWE457_Use_of_Uninitialized_Variable__new_double_array_no_init_16.cpp,"    double * data;
    data = new double[10];
    while(1)
    {
        
        ; 
        break;
    }
    while(1)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printDoubleLine(data[i]);
            }
        }
        
        delete [] data;
        break;
"
4303,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_34.c,"    size_t data;
    CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_34_unionType myUnion;
    
    data = 0;
    
    data = rand();
    myUnion.unionFirst = data;
    {
        size_t data = myUnion.unionSecond;
        {
            char * myString;
            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
             * for the strcpy() function to not cause a buffer overflow */
            
            if (data > strlen(HELLO_STRING))
            {
                myString = (char *)malloc(data*sizeof(char));
                if (myString == NULL) {exit(-1);}
                
                strcpy(myString, HELLO_STRING);
                printLine(myString);
                free(myString);
            }
            else
            {
                printLine(""Input is less than the length of the source string"");
            }
        }
"
1183,0,CWE369_Divide_by_Zero__float_fscanf_81a.cpp,"    float data;
    
    data = 0.0F;
    
    fscanf (stdin, ""%f"", &data);
    const CWE369_Divide_by_Zero__float_fscanf_81_base& baseObject = CWE369_Divide_by_Zero__float_fscanf_81_bad();
"
15789,0,CWE190_Integer_Overflow__int64_t_fscanf_add_82a.cpp,"    int64_t data;
    data = 0LL;
    
    fscanf (stdin, ""%"" SCNd64, &data);
    CWE190_Integer_Overflow__int64_t_fscanf_add_82_base* baseObject = new CWE190_Integer_Overflow__int64_t_fscanf_add_82_bad;
    baseObject->action(data);
"
13209,1,CWE758_Undefined_Behavior__double_pointer_new_use_07.cpp,"    if(staticFive!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            double * data;
            
            data = new double;
            *data = 5.0;
            double * * pointer = new double *;
            *pointer = data; 
            {
                double * data = *pointer;
                printDoubleLine(*data);
            }
            delete pointer;
        }
"
3785,0,CWE690_NULL_Deref_From_Return__long_realloc_62a.cpp,"    long * data;
    data = NULL; 
    badSource(data);
    
    data[0] = 5L;
    printLongLine(data[0]);
"
8164,0,CWE457_Use_of_Uninitialized_Variable__struct_array_alloca_no_init_14.c,"    twoIntsStruct * data;
    data = (twoIntsStruct *)ALLOCA(10*sizeof(twoIntsStruct));
    if(globalFive==5)
    {
        
        ; 
    }
    if(globalFive==5)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i].intOne);
                printIntLine(data[i].intTwo);
            }
        }
"
15908,0,CWE690_NULL_Deref_From_Return__int_malloc_42.c,"    int * data;
    data = NULL; 
    data = badSource(data);
    
    data[0] = 5;
    printIntLine(data[0]);
"
9258,0,CWE590_Free_Memory_Not_on_Heap__delete_long_alloca_74a.cpp,"    long * data;
    map<int, long *> dataMap;
    data = NULL; 
    {
        
        long * dataBuffer = (long *)ALLOCA(sizeof(long));
        *dataBuffer = 5L;
        data = dataBuffer;
    }
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
33,0,CWE590_Free_Memory_Not_on_Heap__delete_array_struct_alloca_03.cpp,"    twoIntsStruct * data;
    data = NULL; 
    if(5==5)
    {
        {
            
            twoIntsStruct * dataBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i].intOne = 1;
                    dataBuffer[i].intTwo = 1;
                }
            }
            data = dataBuffer;
        }
    }
    printStructLine(&data[0]);
    
"
10279,0,CWE369_Divide_by_Zero__int_rand_divide_31.c,"    int data;
    
    data = -1;
    
    data = RAND32();
    {
        int dataCopy = data;
        int data = dataCopy;
        
        printIntLine(100 / data);
"
10091,0,CWE197_Numeric_Truncation_Error__short_listen_socket_42.c,"    short data;
    
    data = -1;
    data = badSource(data);
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
1428,0,CWE369_Divide_by_Zero__int_fgets_divide_68a.c,"    int data;
    
    data = -1;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    CWE369_Divide_by_Zero__int_fgets_divide_68_badData = data;
"
9776,0,CWE416_Use_After_Free__new_delete_array_long_06.cpp,"    long * data;
    
    data = NULL;
    if(STATIC_CONST_FIVE==5)
    {
        data = new long[100];
        {
            size_t i;
            for(i = 0; i < 100; i++)
            {
                data[i] = 5L;
            }
        }
        
        delete [] data;
    }
    if(STATIC_CONST_FIVE==5)
    {
        
        printLongLine(data[0]);
        
"
8736,0,CWE401_Memory_Leak__new_array_twointsStruct_12.cpp,"    twoIntsStruct * data;
    data = NULL;
    if(globalReturnsTrueOrFalse())
    {
        
        data = new twoIntsStruct[100];
        
        data[0].intOne = 0;
        data[0].intTwo = 0;
        printStructLine(&data[0]);
    }
    else
    {
        
        twoIntsStruct dataGoodBuffer[100];
        data = dataGoodBuffer;
        
        data[0].intOne = 0;
        data[0].intTwo = 0;
        printStructLine(&data[0]);
    }
    if(globalReturnsTrueOrFalse())
    {
        
        ; 
    }
    else
    {
        
        delete[] data;
"
198,0,CWE78_OS_Command_Injection__char_environment_system_53a.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
        
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        
        if (environment != NULL)
        {
            
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
"
6362,0,CWE590_Free_Memory_Not_on_Heap__delete_array_struct_alloca_04.cpp,"    twoIntsStruct * data;
    data = NULL; 
    if(STATIC_CONST_TRUE)
    {
        {
            
            twoIntsStruct * dataBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i].intOne = 1;
                    dataBuffer[i].intTwo = 1;
                }
            }
            data = dataBuffer;
        }
    }
    printStructLine(&data[0]);
    
"
10939,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_64a.c,"    size_t data;
    
    data = 0;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = strtoul(inputBuffer, NULL, 0);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
"
17269,0,CWE197_Numeric_Truncation_Error__short_fscanf_34.c,"    short data;
    CWE197_Numeric_Truncation_Error__short_fscanf_34_unionType myUnion;
    
    data = -1;
    
    fscanf (stdin, ""%hd"", &data);
    myUnion.unionFirst = data;
    {
        short data = myUnion.unionSecond;
        {
            
            char charData = (char)data;
            printHexCharLine(charData);
        }
"
18017,0,CWE590_Free_Memory_Not_on_Heap__delete_array_long_alloca_82a.cpp,"    long * data;
    data = NULL; 
    {
        
        long * dataBuffer = (long *)ALLOCA(100*sizeof(long));
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5L;
            }
        }
        data = dataBuffer;
    }
    CWE590_Free_Memory_Not_on_Heap__delete_array_long_alloca_82_base* baseObject = new CWE590_Free_Memory_Not_on_Heap__delete_array_long_alloca_82_bad;
    baseObject->action(data);
"
13338,0,CWE758_Undefined_Behavior__int64_t_malloc_use_04.c,"    if(STATIC_CONST_TRUE)
    {
        {
            int64_t * pointer = (int64_t *)malloc(sizeof(int64_t));
            if (pointer == NULL) {exit(-1);}
            int64_t data = *pointer; 
            free(pointer);
            printLongLongLine(data);
        }
"
13835,0,CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_22a.c,"    unsigned int data;
    data = 0;
    
    fscanf (stdin, ""%u"", &data);
    CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_22_badGlobal = 1; 
"
18730,0,CWE789_Uncontrolled_Mem_Alloc__new_char_connect_socket_06.cpp,"    size_t data;
    
    data = 0;
    if(STATIC_CONST_FIVE==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = strtoul(inputBuffer, NULL, 0);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(STATIC_CONST_FIVE==5)
    {
        {
            char * myString;
            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
             * for the strcpy() function to not cause a buffer overflow */
            
            if (data > strlen(HELLO_STRING))
            {
                myString = new char[data];
                
                strcpy(myString, HELLO_STRING);
                printLine(myString);
                delete [] myString;
            }
            else
            {
                printLine(""Input is less than the length of the source string"");
            }
        }
"
7144,1,CWE758_Undefined_Behavior__int_alloca_use_07.c,"    if(staticFive!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            int data;
            int * pointer = (int *)ALLOCA(sizeof(int));
            data = 5;
            *pointer = data; 
            {
                int data = *pointer;
                printIntLine(data);
            }
        }
"
2405,0,CWE457_Use_of_Uninitialized_Variable__twointsclass_array_new_no_init_18.cpp,"    TwoIntsClass * data;
    data = new TwoIntsClass[10];
    goto source;
source:
    
    ; 
    goto sink;
sink:
    
    for(int i=0; i<10; i++)
    {
        printIntLine(data[i].intOne);
        printIntLine(data[i].intTwo);
"
16010,0,CWE563_Unused_Variable__unused_value_long_84a.cpp,"    long data;
    CWE563_Unused_Variable__unused_value_long_84_bad * badObject = new CWE563_Unused_Variable__unused_value_long_84_bad(data);
"
10212,0,CWE401_Memory_Leak__char_realloc_21.c,"    char * data;
    data = NULL;
    
    data = (char *)realloc(data, 100*sizeof(char));
    if (data == NULL) {exit(-1);}
    
    strcpy(data, ""A String"");
    printLine(data);
    badStatic = 1; 
"
13921,0,CWE401_Memory_Leak__malloc_realloc_int64_t_09.c,"    if(GLOBAL_CONST_TRUE)
    {
        {
            int64_t * data = (int64_t *)malloc(100*sizeof(int64_t));
            if (data == NULL) {exit(-1);}
            
            data[0] = 5LL;
            printLongLongLine(data[0]);
            
            data = (int64_t *)realloc(data, (130000)*sizeof(int64_t));
            if (data != NULL)
            {
                
                data[0] = 10LL;
                printLongLongLine(data[0]);
                free(data);
            }
        }
"
356,0,CWE590_Free_Memory_Not_on_Heap__delete_int64_t_declare_08.cpp,"    int64_t * data;
    data = NULL; 
    if(staticReturnsTrue())
    {
        {
            
            int64_t dataBuffer;
            dataBuffer = 5LL;
            data = &dataBuffer;
        }
    }
    printLongLongLine(*data);
    
"
13277,0,CWE590_Free_Memory_Not_on_Heap__free_int64_t_alloca_63a.c,"    int64_t * data;
    data = NULL; 
    {
        
        int64_t * dataBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5LL;
            }
        }
        data = dataBuffer;
    }
"
14825,0,CWE457_Use_of_Uninitialized_Variable__double_array_alloca_partial_init_16.c,"    double * data;
    data = (double *)ALLOCA(10*sizeof(double));
    while(1)
    {
        
        {
            int i;
            for(i=0; i<(10/2); i++)
            {
                data[i] = (double)i;
            }
        }
        break;
    }
    while(1)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printDoubleLine(data[i]);
            }
        }
        break;
"
16227,0,CWE190_Integer_Overflow__char_fscanf_square_64a.c,"    char data;
    data = ' ';
    
    fscanf (stdin, ""%c"", &data);
"
18090,1,CWE401_Memory_Leak__malloc_realloc_struct_twoIntsStruct_11.c,"    if(globalReturnsFalse())
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            struct _twoIntsStruct * data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));
            if (data == NULL) {exit(-1);}
            struct _twoIntsStruct * tmpData;
            
            data[0].intOne = 0;
            data[0].intTwo = 0;
            printStructLine((twoIntsStruct *)&data[0]);
            tmpData = (struct _twoIntsStruct *)realloc(data, (130000)*sizeof(struct _twoIntsStruct));
            /* FIX: Ensure realloc() was successful before assigning data to the memory block
            * allocated with realloc() */
            if (tmpData != NULL)
            {
                data = tmpData;
                
                data[0].intOne = 1;
                data[0].intTwo = 1;
                printStructLine((twoIntsStruct *)&data[0]);
            }
            free(data);
        }
"
13701,0,CWE401_Memory_Leak__int64_t_realloc_02.c,"    int64_t * data;
    data = NULL;
    if(1)
    {
        
        data = (int64_t *)realloc(data, 100*sizeof(int64_t));
        if (data == NULL) {exit(-1);}
        
        data[0] = 5LL;
        printLongLongLine(data[0]);
    }
    if(1)
    {
        
        ; 
"
2187,0,CWE415_Double_Free__new_delete_int_64a.cpp,"    int * data;
    
    data = NULL;
    data = new int;
    
    delete data;
"
13892,0,CWE590_Free_Memory_Not_on_Heap__delete_array_int_static_16.cpp,"    int * data;
    data = NULL; 
    while(1)
    {
        {
            
            static int dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5;
                }
            }
            data = dataBuffer;
        }
        break;
    }
    printIntLine(data[0]);
    
"
7609,0,CWE590_Free_Memory_Not_on_Heap__delete_array_struct_static_11.cpp,"    twoIntsStruct * data;
    data = NULL; 
    if(globalReturnsTrue())
    {
        {
            
            static twoIntsStruct dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i].intOne = 1;
                    dataBuffer[i].intTwo = 1;
                }
            }
            data = dataBuffer;
        }
    }
    printStructLine(&data[0]);
    
"
11229,0,CWE457_Use_of_Uninitialized_Variable__int_array_malloc_partial_init_43.cpp,"    int * data;
    data = (int *)malloc(10*sizeof(int));
    if (data == NULL) {exit(-1);}
    badSource(data);
    
    {
        int i;
        for(i=0; i<10; i++)
        {
            printIntLine(data[i]);
        }
"
13448,1,CWE758_Undefined_Behavior__struct_pointer_new_use_08.cpp,"    if(staticReturnsTrue())
    {
        {
            twoIntsStruct * data;
            
            data = new twoIntsStruct;
            data->intOne = 5;
            data->intTwo = 6;
            twoIntsStruct * * pointer = new twoIntsStruct *;
            *pointer = data; 
            {
                twoIntsStruct * data = *pointer;
                printIntLine(data->intOne);
                printIntLine(data->intTwo);
            }
            delete pointer;
        }
"
2902,0,CWE190_Integer_Overflow__int_fgets_add_13.c,"    int data;
    
    data = 0;
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            
            int result = data + 1;
            printIntLine(result);
        }
"
5182,0,CWE134_Uncontrolled_Format_String__char_console_vprintf_01.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        
        if (100-dataLen > 1)
        {
            
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgets() */
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
                    data[dataLen-1] = '\0';
                }
            }
            else
            {
                printLine(""fgets() failed"");
                
                data[dataLen] = '\0';
            }
        }
    }
"
12303,0,CWE134_Uncontrolled_Format_String__char_environment_fprintf_09.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(GLOBAL_CONST_TRUE)
    {
        {
            
            size_t dataLen = strlen(data);
            char * environment = GETENV(ENV_VARIABLE);
            
            if (environment != NULL)
            {
                
                strncat(data+dataLen, environment, 100-dataLen-1);
            }
        }
    }
    if(GLOBAL_CONST_TRUE)
    {
        
        fprintf(stdout, data);
"
19110,0,CWE401_Memory_Leak__int64_t_malloc_84a.cpp,"    int64_t * data;
    data = NULL;
    CWE401_Memory_Leak__int64_t_malloc_84_bad * badObject = new CWE401_Memory_Leak__int64_t_malloc_84_bad(data);
"
12761,0,CWE401_Memory_Leak__int_malloc_15.c,"    int * data;
    data = NULL;
    switch(6)
    {
    case 6:
        
        data = (int *)malloc(100*sizeof(int));
        if (data == NULL) {exit(-1);}
        
        data[0] = 5;
        printIntLine(data[0]);
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
        
        ; 
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
3800,1,CWE758_Undefined_Behavior__char_alloca_use_05.c,"    if(staticTrue)
    {
        {
            char data;
            char * pointer = (char *)ALLOCA(sizeof(char));
            data = 5;
            *pointer = data; 
            {
                char data = *pointer;
                printHexCharLine(data);
            }
        }
"
1680,0,CWE401_Memory_Leak__new_int_68a.cpp,"    int * data;
    data = NULL;
    
    data = new int;
    
    *data = 5;
    printIntLine(*data);
    badData = data;
"
9850,0,CWE190_Integer_Overflow__unsigned_int_max_add_68a.c,"    unsigned int data;
    data = 0;
    
    data = UINT_MAX;
    CWE190_Integer_Overflow__unsigned_int_max_add_68_badData = data;
"
8190,0,CWE476_NULL_Pointer_Dereference__int_10.c,"    int * data;
    if(globalTrue)
    {
        
        data = NULL;
    }
    if(globalTrue)
    {
        
        printIntLine(*data);
"
18406,0,CWE190_Integer_Overflow__char_max_multiply_74a.cpp,"    char data;
    map<int, char> dataMap;
    data = ' ';
    
    data = CHAR_MAX;
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
3206,0,CWE190_Integer_Overflow__int64_t_max_postinc_07.c,"    int64_t data;
    data = 0LL;
    if(staticFive==5)
    {
        
        data = LLONG_MAX;
    }
    if(staticFive==5)
    {
        {
            
            data++;
            int64_t result = data;
            printLongLongLine(result);
        }
"
8700,0,CWE401_Memory_Leak__struct_twoIntsStruct_calloc_18.c,"    struct _twoIntsStruct * data;
    data = NULL;
    goto source;
source:
    
    data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));
    if (data == NULL) {exit(-1);}
    
    data[0].intOne = 0;
    data[0].intTwo = 0;
    printStructLine((twoIntsStruct *)&data[0]);
    goto sink;
sink:
    
"
18810,0,CWE590_Free_Memory_Not_on_Heap__free_struct_static_45.c,"    twoIntsStruct * data;
    data = NULL; 
    {
        
        static twoIntsStruct dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i].intOne = 1;
                dataBuffer[i].intTwo = 1;
            }
        }
        data = dataBuffer;
    }
    CWE590_Free_Memory_Not_on_Heap__free_struct_static_45_badData = data;
"
9692,0,CWE190_Integer_Overflow__unsigned_int_max_square_12.c,"    unsigned int data;
    data = 0;
    if(globalReturnsTrueOrFalse())
    {
        
        data = UINT_MAX;
    }
    else
    {
        
        data = 2;
    }
    if(globalReturnsTrueOrFalse())
    {
        {
            
            unsigned int result = data * data;
            printUnsignedLine(result);
        }
    }
    else
    {
        
        if (abs((long)data) < (long)sqrt((double)UINT_MAX))
        {
            unsigned int result = data * data;
            printUnsignedLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
"
5728,0,CWE690_NULL_Deref_From_Return__fopen_84a.cpp,"    FILE * data;
    
    data = NULL;
    CWE690_NULL_Deref_From_Return__fopen_84_bad * badObject = new CWE690_NULL_Deref_From_Return__fopen_84_bad(data);
"
18879,1,CWE252_Unchecked_Return_Value__char_remove_06.c,"    if(STATIC_CONST_FIVE==5)
    {
        
        if (REMOVE(""removemegood.txt"") != 0)
        {
            printLine(""remove failed!"");
        }
"
19093,0,CWE401_Memory_Leak__char_calloc_54a.c,"    char * data;
    data = NULL;
    
    data = (char *)calloc(100, sizeof(char));
    if (data == NULL) {exit(-1);}
    
    strcpy(data, ""A String"");
    printLine(data);
"
13432,0,CWE369_Divide_by_Zero__float_rand_45.c,"    float data;
    
    data = 0.0F;
    
    data = (float)RAND32();
    CWE369_Divide_by_Zero__float_rand_45_badData = data;
"
17988,0,CWE416_Use_After_Free__new_delete_array_struct_63a.cpp,"    twoIntsStruct * data;
    
    data = NULL;
    data = new twoIntsStruct[100];
    {
        size_t i;
        for(i = 0; i < 100; i++)
        {
            data[i].intOne = 1;
            data[i].intTwo = 2;
        }
    }
    
    delete [] data;
"
1002,0,CWE401_Memory_Leak__new_int_09.cpp,"    int * data;
    data = NULL;
    if(GLOBAL_CONST_TRUE)
    {
        
        data = new int;
        
        *data = 5;
        printIntLine(*data);
    }
    if(GLOBAL_CONST_TRUE)
    {
        
        ; 
"
10067,1,CWE758_Undefined_Behavior__int64_t_alloca_use_06.c,"    if(STATIC_CONST_FIVE==5)
    {
        {
            int64_t data;
            int64_t * pointer = (int64_t *)ALLOCA(sizeof(int64_t));
            data = 5LL;
            *pointer = data; 
            {
                int64_t data = *pointer;
                printLongLongLine(data);
            }
        }
"
13309,0,CWE590_Free_Memory_Not_on_Heap__free_long_declare_16.c,"    long * data;
    data = NULL; 
    while(1)
    {
        {
            
            long dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5L;
                }
            }
            data = dataBuffer;
        }
        break;
    }
    printLongLine(data[0]);
    
"
9637,0,CWE563_Unused_Variable__unused_init_variable_int_83_bad.cpp,"Label Definition File: CWE563_Unused_Variable__unused_init_variable.label.xml
Template File: source-sinks-83_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 563 Unused Variable
 * BadSource:  Initialize data
 * Sinks:
 *    GoodSink: Use data
 *    BadSink : do nothing
 * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE563_Unused_Variable__unused_init_variable_int_83.h""

namespace CWE563_Unused_Variable__unused_init_variable_int_83
{
CWE563_Unused_Variable__unused_init_variable_int_83_bad::CWE563_Unused_Variable__unused_init_variable_int_83_bad(int dataCopy)
{
    data = dataCopy;
    
    data = 5;
}

CWE563_Unused_Variable__unused_init_variable_int_83_bad::~CWE563_Unused_Variable__unused_init_variable_int_83_bad()
{
    
    
    ; 
}
}
"
8856,0,CWE369_Divide_by_Zero__int_connect_socket_modulo_02.c,"    int data;
    
    data = -1;
    if(1)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(1)
    {
        
        printIntLine(100 % data);
"
10829,0,CWE467_Use_of_sizeof_on_Pointer_Type__char_12.c,"    if(globalReturnsTrueOrFalse())
    {
        {
            char * badChar = NULL;
            
            badChar = (char *)malloc(sizeof(badChar));
            if (badChar == NULL) {exit(-1);}
            *badChar = 'B';
            printHexCharLine(*badChar);
            free(badChar);
        }
    }
    else
    {
        {
            char * goodChar = NULL;
            
            goodChar = (char *)malloc(sizeof(*goodChar));
            if (goodChar == NULL) {exit(-1);}
            *goodChar = 'G';
            printHexCharLine(*goodChar);
            free(goodChar);
        }
"
12872,0,CWE415_Double_Free__new_delete_array_int64_t_51a.cpp,"    int64_t * data;
    
    data = NULL;
    data = new int64_t[100];
    
    delete [] data;
"
18089,0,CWE197_Numeric_Truncation_Error__int_connect_socket_to_short_64a.c,"    int data;
    
    data = -1;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
4021,0,CWE590_Free_Memory_Not_on_Heap__delete_class_declare_54a.cpp,"    TwoIntsClass * data;
    data = NULL; 
    {
        
        TwoIntsClass dataBuffer;
        dataBuffer.intOne = 1;
        dataBuffer.intTwo = 1;
        data = &dataBuffer;
    }
"
16830,0,CWE476_NULL_Pointer_Dereference__class_52a.cpp,"    TwoIntsClass * data;
    
    data = NULL;
"
18361,0,CWE590_Free_Memory_Not_on_Heap__delete_int64_t_declare_81a.cpp,"    int64_t * data;
    data = NULL; 
    {
        
        int64_t dataBuffer;
        dataBuffer = 5LL;
        data = &dataBuffer;
    }
    const CWE590_Free_Memory_Not_on_Heap__delete_int64_t_declare_81_base& baseObject = CWE590_Free_Memory_Not_on_Heap__delete_int64_t_declare_81_bad();
"
4517,0,CWE197_Numeric_Truncation_Error__short_fscanf_53a.c,"    short data;
    
    data = -1;
    
    fscanf (stdin, ""%hd"", &data);
"
16773,0,CWE369_Divide_by_Zero__int_fscanf_divide_14.c,"    int data;
    
    data = -1;
    if(globalFive==5)
    {
        
        fscanf(stdin, ""%d"", &data);
    }
    if(globalFive==5)
    {
        
        printIntLine(100 / data);
"
16793,0,CWE457_Use_of_Uninitialized_Variable__new_double_array_partial_init_14.cpp,"    double * data;
    data = new double[10];
    if(globalFive==5)
    {
        
        {
            int i;
            for(i=0; i<(10/2); i++)
            {
                data[i] = (double)i;
            }
        }
    }
    if(globalFive==5)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printDoubleLine(data[i]);
            }
        }
        
        delete [] data;
"
587,0,CWE190_Integer_Overflow__unsigned_int_max_postinc_08.c,"    unsigned int data;
    data = 0;
    if(staticReturnsTrue())
    {
        
        data = UINT_MAX;
    }
    if(staticReturnsTrue())
    {
        {
            
            data++;
            unsigned int result = data;
            printUnsignedLine(result);
        }
"
8834,0,CWE190_Integer_Overflow__int_fscanf_multiply_02.c,"    int data;
    
    data = 0;
    if(1)
    {
        
        fscanf(stdin, ""%d"", &data);
    }
    if(1)
    {
        if(data > 0) 
        {
            
            int result = data * 2;
            printIntLine(result);
        }
"
1377,0,CWE590_Free_Memory_Not_on_Heap__free_char_alloca_15.c,"    char * data;
    data = NULL; 
    switch(6)
    {
    case 6:
    {
        
        char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
        memset(dataBuffer, 'A', 100-1); 
        dataBuffer[100-1] = '\0'; 
        data = dataBuffer;
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    printLine(data);
    
"
16545,0,CWE457_Use_of_Uninitialized_Variable__new_struct_array_partial_init_15.cpp,"    twoIntsStruct * data;
    data = new twoIntsStruct[10];
    switch(6)
    {
    case 6:
        
    {
        int i;
        for(i=0; i<(10/2); i++)
        {
            data[i].intOne = i;
            data[i].intTwo = i;
        }
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
        
    {
        int i;
        for(i=0; i<10; i++)
        {
            printIntLine(data[i].intOne);
            printIntLine(data[i].intTwo);
        }
    }
    
    delete [] data;
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
3742,0,CWE134_Uncontrolled_Format_String__char_listen_socket_printf_63a.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
56,1,CWE758_Undefined_Behavior__int_new_use_12.cpp,"    if(globalReturnsTrueOrFalse())
    {
        {
            int data;
            data = 5;
            int * pointer = new int;
            *pointer = data; 
            {
                int data = *pointer;
                printIntLine(data);
            }
            delete pointer;
        }
    }
    else
    {
        {
            int data;
            data = 5;
            int * pointer = new int;
            *pointer = data; 
            {
                int data = *pointer;
                printIntLine(data);
            }
            delete pointer;
        }
"
6357,0,CWE369_Divide_by_Zero__int_fgets_divide_45.c,"    int data;
    
    data = -1;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    CWE369_Divide_by_Zero__int_fgets_divide_45_badData = data;
"
18652,1,CWE758_Undefined_Behavior__char_alloca_use_06.c,"    if(STATIC_CONST_FIVE==5)
    {
        {
            char data;
            char * pointer = (char *)ALLOCA(sizeof(char));
            data = 5;
            *pointer = data; 
            {
                char data = *pointer;
                printHexCharLine(data);
            }
        }
"
9652,0,CWE416_Use_After_Free__malloc_free_struct_05.c,"    twoIntsStruct * data;
    
    data = NULL;
    if(staticTrue)
    {
        data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
        if (data == NULL) {exit(-1);}
        {
            size_t i;
            for(i = 0; i < 100; i++)
            {
                data[i].intOne = 1;
                data[i].intTwo = 2;
            }
        }
        
        free(data);
    }
    if(staticTrue)
    {
        
        printStructLine(&data[0]);
        
"
1881,0,CWE197_Numeric_Truncation_Error__int_large_to_short_01.c,"    int data;
    
    data = -1;
    
    data = SHRT_MAX + 5;
    {
        
        short shortData = (short)data;
        printShortLine(shortData);
"
9346,0,CWE590_Free_Memory_Not_on_Heap__delete_struct_static_17.cpp,"    int i;
    twoIntsStruct * data;
    data = NULL; 
    for(i = 0; i < 1; i++)
    {
        {
            
            static twoIntsStruct dataBuffer;
            dataBuffer.intOne = 1;
            dataBuffer.intTwo = 1;
            data = &dataBuffer;
        }
    }
    printStructLine(data);
    
"
2892,0,CWE369_Divide_by_Zero__int_listen_socket_modulo_22a.c,"    int data;
    
    data = -1;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    CWE369_Divide_by_Zero__int_listen_socket_modulo_22_badGlobal = 1; 
"
14267,0,CWE457_Use_of_Uninitialized_Variable__int_array_declare_partial_init_11.c,"    int * data;
    int dataUninitArray[10];
    data = dataUninitArray;
    if(globalReturnsTrue())
    {
        
        {
            int i;
            for(i=0; i<(10/2); i++)
            {
                data[i] = i;
            }
        }
    }
    if(globalReturnsTrue())
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i]);
            }
        }
"
13328,0,CWE690_NULL_Deref_From_Return__fopen_05.c,"    FILE * data;
    
    data = NULL;
    
    data = fopen(""file.txt"", ""w+"");
    if(staticTrue)
    {
        
        fclose(data);
"
333,1,CWE758_Undefined_Behavior__struct_pointer_malloc_use_07.c,"    if(staticFive==5)
    {
        {
            twoIntsStruct * data;
            twoIntsStruct * * pointer = (twoIntsStruct * *)malloc(sizeof(twoIntsStruct *));
            if (pointer == NULL) {exit(-1);}
            
            data = (twoIntsStruct *)malloc(sizeof(twoIntsStruct));
            if (data == NULL) {exit(-1);}
            data->intOne = 5;
            data->intTwo = 6;
            *pointer = data; 
            {
                twoIntsStruct * data = *pointer;
                printIntLine(data->intOne);
                printIntLine(data->intTwo);
            }
            free(pointer);
        }
"
13678,0,CWE758_Undefined_Behavior__long_alloca_use_14.c,"    if(globalFive==5)
    {
        {
            long * pointer = (long *)ALLOCA(sizeof(long));
            long data = *pointer; 
            printLongLine(data);
        }
"
6888,0,CWE690_NULL_Deref_From_Return__int64_t_realloc_04.c,"    int64_t * data;
    data = NULL; 
    
    data = (int64_t *)realloc(data, 1*sizeof(int64_t));
    if(STATIC_CONST_TRUE)
    {
        
        data[0] = 5LL;
        printLongLongLine(data[0]);
        free(data);
"
473,0,CWE134_Uncontrolled_Format_String__char_console_vprintf_11.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(globalReturnsTrue())
    {
        {
            
            size_t dataLen = strlen(data);
            
            if (100-dataLen > 1)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
                {
                    /* The next few lines remove the carriage return from the string that is
                     * inserted by fgets() */
                    dataLen = strlen(data);
                    if (dataLen > 0 && data[dataLen-1] == '\n')
                    {
                        data[dataLen-1] = '\0';
                    }
                }
                else
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
            }
        }
    }
    if(globalReturnsTrue())
    {
        badVaSinkB(data, data);
"
12157,1,CWE758_Undefined_Behavior__long_malloc_use_17.c,"    int k;
    for(k = 0; k < 1; k++)
    {
        {
            long data;
            long * pointer = (long *)malloc(sizeof(long));
            if (pointer == NULL) {exit(-1);}
            data = 5L;
            *pointer = data; 
            {
                long data = *pointer;
                printLongLine(data);
            }
            free(pointer);
        }
"
14552,0,CWE401_Memory_Leak__malloc_realloc_int64_t_14.c,"    if(globalFive==5)
    {
        {
            int64_t * data = (int64_t *)malloc(100*sizeof(int64_t));
            if (data == NULL) {exit(-1);}
            
            data[0] = 5LL;
            printLongLongLine(data[0]);
            
            data = (int64_t *)realloc(data, (130000)*sizeof(int64_t));
            if (data != NULL)
            {
                
                data[0] = 10LL;
                printLongLongLine(data[0]);
                free(data);
            }
        }
"
9409,0,CWE590_Free_Memory_Not_on_Heap__delete_array_int_alloca_06.cpp,"    int * data;
    data = NULL; 
    if(STATIC_CONST_FIVE==5)
    {
        {
            
            int * dataBuffer = (int *)ALLOCA(100*sizeof(int));
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5;
                }
            }
            data = dataBuffer;
        }
    }
    printIntLine(data[0]);
    
"
8152,0,CWE190_Integer_Overflow__int64_t_rand_add_41.c,"    int64_t data;
    data = 0LL;
    
    data = (int64_t)RAND64();
"
6175,0,CWE134_Uncontrolled_Format_String__char_environment_fprintf_74a.cpp,"    char * data;
    map<int, char *> dataMap;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        
        if (environment != NULL)
        {
            
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
12166,0,CWE415_Double_Free__new_delete_array_int_07.cpp,"    int * data;
    
    data = NULL;
    if(staticFive==5)
    {
        data = new int[100];
        
        delete [] data;
    }
    if(staticFive==5)
    {
        
        delete [] data;
"
8156,0,CWE252_Unchecked_Return_Value__char_puts_15.c,"    switch(6)
    {
    case 6:
        
        PUTS(""string"");
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
16734,0,CWE590_Free_Memory_Not_on_Heap__free_struct_alloca_68a.c,"    twoIntsStruct * data;
    data = NULL; 
    {
        
        twoIntsStruct * dataBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i].intOne = 1;
                dataBuffer[i].intTwo = 1;
            }
        }
        data = dataBuffer;
    }
    CWE590_Free_Memory_Not_on_Heap__free_struct_alloca_68_badData = data;
"
18073,0,CWE590_Free_Memory_Not_on_Heap__delete_struct_placement_new_05.cpp,"    twoIntsStruct * data;
    data = NULL; 
    if(staticTrue)
    {
        {
            
            char buffer[sizeof(twoIntsStruct)];
            twoIntsStruct * dataBuffer = new(buffer) twoIntsStruct;
            dataBuffer->intOne = 1;
            dataBuffer->intTwo = 1;
            data = dataBuffer;
        }
    }
    printStructLine(data);
    
"
7615,0,CWE134_Uncontrolled_Format_String__char_environment_snprintf_12.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(globalReturnsTrueOrFalse())
    {
        {
            
            size_t dataLen = strlen(data);
            char * environment = GETENV(ENV_VARIABLE);
            
            if (environment != NULL)
            {
                
                strncat(data+dataLen, environment, 100-dataLen-1);
            }
        }
    }
    else
    {
        
        strcpy(data, ""fixedstringtest"");
    }
    if(globalReturnsTrueOrFalse())
    {
        {
            char dest[100] = """";
            
            SNPRINTF(dest, 100-1, data);
            printLine(dest);
        }
    }
    else
    {
        {
            char dest[100] = """";
            
            SNPRINTF(dest, 100-1, ""%s"", data);
            printLine(dest);
        }
"
14535,0,CWE590_Free_Memory_Not_on_Heap__free_long_declare_73a.cpp,"    long * data;
    list<long *> dataList;
    data = NULL; 
    {
        
        long dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5L;
            }
        }
        data = dataBuffer;
    }
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
3373,0,CWE457_Use_of_Uninitialized_Variable__struct_array_malloc_no_init_11.c,"    twoIntsStruct * data;
    data = (twoIntsStruct *)malloc(10*sizeof(twoIntsStruct));
    if (data == NULL) {exit(-1);}
    if(globalReturnsTrue())
    {
        
        ; 
    }
    if(globalReturnsTrue())
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i].intOne);
                printIntLine(data[i].intTwo);
            }
        }
"
10018,0,CWE457_Use_of_Uninitialized_Variable__int_array_declare_no_init_06.c,"    int * data;
    int dataUninitArray[10];
    data = dataUninitArray;
    if(STATIC_CONST_FIVE==5)
    {
        
        ; 
    }
    if(STATIC_CONST_FIVE==5)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i]);
            }
        }
"
17019,0,CWE590_Free_Memory_Not_on_Heap__delete_class_declare_63a.cpp,"    TwoIntsClass * data;
    data = NULL; 
    {
        
        TwoIntsClass dataBuffer;
        dataBuffer.intOne = 1;
        dataBuffer.intTwo = 1;
        data = &dataBuffer;
    }
"
4664,0,CWE690_NULL_Deref_From_Return__struct_realloc_64a.c,"    twoIntsStruct * data;
    data = NULL; 
    
    data = (twoIntsStruct *)realloc(data, 1*sizeof(twoIntsStruct));
"
8149,0,CWE590_Free_Memory_Not_on_Heap__delete_int64_t_static_05.cpp,"    int64_t * data;
    data = NULL; 
    if(staticTrue)
    {
        {
            
            static int64_t dataBuffer;
            dataBuffer = 5LL;
            data = &dataBuffer;
        }
    }
    printLongLongLine(*data);
    
"
1463,0,CWE134_Uncontrolled_Format_String__char_console_fprintf_51a.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        
        if (100-dataLen > 1)
        {
            
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgets() */
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
                    data[dataLen-1] = '\0';
                }
            }
            else
            {
                printLine(""fgets() failed"");
                
                data[dataLen] = '\0';
            }
        }
    }
"
15014,0,CWE134_Uncontrolled_Format_String__char_environment_snprintf_68a.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        
        if (environment != NULL)
        {
            
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    CWE134_Uncontrolled_Format_String__char_environment_snprintf_68_badData = data;
"
19456,0,CWE590_Free_Memory_Not_on_Heap__delete_int_declare_74a.cpp,"    int * data;
    map<int, int *> dataMap;
    data = NULL; 
    {
        
        int dataBuffer;
        dataBuffer = 5;
        data = &dataBuffer;
    }
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
93,0,CWE197_Numeric_Truncation_Error__short_fgets_82a.cpp,"    short data;
    
    data = -1;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = (short)atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    CWE197_Numeric_Truncation_Error__short_fgets_82_base* baseObject = new CWE197_Numeric_Truncation_Error__short_fgets_82_bad;
    baseObject->action(data);
"
12425,0,CWE190_Integer_Overflow__unsigned_int_rand_preinc_05.c,"    unsigned int data;
    data = 0;
    if(staticTrue)
    {
        
        data = (unsigned int)RAND32();
    }
    if(staticTrue)
    {
        {
            
            ++data;
            unsigned int result = data;
            printUnsignedLine(result);
        }
"
6311,0,CWE134_Uncontrolled_Format_String__char_file_fprintf_44.c,"    char * data;
    
    void (*funcPtr) (char *) = badSink;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        FILE * pFile;
        
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
    
"
177,0,CWE690_NULL_Deref_From_Return__long_realloc_07.c,"    long * data;
    data = NULL; 
    
    data = (long *)realloc(data, 1*sizeof(long));
    if(staticFive==5)
    {
        
        data[0] = 5L;
        printLongLine(data[0]);
        free(data);
"
19331,0,CWE590_Free_Memory_Not_on_Heap__free_long_static_33.cpp,"    long * data;
    long * &dataRef = data;
    data = NULL; 
    {
        
        static long dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5L;
            }
        }
        data = dataBuffer;
    }
    {
        long * data = dataRef;
        printLongLine(data[0]);
        
        free(data);
"
3758,1,CWE416_Use_After_Free__return_freed_ptr_04.c,"    if(STATIC_CONST_TRUE)
    {
        {
            
            char * reversedString = helperGood(""GoodSink"");
            printLine(reversedString);
            /* free(reversedString);
             * This call to free() was removed because we want the tool to detect the use after free,
             * but we don't want that function to be free(). Essentially we want to avoid a double free
             */
        }
"
12296,1,CWE587_Assignment_of_Fixed_Address_to_Pointer__basic_13.c,"    if(GLOBAL_CONST_FIVE!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            
            char charStack = 'a';
            char *charPointer = &charStack;
            printHexCharLine(*charPointer);
        }
"
6633,0,CWE78_OS_Command_Injection__char_file_system_42.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    data = badSource(data);
    
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
"
17688,0,CWE590_Free_Memory_Not_on_Heap__free_int64_t_alloca_17.c,"    int i;
    int64_t * data;
    data = NULL; 
    for(i = 0; i < 1; i++)
    {
        {
            
            int64_t * dataBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5LL;
                }
            }
            data = dataBuffer;
        }
    }
    printLongLongLine(data[0]);
    
"
3864,0,CWE190_Integer_Overflow__char_rand_add_82a.cpp,"    char data;
    data = ' ';
    
    data = (char)RAND32();
    CWE190_Integer_Overflow__char_rand_add_82_base* baseObject = new CWE190_Integer_Overflow__char_rand_add_82_bad;
    baseObject->action(data);
"
3807,0,CWE690_NULL_Deref_From_Return__struct_calloc_52a.c,"    twoIntsStruct * data;
    data = NULL; 
    
    data = (twoIntsStruct *)calloc(1, sizeof(twoIntsStruct));
"
4686,0,CWE369_Divide_by_Zero__int_zero_divide_34.c,"    int data;
    CWE369_Divide_by_Zero__int_zero_divide_34_unionType myUnion;
    
    data = -1;
    
    data = 0;
    myUnion.unionFirst = data;
    {
        int data = myUnion.unionSecond;
        
        printIntLine(100 / data);
"
1631,0,CWE190_Integer_Overflow__int_rand_square_66a.c,"    int data;
    int dataArray[5];
    
    data = 0;
    
    data = RAND32();
    
    dataArray[2] = data;
"
627,0,CWE476_NULL_Pointer_Dereference__struct_66a.c,"    twoIntsStruct * data;
    twoIntsStruct * dataArray[5];
    
    data = NULL;
    
    dataArray[2] = data;
"
12927,0,CWE590_Free_Memory_Not_on_Heap__free_int64_t_static_31.c,"    int64_t * data;
    data = NULL; 
    {
        
        static int64_t dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5LL;
            }
        }
        data = dataBuffer;
    }
    {
        int64_t * dataCopy = data;
        int64_t * data = dataCopy;
        printLongLongLine(data[0]);
        
        free(data);
"
2380,0,CWE190_Integer_Overflow__short_fscanf_preinc_07.c,"    short data;
    data = 0;
    if(staticFive==5)
    {
        
        fscanf (stdin, ""%hd"", &data);
    }
    if(staticFive==5)
    {
        {
            
            ++data;
            short result = data;
            printIntLine(result);
        }
"
10880,0,CWE457_Use_of_Uninitialized_Variable__int_array_malloc_no_init_03.c,"    int * data;
    data = (int *)malloc(10*sizeof(int));
    if (data == NULL) {exit(-1);}
    if(5==5)
    {
        
        ; 
    }
    if(5==5)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i]);
            }
        }
"
7201,0,CWE190_Integer_Overflow__short_fscanf_multiply_10.c,"    short data;
    data = 0;
    if(globalTrue)
    {
        
        fscanf (stdin, ""%hd"", &data);
    }
    if(globalTrue)
    {
        if(data > 0) 
        {
            
            short result = data * 2;
            printIntLine(result);
        }
"
15977,0,CWE190_Integer_Overflow__int64_t_rand_preinc_65a.c,"    int64_t data;
    
    void (*funcPtr) (int64_t) = CWE190_Integer_Overflow__int64_t_rand_preinc_65b_badSink;
    data = 0LL;
    
    data = (int64_t)RAND64();
    
"
3143,0,CWE190_Integer_Overflow__short_fscanf_add_67a.c,"    short data;
    CWE190_Integer_Overflow__short_fscanf_add_67_structType myStruct;
    data = 0;
    
    fscanf (stdin, ""%hd"", &data);
    myStruct.structFirst = data;
"
17406,0,CWE563_Unused_Variable__unused_value_struct_04.c,"    twoIntsStruct data;
    if(STATIC_CONST_TRUE)
    {
        
        data.intOne = 0;
        data.intTwo = 0;
    }
    if(STATIC_CONST_TRUE)
    {
        
        data.intOne = 1;
        data.intTwo = 1;
        printStructLine(&data);
"
5064,0,CWE78_OS_Command_Injection__char_console_popen_22a.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    CWE78_OS_Command_Injection__char_console_popen_22_badGlobal = 1; 
    data = CWE78_OS_Command_Injection__char_console_popen_22_badSource(data);
    {
        FILE *pipe;
        
        pipe = POPEN(data, ""w"");
        if (pipe != NULL)
        {
            PCLOSE(pipe);
        }
    }
}

#endif 
"
3090,0,CWE476_NULL_Pointer_Dereference__int_81_bad.cpp,"Label Definition File: CWE476_NULL_Pointer_Dereference.label.xml
Template File: sources-sinks-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 476 NULL Pointer Dereference
 * BadSource:  Set data to NULL
 * GoodSource: Initialize data
 * Sinks:
 *    GoodSink: Check for NULL before attempting to print data
 *    BadSink : Print data
 * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE476_NULL_Pointer_Dereference__int_81.h""

namespace CWE476_NULL_Pointer_Dereference__int_81
{

void CWE476_NULL_Pointer_Dereference__int_81_bad::action(int * data) const
{
    
    printIntLine(*data);
}

}
"
1673,0,CWE563_Unused_Variable__unused_init_variable_struct_82a.cpp,"    twoIntsStruct data;
    
    data.intOne = 0;
    data.intTwo = 0;
    CWE563_Unused_Variable__unused_init_variable_struct_82_base* baseObject = new CWE563_Unused_Variable__unused_init_variable_struct_82_bad;
    baseObject->action(data);
"
18435,0,CWE78_OS_Command_Injection__char_console_popen_44.c,"    char * data;
    
    void (*funcPtr) (char *) = badSink;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
        
        size_t dataLen = strlen(data);
        
        if (100-dataLen > 1)
        {
            
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgets() */
                dataLen = strlen(data);
"
6337,0,CWE190_Integer_Overflow__int_max_postinc_12.c,"    int data;
    
    data = 0;
    if(globalReturnsTrueOrFalse())
    {
        
        data = INT_MAX;
    }
    else
    {
        
        data = 2;
    }
    if(globalReturnsTrueOrFalse())
    {
        {
            
            data++;
            int result = data;
            printIntLine(result);
        }
    }
    else
    {
        
        if (data < INT_MAX)
        {
            data++;
            int result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
"
14073,0,CWE190_Integer_Overflow__unsigned_int_fscanf_square_18.c,"    unsigned int data;
    data = 0;
    goto source;
source:
    
    fscanf (stdin, ""%u"", &data);
    goto sink;
sink:
    {
        
        unsigned int result = data * data;
        printUnsignedLine(result);
"
7847,0,CWE190_Integer_Overflow__short_fscanf_postinc_61a.c,"    short data;
    data = 0;
    data = CWE190_Integer_Overflow__short_fscanf_postinc_61b_badSource(data);
    {
        
        data++;
        short result = data;
        printIntLine(result);
"
10627,0,CWE190_Integer_Overflow__int64_t_max_add_33.cpp,"    int64_t data;
    int64_t &dataRef = data;
    data = 0LL;
    
    data = LLONG_MAX;
    {
        int64_t data = dataRef;
        {
            
            int64_t result = data + 1;
            printLongLongLine(result);
        }
"
5205,0,CWE758_Undefined_Behavior__int_alloca_use_07.c,"    if(staticFive==5)
    {
        {
            int * pointer = (int *)ALLOCA(sizeof(int));
            int data = *pointer; 
            printIntLine(data);
        }
"
19184,0,CWE369_Divide_by_Zero__int_rand_modulo_10.c,"    int data;
    
    data = -1;
    if(globalTrue)
    {
        
        data = RAND32();
    }
    if(globalTrue)
    {
        
        printIntLine(100 % data);
"
11616,0,CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_81a.cpp,"    size_t data;
    
    data = 0;
    
    fscanf(stdin, ""%zu"", &data);
    const CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_81_base& o = CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_81_bad();
"
456,1,CWE252_Unchecked_Return_Value__char_fputs_16.c,"    while(1)
    {
        
        if (fputs(""string"", stdout) == EOF)
        {
            printLine(""fputs failed!"");
        }
        break;
"
2546,1,CWE758_Undefined_Behavior__int64_t_new_use_03.cpp,"    if(5==5)
    {
        {
            int64_t data;
            data = 5LL;
            int64_t * pointer = new int64_t;
            *pointer = data; 
            {
                int64_t data = *pointer;
                printLongLongLine(data);
            }
            delete pointer;
        }
"
7423,0,CWE401_Memory_Leak__new_struct_twoIntsStruct_13.cpp,"    struct _twoIntsStruct * data;
    data = NULL;
    if(GLOBAL_CONST_FIVE==5)
    {
        
        data = new struct _twoIntsStruct;
        
        data->intOne = 0;
        data->intTwo = 0;
        printStructLine((twoIntsStruct *)data);
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        
        ; 
"
6677,0,CWE416_Use_After_Free__malloc_free_long_05.c,"    long * data;
    
    data = NULL;
    if(staticTrue)
    {
        data = (long *)malloc(100*sizeof(long));
        if (data == NULL) {exit(-1);}
        {
            size_t i;
            for(i = 0; i < 100; i++)
            {
                data[i] = 5L;
            }
        }
        
        free(data);
    }
    if(staticTrue)
    {
        
        printLongLine(data[0]);
        
"
795,0,CWE190_Integer_Overflow__char_max_add_83_bad.cpp,"Label Definition File: CWE190_Integer_Overflow.label.xml
Template File: sources-sinks-83_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 190 Integer Overflow
 * BadSource: max Set data to the max value for char
 * GoodSource: Set data to a small, non-zero number (two)
 * Sinks: add
 *    GoodSink: Ensure there will not be an overflow before adding 1 to data
 *    BadSink : Add 1 to data, which can cause an overflow
 * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE190_Integer_Overflow__char_max_add_83.h""

namespace CWE190_Integer_Overflow__char_max_add_83
{
CWE190_Integer_Overflow__char_max_add_83_bad::CWE190_Integer_Overflow__char_max_add_83_bad(char dataCopy)
{
    data = dataCopy;
    
    data = CHAR_MAX;
}

CWE190_Integer_Overflow__char_max_add_83_bad::~CWE190_Integer_Overflow__char_max_add_83_bad()
{
    {
        
        char result = data + 1;
        printHexCharLine(result);
    }
}
}
"
13652,0,CWE78_OS_Command_Injection__char_environment_system_22a.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    CWE78_OS_Command_Injection__char_environment_system_22_badGlobal = 1; 
    data = CWE78_OS_Command_Injection__char_environment_system_22_badSource(data);
    
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
"
6022,0,CWE190_Integer_Overflow__unsigned_int_rand_square_44.c,"    unsigned int data;
    
    void (*funcPtr) (unsigned int) = badSink;
    data = 0;
    
    data = (unsigned int)RAND32();
    
"
11313,0,CWE690_NULL_Deref_From_Return__long_realloc_15.c,"    long * data;
    data = NULL; 
    
    data = (long *)realloc(data, 1*sizeof(long));
    switch(6)
    {
    case 6:
        
        data[0] = 5L;
        printLongLine(data[0]);
        free(data);
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
18818,0,CWE78_OS_Command_Injection__char_listen_socket_execlp_63a.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
2103,0,CWE457_Use_of_Uninitialized_Variable__char_pointer_09.c,"    char * data;
    if(GLOBAL_CONST_TRUE)
    {
        
        ; 
    }
    if(GLOBAL_CONST_TRUE)
    {
        
        printLine(data);
"
4319,0,CWE197_Numeric_Truncation_Error__int_listen_socket_to_char_82a.cpp,"    int data;
    
    data = -1;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    CWE197_Numeric_Truncation_Error__int_listen_socket_to_char_82_base* baseObject = new CWE197_Numeric_Truncation_Error__int_listen_socket_to_char_82_bad;
    baseObject->action(data);
"
19083,0,CWE690_NULL_Deref_From_Return__int_realloc_07.c,"    int * data;
    data = NULL; 
    
    data = (int *)realloc(data, 1*sizeof(int));
    if(staticFive==5)
    {
        
        data[0] = 5;
        printIntLine(data[0]);
        free(data);
"
9644,0,CWE415_Double_Free__new_delete_array_int_67a.cpp,"    int * data;
    structType myStruct;
    
    data = NULL;
    data = new int[100];
    
    delete [] data;
    myStruct.structFirst = data;
"
17097,0,CWE590_Free_Memory_Not_on_Heap__delete_array_long_static_51a.cpp,"    long * data;
    data = NULL; 
    {
        
        static long dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5L;
            }
        }
        data = dataBuffer;
    }
"
11981,0,CWE476_NULL_Pointer_Dereference__char_41.c,"    char * data;
    
    data = NULL;
"
19277,0,CWE789_Uncontrolled_Mem_Alloc__new_char_listen_socket_33.cpp,"    size_t data;
    size_t &dataRef = data;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = strtoul(inputBuffer, NULL, 0);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    {
        size_t data = dataRef;
        {
            char * myString;
            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
             * for the strcpy() function to not cause a buffer overflow */
            
            if (data > strlen(HELLO_STRING))
            {
                myString = new char[data];
                
                strcpy(myString, HELLO_STRING);
                printLine(myString);
                delete [] myString;
            }
            else
            {
                printLine(""Input is less than the length of the source string"");
            }
        }
"
956,0,CWE78_OS_Command_Injection__char_console_execlp_52a.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        
        if (100-dataLen > 1)
        {
            
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgets() */
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
                    data[dataLen-1] = '\0';
                }
            }
            else
            {
                printLine(""fgets() failed"");
                
                data[dataLen] = '\0';
            }
        }
    }
"
16899,0,CWE401_Memory_Leak__malloc_realloc_int_07.c,"    if(staticFive==5)
    {
        {
            int * data = (int *)malloc(100*sizeof(int));
            if (data == NULL) {exit(-1);}
            
            data[0] = 5;
            printIntLine(data[0]);
            
            data = (int *)realloc(data, (130000)*sizeof(int));
            if (data != NULL)
            {
                
                data[0] = 10;
                printIntLine(data[0]);
                free(data);
            }
        }
"
5764,0,CWE190_Integer_Overflow__char_fscanf_multiply_10.c,"    char data;
    data = ' ';
    if(globalTrue)
    {
        
        fscanf (stdin, ""%c"", &data);
    }
    if(globalTrue)
    {
        if(data > 0) 
        {
            
            char result = data * 2;
            printHexCharLine(result);
        }
"
11416,0,CWE590_Free_Memory_Not_on_Heap__delete_int_declare_32.cpp,"    int * data;
    int * *dataPtr1 = &data;
    int * *dataPtr2 = &data;
    data = NULL; 
    {
        int * data = *dataPtr1;
        {
            
            int dataBuffer;
            dataBuffer = 5;
            data = &dataBuffer;
        }
        *dataPtr1 = data;
    }
    {
        int * data = *dataPtr2;
        printIntLine(*data);
        
        delete data;
"
5734,0,CWE457_Use_of_Uninitialized_Variable__struct_array_alloca_partial_init_64a.c,"    twoIntsStruct * data;
    data = (twoIntsStruct *)ALLOCA(10*sizeof(twoIntsStruct));
    
    {
        int i;
        for(i=0; i<(10/2); i++)
        {
            data[i].intOne = i;
            data[i].intTwo = i;
        }
    }
"
17067,0,CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_32.cpp,"    size_t data;
    size_t *dataPtr1 = &data;
    size_t *dataPtr2 = &data;
    
    data = 0;
    {
        size_t data = *dataPtr1;
        
        fscanf(stdin, ""%zu"", &data);
        *dataPtr1 = data;
    }
    {
        size_t data = *dataPtr2;
        {
            char * myString;
            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
             * for the strcpy() function to not cause a buffer overflow */
            
            if (data > strlen(HELLO_STRING))
            {
                myString = new char[data];
                
                strcpy(myString, HELLO_STRING);
                printLine(myString);
                delete [] myString;
            }
            else
            {
                printLine(""Input is less than the length of the source string"");
            }
        }
"
10621,0,CWE134_Uncontrolled_Format_String__char_console_snprintf_06.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(STATIC_CONST_FIVE==5)
    {
        {
            
            size_t dataLen = strlen(data);
            
            if (100-dataLen > 1)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
                {
                    /* The next few lines remove the carriage return from the string that is
                     * inserted by fgets() */
                    dataLen = strlen(data);
                    if (dataLen > 0 && data[dataLen-1] == '\n')
                    {
                        data[dataLen-1] = '\0';
                    }
                }
                else
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
            }
        }
    }
    if(STATIC_CONST_FIVE==5)
    {
        {
            char dest[100] = """";
            
            SNPRINTF(dest, 100-1, data);
            printLine(dest);
        }
"
10148,0,CWE415_Double_Free__new_delete_array_class_43.cpp,"    TwoIntsClass * data;
    
    data = NULL;
    badSource(data);
    
"
19256,0,CWE401_Memory_Leak__new_char_33.cpp,"    char * data;
    char * &dataRef = data;
    data = NULL;
    
    data = new char;
    
    *data = 'A';
    printHexCharLine(*data);
    {
        char * data = dataRef;
        
        ; 
"
18882,1,CWE688_Function_Call_With_Incorrect_Variable_or_Reference_as_Argument__basic_07.c,"    if(staticFive!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            char dest[DEST_SIZE];
            int intFive = 5;
            
            sprintf(dest, ""%d"", intFive);
            printLine(dest);
        }
"
7151,0,CWE197_Numeric_Truncation_Error__int_large_to_char_11.c,"    int data;
    
    data = -1;
    if(globalReturnsTrue())
    {
        
        data = SHRT_MAX + 5;
    }
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
18226,0,CWE416_Use_After_Free__malloc_free_long_12.c,"    long * data;
    
    data = NULL;
    if(globalReturnsTrueOrFalse())
    {
        data = (long *)malloc(100*sizeof(long));
        if (data == NULL) {exit(-1);}
        {
            size_t i;
            for(i = 0; i < 100; i++)
            {
                data[i] = 5L;
            }
        }
        
        free(data);
    }
    else
    {
        data = (long *)malloc(100*sizeof(long));
        if (data == NULL) {exit(-1);}
        {
            size_t i;
            for(i = 0; i < 100; i++)
            {
                data[i] = 5L;
            }
        }
        
    }
    if(globalReturnsTrueOrFalse())
    {
        
        printLongLine(data[0]);
        
    }
    else
    {
        
        
        
        ; 
"
3790,0,CWE590_Free_Memory_Not_on_Heap__delete_long_placement_new_31.cpp,"    long * data;
    data = NULL; 
    {
        
        char buffer[sizeof(long)];
        long * dataBuffer = new(buffer) long;
        *dataBuffer = 5L;
        data = dataBuffer;
    }
    {
        long * dataCopy = data;
        long * data = dataCopy;
        printLongLine(*data);
        
        delete data;
"
12759,1,CWE676_Use_of_Potentially_Dangerous_Function__basic_14.cpp,"    if(globalFive!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            char charBuffer[CHAR_BUFFER_SIZE];
            
            cin.width(CHAR_BUFFER_SIZE);
            cin >> charBuffer;
            charBuffer[CHAR_BUFFER_SIZE-1] = '\0';
            printLine(charBuffer);
        }
"
16197,0,CWE190_Integer_Overflow__int_fscanf_postinc_06.c,"    int data;
    
    data = 0;
    if(STATIC_CONST_FIVE==5)
    {
        
        fscanf(stdin, ""%d"", &data);
    }
    if(STATIC_CONST_FIVE==5)
    {
        {
            
            data++;
            int result = data;
            printIntLine(result);
        }
"
4352,0,CWE590_Free_Memory_Not_on_Heap__delete_class_static_82_bad.cpp,"Label Definition File: CWE590_Free_Memory_Not_on_Heap__delete.nonpointer.label.xml
Template File: sources-sink-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 590 Free Memory Not on Heap
 * BadSource: static Data buffer is declared static on the stack
 * GoodSource: Allocate memory on the heap
 * Sinks:
 *    BadSink : Print then free data
 * Flow Variant: 82 Data flow: data passed in a parameter to a virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE590_Free_Memory_Not_on_Heap__delete_class_static_82.h""

namespace CWE590_Free_Memory_Not_on_Heap__delete_class_static_82
{

void CWE590_Free_Memory_Not_on_Heap__delete_class_static_82_bad::action(TwoIntsClass * data)
{
    printIntLine(data->intOne);
    
    delete data;
}

}
"
7510,0,CWE457_Use_of_Uninitialized_Variable__no_constructor_01_bad.cpp," * 
 * */

#include ""std_testcase.h""

namespace CWE457_Use_of_Uninitialized_Variable__no_constructor_01
{

#ifndef OMITBAD

class BadClass 
{
    public:
        
        int intOne;        
};

void bad()
{
    
    BadClass * badClassObject = new BadClass;
    printIntLine(badClassObject->intOne);
}

#endif 

} 

/* Below is the main(). It is only used when building this testcase on 
 * its own for testing or for building a binary to use in testing binary 
 * analysis tools. It is not used when compiling all the testcases as one 
 * application, which is how source code analysis tools are tested. 
 */ 

#ifdef INCLUDEMAIN

using namespace CWE457_Use_of_Uninitialized_Variable__no_constructor_01; 

int main(int argc, char * argv[])
{
    
    srand( (unsigned)time(NULL) );
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}

"
2043,1,CWE758_Undefined_Behavior__class_new_use_17.cpp,"    int k;
    for(k = 0; k < 1; k++)
    {
        {
            TwoIntsClass data;
            data.intOne = 1;
            data.intTwo = 2;
            TwoIntsClass * pointer = new TwoIntsClass;
            *pointer = data; 
            {
                TwoIntsClass data = *pointer;
                printIntLine(data.intOne);
                printIntLine(data.intTwo);
            }
            delete pointer;
        }
"
18988,0,CWE457_Use_of_Uninitialized_Variable__twointsclass_array_declare_no_init_18.cpp,"    TwoIntsClass * data;
    TwoIntsClass dataUninitArray[10];
    data = dataUninitArray;
    goto source;
source:
    
    ; 
    goto sink;
sink:
    
    for(int i=0; i<10; i++)
    {
        printIntLine(data[i].intOne);
        printIntLine(data[i].intTwo);
"
18301,0,CWE190_Integer_Overflow__int64_t_max_add_01.c,"    int64_t data;
    data = 0LL;
    
    data = LLONG_MAX;
    {
        
        int64_t result = data + 1;
        printLongLongLine(result);
"
12073,1,CWE758_Undefined_Behavior__long_malloc_use_12.c,"    if(globalReturnsTrueOrFalse())
    {
        {
            long data;
            long * pointer = (long *)malloc(sizeof(long));
            if (pointer == NULL) {exit(-1);}
            data = 5L;
            *pointer = data; 
            {
                long data = *pointer;
                printLongLine(data);
            }
            free(pointer);
        }
    }
    else
    {
        {
            long data;
            long * pointer = (long *)malloc(sizeof(long));
            if (pointer == NULL) {exit(-1);}
            data = 5L;
            *pointer = data; 
            {
                long data = *pointer;
                printLongLine(data);
            }
            free(pointer);
        }
"
19107,0,CWE190_Integer_Overflow__int_listen_socket_multiply_83a.cpp,"    int data;
    
    data = 0;
"
19175,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_15.c,"    size_t data;
    
    data = 0;
    switch(6)
    {
    case 6:
        
        data = rand();
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
    {
        char * myString;
        /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
         * for the strcpy() function to not cause a buffer overflow */
        
        if (data > strlen(HELLO_STRING))
        {
            myString = (char *)malloc(data*sizeof(char));
            if (myString == NULL) {exit(-1);}
            
            strcpy(myString, HELLO_STRING);
            printLine(myString);
            free(myString);
        }
        else
        {
            printLine(""Input is less than the length of the source string"");
        }
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
7068,0,CWE401_Memory_Leak__int_malloc_52a.c,"    int * data;
    data = NULL;
    
    data = (int *)malloc(100*sizeof(int));
    if (data == NULL) {exit(-1);}
    
    data[0] = 5;
    printIntLine(data[0]);
"
1509,0,CWE590_Free_Memory_Not_on_Heap__free_long_declare_17.c,"    int i;
    long * data;
    data = NULL; 
    for(i = 0; i < 1; i++)
    {
        {
            
            long dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5L;
                }
            }
            data = dataBuffer;
        }
    }
    printLongLine(data[0]);
    
"
16402,0,CWE690_NULL_Deref_From_Return__struct_realloc_01.c,"    twoIntsStruct * data;
    data = NULL; 
    
    data = (twoIntsStruct *)realloc(data, 1*sizeof(twoIntsStruct));
    
    data[0].intOne = 1;
    data[0].intTwo = 1;
    printStructLine(&data[0]);
"
15367,0,CWE416_Use_After_Free__malloc_free_struct_64a.c,"    twoIntsStruct * data;
    
    data = NULL;
    data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
    if (data == NULL) {exit(-1);}
    {
        size_t i;
        for(i = 0; i < 100; i++)
        {
            data[i].intOne = 1;
            data[i].intTwo = 2;
        }
    }
    
    free(data);
"
15027,0,CWE758_Undefined_Behavior__struct_pointer_new_use_12.cpp,"    if(globalReturnsTrueOrFalse())
    {
        {
            twoIntsStruct * * pointer = new twoIntsStruct *;
            twoIntsStruct * data = *pointer; 
            delete pointer;
            printIntLine(data->intOne);
            printIntLine(data->intTwo);
        }
    }
    else
    {
        {
            twoIntsStruct * data;
            
            data = new twoIntsStruct;
            data->intOne = 5;
            data->intTwo = 6;
            twoIntsStruct * * pointer = new twoIntsStruct *;
            *pointer = data; 
            {
                twoIntsStruct * data = *pointer;
                printIntLine(data->intOne);
                printIntLine(data->intTwo);
            }
            delete pointer;
        }
"
15511,0,CWE415_Double_Free__new_delete_int_81_bad.cpp,"Label Definition File: CWE415_Double_Free__new_delete.label.xml
Template File: sources-sinks-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 415 Double Free
 * BadSource:  Allocate data using new and Deallocae data using delete
 * GoodSource: Allocate data using new
 * Sinks:
 *    GoodSink: do nothing
 *    BadSink : Deallocate data using delete
 * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE415_Double_Free__new_delete_int_81.h""

namespace CWE415_Double_Free__new_delete_int_81
{

void CWE415_Double_Free__new_delete_int_81_bad::action(int * data) const
{
    
    delete data;
}

}
"
16894,0,CWE190_Integer_Overflow__char_fscanf_postinc_44.c,"    char data;
    
    void (*funcPtr) (char) = badSink;
    data = ' ';
    
    fscanf (stdin, ""%c"", &data);
    
"
17881,0,CWE190_Integer_Overflow__int_fgets_preinc_65a.c,"    int data;
    
    void (*funcPtr) (int) = CWE190_Integer_Overflow__int_fgets_preinc_65b_badSink;
    
    data = 0;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    
"
2757,0,CWE190_Integer_Overflow__int_fscanf_preinc_63a.c,"    int data;
    
    data = 0;
    
    fscanf(stdin, ""%d"", &data);
"
15845,1,CWE467_Use_of_sizeof_on_Pointer_Type__int_01.c,"    {
        int * goodInt = NULL;
        
        goodInt = (int *)malloc(sizeof(*goodInt));
        if (goodInt == NULL) {exit(-1);}
        *goodInt = 6;
        printIntLine(*goodInt);
        free(goodInt);
"
677,0,CWE190_Integer_Overflow__short_max_square_33.cpp,"    short data;
    short &dataRef = data;
    data = 0;
    
    data = SHRT_MAX;
    {
        short data = dataRef;
        {
            
            short result = data * data;
            printIntLine(result);
        }
"
15134,0,CWE563_Unused_Variable__unused_init_variable_int64_t_16.c,"    int64_t data;
    
    data = 5LL;
    while(1)
    {
        
        
        ; 
        break;
"
18947,0,CWE590_Free_Memory_Not_on_Heap__free_struct_declare_16.c,"    twoIntsStruct * data;
    data = NULL; 
    while(1)
    {
        {
            
            twoIntsStruct dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i].intOne = 1;
                    dataBuffer[i].intTwo = 1;
                }
            }
            data = dataBuffer;
        }
        break;
    }
    printStructLine(&data[0]);
    
"
9949,0,CWE590_Free_Memory_Not_on_Heap__free_int64_t_declare_81_bad.cpp,"Label Definition File: CWE590_Free_Memory_Not_on_Heap__free.label.xml
Template File: sources-sink-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 590 Free Memory Not on Heap
 * BadSource: declare Data buffer is declared on the stack
 * GoodSource: Allocate memory on the heap
 * Sinks:
 *    BadSink : Print then free data
 * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE590_Free_Memory_Not_on_Heap__free_int64_t_declare_81.h""

namespace CWE590_Free_Memory_Not_on_Heap__free_int64_t_declare_81
{

void CWE590_Free_Memory_Not_on_Heap__free_int64_t_declare_81_bad::action(int64_t * data) const
{
    printLongLongLine(data[0]);
    
    free(data);
}

}
"
10132,0,CWE134_Uncontrolled_Format_String__char_environment_vfprintf_66a.c,"    char * data;
    char * dataArray[5];
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        
        if (environment != NULL)
        {
            
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    
    dataArray[2] = data;
"
9103,0,CWE789_Uncontrolled_Mem_Alloc__new_char_connect_socket_15.cpp,"    size_t data;
    
    data = 0;
    switch(6)
    {
    case 6:
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = strtoul(inputBuffer, NULL, 0);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
    {
        char * myString;
        /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
         * for the strcpy() function to not cause a buffer overflow */
        
        if (data > strlen(HELLO_STRING))
        {
            myString = new char[data];
            
            strcpy(myString, HELLO_STRING);
            printLine(myString);
            delete [] myString;
        }
        else
        {
            printLine(""Input is less than the length of the source string"");
        }
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
11218,0,CWE78_OS_Command_Injection__char_listen_socket_popen_13.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(GLOBAL_CONST_FIVE==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                data[dataLen + recvResult / sizeof(char)] = '\0';
                
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    {
        FILE *pipe;
        
        pipe = POPEN(data, ""w"");
        if (pipe != NULL)
        {
            PCLOSE(pipe);
        }
"
5466,1,CWE758_Undefined_Behavior__int_pointer_alloca_use_07.c,"    if(staticFive!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            int * data;
            int * * pointer = (int * *)ALLOCA(sizeof(int *));
            
            data = (int *)malloc(sizeof(int));
            if (data == NULL) {exit(-1);}
            *data = 5;
            *pointer = data; 
            {
                int * data = *pointer;
                printIntLine(*data);
            }
        }
"
10099,0,CWE190_Integer_Overflow__unsigned_int_rand_add_14.c,"    unsigned int data;
    data = 0;
    if(globalFive==5)
    {
        
        data = (unsigned int)RAND32();
    }
    if(globalFive==5)
    {
        {
            
            unsigned int result = data + 1;
            printUnsignedLine(result);
        }
"
12553,0,CWE401_Memory_Leak__new_array_char_11.cpp,"    char * data;
    data = NULL;
    if(globalReturnsTrue())
    {
        
        data = new char[100];
        
        strcpy(data, ""A String"");
        printLine(data);
    }
    if(globalReturnsTrue())
    {
        
        ; 
"
3096,0,CWE457_Use_of_Uninitialized_Variable__twointsclass_array_new_no_init_01.cpp,"    TwoIntsClass * data;
    data = new TwoIntsClass[10];
    
    ; 
    
    for(int i=0; i<10; i++)
    {
        printIntLine(data[i].intOne);
        printIntLine(data[i].intTwo);
"
9153,0,CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_11.cpp,"    size_t data;
    
    data = 0;
    if(globalReturnsTrue())
    {
        
        fscanf(stdin, ""%zu"", &data);
    }
    if(globalReturnsTrue())
    {
        {
            char * myString;
            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
             * for the strcpy() function to not cause a buffer overflow */
            
            if (data > strlen(HELLO_STRING))
            {
                myString = new char[data];
                
                strcpy(myString, HELLO_STRING);
                printLine(myString);
                delete [] myString;
            }
            else
            {
                printLine(""Input is less than the length of the source string"");
            }
        }
"
14047,0,CWE758_Undefined_Behavior__char_pointer_malloc_use_15.c,"    switch(6)
    {
    case 6:
    {
        char * * pointer = (char * *)malloc(sizeof(char *));
        if (pointer == NULL) {exit(-1);}
        char * data = *pointer; 
        free(pointer);
        printLine(data);
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
16504,0,CWE401_Memory_Leak__char_malloc_16.c,"    char * data;
    data = NULL;
    while(1)
    {
        
        data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        
        strcpy(data, ""A String"");
        printLine(data);
        break;
    }
    while(1)
    {
        
        ; 
        break;
"
5544,0,CWE590_Free_Memory_Not_on_Heap__delete_array_int_static_10.cpp,"    int * data;
    data = NULL; 
    if(globalTrue)
    {
        {
            
            static int dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5;
                }
            }
            data = dataBuffer;
        }
    }
    printIntLine(data[0]);
    
"
15173,1,CWE401_Memory_Leak__malloc_realloc_char_08.c,"    if(staticReturnsFalse())
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            char * data = (char *)malloc(100*sizeof(char));
            if (data == NULL) {exit(-1);}
            char * tmpData;
            
            strcpy(data, ""A String"");
            printLine(data);
            tmpData = (char *)realloc(data, (130000)*sizeof(char));
            /* FIX: Ensure realloc() was successful before assigning data to the memory block
            * allocated with realloc() */
            if (tmpData != NULL)
            {
                data = tmpData;
                
                strcpy(data, ""New String"");
                printLine(data);
            }
            free(data);
        }
"
19300,0,CWE590_Free_Memory_Not_on_Heap__delete_int_placement_new_54a.cpp,"    int * data;
    data = NULL; 
    {
        
        char buffer[sizeof(int)];
        int * dataBuffer = new(buffer) int;
        *dataBuffer = 5;
        data = dataBuffer;
    }
"
15358,0,CWE401_Memory_Leak__new_TwoIntsClass_14.cpp,"    TwoIntsClass * data;
    data = NULL;
    if(globalFive==5)
    {
        
        data = new TwoIntsClass;
        
        data->intOne = 0;
        data->intTwo = 0;
        printIntLine(data->intOne);
        printIntLine(data->intTwo);
    }
    if(globalFive==5)
    {
        
        ; 
"
1534,1,CWE758_Undefined_Behavior__char_pointer_alloca_use_07.c,"    if(staticFive==5)
    {
        {
            char * data;
            char * * pointer = (char * *)ALLOCA(sizeof(char *));
            data = ""string"";
            *pointer = data; 
            {
                char * data = *pointer;
                printLine(data);
            }
        }
"
15825,0,CWE134_Uncontrolled_Format_String__char_connect_socket_printf_54a.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
8009,1,CWE401_Memory_Leak__malloc_realloc_twoIntsStruct_02.c,"    if(0)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            twoIntsStruct * data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
            if (data == NULL) {exit(-1);}
            twoIntsStruct * tmpData;
            
            data[0].intOne = 0;
            data[0].intTwo = 0;
            printStructLine(&data[0]);
            tmpData = (twoIntsStruct *)realloc(data, (130000)*sizeof(twoIntsStruct));
            /* FIX: Ensure realloc() was successful before assigning data to the memory block
            * allocated with realloc() */
            if (tmpData != NULL)
            {
                data = tmpData;
                
                data[0].intOne = 1;
                data[0].intTwo = 1;
                printStructLine(&data[0]);
            }
            free(data);
        }
"
6914,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_62a.cpp,"    size_t data;
    
    data = 0;
    badSource(data);
    {
        char * myString;
        /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
         * for the strcpy() function to not cause a buffer overflow */
        
        if (data > strlen(HELLO_STRING))
        {
            myString = (char *)malloc(data*sizeof(char));
            if (myString == NULL) {exit(-1);}
            
            strcpy(myString, HELLO_STRING);
            printLine(myString);
            free(myString);
        }
        else
        {
            printLine(""Input is less than the length of the source string"");
        }
"
1489,0,CWE134_Uncontrolled_Format_String__char_environment_printf_64a.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        
        if (environment != NULL)
        {
            
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
"
11200,0,CWE401_Memory_Leak__int_calloc_83a.cpp,"    int * data;
    data = NULL;
"
11703,0,CWE197_Numeric_Truncation_Error__int_fgets_to_short_18.c,"    int data;
    
    data = -1;
    goto source;
source:
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    {
        
        short shortData = (short)data;
        printShortLine(shortData);
"
17397,0,CWE190_Integer_Overflow__short_max_square_64a.c,"    short data;
    data = 0;
    
    data = SHRT_MAX;
"
3461,0,CWE590_Free_Memory_Not_on_Heap__delete_array_struct_static_82a.cpp,"    twoIntsStruct * data;
    data = NULL; 
    {
        
        static twoIntsStruct dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i].intOne = 1;
                dataBuffer[i].intTwo = 1;
            }
        }
        data = dataBuffer;
    }
    CWE590_Free_Memory_Not_on_Heap__delete_array_struct_static_82_base* baseObject = new CWE590_Free_Memory_Not_on_Heap__delete_array_struct_static_82_bad;
    baseObject->action(data);
"
2702,0,CWE197_Numeric_Truncation_Error__int_large_to_short_07.c,"    int data;
    
    data = -1;
    if(staticFive==5)
    {
        
        data = SHRT_MAX + 5;
    }
    {
        
        short shortData = (short)data;
        printShortLine(shortData);
"
11118,0,CWE369_Divide_by_Zero__int_listen_socket_divide_34.c,"    int data;
    CWE369_Divide_by_Zero__int_listen_socket_divide_34_unionType myUnion;
    
    data = -1;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    myUnion.unionFirst = data;
    {
        int data = myUnion.unionSecond;
        
        printIntLine(100 / data);
"
7227,0,CWE590_Free_Memory_Not_on_Heap__free_char_static_18.c,"    char * data;
    data = NULL; 
    goto source;
source:
    {
        
        static char dataBuffer[100];
        memset(dataBuffer, 'A', 100-1); 
        dataBuffer[100-1] = '\0'; 
        data = dataBuffer;
    }
    printLine(data);
    
"
4941,0,CWE563_Unused_Variable__unused_init_variable_struct_13.c,"    twoIntsStruct data;
    
    data.intOne = 0;
    data.intTwo = 0;
    if(GLOBAL_CONST_FIVE==5)
    {
        
        
        ; 
"
13804,0,CWE369_Divide_by_Zero__int_fscanf_divide_81_bad.cpp,"Label Definition File: CWE369_Divide_by_Zero__int.label.xml
Template File: sources-sinks-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 369 Divide by Zero
 * BadSource: fscanf Read data from the console using fscanf()
 * GoodSource: Non-zero
 * Sinks: divide
 *    GoodSink: Check for zero before dividing
 *    BadSink : Divide a constant by data
 * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE369_Divide_by_Zero__int_fscanf_divide_81.h""

namespace CWE369_Divide_by_Zero__int_fscanf_divide_81
{

void CWE369_Divide_by_Zero__int_fscanf_divide_81_bad::action(int data) const
{
    
    printIntLine(100 / data);
}

}
"
16349,0,CWE401_Memory_Leak__twoIntsStruct_realloc_65a.c,"    twoIntsStruct * data;
    
    void (*funcPtr) (twoIntsStruct *) = CWE401_Memory_Leak__twoIntsStruct_realloc_65b_badSink;
    data = NULL;
    
    data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));
    if (data == NULL) {exit(-1);}
    
    data[0].intOne = 0;
    data[0].intTwo = 0;
    printStructLine(&data[0]);
    
"
2896,0,CWE758_Undefined_Behavior__char_malloc_use_07.c,"    if(staticFive==5)
    {
        {
            char * pointer = (char *)malloc(sizeof(char));
            if (pointer == NULL) {exit(-1);}
            char data = *pointer; 
            free(pointer);
            printHexCharLine(data);
        }
"
13259,0,CWE197_Numeric_Truncation_Error__int_listen_socket_to_short_15.c,"    int data;
    
    data = -1;
    switch(6)
    {
    case 6:
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    {
        
        short shortData = (short)data;
        printShortLine(shortData);
"
18473,1,CWE467_Use_of_sizeof_on_Pointer_Type__int_03.c,"    if(5==5)
    {
        {
            int * goodInt = NULL;
            
            goodInt = (int *)malloc(sizeof(*goodInt));
            if (goodInt == NULL) {exit(-1);}
            *goodInt = 6;
            printIntLine(*goodInt);
            free(goodInt);
        }
"
7324,0,CWE197_Numeric_Truncation_Error__short_listen_socket_84_bad.cpp,"Label Definition File: CWE197_Numeric_Truncation_Error__short.label.xml
Template File: sources-sink-84_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 197 Numeric Truncation Error
 * BadSource: listen_socket Read data using a listen socket (server side)
 * GoodSource: Less than CHAR_MAX
 * Sinks:
 *    BadSink : Convert data to a char
 * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE197_Numeric_Truncation_Error__short_listen_socket_84.h""

#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif

#define TCP_PORT 27015
#define LISTEN_BACKLOG 5

#define CHAR_ARRAY_SIZE 8

namespace CWE197_Numeric_Truncation_Error__short_listen_socket_84
{
CWE197_Numeric_Truncation_Error__short_listen_socket_84_bad::CWE197_Numeric_Truncation_Error__short_listen_socket_84_bad(short dataCopy)
{
    data = dataCopy;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = (short)atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
}

CWE197_Numeric_Truncation_Error__short_listen_socket_84_bad::~CWE197_Numeric_Truncation_Error__short_listen_socket_84_bad()
{
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
    }
}
}
"
13724,0,CWE415_Double_Free__new_delete_class_17.cpp,"    int i,j;
    TwoIntsClass * data;
    
    data = NULL;
    for(i = 0; i < 1; i++)
    {
        data = new TwoIntsClass;
        
        delete data;
    }
    for(j = 0; j < 1; j++)
    {
        
        delete data;
"
8327,1,CWE401_Memory_Leak__malloc_realloc_struct_twoIntsStruct_03.c,"    if(5==5)
    {
        {
            struct _twoIntsStruct * data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));
            if (data == NULL) {exit(-1);}
            struct _twoIntsStruct * tmpData;
            
            data[0].intOne = 0;
            data[0].intTwo = 0;
            printStructLine((twoIntsStruct *)&data[0]);
            tmpData = (struct _twoIntsStruct *)realloc(data, (130000)*sizeof(struct _twoIntsStruct));
            /* FIX: Ensure realloc() was successful before assigning data to the memory block
            * allocated with realloc() */
            if (tmpData != NULL)
            {
                data = tmpData;
                
                data[0].intOne = 1;
                data[0].intTwo = 1;
                printStructLine((twoIntsStruct *)&data[0]);
            }
            free(data);
        }
"
8524,0,CWE457_Use_of_Uninitialized_Variable__struct_array_malloc_partial_init_12.c,"    twoIntsStruct * data;
    data = (twoIntsStruct *)malloc(10*sizeof(twoIntsStruct));
    if (data == NULL) {exit(-1);}
    if(globalReturnsTrueOrFalse())
    {
        
        {
            int i;
            for(i=0; i<(10/2); i++)
            {
                data[i].intOne = i;
                data[i].intTwo = i;
            }
        }
    }
    else
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                data[i].intOne = i;
                data[i].intTwo = i;
            }
        }
    }
    if(globalReturnsTrueOrFalse())
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i].intOne);
                printIntLine(data[i].intTwo);
            }
        }
    }
    else
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                data[i].intOne = i;
                data[i].intTwo = i;
            }
        }
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i].intOne);
                printIntLine(data[i].intTwo);
            }
        }
"
17829,0,CWE758_Undefined_Behavior__char_pointer_alloca_use_04.c,"    if(STATIC_CONST_TRUE)
    {
        {
            char * * pointer = (char * *)ALLOCA(sizeof(char *));
            char * data = *pointer; 
            printLine(data);
        }
"
7908,0,CWE190_Integer_Overflow__int_fscanf_multiply_05.c,"    int data;
    
    data = 0;
    if(staticTrue)
    {
        
        fscanf(stdin, ""%d"", &data);
    }
    if(staticTrue)
    {
        if(data > 0) 
        {
            
            int result = data * 2;
            printIntLine(result);
        }
"
8356,0,CWE401_Memory_Leak__malloc_realloc_char_12.c,"    if(globalReturnsTrueOrFalse())
    {
        {
            char * data = (char *)malloc(100*sizeof(char));
            if (data == NULL) {exit(-1);}
            
            strcpy(data, ""A String"");
            printLine(data);
            
            data = (char *)realloc(data, (130000)*sizeof(char));
            if (data != NULL)
            {
                
                strcpy(data, ""New String"");
                printLine(data);
                free(data);
            }
        }
    }
    else
    {
        {
            char * data = (char *)malloc(100*sizeof(char));
            if (data == NULL) {exit(-1);}
            char * tmpData;
            
            strcpy(data, ""A String"");
            printLine(data);
            tmpData = (char *)realloc(data, (130000)*sizeof(char));
            /* FIX: Ensure realloc() was successful before assigning data to the memory block
            * allocated with realloc() */
            if (tmpData != NULL)
            {
                data = tmpData;
                
                strcpy(data, ""New String"");
                printLine(data);
            }
            free(data);
        }
"
6442,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_45.c,"    size_t data;
    
    data = 0;
    
    data = rand();
    CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_45_badData = data;
"
890,0,CWE369_Divide_by_Zero__int_fscanf_modulo_14.c,"    int data;
    
    data = -1;
    if(globalFive==5)
    {
        
        fscanf(stdin, ""%d"", &data);
    }
    if(globalFive==5)
    {
        
        printIntLine(100 % data);
"
6356,0,CWE190_Integer_Overflow__short_max_add_72a.cpp,"    short data;
    vector<short> dataVector;
    data = 0;
    
    data = SHRT_MAX;
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
10619,0,CWE415_Double_Free__new_delete_array_long_02.cpp,"    long * data;
    
    data = NULL;
    if(1)
    {
        data = new long[100];
        
        delete [] data;
    }
    if(1)
    {
        
        delete [] data;
"
9226,0,CWE590_Free_Memory_Not_on_Heap__delete_array_class_declare_08.cpp,"    TwoIntsClass * data;
    data = NULL; 
    if(staticReturnsTrue())
    {
        {
            
            TwoIntsClass dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i].intOne = 1;
                    dataBuffer[i].intTwo = 1;
                }
            }
            data = dataBuffer;
        }
    }
    printIntLine(data[0].intOne);
    
"
3617,0,CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_14.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(globalFive==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET connectSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                
                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                data[dataLen + recvResult / sizeof(char)] = '\0';
                
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(globalFive==5)
    {
        badVaSinkB(data, data);
"
16717,0,CWE590_Free_Memory_Not_on_Heap__delete_array_long_alloca_72a.cpp,"    long * data;
    vector<long *> dataVector;
    data = NULL; 
    {
        
        long * dataBuffer = (long *)ALLOCA(100*sizeof(long));
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5L;
            }
        }
        data = dataBuffer;
    }
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
8629,0,CWE789_Uncontrolled_Mem_Alloc__new_char_fgets_61a.cpp,"    size_t data;
    
    data = 0;
    data = badSource(data);
    {
        char * myString;
        /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
         * for the strcpy() function to not cause a buffer overflow */
        
        if (data > strlen(HELLO_STRING))
        {
            myString = new char[data];
            
            strcpy(myString, HELLO_STRING);
            printLine(myString);
            delete [] myString;
        }
        else
        {
            printLine(""Input is less than the length of the source string"");
        }
"
13668,0,CWE590_Free_Memory_Not_on_Heap__delete_char_static_81_bad.cpp,"Label Definition File: CWE590_Free_Memory_Not_on_Heap__delete.nonpointer.label.xml
Template File: sources-sink-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 590 Free Memory Not on Heap
 * BadSource: static Data buffer is declared static on the stack
 * GoodSource: Allocate memory on the heap
 * Sinks:
 *    BadSink : Print then free data
 * Flow Variant: 81 Data flow: data passed in a parameter to a virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE590_Free_Memory_Not_on_Heap__delete_char_static_81.h""

namespace CWE590_Free_Memory_Not_on_Heap__delete_char_static_81
{

void CWE590_Free_Memory_Not_on_Heap__delete_char_static_81_bad::action(char * data) const
{
    printHexCharLine(*data);
    
    delete data;
}

}
"
16224,0,CWE190_Integer_Overflow__short_rand_preinc_17.c,"    int i,j;
    short data;
    data = 0;
    for(i = 0; i < 1; i++)
    {
        
        data = (short)RAND32();
    }
    for(j = 0; j < 1; j++)
    {
        {
            
            ++data;
            short result = data;
            printIntLine(result);
        }
"
11024,0,CWE78_OS_Command_Injection__char_connect_socket_popen_17.c,"    int i;
    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    for(i = 0; i < 1; i++)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET connectSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
"
11547,0,CWE190_Integer_Overflow__int64_t_fscanf_multiply_05.c,"    int64_t data;
    data = 0LL;
    if(staticTrue)
    {
        
        fscanf (stdin, ""%"" SCNd64, &data);
    }
    if(staticTrue)
    {
        if(data > 0) 
        {
            
            int64_t result = data * 2;
            printLongLongLine(result);
        }
"
8107,0,CWE401_Memory_Leak__char_realloc_18.c,"    char * data;
    data = NULL;
    goto source;
source:
    
    data = (char *)realloc(data, 100*sizeof(char));
    if (data == NULL) {exit(-1);}
    
    strcpy(data, ""A String"");
    printLine(data);
    goto sink;
sink:
    
"
16445,1,CWE758_Undefined_Behavior__int_alloca_use_08.c,"    if(staticReturnsFalse())
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            int data;
            int * pointer = (int *)ALLOCA(sizeof(int));
            data = 5;
            *pointer = data; 
            {
                int data = *pointer;
                printIntLine(data);
            }
        }
"
4525,0,CWE590_Free_Memory_Not_on_Heap__delete_class_static_03.cpp,"    TwoIntsClass * data;
    data = NULL; 
    if(5==5)
    {
        {
            
            static TwoIntsClass dataBuffer;
            dataBuffer.intOne = 1;
            dataBuffer.intTwo = 1;
            data = &dataBuffer;
        }
    }
    printIntLine(data->intOne);
    
"
7782,0,CWE190_Integer_Overflow__int_fgets_add_22a.c,"    int data;
    
    data = 0;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    CWE190_Integer_Overflow__int_fgets_add_22_badGlobal = 1; 
"
15235,0,CWE190_Integer_Overflow__int_max_postinc_17.c,"    int i,j;
    int data;
    
    data = 0;
    for(i = 0; i < 1; i++)
    {
        
        data = INT_MAX;
    }
    for(j = 0; j < 1; j++)
    {
        {
            
            data++;
            int result = data;
            printIntLine(result);
        }
"
6223,0,CWE190_Integer_Overflow__char_max_square_68a.c,"    char data;
    data = ' ';
    
    data = CHAR_MAX;
    CWE190_Integer_Overflow__char_max_square_68_badData = data;
"
17044,0,CWE252_Unchecked_Return_Value__char_sscanf_01.c,"    {
        /* By initializing dataBuffer, we ensure this will not be the
         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
        char dataBuffer[100] = """";
        char * data = dataBuffer;
        
        sscanf(SRC, ""%99s\0"", data);
"
18564,0,CWE590_Free_Memory_Not_on_Heap__delete_array_long_alloca_14.cpp,"    long * data;
    data = NULL; 
    if(globalFive==5)
    {
        {
            
            long * dataBuffer = (long *)ALLOCA(100*sizeof(long));
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5L;
                }
            }
            data = dataBuffer;
        }
    }
    printLongLine(data[0]);
    
"
19026,0,CWE134_Uncontrolled_Format_String__char_console_fprintf_31.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        
        if (100-dataLen > 1)
        {
            
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgets() */
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
                    data[dataLen-1] = '\0';
                }
            }
            else
            {
                printLine(""fgets() failed"");
                
                data[dataLen] = '\0';
            }
        }
    }
    {
        char * dataCopy = data;
        char * data = dataCopy;
        
        fprintf(stdout, data);
"
892,0,CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_72a.cpp,"    char * data;
    vector<char *> dataVector;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
13419,0,CWE190_Integer_Overflow__int64_t_fscanf_postinc_42.c,"    int64_t data;
    data = 0LL;
    data = badSource(data);
    {
        
        data++;
        int64_t result = data;
        printLongLongLine(result);
"
1890,0,CWE197_Numeric_Truncation_Error__int_connect_socket_to_short_33.cpp,"    int data;
    int &dataRef = data;
    
    data = -1;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    {
        int data = dataRef;
        {
            
            short shortData = (short)data;
            printShortLine(shortData);
        }
"
3281,0,CWE190_Integer_Overflow__short_rand_preinc_12.c,"    short data;
    data = 0;
    if(globalReturnsTrueOrFalse())
    {
        
        data = (short)RAND32();
    }
    else
    {
        
        data = 2;
    }
    if(globalReturnsTrueOrFalse())
    {
        {
            
            ++data;
            short result = data;
            printIntLine(result);
        }
    }
    else
    {
        
        if (data < SHRT_MAX)
        {
            ++data;
            short result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
"
17227,0,CWE78_OS_Command_Injection__char_connect_socket_execl_63a.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
15923,0,CWE78_OS_Command_Injection__char_console_system_83a.cpp,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
"
1268,0,CWE690_NULL_Deref_From_Return__struct_malloc_12.c,"    twoIntsStruct * data;
    data = NULL; 
    
    data = (twoIntsStruct *)malloc(1*sizeof(twoIntsStruct));
    if(globalReturnsTrueOrFalse())
    {
        
        data[0].intOne = 1;
        data[0].intTwo = 1;
        printStructLine(&data[0]);
        free(data);
    }
    else
    {
        
        if (data != NULL)
        {
            data[0].intOne = 1;
            data[0].intTwo = 1;
            printStructLine(&data[0]);
            free(data);
        }
"
16818,0,CWE369_Divide_by_Zero__int_connect_socket_modulo_81_bad.cpp,"Label Definition File: CWE369_Divide_by_Zero__int.label.xml
Template File: sources-sinks-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 369 Divide by Zero
 * BadSource: connect_socket Read data using a connect socket (client side)
 * GoodSource: Non-zero
 * Sinks: modulo
 *    GoodSink: Check for zero before modulo
 *    BadSink : Modulo a constant with data
 * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE369_Divide_by_Zero__int_connect_socket_modulo_81.h""

namespace CWE369_Divide_by_Zero__int_connect_socket_modulo_81
{

void CWE369_Divide_by_Zero__int_connect_socket_modulo_81_bad::action(int data) const
{
    
    printIntLine(100 % data);
}

}
"
2205,1,CWE758_Undefined_Behavior__int_malloc_use_01.c,"    {
        int data;
        int * pointer = (int *)malloc(sizeof(int));
        if (pointer == NULL) {exit(-1);}
        data = 5;
        *pointer = data; 
        {
            int data = *pointer;
            printIntLine(data);
        }
        free(pointer);
"
19087,1,CWE758_Undefined_Behavior__long_alloca_use_03.c,"    if(5!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            long data;
            long * pointer = (long *)ALLOCA(sizeof(long));
            data = 5L;
            *pointer = data; 
            {
                long data = *pointer;
                printLongLine(data);
            }
        }
"
535,0,CWE190_Integer_Overflow__unsigned_int_max_preinc_31.c,"    unsigned int data;
    data = 0;
    
    data = UINT_MAX;
    {
        unsigned int dataCopy = data;
        unsigned int data = dataCopy;
        {
            
            ++data;
            unsigned int result = data;
            printUnsignedLine(result);
        }
"
5103,0,CWE197_Numeric_Truncation_Error__int_fscanf_to_short_82_bad.cpp,"Label Definition File: CWE197_Numeric_Truncation_Error__int.label.xml
Template File: sources-sink-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 197 Numeric Truncation Error
 * BadSource: fscanf Read data from the console using fscanf()
 * GoodSource: Less than CHAR_MAX
 * Sinks: to_short
 *    BadSink : Convert data to a short
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE197_Numeric_Truncation_Error__int_fscanf_to_short_82.h""

namespace CWE197_Numeric_Truncation_Error__int_fscanf_to_short_82
{

void CWE197_Numeric_Truncation_Error__int_fscanf_to_short_82_bad::action(int data)
{
    {
        
        short shortData = (short)data;
        printShortLine(shortData);
    }
}

}
"
16677,0,CWE590_Free_Memory_Not_on_Heap__delete_int_placement_new_82_bad.cpp,"Label Definition File: CWE590_Free_Memory_Not_on_Heap__delete.pointer.label.xml
Template File: sources-sink-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 590 Free Memory Not on Heap
 * BadSource: placement_new Data buffer is declared on the stack
 * GoodSource: Allocate memory on the heap
 * Sinks:
 *    BadSink : Print then free data
 * Flow Variant: 82 Data flow: data passed in a parameter to a virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE590_Free_Memory_Not_on_Heap__delete_int_placement_new_82.h""

namespace CWE590_Free_Memory_Not_on_Heap__delete_int_placement_new_82
{

void CWE590_Free_Memory_Not_on_Heap__delete_int_placement_new_82_bad::action(int * data)
{
    printIntLine(*data);
    
    delete data;
}

}
"
5879,0,CWE457_Use_of_Uninitialized_Variable__double_01.c,"    double data;
    
    ; 
    
"
18003,0,CWE190_Integer_Overflow__char_fscanf_square_82_bad.cpp,"Label Definition File: CWE190_Integer_Overflow.label.xml
Template File: sources-sinks-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 190 Integer Overflow
 * BadSource: fscanf Read data from the console using fscanf()
 * GoodSource: Set data to a small, non-zero number (two)
 * Sinks: square
 *    GoodSink: Ensure there will not be an overflow before squaring data
 *    BadSink : Square data, which can lead to overflow
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE190_Integer_Overflow__char_fscanf_square_82.h""

#include <math.h>

namespace CWE190_Integer_Overflow__char_fscanf_square_82
{

void CWE190_Integer_Overflow__char_fscanf_square_82_bad::action(char data)
{
    {
        
        char result = data * data;
        printHexCharLine(result);
    }
}

}
"
11251,0,CWE590_Free_Memory_Not_on_Heap__delete_char_static_03.cpp,"    char * data;
    data = NULL; 
    if(5==5)
    {
        {
            
            static char dataBuffer;
            dataBuffer = 'A';
            data = &dataBuffer;
        }
    }
    printHexCharLine(*data);
    
"
15163,0,CWE369_Divide_by_Zero__float_listenSocket_11.c,"    float data;
    
    data = 0.0F;
    if(globalReturnsTrue())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = (float)atof(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(globalReturnsTrue())
    {
        {
            
            int result = (int)(100.0 / data);
            printIntLine(result);
        }
"
5372,0,CWE590_Free_Memory_Not_on_Heap__delete_long_alloca_64a.cpp,"    long * data;
    data = NULL; 
    {
        
        long * dataBuffer = (long *)ALLOCA(sizeof(long));
        *dataBuffer = 5L;
        data = dataBuffer;
    }
"
3408,0,CWE190_Integer_Overflow__char_max_multiply_82_bad.cpp,"Label Definition File: CWE190_Integer_Overflow.label.xml
Template File: sources-sinks-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 190 Integer Overflow
 * BadSource: max Set data to the max value for char
 * GoodSource: Set data to a small, non-zero number (two)
 * Sinks: multiply
 *    GoodSink: Ensure there will not be an overflow before multiplying data by 2
 *    BadSink : If data is positive, multiply by 2, which can cause an overflow
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE190_Integer_Overflow__char_max_multiply_82.h""

namespace CWE190_Integer_Overflow__char_max_multiply_82
{

void CWE190_Integer_Overflow__char_max_multiply_82_bad::action(char data)
{
    if(data > 0) 
    {
        
        char result = data * 2;
        printHexCharLine(result);
    }
}

}
"
851,0,CWE190_Integer_Overflow__int_fscanf_add_53a.c,"    int data;
    
    data = 0;
    
    fscanf(stdin, ""%d"", &data);
"
723,0,CWE134_Uncontrolled_Format_String__char_console_printf_15.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    switch(6)
    {
    case 6:
    {
        
        size_t dataLen = strlen(data);
        
        if (100-dataLen > 1)
        {
            
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgets() */
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
                    data[dataLen-1] = '\0';
                }
            }
            else
            {
                printLine(""fgets() failed"");
                
                data[dataLen] = '\0';
            }
        }
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
        
        printf(data);
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
10233,0,CWE190_Integer_Overflow__int_fscanf_add_04.c,"    int data;
    
    data = 0;
    if(STATIC_CONST_TRUE)
    {
        
        fscanf(stdin, ""%d"", &data);
    }
    if(STATIC_CONST_TRUE)
    {
        {
            
            int result = data + 1;
            printIntLine(result);
        }
"
12403,1,CWE758_Undefined_Behavior__char_alloca_use_10.c,"    if(globalFalse)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            char data;
            char * pointer = (char *)ALLOCA(sizeof(char));
            data = 5;
            *pointer = data; 
            {
                char data = *pointer;
                printHexCharLine(data);
            }
        }
"
1479,0,CWE190_Integer_Overflow__char_max_square_45.c,"    char data;
    data = ' ';
    
    data = CHAR_MAX;
    CWE190_Integer_Overflow__char_max_square_45_badData = data;
"
2722,0,CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_67a.c,"    char * data;
    CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_67_structType myStruct;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    myStruct.structFirst = data;
"
13542,0,CWE190_Integer_Overflow__unsigned_int_rand_preinc_03.c,"    unsigned int data;
    data = 0;
    if(5==5)
    {
        
        data = (unsigned int)RAND32();
    }
    if(5==5)
    {
        {
            
            ++data;
            unsigned int result = data;
            printUnsignedLine(result);
        }
"
8033,0,CWE190_Integer_Overflow__int64_t_rand_square_03.c,"    int64_t data;
    data = 0LL;
    if(5==5)
    {
        
        data = (int64_t)RAND64();
    }
    if(5==5)
    {
        {
            
            int64_t result = data * data;
            printLongLongLine(result);
        }
"
10788,0,CWE197_Numeric_Truncation_Error__short_large_68a.c,"    short data;
    
    data = -1;
    
    data = CHAR_MAX + 1;
    CWE197_Numeric_Truncation_Error__short_large_68_badData = data;
"
9607,0,CWE457_Use_of_Uninitialized_Variable__new_struct_array_no_init_12.cpp,"    twoIntsStruct * data;
    data = new twoIntsStruct[10];
    if(globalReturnsTrueOrFalse())
    {
        
        ; 
    }
    else
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                data[i].intOne = i;
                data[i].intTwo = i;
            }
        }
    }
    if(globalReturnsTrueOrFalse())
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i].intOne);
                printIntLine(data[i].intTwo);
            }
        }
        
        delete [] data;
    }
    else
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                data[i].intOne = i;
                data[i].intTwo = i;
            }
        }
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i].intOne);
                printIntLine(data[i].intTwo);
            }
        }
        
        delete [] data;
"
14647,0,CWE457_Use_of_Uninitialized_Variable__int_array_alloca_no_init_63a.c,"    int * data;
    data = (int *)ALLOCA(10*sizeof(int));
    
    ; 
"
124,0,CWE369_Divide_by_Zero__int_listen_socket_divide_72a.cpp,"    int data;
    vector<int> dataVector;
    
    data = -1;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
5455,0,CWE78_OS_Command_Injection__char_connect_socket_execlp_83a.cpp,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
"
7020,1,CWE467_Use_of_sizeof_on_Pointer_Type__int_07.c,"    if(staticFive==5)
    {
        {
            int * goodInt = NULL;
            
            goodInt = (int *)malloc(sizeof(*goodInt));
            if (goodInt == NULL) {exit(-1);}
            *goodInt = 6;
            printIntLine(*goodInt);
            free(goodInt);
        }
"
19160,0,CWE197_Numeric_Truncation_Error__int_listen_socket_to_char_68a.c,"    int data;
    
    data = -1;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    CWE197_Numeric_Truncation_Error__int_listen_socket_to_char_68_badData = data;
"
17857,0,CWE476_NULL_Pointer_Dereference__char_02.c,"    char * data;
    if(1)
    {
        
        data = NULL;
    }
    if(1)
    {
        
        
        printHexCharLine(data[0]);
"
11184,0,CWE369_Divide_by_Zero__float_zero_17.c,"    int i,j;
    float data;
    
    data = 0.0F;
    for(i = 0; i < 1; i++)
    {
        
        data = 0.0F;
    }
    for(j = 0; j < 1; j++)
    {
        {
            
            int result = (int)(100.0 / data);
            printIntLine(result);
        }
"
5445,0,CWE190_Integer_Overflow__int64_t_max_square_44.c,"    int64_t data;
    
    void (*funcPtr) (int64_t) = badSink;
    data = 0LL;
    
    data = LLONG_MAX;
    
"
2543,0,CWE415_Double_Free__malloc_free_int_51a.c,"    int * data;
    
    data = NULL;
    data = (int *)malloc(100*sizeof(int));
    if (data == NULL) {exit(-1);}
    
    free(data);
"
4704,0,CWE401_Memory_Leak__int_malloc_01.c,"    int * data;
    data = NULL;
    
    data = (int *)malloc(100*sizeof(int));
    if (data == NULL) {exit(-1);}
    
    data[0] = 5;
    printIntLine(data[0]);
    
"
2510,0,CWE590_Free_Memory_Not_on_Heap__delete_int_alloca_74a.cpp,"    int * data;
    map<int, int *> dataMap;
    data = NULL; 
    {
        
        int * dataBuffer = (int *)ALLOCA(sizeof(int));
        *dataBuffer = 5;
        data = dataBuffer;
    }
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
8896,0,CWE190_Integer_Overflow__int64_t_fscanf_add_62a.cpp,"    int64_t data;
    data = 0LL;
    badSource(data);
    {
        
        int64_t result = data + 1;
        printLongLongLine(result);
"
1301,0,CWE690_NULL_Deref_From_Return__char_malloc_11.c,"    char * data;
    data = NULL; 
    
    data = (char *)malloc(20*sizeof(char));
    if(globalReturnsTrue())
    {
        
        strcpy(data, ""Initialize"");
        printLine(data);
        free(data);
"
5733,0,CWE590_Free_Memory_Not_on_Heap__delete_array_long_static_72a.cpp,"    long * data;
    vector<long *> dataVector;
    data = NULL; 
    {
        
        static long dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5L;
            }
        }
        data = dataBuffer;
    }
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
18872,0,CWE369_Divide_by_Zero__int_connect_socket_modulo_10.c,"    int data;
    
    data = -1;
    if(globalTrue)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(globalTrue)
    {
        
        printIntLine(100 % data);
"
7483,0,CWE758_Undefined_Behavior__int_new_use_01.cpp,"    {
        int * pointer = new int;
        int data = *pointer; 
        delete pointer;
        printIntLine(data);
"
8753,0,CWE415_Double_Free__new_delete_int_67a.cpp,"    int * data;
    structType myStruct;
    
    data = NULL;
    data = new int;
    
    delete data;
    myStruct.structFirst = data;
"
7418,0,CWE401_Memory_Leak__int_calloc_43.cpp,"    int * data;
    data = NULL;
    badSource(data);
    
"
5986,0,CWE369_Divide_by_Zero__int_fgets_divide_34.c,"    int data;
    CWE369_Divide_by_Zero__int_fgets_divide_34_unionType myUnion;
    
    data = -1;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    myUnion.unionFirst = data;
    {
        int data = myUnion.unionSecond;
        
        printIntLine(100 / data);
"
19332,0,CWE401_Memory_Leak__int64_t_malloc_31.c,"    int64_t * data;
    data = NULL;
    
    data = (int64_t *)malloc(100*sizeof(int64_t));
    if (data == NULL) {exit(-1);}
    
    data[0] = 5LL;
    printLongLongLine(data[0]);
    {
        int64_t * dataCopy = data;
        int64_t * data = dataCopy;
        
        ; 
"
4813,0,CWE134_Uncontrolled_Format_String__char_console_snprintf_73a.cpp,"    char * data;
    list<char *> dataList;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        
        if (100-dataLen > 1)
        {
            
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgets() */
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
                    data[dataLen-1] = '\0';
                }
            }
            else
            {
                printLine(""fgets() failed"");
                
                data[dataLen] = '\0';
            }
        }
    }
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
11295,0,CWE190_Integer_Overflow__int_connect_socket_square_45.c,"    int data;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    CWE190_Integer_Overflow__int_connect_socket_square_45_badData = data;
"
17747,0,CWE476_NULL_Pointer_Dereference__int64_t_52a.c,"    int64_t * data;
    
    data = NULL;
"
6664,0,CWE690_NULL_Deref_From_Return__char_malloc_06.c,"    char * data;
    data = NULL; 
    
    data = (char *)malloc(20*sizeof(char));
    if(STATIC_CONST_FIVE==5)
    {
        
        strcpy(data, ""Initialize"");
        printLine(data);
        free(data);
"
8077,0,CWE590_Free_Memory_Not_on_Heap__delete_array_class_static_13.cpp,"    TwoIntsClass * data;
    data = NULL; 
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            
            static TwoIntsClass dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i].intOne = 1;
                    dataBuffer[i].intTwo = 1;
                }
            }
            data = dataBuffer;
        }
    }
    printIntLine(data[0].intOne);
    
"
1566,0,CWE401_Memory_Leak__new_array_int64_t_06.cpp,"    int64_t * data;
    data = NULL;
    if(STATIC_CONST_FIVE==5)
    {
        
        data = new int64_t[100];
        
        data[0] = 5LL;
        printLongLongLine(data[0]);
    }
    if(STATIC_CONST_FIVE==5)
    {
        
        ; 
"
686,0,CWE190_Integer_Overflow__int_listen_socket_multiply_09.c,"    int data;
    
    data = 0;
    if(GLOBAL_CONST_TRUE)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(GLOBAL_CONST_TRUE)
    {
        if(data > 0) 
        {
            
            int result = data * 2;
            printIntLine(result);
        }
"
12357,0,CWE758_Undefined_Behavior__int_pointer_new_use_17.cpp,"    int j;
    for(j = 0; j < 1; j++)
    {
        {
            int * * pointer = new int *;
            int * data = *pointer; 
            delete pointer;
            printIntLine(*data);
        }
"
10330,0,CWE134_Uncontrolled_Format_String__char_environment_vprintf_15.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    switch(6)
    {
    case 6:
    {
        
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        
        if (environment != NULL)
        {
            
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
        badVaSinkB(data, data);
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
1060,0,CWE197_Numeric_Truncation_Error__int_fgets_to_char_07.c,"    int data;
    
    data = -1;
    if(staticFive==5)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
18057,1,CWE252_Unchecked_Return_Value__char_fscanf_18.c,"    goto sink;
sink:
    {
        /* By initializing dataBuffer, we ensure this will not be the
         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
        char dataBuffer[100] = """";
        char * data = dataBuffer;
        
        if (fscanf(stdin, ""%99s\0"", data) == EOF)
        {
            printLine(""fscanf failed!"");
        }
"
884,0,CWE401_Memory_Leak__new_array_struct_twoIntsStruct_81_bad.cpp,"Label Definition File: CWE401_Memory_Leak__new_array.label.xml
Template File: sources-sinks-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 401 Memory Leak
 * BadSource:  Allocate data using new[]
 * GoodSource: Point data to a stack buffer
 * Sinks:
 *    GoodSink: call delete[] on data
 *    BadSink : no deallocation of data
 * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE401_Memory_Leak__new_array_struct_twoIntsStruct_81.h""

namespace CWE401_Memory_Leak__new_array_struct_twoIntsStruct_81
{

void CWE401_Memory_Leak__new_array_struct_twoIntsStruct_81_bad::action(struct _twoIntsStruct * data) const
{
    
    ; 
}

}
"
10711,0,CWE78_OS_Command_Injection__char_console_system_73a.cpp,"    char * data;
    list<char *> dataList;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
        
        size_t dataLen = strlen(data);
        
        if (100-dataLen > 1)
        {
            
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgets() */
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
                    data[dataLen-1] = '\0';
                }
            }
            else
            {
                printLine(""fgets() failed"");
                
                data[dataLen] = '\0';
            }
        }
    }
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
8650,0,CWE190_Integer_Overflow__unsigned_int_max_preinc_44.c,"    unsigned int data;
    
    void (*funcPtr) (unsigned int) = badSink;
    data = 0;
    
    data = UINT_MAX;
    
"
11275,0,CWE590_Free_Memory_Not_on_Heap__delete_array_struct_alloca_18.cpp,"    twoIntsStruct * data;
    data = NULL; 
    goto source;
source:
    {
        
        twoIntsStruct * dataBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i].intOne = 1;
                dataBuffer[i].intTwo = 1;
            }
        }
        data = dataBuffer;
    }
    printStructLine(&data[0]);
    
"
1660,0,CWE758_Undefined_Behavior__double_pointer_malloc_use_17.c,"    int j;
    for(j = 0; j < 1; j++)
    {
        {
            double * * pointer = (double * *)malloc(sizeof(double *));
            if (pointer == NULL) {exit(-1);}
            double * data = *pointer; 
            free(pointer);
            printDoubleLine(*data);
        }
"
9137,0,CWE415_Double_Free__malloc_free_long_72a.cpp,"    long * data;
    vector<long *> dataVector;
    
    data = NULL;
    data = (long *)malloc(100*sizeof(long));
    if (data == NULL) {exit(-1);}
    
    free(data);
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
19220,0,CWE476_NULL_Pointer_Dereference__class_74a.cpp,"    TwoIntsClass * data;
    map<int, TwoIntsClass *> dataMap;
    
    data = NULL;
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
14167,0,CWE190_Integer_Overflow__char_fscanf_add_65a.c,"    char data;
    
    void (*funcPtr) (char) = CWE190_Integer_Overflow__char_fscanf_add_65b_badSink;
    data = ' ';
    
    fscanf (stdin, ""%c"", &data);
    
"
4107,0,CWE587_Assignment_of_Fixed_Address_to_Pointer__basic_17.c,"    int j;
    for(j = 0; j < 1; j++)
    {
        {
            
            char *charPointer = (char*)0x400000;
            printHexCharLine(*charPointer);
        }
"
8354,0,CWE197_Numeric_Truncation_Error__short_listen_socket_51a.c,"    short data;
    
    data = -1;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = (short)atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
7141,0,CWE78_OS_Command_Injection__char_file_popen_22a.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    CWE78_OS_Command_Injection__char_file_popen_22_badGlobal = 1; 
    data = CWE78_OS_Command_Injection__char_file_popen_22_badSource(data);
    {
        FILE *pipe;
        
        pipe = POPEN(data, ""w"");
        if (pipe != NULL)
        {
            PCLOSE(pipe);
        }
"
10017,0,CWE252_Unchecked_Return_Value__char_fwrite_09.c,"    if(GLOBAL_CONST_TRUE)
    {
        
        fwrite((char *)""string"", sizeof(char), strlen(""string""), stdout);
"
6429,0,CWE401_Memory_Leak__twoIntsStruct_malloc_66a.c,"    twoIntsStruct * data;
    twoIntsStruct * dataArray[5];
    data = NULL;
    
    data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
    if (data == NULL) {exit(-1);}
    
    data[0].intOne = 0;
    data[0].intTwo = 0;
    printStructLine(&data[0]);
    
    dataArray[2] = data;
"
9057,1,CWE401_Memory_Leak__malloc_realloc_int64_t_05.c,"    if(staticTrue)
    {
        {
            int64_t * data = (int64_t *)malloc(100*sizeof(int64_t));
            if (data == NULL) {exit(-1);}
            int64_t * tmpData;
            
            data[0] = 5LL;
            printLongLongLine(data[0]);
            tmpData = (int64_t *)realloc(data, (130000)*sizeof(int64_t));
            /* FIX: Ensure realloc() was successful before assigning data to the memory block
            * allocated with realloc() */
            if (tmpData != NULL)
            {
                data = tmpData;
                
                data[0] = 10LL;
                printLongLongLine(data[0]);
            }
            free(data);
        }
"
14325,0,CWE690_NULL_Deref_From_Return__fopen_11.c,"    FILE * data;
    
    data = NULL;
    
    data = fopen(""file.txt"", ""w+"");
    if(globalReturnsTrue())
    {
        
        fclose(data);
"
13833,0,CWE190_Integer_Overflow__int64_t_fscanf_add_84a.cpp,"    int64_t data;
    data = 0LL;
    CWE190_Integer_Overflow__int64_t_fscanf_add_84_bad * badObject = new CWE190_Integer_Overflow__int64_t_fscanf_add_84_bad(data);
"
3576,0,CWE134_Uncontrolled_Format_String__char_console_vprintf_43.cpp,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    badSource(data);
"
1197,0,CWE415_Double_Free__new_delete_array_int64_t_04.cpp,"    int64_t * data;
    
    data = NULL;
    if(STATIC_CONST_TRUE)
    {
        data = new int64_t[100];
        
        delete [] data;
    }
    if(STATIC_CONST_TRUE)
    {
        
        delete [] data;
"
19499,0,CWE476_NULL_Pointer_Dereference__char_54a.c,"    char * data;
    
    data = NULL;
"
17107,0,CWE78_OS_Command_Injection__char_console_execlp_14.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(globalFive==5)
    {
        {
            
            size_t dataLen = strlen(data);
            
            if (100-dataLen > 1)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
                {
                    /* The next few lines remove the carriage return from the string that is
                     * inserted by fgets() */
                    dataLen = strlen(data);
"
17333,0,CWE190_Integer_Overflow__int_listen_socket_add_01.c,"    int data;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    {
        
        int result = data + 1;
        printIntLine(result);
"
11092,0,CWE197_Numeric_Truncation_Error__short_fscanf_51a.c,"    short data;
    
    data = -1;
    
    fscanf (stdin, ""%hd"", &data);
"
8838,0,CWE457_Use_of_Uninitialized_Variable__twointsclass_array_new_partial_init_02.cpp,"    TwoIntsClass * data;
    data = new TwoIntsClass[10];
    if(1)
    {
        
        for(int i=0; i<(10/2); i++)
        {
            data[i].intOne = i;
            data[i].intTwo = i;
        }
    }
    if(1)
    {
        
        for(int i=0; i<10; i++)
        {
            printIntLine(data[i].intOne);
            printIntLine(data[i].intTwo);
        }
"
6570,0,CWE369_Divide_by_Zero__float_listenSocket_16.c,"    float data;
    
    data = 0.0F;
    while(1)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = (float)atof(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
        break;
    }
    while(1)
    {
        {
            
            int result = (int)(100.0 / data);
            printIntLine(result);
        }
        break;
"
4064,0,CWE590_Free_Memory_Not_on_Heap__delete_array_int_declare_63a.cpp,"    int * data;
    data = NULL; 
    {
        
        int dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5;
            }
        }
        data = dataBuffer;
    }
"
11448,0,CWE369_Divide_by_Zero__int_fgets_modulo_51a.c,"    int data;
    
    data = -1;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
"
9220,0,CWE457_Use_of_Uninitialized_Variable__int_08.c,"    int data;
    if(staticReturnsTrue())
    {
        
        ; 
    }
    if(staticReturnsTrue())
    {
        
        printIntLine(data);
"
4390,0,CWE563_Unused_Variable__unused_uninit_variable_int_05.c,"    int data;
    
    ; 
    if(staticTrue)
    {
        
        
        ; 
"
11897,0,CWE415_Double_Free__malloc_free_char_81_bad.cpp,"Label Definition File: CWE415_Double_Free__malloc_free.label.xml
Template File: sources-sinks-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 415 Double Free
 * BadSource:  Allocate data using malloc() and Deallocate data using free()
 * GoodSource: Allocate data using malloc()
 * Sinks:
 *    GoodSink: do nothing
 *    BadSink : Deallocate data using free()
 * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE415_Double_Free__malloc_free_char_81.h""

namespace CWE415_Double_Free__malloc_free_char_81
{

void CWE415_Double_Free__malloc_free_char_81_bad::action(char * data) const
{
    
    free(data);
}

}
"
15857,0,CWE590_Free_Memory_Not_on_Heap__delete_array_class_alloca_13.cpp,"    TwoIntsClass * data;
    data = NULL; 
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            
            TwoIntsClass * dataBuffer = (TwoIntsClass *)ALLOCA(100*sizeof(TwoIntsClass));
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i].intOne = 1;
                    dataBuffer[i].intTwo = 1;
                }
            }
            data = dataBuffer;
        }
    }
    printIntLine(data[0].intOne);
    
"
17804,0,CWE78_OS_Command_Injection__char_listen_socket_execlp_17.c,"    int i;
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    for(i = 0; i < 1; i++)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                data[dataLen + recvResult / sizeof(char)] = '\0';
                
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    /* execlp - searches for the location of the command among
     * the directories specified by the PATH environment variable */
    
"
14878,1,CWE476_NULL_Pointer_Dereference__binary_if_07.c,"    if(staticFive!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            twoIntsStruct *twoIntsStructPointer = NULL;
            /* FIX: Use && in the if statement so that if the left side of the expression fails then
             * the right side will not be evaluated */
            if ((twoIntsStructPointer != NULL) && (twoIntsStructPointer->intOne == 5))
            {
                printLine(""intOne == 5"");
            }
        }
"
16097,0,CWE190_Integer_Overflow__char_fscanf_square_07.c,"    char data;
    data = ' ';
    if(staticFive==5)
    {
        
        fscanf (stdin, ""%c"", &data);
    }
    if(staticFive==5)
    {
        {
            
            char result = data * data;
            printHexCharLine(result);
        }
"
16532,0,CWE690_NULL_Deref_From_Return__long_realloc_43.cpp,"    long * data;
    data = NULL; 
    badSource(data);
    
    data[0] = 5L;
    printLongLine(data[0]);
"
14870,0,CWE134_Uncontrolled_Format_String__char_listen_socket_printf_18.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    goto source;
source:
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    goto sink;
sink:
    
"
12876,0,CWE590_Free_Memory_Not_on_Heap__delete_array_char_static_12.cpp,"    char * data;
    data = NULL; 
    if(globalReturnsTrueOrFalse())
    {
        {
            
            static char dataBuffer[100];
            memset(dataBuffer, 'A', 100-1); 
            dataBuffer[100-1] = '\0'; 
            data = dataBuffer;
        }
    }
    else
    {
        {
            
            char * dataBuffer = new char[100];
            memset(dataBuffer, 'A', 100-1); 
            dataBuffer[100-1] = '\0'; 
            data = dataBuffer;
        }
    }
    printLine(data);
    
"
15721,0,CWE134_Uncontrolled_Format_String__char_environment_printf_81a.cpp,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        
        if (environment != NULL)
        {
            
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    const CWE134_Uncontrolled_Format_String__char_environment_printf_81_base& baseObject = CWE134_Uncontrolled_Format_String__char_environment_printf_81_bad();
"
13410,0,CWE78_OS_Command_Injection__char_console_popen_34.c,"    char * data;
    CWE78_OS_Command_Injection__char_console_popen_34_unionType myUnion;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
        
        size_t dataLen = strlen(data);
        
        if (100-dataLen > 1)
        {
            
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgets() */
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
"
2132,0,CWE190_Integer_Overflow__int_rand_multiply_81a.cpp,"    int data;
    
    data = 0;
    
    data = RAND32();
    const CWE190_Integer_Overflow__int_rand_multiply_81_base& baseObject = CWE190_Integer_Overflow__int_rand_multiply_81_bad();
"
15544,0,CWE252_Unchecked_Return_Value__char_fgets_06.c,"    if(STATIC_CONST_FIVE==5)
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            printLine(""Please enter a string: "");
            
            fgets(data, 100, stdin);
            printLine(data);
        }
"
11712,0,CWE190_Integer_Overflow__int64_t_max_postinc_11.c,"    int64_t data;
    data = 0LL;
    if(globalReturnsTrue())
    {
        
        data = LLONG_MAX;
    }
    if(globalReturnsTrue())
    {
        {
            
            data++;
            int64_t result = data;
            printLongLongLine(result);
        }
"
1036,0,CWE197_Numeric_Truncation_Error__short_large_41.c,"    short data;
    
    data = -1;
    
    data = CHAR_MAX + 1;
"
17717,0,CWE401_Memory_Leak__char_malloc_18.c,"    char * data;
    data = NULL;
    goto source;
source:
    
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    
    strcpy(data, ""A String"");
    printLine(data);
    goto sink;
sink:
    
"
15853,0,CWE690_NULL_Deref_From_Return__struct_malloc_18.c,"    twoIntsStruct * data;
    data = NULL; 
    
    data = (twoIntsStruct *)malloc(1*sizeof(twoIntsStruct));
    goto sink;
sink:
    
    data[0].intOne = 1;
    data[0].intTwo = 1;
    printStructLine(&data[0]);
"
2308,0,CWE369_Divide_by_Zero__int_zero_modulo_45.c,"    int data;
    
    data = -1;
    
    data = 0;
    CWE369_Divide_by_Zero__int_zero_modulo_45_badData = data;
"
15026,1,CWE758_Undefined_Behavior__long_malloc_use_08.c,"    if(staticReturnsFalse())
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            long data;
            long * pointer = (long *)malloc(sizeof(long));
            if (pointer == NULL) {exit(-1);}
            data = 5L;
            *pointer = data; 
            {
                long data = *pointer;
                printLongLine(data);
            }
            free(pointer);
        }
"
1483,0,CWE78_OS_Command_Injection__char_connect_socket_popen_53a.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
3741,0,CWE590_Free_Memory_Not_on_Heap__delete_int64_t_declare_74a.cpp,"    int64_t * data;
    map<int, int64_t *> dataMap;
    data = NULL; 
    {
        
        int64_t dataBuffer;
        dataBuffer = 5LL;
        data = &dataBuffer;
    }
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
4066,0,CWE190_Integer_Overflow__int_listen_socket_add_18.c,"    int data;
    
    data = 0;
    goto source;
source:
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    goto sink;
sink:
    {
        
        int result = data + 1;
        printIntLine(result);
"
7296,0,CWE190_Integer_Overflow__int_connect_socket_add_03.c,"    int data;
    
    data = 0;
    if(5==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(5==5)
    {
        {
            
            int result = data + 1;
            printIntLine(result);
        }
"
4405,0,CWE665_Improper_Initialization__char_ncat_13.c,"    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    if(GLOBAL_CONST_FIVE==5)
    {
        
        ; 
    }
    {
        size_t sourceLen;
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        sourceLen = strlen(source);
        
        strncat(data, source, sourceLen);
        printLine(data);
"
2012,0,CWE401_Memory_Leak__char_realloc_12.c,"    char * data;
    data = NULL;
    if(globalReturnsTrueOrFalse())
    {
        
        data = (char *)realloc(data, 100*sizeof(char));
        if (data == NULL) {exit(-1);}
        
        strcpy(data, ""A String"");
        printLine(data);
    }
    else
    {
        
        data = (char *)ALLOCA(100*sizeof(char));
        
        strcpy(data, ""A String"");
        printLine(data);
    }
    if(globalReturnsTrueOrFalse())
    {
        
        ; 
    }
    else
    {
        
        free(data);
"
12313,0,CWE190_Integer_Overflow__int64_t_max_add_67a.c,"    int64_t data;
    CWE190_Integer_Overflow__int64_t_max_add_67_structType myStruct;
    data = 0LL;
    
    data = LLONG_MAX;
    myStruct.structFirst = data;
"
18778,0,CWE190_Integer_Overflow__int64_t_rand_add_63a.c,"    int64_t data;
    data = 0LL;
    
    data = (int64_t)RAND64();
"
1818,0,CWE590_Free_Memory_Not_on_Heap__delete_char_alloca_52a.cpp,"    char * data;
    data = NULL; 
    {
        
        char * dataBuffer = (char *)ALLOCA(sizeof(char));
        *dataBuffer = 'A';
        data = dataBuffer;
    }
"
6959,0,CWE134_Uncontrolled_Format_String__char_file_vfprintf_84_bad.cpp,"Label Definition File: CWE134_Uncontrolled_Format_String.vasinks.label.xml
Template File: sources-vasinks-84_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 134 Uncontrolled Format String
 * BadSource: file Read input from a file
 * GoodSource: Copy a fixed string into data
 * Sinks: vfprintf
 *    GoodSink: vfprintf with a format string
 *    BadSink : vfprintf without a format string
 * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use
 *
 * */
#ifndef OMITBAD

#include <stdarg.h>
#include ""std_testcase.h""
#include ""CWE134_Uncontrolled_Format_String__char_file_vfprintf_84.h""

#ifdef _WIN32
#define FILENAME ""C:\\temp\\file.txt""
#else
#define FILENAME ""/tmp/file.txt""
#endif

namespace CWE134_Uncontrolled_Format_String__char_file_vfprintf_84
{
CWE134_Uncontrolled_Format_String__char_file_vfprintf_84_bad::CWE134_Uncontrolled_Format_String__char_file_vfprintf_84_bad(char * dataCopy)
{
    data = dataCopy;
    {
        
        size_t dataLen = strlen(data);
        FILE * pFile;
        
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
}

static void badVaSink(char * data, ...)
{
    {
        va_list args;
        va_start(args, data);
        
        vfprintf(stdout, data, args);
        va_end(args);
    }
}

CWE134_Uncontrolled_Format_String__char_file_vfprintf_84_bad::~CWE134_Uncontrolled_Format_String__char_file_vfprintf_84_bad()
{
    badVaSink(data, data);
}
}
"
9785,0,CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_44.c,"    char * data;
    
    void (*funcPtr) (char *) = badSink;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
"
1917,0,CWE590_Free_Memory_Not_on_Heap__delete_struct_placement_new_65a.cpp,"    twoIntsStruct * data;
    
    void (*funcPtr) (twoIntsStruct *) = badSink;
    data = NULL; 
    {
        
        char buffer[sizeof(twoIntsStruct)];
        twoIntsStruct * dataBuffer = new(buffer) twoIntsStruct;
        dataBuffer->intOne = 1;
        dataBuffer->intTwo = 1;
        data = dataBuffer;
    }
    
"
15748,0,CWE190_Integer_Overflow__int_fscanf_preinc_08.c,"    int data;
    
    data = 0;
    if(staticReturnsTrue())
    {
        
        fscanf(stdin, ""%d"", &data);
    }
    if(staticReturnsTrue())
    {
        {
            
            ++data;
            int result = data;
            printIntLine(result);
        }
"
15969,1,CWE252_Unchecked_Return_Value__char_fwrite_15.c,"    switch(5)
    {
    case 6:
        
        printLine(""Benign, fixed string"");
        break;
    default:
        
        if (fwrite((char *)""string"", sizeof(char), strlen(""string""), stdout) != strlen(""string""))
        {
            printLine(""fwrite failed!"");
        }
        break;
"
1368,0,CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_83_bad.cpp,"Label Definition File: CWE134_Uncontrolled_Format_String.vasinks.label.xml
Template File: sources-vasinks-83_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 134 Uncontrolled Format String
 * BadSource: connect_socket Read data using a connect socket (client side)
 * GoodSource: Copy a fixed string into data
 * Sinks: vprintf
 *    GoodSink: vprintf with a format string
 *    BadSink : vprintf without a format string
 * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack
 *
 * */
#ifndef OMITBAD

#include <stdarg.h>
#include ""std_testcase.h""
#include ""CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_83.h""

#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif

#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""

namespace CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_83
{
CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_83_bad::CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_83_bad(char * dataCopy)
{
    data = dataCopy;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
}

static void badVaSink(char * data, ...)
{
    {
        va_list args;
        va_start(args, data);
        
        vprintf(data, args);
        va_end(args);
    }
}

CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_83_bad::~CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_83_bad()
{
    badVaSink(data, data);
}
}
"
125,0,CWE197_Numeric_Truncation_Error__int_fgets_to_char_54a.c,"    int data;
    
    data = -1;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
"
1544,0,CWE416_Use_After_Free__return_freed_ptr_06.c,"    if(STATIC_CONST_FIVE==5)
    {
        {
            
            char * reversedString = helperBad(""BadSink"");
            printLine(reversedString);
            /* free(reversedString);
             * This call to free() was removed because we want the tool to detect the use after free,
             * but we don't want that function to be free(). Essentially we want to avoid a double free
             */
        }
"
16511,0,CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_43.cpp,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    badSource(data);
    {
        char dest[100] = """";
        
        SNPRINTF(dest, 100-1, data);
        printLine(dest);
"
4025,0,CWE457_Use_of_Uninitialized_Variable__new_struct_array_no_init_13.cpp,"    twoIntsStruct * data;
    data = new twoIntsStruct[10];
    if(GLOBAL_CONST_FIVE==5)
    {
        
        ; 
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i].intOne);
                printIntLine(data[i].intTwo);
            }
        }
        
        delete [] data;
"
15232,0,CWE758_Undefined_Behavior__struct_new_use_03.cpp,"    if(5==5)
    {
        {
            twoIntsStruct * pointer = new twoIntsStruct;
            twoIntsStruct data = *pointer; 
            delete pointer;
            printIntLine(data.intOne);
            printIntLine(data.intTwo);
        }
"
14243,1,CWE758_Undefined_Behavior__int_malloc_use_11.c,"    if(globalReturnsFalse())
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            int data;
            int * pointer = (int *)malloc(sizeof(int));
            if (pointer == NULL) {exit(-1);}
            data = 5;
            *pointer = data; 
            {
                int data = *pointer;
                printIntLine(data);
            }
            free(pointer);
        }
"
3546,0,CWE190_Integer_Overflow__int64_t_rand_square_51a.c,"    int64_t data;
    data = 0LL;
    
    data = (int64_t)RAND64();
"
18719,0,CWE78_OS_Command_Injection__char_connect_socket_popen_63a.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
18613,0,CWE190_Integer_Overflow__int64_t_fscanf_preinc_45.c,"    int64_t data;
    data = 0LL;
    
    fscanf (stdin, ""%"" SCNd64, &data);
    CWE190_Integer_Overflow__int64_t_fscanf_preinc_45_badData = data;
"
5964,0,CWE190_Integer_Overflow__int_rand_multiply_41.c,"    int data;
    
    data = 0;
    
    data = RAND32();
"
4922,0,CWE457_Use_of_Uninitialized_Variable__int_array_declare_no_init_01.c,"    int * data;
    int dataUninitArray[10];
    data = dataUninitArray;
    
    ; 
    
    {
        int i;
        for(i=0; i<10; i++)
        {
            printIntLine(data[i]);
        }
"
17307,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_83_bad.cpp,"Label Definition File: CWE789_Uncontrolled_Mem_Alloc__malloc.label.xml
Template File: sources-sinks-83_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: connect_socket Read data using a connect socket (client side)
 * GoodSource: Small number greater than zero
 * Sinks:
 *    GoodSink: Allocate memory with malloc() and check the size of the memory to be allocated
 *    BadSink : Allocate memory with malloc(), but incorrectly check the size of the memory to be allocated
 * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_83.h""

#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif

#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)

#define HELLO_STRING ""hello""

namespace CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_83
{
CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_83_bad::CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_83_bad(size_t dataCopy)
{
    data = dataCopy;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = strtoul(inputBuffer, NULL, 0);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
}

CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_83_bad::~CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_83_bad()
{
    {
        char * myString;
        /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
         * for the strcpy() function to not cause a buffer overflow */
        
        if (data > strlen(HELLO_STRING))
        {
            myString = (char *)malloc(data*sizeof(char));
            if (myString == NULL) {exit(-1);}
            
            strcpy(myString, HELLO_STRING);
            printLine(myString);
            free(myString);
        }
        else
        {
            printLine(""Input is less than the length of the source string"");
        }
    }
}
}
"
15363,0,CWE401_Memory_Leak__new_char_41.cpp,"    char * data;
    data = NULL;
    
    data = new char;
    
    *data = 'A';
    printHexCharLine(*data);
"
13221,0,CWE190_Integer_Overflow__unsigned_int_fscanf_add_10.c,"    unsigned int data;
    data = 0;
    if(globalTrue)
    {
        
        fscanf (stdin, ""%u"", &data);
    }
    if(globalTrue)
    {
        {
            
            unsigned int result = data + 1;
            printUnsignedLine(result);
        }
"
13217,0,CWE690_NULL_Deref_From_Return__long_calloc_43.cpp,"    long * data;
    data = NULL; 
    badSource(data);
    
    data[0] = 5L;
    printLongLine(data[0]);
"
11872,0,CWE590_Free_Memory_Not_on_Heap__delete_class_alloca_15.cpp,"    TwoIntsClass * data;
    data = NULL; 
    switch(6)
    {
    case 6:
    {
        
        TwoIntsClass * dataBuffer = (TwoIntsClass *)ALLOCA(sizeof(TwoIntsClass));
        dataBuffer->intOne = 2;
        dataBuffer->intTwo = 2;
        data = dataBuffer;
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    printIntLine(data->intOne);
    
"
7698,0,CWE190_Integer_Overflow__int_listen_socket_multiply_65a.c,"    int data;
    
    void (*funcPtr) (int) = CWE190_Integer_Overflow__int_listen_socket_multiply_65b_badSink;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
"
18317,1,CWE758_Undefined_Behavior__struct_alloca_use_15.c,"    switch(5)
    {
    case 6:
        
        printLine(""Benign, fixed string"");
        break;
    default:
    {
        twoIntsStruct data;
        twoIntsStruct * pointer = (twoIntsStruct *)ALLOCA(sizeof(twoIntsStruct));
        data.intOne = 1;
        data.intTwo = 2;
        *pointer = data; 
        {
            twoIntsStruct data = *pointer;
            printIntLine(data.intOne);
            printIntLine(data.intTwo);
        }
    }
    break;
"
19454,0,CWE690_NULL_Deref_From_Return__long_malloc_41.c,"    long * data;
    data = NULL; 
    
    data = (long *)malloc(1*sizeof(long));
"
4162,0,CWE590_Free_Memory_Not_on_Heap__delete_int_static_44.cpp,"    int * data;
    
    void (*funcPtr) (int *) = badSink;
    data = NULL; 
    {
        
        static int dataBuffer;
        dataBuffer = 5;
        data = &dataBuffer;
    }
    
"
14655,0,CWE457_Use_of_Uninitialized_Variable__double_array_alloca_partial_init_07.c,"    double * data;
    data = (double *)ALLOCA(10*sizeof(double));
    if(staticFive==5)
    {
        
        {
            int i;
            for(i=0; i<(10/2); i++)
            {
                data[i] = (double)i;
            }
        }
    }
    if(staticFive==5)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printDoubleLine(data[i]);
            }
        }
"
12609,0,CWE690_NULL_Deref_From_Return__long_realloc_83_bad.cpp,"Label Definition File: CWE690_NULL_Deref_From_Return.free.label.xml
Template File: source-sinks-83_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 690 Unchecked Return Value To NULL Pointer
 * BadSource: realloc Allocate data using realloc()
 * Sinks:
 *    GoodSink: Check to see if the data allocation failed and if not, use data
 *    BadSink : Don't check for NULL and use data
 * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE690_NULL_Deref_From_Return__long_realloc_83.h""

namespace CWE690_NULL_Deref_From_Return__long_realloc_83
{
CWE690_NULL_Deref_From_Return__long_realloc_83_bad::CWE690_NULL_Deref_From_Return__long_realloc_83_bad(long * dataCopy)
{
    data = dataCopy;
    
    data = (long *)realloc(data, 1*sizeof(long));
}

CWE690_NULL_Deref_From_Return__long_realloc_83_bad::~CWE690_NULL_Deref_From_Return__long_realloc_83_bad()
{
    
    data[0] = 5L;
    printLongLine(data[0]);
    free(data);
}
}
"
12065,0,CWE190_Integer_Overflow__short_max_multiply_45.c,"    short data;
    data = 0;
    
    data = SHRT_MAX;
    CWE190_Integer_Overflow__short_max_multiply_45_badData = data;
"
783,0,CWE476_NULL_Pointer_Dereference__class_63a.cpp,"    TwoIntsClass * data;
    
    data = NULL;
"
17960,0,CWE416_Use_After_Free__new_delete_array_class_16.cpp,"    TwoIntsClass * data;
    
    data = NULL;
    while(1)
    {
        data = new TwoIntsClass[100];
        {
            size_t i;
            for(i = 0; i < 100; i++)
            {
                data[i].intOne = 1;
                data[i].intTwo = 2;
            }
        }
        
        delete [] data;
        break;
    }
    while(1)
    {
        
        printIntLine(data[0].intOne);
        
        break;
"
4126,0,CWE197_Numeric_Truncation_Error__short_listen_socket_07.c,"    short data;
    
    data = -1;
    if(staticFive==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = (short)atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
4739,0,CWE457_Use_of_Uninitialized_Variable__double_array_malloc_partial_init_14.c,"    double * data;
    data = (double *)malloc(10*sizeof(double));
    if (data == NULL) {exit(-1);}
    if(globalFive==5)
    {
        
        {
            int i;
            for(i=0; i<(10/2); i++)
            {
                data[i] = (double)i;
            }
        }
    }
    if(globalFive==5)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printDoubleLine(data[i]);
            }
        }
"
8562,0,CWE190_Integer_Overflow__char_fscanf_preinc_01.c,"    char data;
    data = ' ';
    
    fscanf (stdin, ""%c"", &data);
    {
        
        ++data;
        char result = data;
        printHexCharLine(result);
"
2783,0,CWE78_OS_Command_Injection__char_connect_socket_popen_67a.c,"    char * data;
    CWE78_OS_Command_Injection__char_connect_socket_popen_67_structType myStruct;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    myStruct.structFirst = data;
"
10862,0,CWE415_Double_Free__new_delete_char_44.cpp,"    char * data;
    
    void (*funcPtr) (char *) = badSink;
    
    data = NULL;
    data = new char;
    
    delete data;
    
"
7567,0,CWE190_Integer_Overflow__int_max_postinc_66a.c,"    int data;
    int dataArray[5];
    
    data = 0;
    
    data = INT_MAX;
    
    dataArray[2] = data;
"
5188,0,CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_16.c,"    unsigned int data;
    data = 0;
    while(1)
    {
        
        fscanf (stdin, ""%u"", &data);
        break;
    }
    while(1)
    {
        {
            
            ++data;
            unsigned int result = data;
            printUnsignedLine(result);
        }
        break;
"
11870,0,CWE190_Integer_Overflow__int64_t_rand_multiply_52a.c,"    int64_t data;
    data = 0LL;
    
    data = (int64_t)RAND64();
"
16482,0,CWE369_Divide_by_Zero__float_listenSocket_68a.c,"    float data;
    
    data = 0.0F;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = (float)atof(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    CWE369_Divide_by_Zero__float_listenSocket_68_badData = data;
"
2310,0,CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_81a.cpp,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    const CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_81_base& baseObject = CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_81_bad();
"
7585,0,CWE190_Integer_Overflow__char_max_preinc_64a.c,"    char data;
    data = ' ';
    
    data = CHAR_MAX;
"
14959,0,CWE190_Integer_Overflow__unsigned_int_max_square_63a.c,"    unsigned int data;
    data = 0;
    
    data = UINT_MAX;
"
18590,0,CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_67a.c,"    unsigned int data;
    CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_67_structType myStruct;
    data = 0;
    
    fscanf (stdin, ""%u"", &data);
    myStruct.structFirst = data;
"
15162,0,CWE78_OS_Command_Injection__char_listen_socket_execl_61a.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    data = CWE78_OS_Command_Injection__char_listen_socket_execl_61b_badSource(data);
    
    
"
17648,0,CWE758_Undefined_Behavior__char_malloc_use_13.c,"    if(GLOBAL_CONST_FIVE==5)
    {
        {
            char * pointer = (char *)malloc(sizeof(char));
            if (pointer == NULL) {exit(-1);}
            char data = *pointer; 
            free(pointer);
            printHexCharLine(data);
        }
"
18535,0,CWE190_Integer_Overflow__char_fscanf_add_54a.c,"    char data;
    data = ' ';
    
    fscanf (stdin, ""%c"", &data);
"
801,0,CWE416_Use_After_Free__malloc_free_int64_t_05.c,"    int64_t * data;
    
    data = NULL;
    if(staticTrue)
    {
        data = (int64_t *)malloc(100*sizeof(int64_t));
        if (data == NULL) {exit(-1);}
        {
            size_t i;
            for(i = 0; i < 100; i++)
            {
                data[i] = 5LL;
            }
        }
        
        free(data);
    }
    if(staticTrue)
    {
        
        printLongLongLine(data[0]);
        
"
1091,1,CWE758_Undefined_Behavior__class_new_use_04.cpp,"    if(STATIC_CONST_FALSE)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            TwoIntsClass data;
            data.intOne = 1;
            data.intTwo = 2;
            TwoIntsClass * pointer = new TwoIntsClass;
            *pointer = data; 
            {
                TwoIntsClass data = *pointer;
                printIntLine(data.intOne);
                printIntLine(data.intTwo);
            }
            delete pointer;
        }
"
18294,0,CWE78_OS_Command_Injection__char_listen_socket_system_84a.cpp,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    CWE78_OS_Command_Injection__char_listen_socket_system_84_bad * badObject = new CWE78_OS_Command_Injection__char_listen_socket_system_84_bad(data);
"
18607,0,CWE590_Free_Memory_Not_on_Heap__delete_char_static_13.cpp,"    char * data;
    data = NULL; 
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            
            static char dataBuffer;
            dataBuffer = 'A';
            data = &dataBuffer;
        }
    }
    printHexCharLine(*data);
    
"
13298,0,CWE590_Free_Memory_Not_on_Heap__delete_struct_static_64a.cpp,"    twoIntsStruct * data;
    data = NULL; 
    {
        
        static twoIntsStruct dataBuffer;
        dataBuffer.intOne = 1;
        dataBuffer.intTwo = 1;
        data = &dataBuffer;
    }
"
9058,0,CWE369_Divide_by_Zero__int_rand_divide_13.c,"    int data;
    
    data = -1;
    if(GLOBAL_CONST_FIVE==5)
    {
        
        data = RAND32();
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        
        printIntLine(100 / data);
"
10217,0,CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_31.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    {
        char * dataCopy = data;
        char * data = dataCopy;
        {
            char dest[100] = """";
            
            SNPRINTF(dest, 100-1, data);
            printLine(dest);
        }
"
109,0,CWE415_Double_Free__new_delete_array_int64_t_52a.cpp,"    int64_t * data;
    
    data = NULL;
    data = new int64_t[100];
    
    delete [] data;
"
8230,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_43.cpp,"    size_t data;
    
    data = 0;
    badSource(data);
    {
        char * myString;
        /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
         * for the strcpy() function to not cause a buffer overflow */
        
        if (data > strlen(HELLO_STRING))
        {
            myString = (char *)malloc(data*sizeof(char));
            if (myString == NULL) {exit(-1);}
            
            strcpy(myString, HELLO_STRING);
            printLine(myString);
            free(myString);
        }
        else
        {
            printLine(""Input is less than the length of the source string"");
        }
"
16167,1,CWE688_Function_Call_With_Incorrect_Variable_or_Reference_as_Argument__basic_02.c,"    if(1)
    {
        {
            char dest[DEST_SIZE];
            int intFive = 5;
            
            sprintf(dest, ""%d"", intFive);
            printLine(dest);
        }
"
13394,0,CWE134_Uncontrolled_Format_String__char_console_vfprintf_33.cpp,"    char * data;
    char * &dataRef = data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        
        if (100-dataLen > 1)
        {
            
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgets() */
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
                    data[dataLen-1] = '\0';
                }
            }
            else
            {
                printLine(""fgets() failed"");
                
                data[dataLen] = '\0';
            }
        }
    }
    {
        char * data = dataRef;
        badVaSink(data, data);
"
7268,0,CWE415_Double_Free__malloc_free_struct_65a.c,"    twoIntsStruct * data;
    
    void (*funcPtr) (twoIntsStruct *) = CWE415_Double_Free__malloc_free_struct_65b_badSink;
    
    data = NULL;
    data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
    if (data == NULL) {exit(-1);}
    
    free(data);
    
"
13791,0,CWE415_Double_Free__new_delete_array_long_03.cpp,"    long * data;
    
    data = NULL;
    if(5==5)
    {
        data = new long[100];
        
        delete [] data;
    }
    if(5==5)
    {
        
        delete [] data;
"
18995,0,CWE190_Integer_Overflow__int_listen_socket_multiply_33.cpp,"    int data;
    int &dataRef = data;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    {
        int data = dataRef;
        if(data > 0) 
        {
            
            int result = data * 2;
            printIntLine(result);
        }
"
10928,0,CWE457_Use_of_Uninitialized_Variable__struct_06.c,"    twoIntsStruct data;
    if(STATIC_CONST_FIVE==5)
    {
        
        ; 
    }
    if(STATIC_CONST_FIVE==5)
    {
        
        printIntLine(data.intOne);
        printIntLine(data.intTwo);
"
14954,0,CWE78_OS_Command_Injection__char_console_execl_45.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        
        if (100-dataLen > 1)
        {
            
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgets() */
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
"
1707,0,CWE690_NULL_Deref_From_Return__struct_malloc_43.cpp,"    twoIntsStruct * data;
    data = NULL; 
    badSource(data);
    
    data[0].intOne = 1;
    data[0].intTwo = 1;
    printStructLine(&data[0]);
"
8224,0,CWE78_OS_Command_Injection__char_file_execl_51a.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        FILE * pFile;
        
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
"
5915,0,CWE401_Memory_Leak__new_array_char_04.cpp,"    char * data;
    data = NULL;
    if(STATIC_CONST_TRUE)
    {
        
        data = new char[100];
        
        strcpy(data, ""A String"");
        printLine(data);
    }
    if(STATIC_CONST_TRUE)
    {
        
        ; 
"
10806,0,CWE78_OS_Command_Injection__char_console_system_43.cpp,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    badSource(data);
    
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
    }
}

#endif 

#ifndef OMITGOOD


"
6405,0,CWE197_Numeric_Truncation_Error__int_rand_to_short_41.c,"    int data;
    
    data = -1;
    
    data = RAND32();
"
11898,1,CWE252_Unchecked_Return_Value__char_fprintf_07.c,"    if(staticFive==5)
    {
        
        if (fprintf(stdout, ""%s\n"", ""string"") < 0)
        {
            printLine(""fprintf failed!"");
        }
"
8888,0,CWE401_Memory_Leak__new_array_struct_twoIntsStruct_09.cpp,"    struct _twoIntsStruct * data;
    data = NULL;
    if(GLOBAL_CONST_TRUE)
    {
        
        data = new struct _twoIntsStruct[100];
        
        data[0].intOne = 0;
        data[0].intTwo = 0;
        printStructLine((twoIntsStruct *)&data[0]);
    }
    if(GLOBAL_CONST_TRUE)
    {
        
        ; 
"
5337,1,CWE252_Unchecked_Return_Value__char_fputc_10.c,"    if(globalFalse)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        
        if (fputc((int)'A', stdout) == EOF)
        {
            printLine(""fputc failed!"");
        }
"
11718,0,CWE190_Integer_Overflow__short_max_multiply_11.c,"    short data;
    data = 0;
    if(globalReturnsTrue())
    {
        
        data = SHRT_MAX;
    }
    if(globalReturnsTrue())
    {
        if(data > 0) 
        {
            
            short result = data * 2;
            printIntLine(result);
        }
"
14160,0,CWE401_Memory_Leak__new_array_struct_twoIntsStruct_10.cpp,"    struct _twoIntsStruct * data;
    data = NULL;
    if(globalTrue)
    {
        
        data = new struct _twoIntsStruct[100];
        
        data[0].intOne = 0;
        data[0].intTwo = 0;
        printStructLine((twoIntsStruct *)&data[0]);
    }
    if(globalTrue)
    {
        
        ; 
"
6892,0,CWE190_Integer_Overflow__int_max_postinc_52a.c,"    int data;
    
    data = 0;
    
    data = INT_MAX;
"
6709,0,CWE690_NULL_Deref_From_Return__int_malloc_43.cpp,"    int * data;
    data = NULL; 
    badSource(data);
    
    data[0] = 5;
    printIntLine(data[0]);
"
5387,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_42.c,"    size_t data;
    
    data = 0;
    data = badSource(data);
    {
        char * myString;
        /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
         * for the strcpy() function to not cause a buffer overflow */
        
        if (data > strlen(HELLO_STRING))
        {
            myString = (char *)malloc(data*sizeof(char));
            if (myString == NULL) {exit(-1);}
            
            strcpy(myString, HELLO_STRING);
            printLine(myString);
            free(myString);
        }
        else
        {
            printLine(""Input is less than the length of the source string"");
        }
"
19474,0,CWE690_NULL_Deref_From_Return__struct_malloc_61a.c,"    twoIntsStruct * data;
    data = NULL; 
    data = CWE690_NULL_Deref_From_Return__struct_malloc_61b_badSource(data);
    
    data[0].intOne = 1;
    data[0].intTwo = 1;
    printStructLine(&data[0]);
"
12324,0,CWE78_OS_Command_Injection__char_listen_socket_popen_63a.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
1290,0,CWE190_Integer_Overflow__int_max_postinc_42.c,"    int data;
    
    data = 0;
    data = badSource(data);
    {
        
        data++;
        int result = data;
        printIntLine(result);
"
8902,0,CWE190_Integer_Overflow__char_max_multiply_14.c,"    char data;
    data = ' ';
    if(globalFive==5)
    {
        
        data = CHAR_MAX;
    }
    if(globalFive==5)
    {
        if(data > 0) 
        {
            
            char result = data * 2;
            printHexCharLine(result);
        }
"
12555,0,CWE590_Free_Memory_Not_on_Heap__delete_array_long_alloca_08.cpp,"    long * data;
    data = NULL; 
    if(staticReturnsTrue())
    {
        {
            
            long * dataBuffer = (long *)ALLOCA(100*sizeof(long));
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5L;
                }
            }
            data = dataBuffer;
        }
    }
    printLongLine(data[0]);
    
"
16499,0,CWE190_Integer_Overflow__unsigned_int_max_preinc_08.c,"    unsigned int data;
    data = 0;
    if(staticReturnsTrue())
    {
        
        data = UINT_MAX;
    }
    if(staticReturnsTrue())
    {
        {
            
            ++data;
            unsigned int result = data;
            printUnsignedLine(result);
        }
"
14738,0,CWE690_NULL_Deref_From_Return__int_realloc_16.c,"    int * data;
    data = NULL; 
    
    data = (int *)realloc(data, 1*sizeof(int));
    while(1)
    {
        
        data[0] = 5;
        printIntLine(data[0]);
        free(data);
        break;
"
16276,0,CWE415_Double_Free__malloc_free_int64_t_34.c,"    int64_t * data;
    CWE415_Double_Free__malloc_free_int64_t_34_unionType myUnion;
    
    data = NULL;
    data = (int64_t *)malloc(100*sizeof(int64_t));
    if (data == NULL) {exit(-1);}
    
    free(data);
    myUnion.unionFirst = data;
    {
        int64_t * data = myUnion.unionSecond;
        
        free(data);
"
5297,0,CWE134_Uncontrolled_Format_String__char_environment_snprintf_10.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(globalTrue)
    {
        {
            
            size_t dataLen = strlen(data);
            char * environment = GETENV(ENV_VARIABLE);
            
            if (environment != NULL)
            {
                
                strncat(data+dataLen, environment, 100-dataLen-1);
            }
        }
    }
    if(globalTrue)
    {
        {
            char dest[100] = """";
            
            SNPRINTF(dest, 100-1, data);
            printLine(dest);
        }
"
18819,0,CWE457_Use_of_Uninitialized_Variable__new_struct_array_partial_init_64a.cpp,"    twoIntsStruct * data;
    data = new twoIntsStruct[10];
    
    {
        int i;
        for(i=0; i<(10/2); i++)
        {
            data[i].intOne = i;
            data[i].intTwo = i;
        }
    }
"
9545,0,CWE457_Use_of_Uninitialized_Variable__twointsclass_array_malloc_partial_init_01.cpp,"    TwoIntsClass * data;
    data = reinterpret_cast<TwoIntsClass *>(malloc(10*sizeof(TwoIntsClass)));
    if (data == NULL) {exit(-1);}
    
    for(int i=0; i<(10/2); i++)
    {
        data[i].intOne = i;
        data[i].intTwo = i;
    }
    
    for(int i=0; i<10; i++)
    {
        printIntLine(data[i].intOne);
        printIntLine(data[i].intTwo);
"
14342,0,CWE457_Use_of_Uninitialized_Variable__twointsclass_array_declare_partial_init_17.cpp,"    int i,j;
    TwoIntsClass * data;
    TwoIntsClass dataUninitArray[10];
    data = dataUninitArray;
    for(i = 0; i < 1; i++)
    {
        
        for(int i=0; i<(10/2); i++)
        {
            data[i].intOne = i;
            data[i].intTwo = i;
        }
    }
    for(j = 0; j < 1; j++)
    {
        
        for(int i=0; i<10; i++)
        {
            printIntLine(data[i].intOne);
            printIntLine(data[i].intTwo);
        }
"
1040,0,CWE690_NULL_Deref_From_Return__int64_t_calloc_42.c,"    int64_t * data;
    data = NULL; 
    data = badSource(data);
    
    data[0] = 5LL;
    printLongLongLine(data[0]);
"
16958,0,CWE190_Integer_Overflow__char_fscanf_preinc_44.c,"    char data;
    
    void (*funcPtr) (char) = badSink;
    data = ' ';
    
    fscanf (stdin, ""%c"", &data);
    
"
8826,0,CWE415_Double_Free__malloc_free_int_08.c,"    int * data;
    
    data = NULL;
    if(staticReturnsTrue())
    {
        data = (int *)malloc(100*sizeof(int));
        if (data == NULL) {exit(-1);}
        
        free(data);
    }
    if(staticReturnsTrue())
    {
        
        free(data);
"
6133,0,CWE190_Integer_Overflow__int_fscanf_add_14.c,"    int data;
    
    data = 0;
    if(globalFive==5)
    {
        
        fscanf(stdin, ""%d"", &data);
    }
    if(globalFive==5)
    {
        {
            
            int result = data + 1;
            printIntLine(result);
        }
"
19085,0,CWE415_Double_Free__malloc_free_int_83_bad.cpp,"Label Definition File: CWE415_Double_Free__malloc_free.label.xml
Template File: sources-sinks-83_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 415 Double Free
 * BadSource:  Allocate data using malloc() and Deallocate data using free()
 * GoodSource: Allocate data using malloc()
 * Sinks:
 *    GoodSink: do nothing
 *    BadSink : Deallocate data using free()
 * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE415_Double_Free__malloc_free_int_83.h""

namespace CWE415_Double_Free__malloc_free_int_83
{
CWE415_Double_Free__malloc_free_int_83_bad::CWE415_Double_Free__malloc_free_int_83_bad(int * dataCopy)
{
    data = dataCopy;
    data = (int *)malloc(100*sizeof(int));
    if (data == NULL) {exit(-1);}
    
    free(data);
}

CWE415_Double_Free__malloc_free_int_83_bad::~CWE415_Double_Free__malloc_free_int_83_bad()
{
    
    free(data);
}
}
"
5375,0,CWE415_Double_Free__new_delete_array_class_67a.cpp,"    TwoIntsClass * data;
    structType myStruct;
    
    data = NULL;
    data = new TwoIntsClass[100];
    
    delete [] data;
    myStruct.structFirst = data;
"
16051,0,CWE190_Integer_Overflow__char_max_preinc_53a.c,"    char data;
    data = ' ';
    
    data = CHAR_MAX;
"
18116,0,CWE563_Unused_Variable__unused_uninit_variable_struct_11.c,"    twoIntsStruct data;
    
    ; 
    if(globalReturnsTrue())
    {
        
        
        ; 
"
15965,0,CWE134_Uncontrolled_Format_String__char_environment_fprintf_64a.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        
        if (environment != NULL)
        {
            
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
"
5676,0,CWE252_Unchecked_Return_Value__char_scanf_04.c,"    if(STATIC_CONST_TRUE)
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            
            scanf(""%99s\0"", data);
        }
"
9662,1,CWE252_Unchecked_Return_Value__char_fgets_14.c,"    if(globalFive==5)
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            printLine(""Please enter a string: "");
            
            if (fgets(data, 100, stdin) == NULL)
            {
                printLine(""fgets failed!"");
                exit(1);
            }
            printLine(data);
        }
"
15112,0,CWE197_Numeric_Truncation_Error__int_listen_socket_to_short_45.c,"    int data;
    
    data = -1;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    CWE197_Numeric_Truncation_Error__int_listen_socket_to_short_45_badData = data;
"
16327,0,CWE590_Free_Memory_Not_on_Heap__delete_char_static_16.cpp,"    char * data;
    data = NULL; 
    while(1)
    {
        {
            
            static char dataBuffer;
            dataBuffer = 'A';
            data = &dataBuffer;
        }
        break;
    }
    printHexCharLine(*data);
    
"
12894,0,CWE416_Use_After_Free__new_delete_array_long_08.cpp,"    long * data;
    
    data = NULL;
    if(staticReturnsTrue())
    {
        data = new long[100];
        {
            size_t i;
            for(i = 0; i < 100; i++)
            {
                data[i] = 5L;
            }
        }
        
        delete [] data;
    }
    if(staticReturnsTrue())
    {
        
        printLongLine(data[0]);
        
"
3048,0,CWE590_Free_Memory_Not_on_Heap__free_int_static_64a.c,"    int * data;
    data = NULL; 
    {
        
        static int dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5;
            }
        }
        data = dataBuffer;
    }
"
16453,0,CWE369_Divide_by_Zero__int_fgets_modulo_43.cpp,"    int data;
    
    data = -1;
    badSource(data);
    
"
1028,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_09.c,"    size_t data;
    
    data = 0;
    if(GLOBAL_CONST_TRUE)
    {
        
        fscanf(stdin, ""%zu"", &data);
    }
    if(GLOBAL_CONST_TRUE)
    {
        {
            char * myString;
            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
             * for the strcpy() function to not cause a buffer overflow */
            
            if (data > strlen(HELLO_STRING))
            {
                myString = (char *)malloc(data*sizeof(char));
                if (myString == NULL) {exit(-1);}
                
                strcpy(myString, HELLO_STRING);
                printLine(myString);
                free(myString);
            }
            else
            {
                printLine(""Input is less than the length of the source string"");
            }
        }
"
3659,0,CWE78_OS_Command_Injection__char_connect_socket_execlp_22a.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    CWE78_OS_Command_Injection__char_connect_socket_execlp_22_badGlobal = 1; 
    data = CWE78_OS_Command_Injection__char_connect_socket_execlp_22_badSource(data);
    /* execlp - searches for the location of the command among
     * the directories specified by the PATH environment variable */
    
    EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}

#endif 

#ifndef OMITGOOD


int CWE78_OS_Command_Injection__char_connect_socket_execlp_22_goodG2B1Global = 0;
"
14597,1,CWE758_Undefined_Behavior__char_pointer_malloc_use_07.c,"    if(staticFive==5)
    {
        {
            char * data;
            char * * pointer = (char * *)malloc(sizeof(char *));
            if (pointer == NULL) {exit(-1);}
            data = ""string"";
            *pointer = data; 
            {
                char * data = *pointer;
                printLine(data);
            }
            free(pointer);
        }
"
16660,0,CWE789_Uncontrolled_Mem_Alloc__new_char_connect_socket_61a.cpp,"    size_t data;
    
    data = 0;
    data = badSource(data);
    {
        char * myString;
        /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
         * for the strcpy() function to not cause a buffer overflow */
        
        if (data > strlen(HELLO_STRING))
        {
            myString = new char[data];
            
            strcpy(myString, HELLO_STRING);
            printLine(myString);
            delete [] myString;
        }
        else
        {
            printLine(""Input is less than the length of the source string"");
        }
"
15414,1,CWE252_Unchecked_Return_Value__char_scanf_17.c,"    int k;
    for(k = 0; k < 1; k++)
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            
            if (scanf(""%99s\0"", data) == EOF)
            {
                printLine(""scanf failed!"");
            }
        }
"
6009,0,CWE401_Memory_Leak__int64_t_malloc_15.c,"    int64_t * data;
    data = NULL;
    switch(6)
    {
    case 6:
        
        data = (int64_t *)malloc(100*sizeof(int64_t));
        if (data == NULL) {exit(-1);}
        
        data[0] = 5LL;
        printLongLongLine(data[0]);
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
        
        ; 
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
12781,0,CWE190_Integer_Overflow__int_listen_socket_add_51a.c,"    int data;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
14988,0,CWE401_Memory_Leak__char_calloc_41.c,"    char * data;
    data = NULL;
    
    data = (char *)calloc(100, sizeof(char));
    if (data == NULL) {exit(-1);}
    
    strcpy(data, ""A String"");
    printLine(data);
"
7214,0,CWE416_Use_After_Free__new_delete_char_04.cpp,"    char * data;
    
    data = NULL;
    if(STATIC_CONST_TRUE)
    {
        data = new char;
        *data = 'A';
        
        delete data;
    }
    if(STATIC_CONST_TRUE)
    {
        
        printHexCharLine(*data);
        
"
13306,0,CWE457_Use_of_Uninitialized_Variable__twointsclass_array_malloc_no_init_04.cpp,"    TwoIntsClass * data;
    data = reinterpret_cast<TwoIntsClass *>(malloc(10*sizeof(TwoIntsClass)));
    if (data == NULL) {exit(-1);}
    if(STATIC_CONST_TRUE)
    {
        
        ; 
    }
    if(STATIC_CONST_TRUE)
    {
        
        for(int i=0; i<10; i++)
        {
            printIntLine(data[i].intOne);
            printIntLine(data[i].intTwo);
        }
"
1381,0,CWE476_NULL_Pointer_Dereference__binary_if_17.c,"    int j;
    for(j = 0; j < 1; j++)
    {
        {
            twoIntsStruct *twoIntsStructPointer = NULL;
            /* FLAW: Using a single & in the if statement will cause both sides of the expression to be evaluated
             * thus causing a NPD */
            if ((twoIntsStructPointer != NULL) & (twoIntsStructPointer->intOne == 5))
            {
                printLine(""intOne == 5"");
            }
        }
"
17239,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_54a.c,"    size_t data;
    
    data = 0;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = strtoul(inputBuffer, NULL, 0);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
"
358,0,CWE134_Uncontrolled_Format_String__char_environment_fprintf_62a.cpp,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    badSource(data);
    
"
3173,0,CWE415_Double_Free__new_delete_int_06.cpp,"    int * data;
    
    data = NULL;
    if(STATIC_CONST_FIVE==5)
    {
        data = new int;
        
        delete data;
    }
    if(STATIC_CONST_FIVE==5)
    {
        
        delete data;
"
2097,0,CWE134_Uncontrolled_Format_String__char_environment_snprintf_14.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(globalFive==5)
    {
        {
            
            size_t dataLen = strlen(data);
            char * environment = GETENV(ENV_VARIABLE);
            
            if (environment != NULL)
            {
                
                strncat(data+dataLen, environment, 100-dataLen-1);
            }
        }
    }
    if(globalFive==5)
    {
        {
            char dest[100] = """";
            
            SNPRINTF(dest, 100-1, data);
            printLine(dest);
        }
"
15549,0,CWE415_Double_Free__new_delete_long_52a.cpp,"    long * data;
    
    data = NULL;
    data = new long;
    
    delete data;
"
9791,0,CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_41.cpp,"    size_t data;
    
    data = 0;
    
    fscanf(stdin, ""%zu"", &data);
"
15351,0,CWE252_Unchecked_Return_Value__char_sscanf_12.c,"    if(globalReturnsTrueOrFalse())
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            
            sscanf(SRC, ""%99s\0"", data);
        }
    }
    else
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            
            if (sscanf(SRC, ""%99s\0"", data) == EOF)
            {
                printLine(""sscanf failed!"");
            }
        }
"
16019,1,CWE758_Undefined_Behavior__int64_t_malloc_use_16.c,"    while(1)
    {
        {
            int64_t data;
            int64_t * pointer = (int64_t *)malloc(sizeof(int64_t));
            if (pointer == NULL) {exit(-1);}
            data = 5LL;
            *pointer = data; 
            {
                int64_t data = *pointer;
                printLongLongLine(data);
            }
            free(pointer);
        }
        break;
"
10644,0,CWE78_OS_Command_Injection__char_connect_socket_execl_05.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(staticTrue)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET connectSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
"
5144,0,CWE401_Memory_Leak__new_array_int_18.cpp,"    int * data;
    data = NULL;
    goto source;
source:
    
    data = new int[100];
    
    data[0] = 5;
    printIntLine(data[0]);
    goto sink;
sink:
    
"
590,0,CWE190_Integer_Overflow__unsigned_int_fscanf_square_83a.cpp,"    unsigned int data;
    data = 0;
"
10165,0,CWE190_Integer_Overflow__unsigned_int_rand_square_43.cpp,"    unsigned int data;
    data = 0;
    badSource(data);
    {
        
        unsigned int result = data * data;
        printUnsignedLine(result);
"
6212,0,CWE590_Free_Memory_Not_on_Heap__free_int_alloca_05.c,"    int * data;
    data = NULL; 
    if(staticTrue)
    {
        {
            
            int * dataBuffer = (int *)ALLOCA(100*sizeof(int));
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5;
                }
            }
            data = dataBuffer;
        }
    }
    printIntLine(data[0]);
    
"
3138,0,CWE690_NULL_Deref_From_Return__int_malloc_11.c,"    int * data;
    data = NULL; 
    
    data = (int *)malloc(1*sizeof(int));
    if(globalReturnsTrue())
    {
        
        data[0] = 5;
        printIntLine(data[0]);
        free(data);
"
6963,0,CWE401_Memory_Leak__char_calloc_83_bad.cpp,"Label Definition File: CWE401_Memory_Leak.c.label.xml
Template File: sources-sinks-83_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 401 Memory Leak
 * BadSource: calloc Allocate data using calloc()
 * GoodSource: Allocate data on the stack
 * Sinks:
 *    GoodSink: call free() on data
 *    BadSink : no deallocation of data
 * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE401_Memory_Leak__char_calloc_83.h""

namespace CWE401_Memory_Leak__char_calloc_83
{
CWE401_Memory_Leak__char_calloc_83_bad::CWE401_Memory_Leak__char_calloc_83_bad(char * dataCopy)
{
    data = dataCopy;
    
    data = (char *)calloc(100, sizeof(char));
    if (data == NULL) {exit(-1);}
    
    strcpy(data, ""A String"");
    printLine(data);
}

CWE401_Memory_Leak__char_calloc_83_bad::~CWE401_Memory_Leak__char_calloc_83_bad()
{
    
    ; 
}
}
"
12219,0,CWE190_Integer_Overflow__int_rand_multiply_34.c,"    int data;
    CWE190_Integer_Overflow__int_rand_multiply_34_unionType myUnion;
    
    data = 0;
    
    data = RAND32();
    myUnion.unionFirst = data;
    {
        int data = myUnion.unionSecond;
        if(data > 0) 
        {
            
            int result = data * 2;
            printIntLine(result);
        }
"
11864,0,CWE78_OS_Command_Injection__char_environment_execl_61a.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    data = CWE78_OS_Command_Injection__char_environment_execl_61b_badSource(data);
    
    
"
2877,0,CWE134_Uncontrolled_Format_String__char_environment_vfprintf_06.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(STATIC_CONST_FIVE==5)
    {
        {
            
            size_t dataLen = strlen(data);
            char * environment = GETENV(ENV_VARIABLE);
            
            if (environment != NULL)
            {
                
                strncat(data+dataLen, environment, 100-dataLen-1);
            }
        }
    }
    if(STATIC_CONST_FIVE==5)
    {
        badVaSinkB(data, data);
"
3654,0,CWE415_Double_Free__new_delete_struct_04.cpp,"    twoIntsStruct * data;
    
    data = NULL;
    if(STATIC_CONST_TRUE)
    {
        data = new twoIntsStruct;
        
        delete data;
    }
    if(STATIC_CONST_TRUE)
    {
        
        delete data;
"
9756,1,CWE758_Undefined_Behavior__int_pointer_new_use_09.cpp,"    if(GLOBAL_CONST_FALSE)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            int * data;
            
            data = new int;
            *data = 5;
            int * * pointer = new int *;
            *pointer = data; 
            {
                int * data = *pointer;
                printIntLine(*data);
            }
            delete pointer;
        }
"
1781,0,CWE190_Integer_Overflow__char_rand_preinc_17.c,"    int i,j;
    char data;
    data = ' ';
    for(i = 0; i < 1; i++)
    {
        
        data = (char)RAND32();
    }
    for(j = 0; j < 1; j++)
    {
        {
            
            ++data;
            char result = data;
            printHexCharLine(result);
        }
"
17851,0,CWE401_Memory_Leak__new_struct_twoIntsStruct_05.cpp,"    struct _twoIntsStruct * data;
    data = NULL;
    if(staticTrue)
    {
        
        data = new struct _twoIntsStruct;
        
        data->intOne = 0;
        data->intTwo = 0;
        printStructLine((twoIntsStruct *)data);
    }
    if(staticTrue)
    {
        
        ; 
"
9183,0,CWE78_OS_Command_Injection__char_environment_system_64a.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
        
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        
        if (environment != NULL)
        {
            
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
"
11380,0,CWE590_Free_Memory_Not_on_Heap__delete_int_placement_new_73a.cpp,"    int * data;
    list<int *> dataList;
    data = NULL; 
    {
        
        char buffer[sizeof(int)];
        int * dataBuffer = new(buffer) int;
        *dataBuffer = 5;
        data = dataBuffer;
    }
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
11432,0,CWE590_Free_Memory_Not_on_Heap__delete_char_placement_new_67a.cpp,"    char * data;
    structType myStruct;
    data = NULL; 
    {
        
        char buffer[sizeof(char)];
        char * dataBuffer = new(buffer) char;
        *dataBuffer = 'A';
        data = dataBuffer;
    }
    myStruct.structFirst = data;
"
15342,0,CWE190_Integer_Overflow__int64_t_rand_postinc_02.c,"    int64_t data;
    data = 0LL;
    if(1)
    {
        
        data = (int64_t)RAND64();
    }
    if(1)
    {
        {
            
            data++;
            int64_t result = data;
            printLongLongLine(result);
        }
"
2094,0,CWE369_Divide_by_Zero__int_rand_divide_73a.cpp,"    int data;
    list<int> dataList;
    
    data = -1;
    
    data = RAND32();
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
2188,0,CWE190_Integer_Overflow__int64_t_rand_add_07.c,"    int64_t data;
    data = 0LL;
    if(staticFive==5)
    {
        
        data = (int64_t)RAND64();
    }
    if(staticFive==5)
    {
        {
            
            int64_t result = data + 1;
            printLongLongLine(result);
        }
"
3242,0,CWE457_Use_of_Uninitialized_Variable__new_struct_array_partial_init_09.cpp,"    twoIntsStruct * data;
    data = new twoIntsStruct[10];
    if(GLOBAL_CONST_TRUE)
    {
        
        {
            int i;
            for(i=0; i<(10/2); i++)
            {
                data[i].intOne = i;
                data[i].intTwo = i;
            }
        }
    }
    if(GLOBAL_CONST_TRUE)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i].intOne);
                printIntLine(data[i].intTwo);
            }
        }
        
        delete [] data;
"
6499,0,CWE690_NULL_Deref_From_Return__long_realloc_65a.c,"    long * data;
    
    void (*funcPtr) (long *) = CWE690_NULL_Deref_From_Return__long_realloc_65b_badSink;
    data = NULL; 
    
    data = (long *)realloc(data, 1*sizeof(long));
    
"
2989,0,CWE563_Unused_Variable__unused_value_int_06.c,"    int data;
    if(STATIC_CONST_FIVE==5)
    {
        
        data = 5;
    }
    if(STATIC_CONST_FIVE==5)
    {
        
        data = 10;
        printIntLine(data);
"
10675,0,CWE401_Memory_Leak__new_array_int_06.cpp,"    int * data;
    data = NULL;
    if(STATIC_CONST_FIVE==5)
    {
        
        data = new int[100];
        
        data[0] = 5;
        printIntLine(data[0]);
    }
    if(STATIC_CONST_FIVE==5)
    {
        
        ; 
"
3101,0,CWE190_Integer_Overflow__int_listen_socket_postinc_65a.c,"    int data;
    
    void (*funcPtr) (int) = CWE190_Integer_Overflow__int_listen_socket_postinc_65b_badSink;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
"
8049,1,CWE401_Memory_Leak__malloc_realloc_char_10.c,"    if(globalFalse)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            char * data = (char *)malloc(100*sizeof(char));
            if (data == NULL) {exit(-1);}
            char * tmpData;
            
            strcpy(data, ""A String"");
            printLine(data);
            tmpData = (char *)realloc(data, (130000)*sizeof(char));
            /* FIX: Ensure realloc() was successful before assigning data to the memory block
            * allocated with realloc() */
            if (tmpData != NULL)
            {
                data = tmpData;
                
                strcpy(data, ""New String"");
                printLine(data);
            }
            free(data);
        }
"
8729,0,CWE401_Memory_Leak__int64_t_calloc_64a.c,"    int64_t * data;
    data = NULL;
    
    data = (int64_t *)calloc(100, sizeof(int64_t));
    if (data == NULL) {exit(-1);}
    
    data[0] = 5LL;
    printLongLongLine(data[0]);
"
4905,1,CWE758_Undefined_Behavior__struct_new_use_12.cpp,"    if(globalReturnsTrueOrFalse())
    {
        {
            twoIntsStruct data;
            data.intOne = 1;
            data.intTwo = 2;
            twoIntsStruct * pointer = new twoIntsStruct;
            *pointer = data; 
            {
                twoIntsStruct data = *pointer;
                printIntLine(data.intOne);
                printIntLine(data.intTwo);
            }
            delete pointer;
        }
    }
    else
    {
        {
            twoIntsStruct data;
            data.intOne = 1;
            data.intTwo = 2;
            twoIntsStruct * pointer = new twoIntsStruct;
            *pointer = data; 
            {
                twoIntsStruct data = *pointer;
                printIntLine(data.intOne);
                printIntLine(data.intTwo);
            }
            delete pointer;
        }
"
7706,0,CWE401_Memory_Leak__new_array_struct_twoIntsStruct_41.cpp,"    struct _twoIntsStruct * data;
    data = NULL;
    
    data = new struct _twoIntsStruct[100];
    
    data[0].intOne = 0;
    data[0].intTwo = 0;
    printStructLine((twoIntsStruct *)&data[0]);
"
18760,0,CWE457_Use_of_Uninitialized_Variable__new_double_array_no_init_06.cpp,"    double * data;
    data = new double[10];
    if(STATIC_CONST_FIVE==5)
    {
        
        ; 
    }
    if(STATIC_CONST_FIVE==5)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printDoubleLine(data[i]);
            }
        }
        
        delete [] data;
"
17007,0,CWE197_Numeric_Truncation_Error__int_connect_socket_to_short_72a.cpp,"    int data;
    vector<int> dataVector;
    
    data = -1;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
8011,0,CWE78_OS_Command_Injection__char_file_popen_05.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(staticTrue)
    {
        {
            
            size_t dataLen = strlen(data);
            FILE * pFile;
            
            if (100-dataLen > 1)
            {
                pFile = fopen(FILENAME, ""r"");
                if (pFile != NULL)
                {
                    
                    if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                    {
                        printLine(""fgets() failed"");
                        
                        data[dataLen] = '\0';
                    }
                    fclose(pFile);
                }
            }
        }
    }
    {
        FILE *pipe;
        
        pipe = POPEN(data, ""w"");
        if (pipe != NULL)
        {
            PCLOSE(pipe);
        }
"
17817,0,CWE190_Integer_Overflow__unsigned_int_rand_square_33.cpp,"    unsigned int data;
    unsigned int &dataRef = data;
    data = 0;
    
    data = (unsigned int)RAND32();
    {
        unsigned int data = dataRef;
        {
            
            unsigned int result = data * data;
            printUnsignedLine(result);
        }
"
19413,0,CWE190_Integer_Overflow__int_fgets_preinc_16.c,"    int data;
    
    data = 0;
    while(1)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
        break;
    }
    while(1)
    {
        {
            
            ++data;
            int result = data;
            printIntLine(result);
        }
        break;
"
16268,0,CWE476_NULL_Pointer_Dereference__null_check_after_deref_06.c,"    if(STATIC_CONST_FIVE==5)
    {
        {
            int *intPointer = NULL;
            intPointer = (int *)malloc(sizeof(int));
            *intPointer = 5;
            printIntLine(*intPointer);
            
            if (intPointer != NULL)
            {
                *intPointer = 10;
            }
            printIntLine(*intPointer);
        }
"
5956,0,CWE190_Integer_Overflow__unsigned_int_max_add_42.c,"    unsigned int data;
    data = 0;
    data = badSource(data);
    {
        
        unsigned int result = data + 1;
        printUnsignedLine(result);
"
4278,0,CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_32.c,"    unsigned int data;
    unsigned int *dataPtr1 = &data;
    unsigned int *dataPtr2 = &data;
    data = 0;
    {
        unsigned int data = *dataPtr1;
        
        fscanf (stdin, ""%u"", &data);
        *dataPtr1 = data;
    }
    {
        unsigned int data = *dataPtr2;
        {
            
            data++;
            unsigned int result = data;
            printUnsignedLine(result);
        }
"
1997,0,CWE190_Integer_Overflow__short_max_multiply_06.c,"    short data;
    data = 0;
    if(STATIC_CONST_FIVE==5)
    {
        
        data = SHRT_MAX;
    }
    if(STATIC_CONST_FIVE==5)
    {
        if(data > 0) 
        {
            
            short result = data * 2;
            printIntLine(result);
        }
"
6410,0,CWE190_Integer_Overflow__char_rand_preinc_54a.c,"    char data;
    data = ' ';
    
    data = (char)RAND32();
"
5584,0,CWE590_Free_Memory_Not_on_Heap__free_int64_t_alloca_03.c,"    int64_t * data;
    data = NULL; 
    if(5==5)
    {
        {
            
            int64_t * dataBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5LL;
                }
            }
            data = dataBuffer;
        }
    }
    printLongLongLine(data[0]);
    
"
17419,0,CWE197_Numeric_Truncation_Error__short_connect_socket_07.c,"    short data;
    
    data = -1;
    if(staticFive==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = (short)atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
3589,0,CWE401_Memory_Leak__new_array_struct_twoIntsStruct_72a.cpp,"    struct _twoIntsStruct * data;
    vector<struct _twoIntsStruct *> dataVector;
    data = NULL;
    
    data = new struct _twoIntsStruct[100];
    
    data[0].intOne = 0;
    data[0].intTwo = 0;
    printStructLine((twoIntsStruct *)&data[0]);
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
11464,0,CWE252_Unchecked_Return_Value__char_remove_04.c,"    if(STATIC_CONST_TRUE)
    {
        
        REMOVE(""removemebad.txt"");
"
1259,0,CWE590_Free_Memory_Not_on_Heap__delete_array_char_static_64a.cpp,"    char * data;
    data = NULL; 
    {
        
        static char dataBuffer[100];
        memset(dataBuffer, 'A', 100-1); 
        dataBuffer[100-1] = '\0'; 
        data = dataBuffer;
    }
"
4175,0,CWE190_Integer_Overflow__short_rand_postinc_01.c,"    short data;
    data = 0;
    
    data = (short)RAND32();
    {
        
        data++;
        short result = data;
        printIntLine(result);
"
13063,0,CWE415_Double_Free__new_delete_array_long_08.cpp,"    long * data;
    
    data = NULL;
    if(staticReturnsTrue())
    {
        data = new long[100];
        
        delete [] data;
    }
    if(staticReturnsTrue())
    {
        
        delete [] data;
"
5931,1,CWE758_Undefined_Behavior__char_pointer_alloca_use_17.c,"    int k;
    for(k = 0; k < 1; k++)
    {
        {
            char * data;
            char * * pointer = (char * *)ALLOCA(sizeof(char *));
            data = ""string"";
            *pointer = data; 
            {
                char * data = *pointer;
                printLine(data);
            }
        }
"
16919,0,CWE590_Free_Memory_Not_on_Heap__delete_int64_t_placement_new_66a.cpp,"    int64_t * data;
    int64_t * dataArray[5];
    data = NULL; 
    {
        
        char buffer[sizeof(int64_t)];
        int64_t * dataBuffer = new(buffer) int64_t;
        *dataBuffer = 5LL;
        data = dataBuffer;
    }
    
    dataArray[2] = data;
"
11738,0,CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_63a.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
16860,0,CWE457_Use_of_Uninitialized_Variable__double_03.c,"    double data;
    if(5==5)
    {
        
        ; 
    }
    if(5==5)
    {
        
        printDoubleLine(data);
"
3946,1,CWE252_Unchecked_Return_Value__char_scanf_10.c,"    if(globalFalse)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            
            if (scanf(""%99s\0"", data) == EOF)
            {
                printLine(""scanf failed!"");
            }
        }
"
17865,0,CWE134_Uncontrolled_Format_String__char_connect_socket_printf_61a.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    data = CWE134_Uncontrolled_Format_String__char_connect_socket_printf_61b_badSource(data);
    
"
1546,0,CWE789_Uncontrolled_Mem_Alloc__new_char_fgets_14.cpp,"    size_t data;
    
    data = 0;
    if(globalFive==5)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                
                data = strtoul(inputBuffer, NULL, 0);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    if(globalFive==5)
    {
        {
            char * myString;
            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
             * for the strcpy() function to not cause a buffer overflow */
            
            if (data > strlen(HELLO_STRING))
            {
                myString = new char[data];
                
                strcpy(myString, HELLO_STRING);
                printLine(myString);
                delete [] myString;
            }
            else
            {
                printLine(""Input is less than the length of the source string"");
            }
        }
"
4038,0,CWE457_Use_of_Uninitialized_Variable__twointsclass_array_declare_no_init_43.cpp,"    TwoIntsClass * data;
    TwoIntsClass dataUninitArray[10];
    data = dataUninitArray;
    badSource(data);
    
    for(int i=0; i<10; i++)
    {
        printIntLine(data[i].intOne);
        printIntLine(data[i].intTwo);
"
1248,0,CWE78_OS_Command_Injection__char_connect_socket_execlp_82_bad.cpp,"Label Definition File: CWE78_OS_Command_Injection.strings.label.xml
Template File: sources-sink-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 78 OS Command Injection
 * BadSource: connect_socket Read data using a connect socket (client side)
 * GoodSource: Fixed string
 * Sinks: execlp
 *    BadSink : execute command with execlp
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE78_OS_Command_Injection__char_connect_socket_execlp_82.h""
"
19281,0,CWE590_Free_Memory_Not_on_Heap__delete_array_long_alloca_34.cpp,"    long * data;
    unionType myUnion;
    data = NULL; 
    {
        
        long * dataBuffer = (long *)ALLOCA(100*sizeof(long));
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5L;
            }
        }
        data = dataBuffer;
    }
    myUnion.unionFirst = data;
    {
        long * data = myUnion.unionSecond;
        printLongLine(data[0]);
        
        delete [] data;
"
7707,0,CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_17.c,"    int i,j;
    unsigned int data;
    data = 0;
    for(i = 0; i < 1; i++)
    {
        
        fscanf (stdin, ""%u"", &data);
    }
    for(j = 0; j < 1; j++)
    {
        {
            
            data++;
            unsigned int result = data;
            printUnsignedLine(result);
        }
"
17146,0,CWE401_Memory_Leak__new_twoIntsStruct_12.cpp,"    twoIntsStruct * data;
    data = NULL;
    if(globalReturnsTrueOrFalse())
    {
        
        data = new twoIntsStruct;
        
        data->intOne = 0;
        data->intTwo = 0;
        printStructLine(data);
    }
    else
    {
        
        twoIntsStruct dataGoodBuffer;
        data = &dataGoodBuffer;
        
        data->intOne = 0;
        data->intTwo = 0;
        printStructLine(data);
    }
    if(globalReturnsTrueOrFalse())
    {
        
        ; 
    }
    else
    {
        
        delete data;
"
16710,0,CWE416_Use_After_Free__malloc_free_struct_62a.cpp,"    twoIntsStruct * data;
    
    data = NULL;
    badSource(data);
    
    printStructLine(&data[0]);
"
7754,0,CWE457_Use_of_Uninitialized_Variable__int64_t_04.c,"    int64_t data;
    if(STATIC_CONST_TRUE)
    {
        
        ; 
    }
    if(STATIC_CONST_TRUE)
    {
        
        printLongLongLine(data);
"
11167,0,CWE78_OS_Command_Injection__char_file_execl_08.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(staticReturnsTrue())
    {
        {
            
            size_t dataLen = strlen(data);
            FILE * pFile;
            
            if (100-dataLen > 1)
            {
                pFile = fopen(FILENAME, ""r"");
                if (pFile != NULL)
                {
                    
                    if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                    {
                        printLine(""fgets() failed"");
                        
                        data[dataLen] = '\0';
                    }
                    fclose(pFile);
                }
            }
        }
    }
    
    
"
4731,0,CWE190_Integer_Overflow__char_fscanf_preinc_06.c,"    char data;
    data = ' ';
    if(STATIC_CONST_FIVE==5)
    {
        
        fscanf (stdin, ""%c"", &data);
    }
    if(STATIC_CONST_FIVE==5)
    {
        {
            
            ++data;
            char result = data;
            printHexCharLine(result);
        }
"
803,0,CWE197_Numeric_Truncation_Error__int_fscanf_to_short_68a.c,"    int data;
    
    data = -1;
    
    fscanf(stdin, ""%d"", &data);
    CWE197_Numeric_Truncation_Error__int_fscanf_to_short_68_badData = data;
"
11127,1,CWE252_Unchecked_Return_Value__char_fwrite_16.c,"    while(1)
    {
        
        if (fwrite((char *)""string"", sizeof(char), strlen(""string""), stdout) != strlen(""string""))
        {
            printLine(""fwrite failed!"");
        }
        break;
"
19021,0,CWE134_Uncontrolled_Format_String__char_console_vfprintf_15.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    switch(6)
    {
    case 6:
    {
        
        size_t dataLen = strlen(data);
        
        if (100-dataLen > 1)
        {
            
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgets() */
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
                    data[dataLen-1] = '\0';
                }
            }
            else
            {
                printLine(""fgets() failed"");
                
                data[dataLen] = '\0';
            }
        }
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
        badVaSinkB(data, data);
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
15563,1,CWE758_Undefined_Behavior__int_pointer_malloc_use_01.c,"    {
        int * data;
        int * * pointer = (int * *)malloc(sizeof(int *));
        if (pointer == NULL) {exit(-1);}
        
        data = (int *)malloc(sizeof(int));
        if (data == NULL) {exit(-1);}
        *data = 5;
        *pointer = data; 
        {
            int * data = *pointer;
            printIntLine(*data);
        }
        free(pointer);
"
13002,0,CWE78_OS_Command_Injection__char_connect_socket_popen_74a.cpp,"    char * data;
    map<int, char *> dataMap;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
12807,0,CWE190_Integer_Overflow__char_rand_square_42.c,"    char data;
    data = ' ';
    data = badSource(data);
    {
        
        char result = data * data;
        printHexCharLine(result);
"
10072,0,CWE78_OS_Command_Injection__char_console_execlp_45.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        
        if (100-dataLen > 1)
        {
            
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgets() */
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
"
4747,0,CWE369_Divide_by_Zero__int_fgets_modulo_15.c,"    int data;
    
    data = -1;
    switch(6)
    {
    case 6:
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
        
        printIntLine(100 % data);
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
6239,1,CWE252_Unchecked_Return_Value__char_fgets_08.c,"    if(staticReturnsTrue())
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            printLine(""Please enter a string: "");
            
            if (fgets(data, 100, stdin) == NULL)
            {
                printLine(""fgets failed!"");
                exit(1);
            }
            printLine(data);
        }
"
12862,0,CWE190_Integer_Overflow__int_fgets_multiply_21.c,"    int data;
    
    data = 0;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    badStatic = 1; 
"
10902,0,CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_84a.cpp,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_84_bad * badObject = new CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_84_bad(data);
"
7571,0,CWE252_Unchecked_Return_Value__char_fscanf_14.c,"    if(globalFive==5)
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            
            fscanf(stdin, ""%99s\0"", data);
        }
"
14514,0,CWE197_Numeric_Truncation_Error__int_fscanf_to_char_21.c,"    int data;
    
    data = -1;
    badStatic = 1; 
    data = badSource(data);
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
6598,0,CWE590_Free_Memory_Not_on_Heap__free_int64_t_alloca_34.c,"    int64_t * data;
    CWE590_Free_Memory_Not_on_Heap__free_int64_t_alloca_34_unionType myUnion;
    data = NULL; 
    {
        
        int64_t * dataBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5LL;
            }
        }
        data = dataBuffer;
    }
    myUnion.unionFirst = data;
    {
        int64_t * data = myUnion.unionSecond;
        printLongLongLine(data[0]);
        
        free(data);
"
17916,0,CWE590_Free_Memory_Not_on_Heap__delete_class_placement_new_63a.cpp,"    TwoIntsClass * data;
    data = NULL; 
    {
        
        char buffer[sizeof(TwoIntsClass)];
        TwoIntsClass * dataBuffer = new(buffer) TwoIntsClass;
        dataBuffer->intOne = 2;
        dataBuffer->intTwo = 2;
        data = dataBuffer;
    }
"
11253,0,CWE134_Uncontrolled_Format_String__char_file_vfprintf_15.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    switch(6)
    {
    case 6:
    {
        
        size_t dataLen = strlen(data);
        FILE * pFile;
        
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
        badVaSinkB(data, data);
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
4147,0,CWE590_Free_Memory_Not_on_Heap__delete_struct_static_10.cpp,"    twoIntsStruct * data;
    data = NULL; 
    if(globalTrue)
    {
        {
            
            static twoIntsStruct dataBuffer;
            dataBuffer.intOne = 1;
            dataBuffer.intTwo = 1;
            data = &dataBuffer;
        }
    }
    printStructLine(data);
    
"
4463,0,CWE78_OS_Command_Injection__char_connect_socket_execlp_62a.cpp,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    badSource(data);
    /* execlp - searches for the location of the command among
     * the directories specified by the PATH environment variable */
    
    EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}

#endif 

#ifndef OMITGOOD


void goodG2BSource(char * &data);

"
14009,1,CWE252_Unchecked_Return_Value__char_fread_04.c,"    if(STATIC_CONST_TRUE)
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            
            if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) != 100-1)
            {
                printLine(""fread failed!"");
            }
        }
"
3502,0,CWE590_Free_Memory_Not_on_Heap__delete_long_declare_09.cpp,"    long * data;
    data = NULL; 
    if(GLOBAL_CONST_TRUE)
    {
        {
            
            long dataBuffer;
            dataBuffer = 5L;
            data = &dataBuffer;
        }
    }
    printLongLine(*data);
    
"
15253,0,CWE758_Undefined_Behavior__struct_pointer_malloc_use_15.c,"    switch(6)
    {
    case 6:
    {
        twoIntsStruct * * pointer = (twoIntsStruct * *)malloc(sizeof(twoIntsStruct *));
        if (pointer == NULL) {exit(-1);}
        twoIntsStruct * data = *pointer; 
        free(pointer);
        printIntLine(data->intOne);
        printIntLine(data->intTwo);
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
7634,0,CWE197_Numeric_Truncation_Error__int_rand_to_short_13.c,"    int data;
    
    data = -1;
    if(GLOBAL_CONST_FIVE==5)
    {
        
        data = RAND32();
    }
    {
        
        short shortData = (short)data;
        printShortLine(shortData);
"
13566,0,CWE457_Use_of_Uninitialized_Variable__double_array_alloca_partial_init_02.c,"    double * data;
    data = (double *)ALLOCA(10*sizeof(double));
    if(1)
    {
        
        {
            int i;
            for(i=0; i<(10/2); i++)
            {
                data[i] = (double)i;
            }
        }
    }
    if(1)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printDoubleLine(data[i]);
            }
        }
"
6683,0,CWE457_Use_of_Uninitialized_Variable__twointsclass_array_declare_no_init_05.cpp,"    TwoIntsClass * data;
    TwoIntsClass dataUninitArray[10];
    data = dataUninitArray;
    if(staticTrue)
    {
        
        ; 
    }
    if(staticTrue)
    {
        
        for(int i=0; i<10; i++)
        {
            printIntLine(data[i].intOne);
            printIntLine(data[i].intTwo);
        }
"
16004,0,CWE190_Integer_Overflow__int64_t_fscanf_add_08.c,"    int64_t data;
    data = 0LL;
    if(staticReturnsTrue())
    {
        
        fscanf (stdin, ""%"" SCNd64, &data);
    }
    if(staticReturnsTrue())
    {
        {
            
            int64_t result = data + 1;
            printLongLongLine(result);
        }
"
12825,0,CWE401_Memory_Leak__new_array_twointsStruct_44.cpp,"    twoIntsStruct * data;
    
    void (*funcPtr) (twoIntsStruct *) = badSink;
    data = NULL;
    
    data = new twoIntsStruct[100];
    
    data[0].intOne = 0;
    data[0].intTwo = 0;
    printStructLine(&data[0]);
    
"
5528,0,CWE190_Integer_Overflow__short_max_preinc_67a.c,"    short data;
    CWE190_Integer_Overflow__short_max_preinc_67_structType myStruct;
    data = 0;
    
    data = SHRT_MAX;
    myStruct.structFirst = data;
"
17731,0,CWE415_Double_Free__new_delete_array_char_15.cpp,"    char * data;
    
    data = NULL;
    switch(6)
    {
    case 6:
        data = new char[100];
        
        delete [] data;
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
        
        delete [] data;
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
10663,0,CWE190_Integer_Overflow__int_connect_socket_preinc_09.c,"    int data;
    
    data = 0;
    if(GLOBAL_CONST_TRUE)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(GLOBAL_CONST_TRUE)
    {
        {
            
            ++data;
            int result = data;
            printIntLine(result);
        }
"
8421,0,CWE252_Unchecked_Return_Value__char_rename_07.c,"    if(staticFive==5)
    {
        
        RENAME(OLD_BAD_FILE_NAME, ""newbadfilename.txt"");
"
7442,0,CWE252_Unchecked_Return_Value__char_puts_07.c,"    if(staticFive==5)
    {
        
        PUTS(""string"");
"
10042,0,CWE590_Free_Memory_Not_on_Heap__delete_array_int_static_13.cpp,"    int * data;
    data = NULL; 
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            
            static int dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5;
                }
            }
            data = dataBuffer;
        }
    }
    printIntLine(data[0]);
    
"
540,0,CWE401_Memory_Leak__struct_twoIntsStruct_calloc_10.c,"    struct _twoIntsStruct * data;
    data = NULL;
    if(globalTrue)
    {
        
        data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));
        if (data == NULL) {exit(-1);}
        
        data[0].intOne = 0;
        data[0].intTwo = 0;
        printStructLine((twoIntsStruct *)&data[0]);
    }
    if(globalTrue)
    {
        
        ; 
"
15381,0,CWE416_Use_After_Free__new_delete_array_struct_09.cpp,"    twoIntsStruct * data;
    
    data = NULL;
    if(GLOBAL_CONST_TRUE)
    {
        data = new twoIntsStruct[100];
        {
            size_t i;
            for(i = 0; i < 100; i++)
            {
                data[i].intOne = 1;
                data[i].intTwo = 2;
            }
        }
        
        delete [] data;
    }
    if(GLOBAL_CONST_TRUE)
    {
        
        printStructLine(&data[0]);
        
"
9474,0,CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_11.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(globalReturnsTrue())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                data[dataLen + recvResult / sizeof(char)] = '\0';
                
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(globalReturnsTrue())
    {
        
        fprintf(stdout, data);
"
6594,1,CWE416_Use_After_Free__return_freed_ptr_15.c,"    switch(5)
    {
    case 6:
        
        printLine(""Benign, fixed string"");
        break;
    default:
    {
        
        char * reversedString = helperGood(""GoodSink"");
        printLine(reversedString);
        /* free(reversedString);
         * This call to free() was removed because we want the tool to detect the use after free,
         * but we don't want that function to be free(). Essentially we want to avoid a double free
         */
    }
    break;
"
14638,0,CWE590_Free_Memory_Not_on_Heap__delete_array_class_static_14.cpp,"    TwoIntsClass * data;
    data = NULL; 
    if(globalFive==5)
    {
        {
            
            static TwoIntsClass dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i].intOne = 1;
                    dataBuffer[i].intTwo = 1;
                }
            }
            data = dataBuffer;
        }
    }
    printIntLine(data[0].intOne);
    
"
13993,0,CWE457_Use_of_Uninitialized_Variable__int64_t_10.c,"    int64_t data;
    if(globalTrue)
    {
        
        ; 
    }
    if(globalTrue)
    {
        
        printLongLongLine(data);
"
13287,0,CWE78_OS_Command_Injection__char_console_system_84a.cpp,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    CWE78_OS_Command_Injection__char_console_system_84_bad * badObject = new CWE78_OS_Command_Injection__char_console_system_84_bad(data);
"
11752,0,CWE415_Double_Free__malloc_free_int_22a.c,"    int * data;
    
    data = NULL;
    data = (int *)malloc(100*sizeof(int));
    if (data == NULL) {exit(-1);}
    
    free(data);
    CWE415_Double_Free__malloc_free_int_22_badGlobal = 1; 
"
15682,0,CWE197_Numeric_Truncation_Error__int_rand_to_short_83_bad.cpp,"Label Definition File: CWE197_Numeric_Truncation_Error__int.label.xml
Template File: sources-sink-83_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 197 Numeric Truncation Error
 * BadSource: rand Set data to result of rand(), which may be zero
 * GoodSource: Less than CHAR_MAX
 * Sinks: to_short
 *    BadSink : Convert data to a short
 * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE197_Numeric_Truncation_Error__int_rand_to_short_83.h""

namespace CWE197_Numeric_Truncation_Error__int_rand_to_short_83
{
CWE197_Numeric_Truncation_Error__int_rand_to_short_83_bad::CWE197_Numeric_Truncation_Error__int_rand_to_short_83_bad(int dataCopy)
{
    data = dataCopy;
    
    data = RAND32();
}

CWE197_Numeric_Truncation_Error__int_rand_to_short_83_bad::~CWE197_Numeric_Truncation_Error__int_rand_to_short_83_bad()
{
    {
        
        short shortData = (short)data;
        printShortLine(shortData);
    }
}
}
"
17028,0,CWE190_Integer_Overflow__int_fscanf_multiply_32.c,"    int data;
    int *dataPtr1 = &data;
    int *dataPtr2 = &data;
    
    data = 0;
    {
        int data = *dataPtr1;
        
        fscanf(stdin, ""%d"", &data);
        *dataPtr1 = data;
    }
    {
        int data = *dataPtr2;
        if(data > 0) 
        {
            
            int result = data * 2;
            printIntLine(result);
        }
"
16613,1,CWE252_Unchecked_Return_Value__char_putchar_15.c,"    switch(6)
    {
    case 6:
        
        if (putchar((int)'A') == EOF)
        {
            printLine(""putchar failed!"");
        }
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
16158,1,CWE758_Undefined_Behavior__int_pointer_malloc_use_13.c,"    if(GLOBAL_CONST_FIVE!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            int * data;
            int * * pointer = (int * *)malloc(sizeof(int *));
            if (pointer == NULL) {exit(-1);}
            
            data = (int *)malloc(sizeof(int));
            if (data == NULL) {exit(-1);}
            *data = 5;
            *pointer = data; 
            {
                int * data = *pointer;
                printIntLine(*data);
            }
            free(pointer);
        }
"
11400,0,CWE190_Integer_Overflow__char_max_preinc_14.c,"    char data;
    data = ' ';
    if(globalFive==5)
    {
        
        data = CHAR_MAX;
    }
    if(globalFive==5)
    {
        {
            
            ++data;
            char result = data;
            printHexCharLine(result);
        }
"
4803,0,CWE78_OS_Command_Injection__char_file_system_83a.cpp,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
"
9840,0,CWE197_Numeric_Truncation_Error__int_large_to_short_10.c,"    int data;
    
    data = -1;
    if(globalTrue)
    {
        
        data = SHRT_MAX + 5;
    }
    {
        
        short shortData = (short)data;
        printShortLine(shortData);
"
16162,0,CWE190_Integer_Overflow__int64_t_fscanf_postinc_63a.c,"    int64_t data;
    data = 0LL;
    
    fscanf (stdin, ""%"" SCNd64, &data);
"
16096,0,CWE590_Free_Memory_Not_on_Heap__delete_array_int64_t_alloca_53a.cpp,"    int64_t * data;
    data = NULL; 
    {
        
        int64_t * dataBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5LL;
            }
        }
        data = dataBuffer;
    }
"
16821,0,CWE190_Integer_Overflow__short_rand_square_72a.cpp,"    short data;
    vector<short> dataVector;
    data = 0;
    
    data = (short)RAND32();
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
4258,0,CWE690_NULL_Deref_From_Return__struct_malloc_51a.c,"    twoIntsStruct * data;
    data = NULL; 
    
    data = (twoIntsStruct *)malloc(1*sizeof(twoIntsStruct));
"
1065,0,CWE190_Integer_Overflow__short_max_add_66a.c,"    short data;
    short dataArray[5];
    data = 0;
    
    data = SHRT_MAX;
    
    dataArray[2] = data;
"
5934,0,CWE369_Divide_by_Zero__int_zero_modulo_15.c,"    int data;
    
    data = -1;
    switch(6)
    {
    case 6:
        
        data = 0;
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
        
        printIntLine(100 % data);
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
12811,0,CWE190_Integer_Overflow__unsigned_int_fscanf_add_08.c,"    unsigned int data;
    data = 0;
    if(staticReturnsTrue())
    {
        
        fscanf (stdin, ""%u"", &data);
    }
    if(staticReturnsTrue())
    {
        {
            
            unsigned int result = data + 1;
            printUnsignedLine(result);
        }
"
19112,0,CWE190_Integer_Overflow__char_fscanf_add_68a.c,"    char data;
    data = ' ';
    
    fscanf (stdin, ""%c"", &data);
    CWE190_Integer_Overflow__char_fscanf_add_68_badData = data;
"
11303,0,CWE457_Use_of_Uninitialized_Variable__long_43.cpp,"    long data;
    badSource(data);
    
"
6262,0,CWE190_Integer_Overflow__unsigned_int_rand_postinc_17.c,"    int i,j;
    unsigned int data;
    data = 0;
    for(i = 0; i < 1; i++)
    {
        
        data = (unsigned int)RAND32();
    }
    for(j = 0; j < 1; j++)
    {
        {
            
            data++;
            unsigned int result = data;
            printUnsignedLine(result);
        }
"
13163,0,CWE190_Integer_Overflow__short_rand_postinc_18.c,"    short data;
    data = 0;
    goto source;
source:
    
    data = (short)RAND32();
    goto sink;
sink:
    {
        
        data++;
        short result = data;
        printIntLine(result);
"
41,0,CWE590_Free_Memory_Not_on_Heap__delete_int64_t_placement_new_13.cpp,"    int64_t * data;
    data = NULL; 
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            
            char buffer[sizeof(int64_t)];
            int64_t * dataBuffer = new(buffer) int64_t;
            *dataBuffer = 5LL;
            data = dataBuffer;
        }
    }
    printLongLongLine(*data);
    
"
16044,0,CWE415_Double_Free__malloc_free_char_84_bad.cpp,"Label Definition File: CWE415_Double_Free__malloc_free.label.xml
Template File: sources-sinks-84_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 415 Double Free
 * BadSource:  Allocate data using malloc() and Deallocate data using free()
 * GoodSource: Allocate data using malloc()
 * Sinks:
 *    GoodSink: do nothing
 *    BadSink : Deallocate data using free()
 * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE415_Double_Free__malloc_free_char_84.h""

namespace CWE415_Double_Free__malloc_free_char_84
{
CWE415_Double_Free__malloc_free_char_84_bad::CWE415_Double_Free__malloc_free_char_84_bad(char * dataCopy)
{
    data = dataCopy;
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    
    free(data);
}

CWE415_Double_Free__malloc_free_char_84_bad::~CWE415_Double_Free__malloc_free_char_84_bad()
{
    
    free(data);
}
}
"
4509,0,CWE190_Integer_Overflow__int64_t_rand_multiply_01.c,"    int64_t data;
    data = 0LL;
    
    data = (int64_t)RAND64();
    if(data > 0) 
    {
        
        int64_t result = data * 2;
        printLongLongLine(result);
"
6626,0,CWE190_Integer_Overflow__unsigned_int_fscanf_square_73a.cpp,"    unsigned int data;
    list<unsigned int> dataList;
    data = 0;
    
    fscanf (stdin, ""%u"", &data);
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
11560,0,CWE78_OS_Command_Injection__char_listen_socket_execlp_83a.cpp,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
"
2615,0,CWE190_Integer_Overflow__int_fscanf_multiply_21.c,"    int data;
    
    data = 0;
    
    fscanf(stdin, ""%d"", &data);
    badStatic = 1; 
"
6471,0,CWE369_Divide_by_Zero__int_fscanf_modulo_72a.cpp,"    int data;
    vector<int> dataVector;
    
    data = -1;
    
    fscanf(stdin, ""%d"", &data);
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
15024,0,CWE190_Integer_Overflow__int64_t_fscanf_multiply_31.c,"    int64_t data;
    data = 0LL;
    
    fscanf (stdin, ""%"" SCNd64, &data);
    {
        int64_t dataCopy = data;
        int64_t data = dataCopy;
        if(data > 0) 
        {
            
            int64_t result = data * 2;
            printLongLongLine(result);
        }
"
13426,1,CWE758_Undefined_Behavior__long_new_use_09.cpp,"    if(GLOBAL_CONST_FALSE)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            long data;
            data = 5L;
            long * pointer = new long;
            *pointer = data; 
            {
                long data = *pointer;
                printLongLine(data);
            }
            delete pointer;
        }
"
15496,0,CWE690_NULL_Deref_From_Return__char_calloc_32.c,"    char * data;
    char * *dataPtr1 = &data;
    char * *dataPtr2 = &data;
    data = NULL; 
    {
        char * data = *dataPtr1;
        
        data = (char *)calloc(20, sizeof(char));
        *dataPtr1 = data;
    }
    {
        char * data = *dataPtr2;
        
        strcpy(data, ""Initialize"");
        printLine(data);
        free(data);
"
138,0,CWE457_Use_of_Uninitialized_Variable__new_int_array_no_init_16.cpp,"    int * data;
    data = new int[10];
    while(1)
    {
        
        ; 
        break;
    }
    while(1)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i]);
            }
        }
        
        delete [] data;
        break;
"
6164,0,CWE134_Uncontrolled_Format_String__char_console_fprintf_73a.cpp,"    char * data;
    list<char *> dataList;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        
        if (100-dataLen > 1)
        {
            
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgets() */
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
                    data[dataLen-1] = '\0';
                }
            }
            else
            {
                printLine(""fgets() failed"");
                
                data[dataLen] = '\0';
            }
        }
    }
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
9099,0,CWE190_Integer_Overflow__unsigned_int_max_multiply_65a.c,"    unsigned int data;
    
    void (*funcPtr) (unsigned int) = CWE190_Integer_Overflow__unsigned_int_max_multiply_65b_badSink;
    data = 0;
    
    data = UINT_MAX;
    
"
10807,0,CWE457_Use_of_Uninitialized_Variable__double_array_declare_no_init_63a.c,"    double * data;
    double dataUninitArray[10];
    data = dataUninitArray;
    
    ; 
"
8982,0,CWE457_Use_of_Uninitialized_Variable__twointsclass_array_new_partial_init_08.cpp,"    TwoIntsClass * data;
    data = new TwoIntsClass[10];
    if(staticReturnsTrue())
    {
        
        for(int i=0; i<(10/2); i++)
        {
            data[i].intOne = i;
            data[i].intTwo = i;
        }
    }
    if(staticReturnsTrue())
    {
        
        for(int i=0; i<10; i++)
        {
            printIntLine(data[i].intOne);
            printIntLine(data[i].intTwo);
        }
"
8111,0,CWE190_Integer_Overflow__int_rand_postinc_67a.c,"    int data;
    CWE190_Integer_Overflow__int_rand_postinc_67_structType myStruct;
    
    data = 0;
    
    data = RAND32();
    myStruct.structFirst = data;
"
15617,0,CWE134_Uncontrolled_Format_String__char_console_vprintf_21.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        
        if (100-dataLen > 1)
        {
            
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgets() */
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
                    data[dataLen-1] = '\0';
                }
            }
            else
            {
                printLine(""fgets() failed"");
                
                data[dataLen] = '\0';
            }
        }
    }
    badStatic = 1; 
"
17972,0,CWE369_Divide_by_Zero__float_fgets_15.c,"    float data;
    
    data = 0.0F;
    switch(6)
    {
    case 6:
    {
        char inputBuffer[CHAR_ARRAY_SIZE];
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = (float)atof(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
    {
        
        int result = (int)(100.0 / data);
        printIntLine(result);
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
1991,0,CWE190_Integer_Overflow__int_fscanf_preinc_34.c,"    int data;
    CWE190_Integer_Overflow__int_fscanf_preinc_34_unionType myUnion;
    
    data = 0;
    
    fscanf(stdin, ""%d"", &data);
    myUnion.unionFirst = data;
    {
        int data = myUnion.unionSecond;
        {
            
            ++data;
            int result = data;
            printIntLine(result);
        }
"
14567,0,CWE590_Free_Memory_Not_on_Heap__free_char_static_17.c,"    int i;
    char * data;
    data = NULL; 
    for(i = 0; i < 1; i++)
    {
        {
            
            static char dataBuffer[100];
            memset(dataBuffer, 'A', 100-1); 
            dataBuffer[100-1] = '\0'; 
            data = dataBuffer;
        }
    }
    printLine(data);
    
"
6073,0,CWE190_Integer_Overflow__short_fscanf_add_84_bad.cpp,"Label Definition File: CWE190_Integer_Overflow.label.xml
Template File: sources-sinks-84_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 190 Integer Overflow
 * BadSource: fscanf Read data from the console using fscanf()
 * GoodSource: Set data to a small, non-zero number (two)
 * Sinks: add
 *    GoodSink: Ensure there will not be an overflow before adding 1 to data
 *    BadSink : Add 1 to data, which can cause an overflow
 * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE190_Integer_Overflow__short_fscanf_add_84.h""

namespace CWE190_Integer_Overflow__short_fscanf_add_84
{
CWE190_Integer_Overflow__short_fscanf_add_84_bad::CWE190_Integer_Overflow__short_fscanf_add_84_bad(short dataCopy)
{
    data = dataCopy;
    
    fscanf (stdin, ""%hd"", &data);
}

CWE190_Integer_Overflow__short_fscanf_add_84_bad::~CWE190_Integer_Overflow__short_fscanf_add_84_bad()
{
    {
        
        short result = data + 1;
        printIntLine(result);
    }
}
}
"
14797,0,CWE590_Free_Memory_Not_on_Heap__delete_array_class_static_12.cpp,"    TwoIntsClass * data;
    data = NULL; 
    if(globalReturnsTrueOrFalse())
    {
        {
            
            static TwoIntsClass dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i].intOne = 1;
                    dataBuffer[i].intTwo = 1;
                }
            }
            data = dataBuffer;
        }
    }
    else
    {
        {
            
            TwoIntsClass * dataBuffer = new TwoIntsClass[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i].intOne = 1;
                    dataBuffer[i].intTwo = 1;
                }
            }
            data = dataBuffer;
        }
    }
    printIntLine(data[0].intOne);
    
"
19440,0,CWE401_Memory_Leak__new_array_int_52a.cpp,"    int * data;
    data = NULL;
    
    data = new int[100];
    
    data[0] = 5;
    printIntLine(data[0]);
"
8081,0,CWE415_Double_Free__new_delete_array_char_81a.cpp,"    char * data;
    
    data = NULL;
    data = new char[100];
    
    delete [] data;
    const CWE415_Double_Free__new_delete_array_char_81_base& o = CWE415_Double_Free__new_delete_array_char_81_bad();
"
3516,0,CWE590_Free_Memory_Not_on_Heap__delete_array_class_declare_51a.cpp,"    TwoIntsClass * data;
    data = NULL; 
    {
        
        TwoIntsClass dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i].intOne = 1;
                dataBuffer[i].intTwo = 1;
            }
        }
        data = dataBuffer;
    }
"
1031,1,CWE401_Memory_Leak__malloc_realloc_twoIntsStruct_09.c,"    if(GLOBAL_CONST_FALSE)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            twoIntsStruct * data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
            if (data == NULL) {exit(-1);}
            twoIntsStruct * tmpData;
            
            data[0].intOne = 0;
            data[0].intTwo = 0;
            printStructLine(&data[0]);
            tmpData = (twoIntsStruct *)realloc(data, (130000)*sizeof(twoIntsStruct));
            /* FIX: Ensure realloc() was successful before assigning data to the memory block
            * allocated with realloc() */
            if (tmpData != NULL)
            {
                data = tmpData;
                
                data[0].intOne = 1;
                data[0].intTwo = 1;
                printStructLine(&data[0]);
            }
            free(data);
        }
"
18858,0,CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_52a.c,"    unsigned int data;
    data = 0;
    
    fscanf (stdin, ""%u"", &data);
"
8391,0,CWE758_Undefined_Behavior__struct_pointer_new_use_06.cpp,"    if(STATIC_CONST_FIVE==5)
    {
        {
            twoIntsStruct * * pointer = new twoIntsStruct *;
            twoIntsStruct * data = *pointer; 
            delete pointer;
            printIntLine(data->intOne);
            printIntLine(data->intTwo);
        }
"
3137,0,CWE190_Integer_Overflow__char_fscanf_add_22a.c,"    char data;
    data = ' ';
    
    fscanf (stdin, ""%c"", &data);
    CWE190_Integer_Overflow__char_fscanf_add_22_badGlobal = 1; 
"
13911,0,CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_53a.cpp,"    size_t data;
    
    data = 0;
    
    fscanf(stdin, ""%zu"", &data);
"
18957,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_52a.c,"    size_t data;
    
    data = 0;
    
    fscanf(stdin, ""%zu"", &data);
"
11607,0,CWE190_Integer_Overflow__int64_t_max_postinc_42.c,"    int64_t data;
    data = 0LL;
    data = badSource(data);
    {
        
        data++;
        int64_t result = data;
        printLongLongLine(result);
"
18917,0,CWE190_Integer_Overflow__char_fscanf_preinc_17.c,"    int i,j;
    char data;
    data = ' ';
    for(i = 0; i < 1; i++)
    {
        
        fscanf (stdin, ""%c"", &data);
    }
    for(j = 0; j < 1; j++)
    {
        {
            
            ++data;
            char result = data;
            printHexCharLine(result);
        }
"
4981,0,CWE190_Integer_Overflow__unsigned_int_max_preinc_05.c,"    unsigned int data;
    data = 0;
    if(staticTrue)
    {
        
        data = UINT_MAX;
    }
    if(staticTrue)
    {
        {
            
            ++data;
            unsigned int result = data;
            printUnsignedLine(result);
        }
"
2220,0,CWE590_Free_Memory_Not_on_Heap__delete_int64_t_static_45.cpp,"    int64_t * data;
    data = NULL; 
    {
        
        static int64_t dataBuffer;
        dataBuffer = 5LL;
        data = &dataBuffer;
    }
    badData = data;
"
6122,0,CWE190_Integer_Overflow__int64_t_rand_add_81_bad.cpp,"Label Definition File: CWE190_Integer_Overflow.label.xml
Template File: sources-sinks-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 190 Integer Overflow
 * BadSource: rand Set data to result of rand()
 * GoodSource: Set data to a small, non-zero number (two)
 * Sinks: add
 *    GoodSink: Ensure there will not be an overflow before adding 1 to data
 *    BadSink : Add 1 to data, which can cause an overflow
 * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE190_Integer_Overflow__int64_t_rand_add_81.h""

namespace CWE190_Integer_Overflow__int64_t_rand_add_81
{

void CWE190_Integer_Overflow__int64_t_rand_add_81_bad::action(int64_t data) const
{
    {
        
        int64_t result = data + 1;
        printLongLongLine(result);
    }
}

}
"
17142,0,CWE401_Memory_Leak__char_realloc_64a.c,"    char * data;
    data = NULL;
    
    data = (char *)realloc(data, 100*sizeof(char));
    if (data == NULL) {exit(-1);}
    
    strcpy(data, ""A String"");
    printLine(data);
"
6243,0,CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_62a.cpp,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    badSource(data);
"
4023,1,CWE758_Undefined_Behavior__int_pointer_alloca_use_09.c,"    if(GLOBAL_CONST_FALSE)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            int * data;
            int * * pointer = (int * *)ALLOCA(sizeof(int *));
            
            data = (int *)malloc(sizeof(int));
            if (data == NULL) {exit(-1);}
            *data = 5;
            *pointer = data; 
            {
                int * data = *pointer;
                printIntLine(*data);
            }
        }
"
10816,0,CWE197_Numeric_Truncation_Error__int_large_to_char_34.c,"    int data;
    CWE197_Numeric_Truncation_Error__int_large_to_char_34_unionType myUnion;
    
    data = -1;
    
    data = SHRT_MAX + 5;
    myUnion.unionFirst = data;
    {
        int data = myUnion.unionSecond;
        {
            
            char charData = (char)data;
            printHexCharLine(charData);
        }
"
8500,0,CWE197_Numeric_Truncation_Error__int_fscanf_to_short_16.c,"    int data;
    
    data = -1;
    while(1)
    {
        
        fscanf(stdin, ""%d"", &data);
        break;
    }
    {
        
        short shortData = (short)data;
        printShortLine(shortData);
"
123,0,CWE758_Undefined_Behavior__class_new_use_01.cpp,"    {
        TwoIntsClass * pointer = new TwoIntsClass;
        TwoIntsClass data = *pointer; 
        delete pointer;
        printIntLine(data.intOne);
        printIntLine(data.intTwo);
"
8613,1,CWE252_Unchecked_Return_Value__char_puts_04.c,"    if(STATIC_CONST_FALSE)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        
        if (PUTS(""string"") == EOF)
        {
            printLine(""puts failed!"");
        }
"
19153,0,CWE563_Unused_Variable__unused_value_struct_22a.c,"    twoIntsStruct data;
    
    data.intOne = 0;
    data.intTwo = 0;
    CWE563_Unused_Variable__unused_value_struct_22_badGlobal = 1; 
"
17085,0,CWE190_Integer_Overflow__char_rand_multiply_01.c,"    char data;
    data = ' ';
    
    data = (char)RAND32();
    if(data > 0) 
    {
        
        char result = data * 2;
        printHexCharLine(result);
"
3850,0,CWE134_Uncontrolled_Format_String__char_connect_socket_printf_73a.cpp,"    char * data;
    list<char *> dataList;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
11654,1,CWE252_Unchecked_Return_Value__char_snprintf_08.c,"    if(staticReturnsTrue())
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            
            if (SNPRINTF(data,100-strlen(SRC)-1, ""%s\n"", SRC) < 0)
            {
                printLine(""snprintf failed!"");
            }
        }
"
403,0,CWE197_Numeric_Truncation_Error__short_fscanf_17.c,"    int i;
    short data;
    
    data = -1;
    for(i = 0; i < 1; i++)
    {
        
        fscanf (stdin, ""%hd"", &data);
    }
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
14337,0,CWE590_Free_Memory_Not_on_Heap__delete_array_char_declare_02.cpp,"    char * data;
    data = NULL; 
    if(1)
    {
        {
            
            char dataBuffer[100];
            memset(dataBuffer, 'A', 100-1); 
            dataBuffer[100-1] = '\0'; 
            data = dataBuffer;
        }
    }
    printLine(data);
    
"
14381,0,CWE758_Undefined_Behavior__struct_pointer_alloca_use_18.c,"    goto sink;
sink:
    {
        twoIntsStruct * * pointer = (twoIntsStruct * *)ALLOCA(sizeof(twoIntsStruct *));
        twoIntsStruct * data = *pointer; 
        printIntLine(data->intOne);
        printIntLine(data->intTwo);
"
994,0,CWE78_OS_Command_Injection__char_file_system_32.c,"    char * data;
    char * *dataPtr1 = &data;
    char * *dataPtr2 = &data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
        char * data = *dataPtr1;
        {
            
            size_t dataLen = strlen(data);
            FILE * pFile;
            
            if (100-dataLen > 1)
            {
                pFile = fopen(FILENAME, ""r"");
                if (pFile != NULL)
                {
                    
                    if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                    {
                        printLine(""fgets() failed"");
                        
                        data[dataLen] = '\0';
                    }
                    fclose(pFile);
                }
            }
        }
        *dataPtr1 = data;
    }
    {
        char * data = *dataPtr2;
        
        if (SYSTEM(data) != 0)
        {
            printLine(""command execution failed!"");
            exit(1);
        }
"
11298,0,CWE401_Memory_Leak__twoIntsStruct_malloc_09.c,"    twoIntsStruct * data;
    data = NULL;
    if(GLOBAL_CONST_TRUE)
    {
        
        data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
        if (data == NULL) {exit(-1);}
        
        data[0].intOne = 0;
        data[0].intTwo = 0;
        printStructLine(&data[0]);
    }
    if(GLOBAL_CONST_TRUE)
    {
        
        ; 
"
14066,0,CWE134_Uncontrolled_Format_String__char_connect_socket_printf_05.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(staticTrue)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET connectSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                
                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                data[dataLen + recvResult / sizeof(char)] = '\0';
                
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(staticTrue)
    {
        
        printf(data);
"
1873,0,CWE190_Integer_Overflow__char_fscanf_multiply_31.c,"    char data;
    data = ' ';
    
    fscanf (stdin, ""%c"", &data);
    {
        char dataCopy = data;
        char data = dataCopy;
        if(data > 0) 
        {
            
            char result = data * 2;
            printHexCharLine(result);
        }
"
17409,0,CWE590_Free_Memory_Not_on_Heap__free_int64_t_declare_10.c,"    int64_t * data;
    data = NULL; 
    if(globalTrue)
    {
        {
            
            int64_t dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5LL;
                }
            }
            data = dataBuffer;
        }
    }
    printLongLongLine(data[0]);
    
"
6408,0,CWE467_Use_of_sizeof_on_Pointer_Type__int_08.c,"    if(staticReturnsTrue())
    {
        {
            int * badInt = NULL;
            
            badInt = (int *)malloc(sizeof(badInt));
            if (badInt == NULL) {exit(-1);}
            *badInt = 5;
            printIntLine(*badInt);
            free(badInt);
        }
"
9547,0,CWE476_NULL_Pointer_Dereference__binary_if_15.c,"    switch(6)
    {
    case 6:
    {
        twoIntsStruct *twoIntsStructPointer = NULL;
        /* FLAW: Using a single & in the if statement will cause both sides of the expression to be evaluated
         * thus causing a NPD */
        if ((twoIntsStructPointer != NULL) & (twoIntsStructPointer->intOne == 5))
        {
            printLine(""intOne == 5"");
        }
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
3551,0,CWE758_Undefined_Behavior__struct_pointer_alloca_use_04.c,"    if(STATIC_CONST_TRUE)
    {
        {
            twoIntsStruct * * pointer = (twoIntsStruct * *)ALLOCA(sizeof(twoIntsStruct *));
            twoIntsStruct * data = *pointer; 
            printIntLine(data->intOne);
            printIntLine(data->intTwo);
        }
"
10060,0,CWE190_Integer_Overflow__char_max_square_82_bad.cpp,"Label Definition File: CWE190_Integer_Overflow.label.xml
Template File: sources-sinks-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 190 Integer Overflow
 * BadSource: max Set data to the max value for char
 * GoodSource: Set data to a small, non-zero number (two)
 * Sinks: square
 *    GoodSink: Ensure there will not be an overflow before squaring data
 *    BadSink : Square data, which can lead to overflow
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE190_Integer_Overflow__char_max_square_82.h""

#include <math.h>

namespace CWE190_Integer_Overflow__char_max_square_82
{

void CWE190_Integer_Overflow__char_max_square_82_bad::action(char data)
{
    {
        
        char result = data * data;
        printHexCharLine(result);
    }
}

}
"
6910,0,CWE416_Use_After_Free__new_delete_struct_16.cpp,"    twoIntsStruct * data;
    
    data = NULL;
    while(1)
    {
        data = new twoIntsStruct;
        data->intOne = 1;
        data->intTwo = 2;
        
        delete data;
        break;
    }
    while(1)
    {
        
        printStructLine(data);
        
        break;
"
19516,0,CWE197_Numeric_Truncation_Error__int_fscanf_to_char_14.c,"    int data;
    
    data = -1;
    if(globalFive==5)
    {
        
        fscanf(stdin, ""%d"", &data);
    }
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
5250,0,CWE416_Use_After_Free__return_freed_ptr_14.c,"    if(globalFive==5)
    {
        {
            
            char * reversedString = helperBad(""BadSink"");
            printLine(reversedString);
            /* free(reversedString);
             * This call to free() was removed because we want the tool to detect the use after free,
             * but we don't want that function to be free(). Essentially we want to avoid a double free
             */
        }
"
5479,0,CWE563_Unused_Variable__unused_uninit_variable_int64_t_07.c,"    int64_t data;
    
    ; 
    if(staticFive==5)
    {
        
        
        ; 
"
5949,0,CWE197_Numeric_Truncation_Error__int_listen_socket_to_short_74a.cpp,"    int data;
    map<int, int> dataMap;
    
    data = -1;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
7569,0,CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_64a.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
8688,0,CWE190_Integer_Overflow__int64_t_max_multiply_53a.c,"    int64_t data;
    data = 0LL;
    
    data = LLONG_MAX;
"
14298,0,CWE134_Uncontrolled_Format_String__char_listen_socket_printf_12.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(globalReturnsTrueOrFalse())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                data[dataLen + recvResult / sizeof(char)] = '\0';
                
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    else
    {
        
        strcpy(data, ""fixedstringtest"");
    }
    if(globalReturnsTrueOrFalse())
    {
        
        printf(data);
    }
    else
    {
        
        printf(""%s\n"", data);
"
18424,0,CWE590_Free_Memory_Not_on_Heap__delete_array_class_declare_04.cpp,"    TwoIntsClass * data;
    data = NULL; 
    if(STATIC_CONST_TRUE)
    {
        {
            
            TwoIntsClass dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i].intOne = 1;
                    dataBuffer[i].intTwo = 1;
                }
            }
            data = dataBuffer;
        }
    }
    printIntLine(data[0].intOne);
    
"
2333,0,CWE590_Free_Memory_Not_on_Heap__delete_int64_t_static_14.cpp,"    int64_t * data;
    data = NULL; 
    if(globalFive==5)
    {
        {
            
            static int64_t dataBuffer;
            dataBuffer = 5LL;
            data = &dataBuffer;
        }
    }
    printLongLongLine(*data);
    
"
12978,0,CWE563_Unused_Variable__unused_uninit_variable_int_02.c,"    int data;
    
    ; 
    if(1)
    {
        
        
        ; 
"
835,1,CWE467_Use_of_sizeof_on_Pointer_Type__char_04.c,"    if(STATIC_CONST_TRUE)
    {
        {
            char * goodChar = NULL;
            
            goodChar = (char *)malloc(sizeof(*goodChar));
            if (goodChar == NULL) {exit(-1);}
            *goodChar = 'G';
            printHexCharLine(*goodChar);
            free(goodChar);
        }
"
1975,0,CWE690_NULL_Deref_From_Return__struct_realloc_07.c,"    twoIntsStruct * data;
    data = NULL; 
    
    data = (twoIntsStruct *)realloc(data, 1*sizeof(twoIntsStruct));
    if(staticFive==5)
    {
        
        data[0].intOne = 1;
        data[0].intTwo = 1;
        printStructLine(&data[0]);
        free(data);
"
19238,0,CWE457_Use_of_Uninitialized_Variable__new_double_array_no_init_09.cpp,"    double * data;
    data = new double[10];
    if(GLOBAL_CONST_TRUE)
    {
        
        ; 
    }
    if(GLOBAL_CONST_TRUE)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printDoubleLine(data[i]);
            }
        }
        
        delete [] data;
"
15758,0,CWE369_Divide_by_Zero__float_fscanf_64a.c,"    float data;
    
    data = 0.0F;
    
    fscanf (stdin, ""%f"", &data);
"
1214,0,CWE401_Memory_Leak__int64_t_realloc_18.c,"    int64_t * data;
    data = NULL;
    goto source;
source:
    
    data = (int64_t *)realloc(data, 100*sizeof(int64_t));
    if (data == NULL) {exit(-1);}
    
    data[0] = 5LL;
    printLongLongLine(data[0]);
    goto sink;
sink:
    
"
16742,0,CWE401_Memory_Leak__new_array_char_44.cpp,"    char * data;
    
    void (*funcPtr) (char *) = badSink;
    data = NULL;
    
    data = new char[100];
    
    strcpy(data, ""A String"");
    printLine(data);
    
"
13025,0,CWE190_Integer_Overflow__short_rand_add_05.c,"    short data;
    data = 0;
    if(staticTrue)
    {
        
        data = (short)RAND32();
    }
    if(staticTrue)
    {
        {
            
            short result = data + 1;
            printIntLine(result);
        }
"
16080,0,CWE78_OS_Command_Injection__char_console_execlp_54a.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        
        if (100-dataLen > 1)
        {
            
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgets() */
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
                    data[dataLen-1] = '\0';
                }
            }
            else
            {
                printLine(""fgets() failed"");
                
                data[dataLen] = '\0';
            }
        }
    }
"
7756,0,CWE190_Integer_Overflow__int_rand_preinc_66a.c,"    int data;
    int dataArray[5];
    
    data = 0;
    
    data = RAND32();
    
    dataArray[2] = data;
"
1618,0,CWE78_OS_Command_Injection__char_listen_socket_system_81a.cpp,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    const CWE78_OS_Command_Injection__char_listen_socket_system_81_base& baseObject = CWE78_OS_Command_Injection__char_listen_socket_system_81_bad();
"
15017,0,CWE190_Integer_Overflow__int64_t_max_preinc_22a.c,"    int64_t data;
    data = 0LL;
    
    data = LLONG_MAX;
    CWE190_Integer_Overflow__int64_t_max_preinc_22_badGlobal = 1; 
"
3151,0,CWE190_Integer_Overflow__char_fscanf_square_34.c,"    char data;
    CWE190_Integer_Overflow__char_fscanf_square_34_unionType myUnion;
    data = ' ';
    
    fscanf (stdin, ""%c"", &data);
    myUnion.unionFirst = data;
    {
        char data = myUnion.unionSecond;
        {
            
            char result = data * data;
            printHexCharLine(result);
        }
"
7258,1,CWE758_Undefined_Behavior__double_pointer_new_use_15.cpp,"    switch(5)
    {
    case 6:
        
        printLine(""Benign, fixed string"");
        break;
    default:
    {
        double * data;
        
        data = new double;
        *data = 5.0;
        double * * pointer = new double *;
        *pointer = data; 
        {
            double * data = *pointer;
            printDoubleLine(*data);
        }
        delete pointer;
    }
    break;
"
16765,0,CWE190_Integer_Overflow__short_fscanf_preinc_67a.c,"    short data;
    CWE190_Integer_Overflow__short_fscanf_preinc_67_structType myStruct;
    data = 0;
    
    fscanf (stdin, ""%hd"", &data);
    myStruct.structFirst = data;
"
17083,1,CWE758_Undefined_Behavior__long_malloc_use_10.c,"    if(globalFalse)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            long data;
            long * pointer = (long *)malloc(sizeof(long));
            if (pointer == NULL) {exit(-1);}
            data = 5L;
            *pointer = data; 
            {
                long data = *pointer;
                printLongLine(data);
            }
            free(pointer);
        }
"
18906,1,CWE758_Undefined_Behavior__char_new_use_11.cpp,"    if(globalReturnsFalse())
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            char data;
            data = 5;
            char * pointer = new char;
            *pointer = data; 
            {
                char data = *pointer;
                printHexCharLine(data);
            }
            delete pointer;
        }
"
7142,0,CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_66a.c,"    unsigned int data;
    unsigned int dataArray[5];
    data = 0;
    
    fscanf (stdin, ""%u"", &data);
    
    dataArray[2] = data;
"
15762,0,CWE590_Free_Memory_Not_on_Heap__free_char_alloca_31.c,"    char * data;
    data = NULL; 
    {
        
        char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
        memset(dataBuffer, 'A', 100-1); 
        dataBuffer[100-1] = '\0'; 
        data = dataBuffer;
    }
    {
        char * dataCopy = data;
        char * data = dataCopy;
        printLine(data);
        
        free(data);
"
816,0,CWE416_Use_After_Free__new_delete_long_13.cpp,"    long * data;
    
    data = NULL;
    if(GLOBAL_CONST_FIVE==5)
    {
        data = new long;
        *data = 5L;
        
        delete data;
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        
        printLongLine(*data);
        
"
16745,0,CWE415_Double_Free__new_delete_struct_34.cpp,"    twoIntsStruct * data;
    unionType myUnion;
    
    data = NULL;
    data = new twoIntsStruct;
    
    delete data;
    myUnion.unionFirst = data;
    {
        twoIntsStruct * data = myUnion.unionSecond;
        
        delete data;
"
14748,0,CWE590_Free_Memory_Not_on_Heap__delete_class_alloca_66a.cpp,"    TwoIntsClass * data;
    TwoIntsClass * dataArray[5];
    data = NULL; 
    {
        
        TwoIntsClass * dataBuffer = (TwoIntsClass *)ALLOCA(sizeof(TwoIntsClass));
        dataBuffer->intOne = 2;
        dataBuffer->intTwo = 2;
        data = dataBuffer;
    }
    
    dataArray[2] = data;
"
15276,0,CWE457_Use_of_Uninitialized_Variable__twointsclass_array_malloc_partial_init_13.cpp,"    TwoIntsClass * data;
    data = reinterpret_cast<TwoIntsClass *>(malloc(10*sizeof(TwoIntsClass)));
    if (data == NULL) {exit(-1);}
    if(GLOBAL_CONST_FIVE==5)
    {
        
        for(int i=0; i<(10/2); i++)
        {
            data[i].intOne = i;
            data[i].intTwo = i;
        }
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        
        for(int i=0; i<10; i++)
        {
            printIntLine(data[i].intOne);
            printIntLine(data[i].intTwo);
        }
"
6979,0,CWE190_Integer_Overflow__int_rand_postinc_65a.c,"    int data;
    
    void (*funcPtr) (int) = CWE190_Integer_Overflow__int_rand_postinc_65b_badSink;
    
    data = 0;
    
    data = RAND32();
    
"
2789,0,CWE789_Uncontrolled_Mem_Alloc__new_char_listen_socket_84a.cpp,"    size_t data;
    
    data = 0;
    CWE789_Uncontrolled_Mem_Alloc__new_char_listen_socket_84_bad * badObject = new CWE789_Uncontrolled_Mem_Alloc__new_char_listen_socket_84_bad(data);
"
5050,0,CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_31.c,"    int data;
    
    data = -1;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    {
        int dataCopy = data;
        int data = dataCopy;
        {
            
            char charData = (char)data;
            printHexCharLine(charData);
        }
"
14008,0,CWE190_Integer_Overflow__short_fscanf_multiply_63a.c,"    short data;
    data = 0;
    
    fscanf (stdin, ""%hd"", &data);
"
14705,0,CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_17.c,"    int i,j;
    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    for(i = 0; i < 1; i++)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET connectSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                
                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                data[dataLen + recvResult / sizeof(char)] = '\0';
                
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    for(j = 0; j < 1; j++)
    {
        badVaSinkB(data, data);
"
6360,0,CWE369_Divide_by_Zero__int_zero_divide_83_bad.cpp,"Label Definition File: CWE369_Divide_by_Zero__int.label.xml
Template File: sources-sinks-83_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 369 Divide by Zero
 * BadSource: zero Fixed value of zero
 * GoodSource: Non-zero
 * Sinks: divide
 *    GoodSink: Check for zero before dividing
 *    BadSink : Divide a constant by data
 * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE369_Divide_by_Zero__int_zero_divide_83.h""

namespace CWE369_Divide_by_Zero__int_zero_divide_83
{
CWE369_Divide_by_Zero__int_zero_divide_83_bad::CWE369_Divide_by_Zero__int_zero_divide_83_bad(int dataCopy)
{
    data = dataCopy;
    
    data = 0;
}

CWE369_Divide_by_Zero__int_zero_divide_83_bad::~CWE369_Divide_by_Zero__int_zero_divide_83_bad()
{
    
    printIntLine(100 / data);
}
}
"
5562,0,CWE590_Free_Memory_Not_on_Heap__delete_long_placement_new_17.cpp,"    int i;
    long * data;
    data = NULL; 
    for(i = 0; i < 1; i++)
    {
        {
            
            char buffer[sizeof(long)];
            long * dataBuffer = new(buffer) long;
            *dataBuffer = 5L;
            data = dataBuffer;
        }
    }
    printLongLine(*data);
    
"
14501,0,CWE190_Integer_Overflow__char_fscanf_add_64a.c,"    char data;
    data = ' ';
    
    fscanf (stdin, ""%c"", &data);
"
11642,1,CWE758_Undefined_Behavior__long_malloc_use_11.c,"    if(globalReturnsFalse())
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            long data;
            long * pointer = (long *)malloc(sizeof(long));
            if (pointer == NULL) {exit(-1);}
            data = 5L;
            *pointer = data; 
            {
                long data = *pointer;
                printLongLine(data);
            }
            free(pointer);
        }
"
4755,0,CWE190_Integer_Overflow__unsigned_int_fscanf_square_43.cpp,"    unsigned int data;
    data = 0;
    badSource(data);
    {
        
        unsigned int result = data * data;
        printUnsignedLine(result);
"
9404,0,CWE190_Integer_Overflow__unsigned_int_max_multiply_66a.c,"    unsigned int data;
    unsigned int dataArray[5];
    data = 0;
    
    data = UINT_MAX;
    
    dataArray[2] = data;
"
2889,0,CWE190_Integer_Overflow__int_rand_postinc_06.c,"    int data;
    
    data = 0;
    if(STATIC_CONST_FIVE==5)
    {
        
        data = RAND32();
    }
    if(STATIC_CONST_FIVE==5)
    {
        {
            
            data++;
            int result = data;
            printIntLine(result);
        }
"
3008,0,CWE590_Free_Memory_Not_on_Heap__delete_char_static_82a.cpp,"    char * data;
    data = NULL; 
    {
        
        static char dataBuffer;
        dataBuffer = 'A';
        data = &dataBuffer;
    }
    CWE590_Free_Memory_Not_on_Heap__delete_char_static_82_base* baseObject = new CWE590_Free_Memory_Not_on_Heap__delete_char_static_82_bad;
    baseObject->action(data);
"
2163,1,CWE476_NULL_Pointer_Dereference__binary_if_18.c,"    goto sink;
sink:
    {
        twoIntsStruct *twoIntsStructPointer = NULL;
        /* FIX: Use && in the if statement so that if the left side of the expression fails then
         * the right side will not be evaluated */
        if ((twoIntsStructPointer != NULL) && (twoIntsStructPointer->intOne == 5))
        {
            printLine(""intOne == 5"");
        }
"
10878,0,CWE590_Free_Memory_Not_on_Heap__delete_class_alloca_03.cpp,"    TwoIntsClass * data;
    data = NULL; 
    if(5==5)
    {
        {
            
            TwoIntsClass * dataBuffer = (TwoIntsClass *)ALLOCA(sizeof(TwoIntsClass));
            dataBuffer->intOne = 2;
            dataBuffer->intTwo = 2;
            data = dataBuffer;
        }
    }
    printIntLine(data->intOne);
    
"
17492,0,CWE415_Double_Free__new_delete_char_16.cpp,"    char * data;
    
    data = NULL;
    while(1)
    {
        data = new char;
        
        delete data;
        break;
    }
    while(1)
    {
        
        delete data;
        break;
"
5228,0,CWE190_Integer_Overflow__int_connect_socket_square_43.cpp,"    int data;
    
    data = 0;
    badSource(data);
    {
        
        int result = data * data;
        printIntLine(result);
"
1855,0,CWE563_Unused_Variable__unused_value_struct_43.cpp,"    twoIntsStruct data;
    badSource(data);
    
    data.intOne = 1;
    data.intTwo = 1;
"
6661,0,CWE134_Uncontrolled_Format_String__char_environment_snprintf_82a.cpp,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        
        if (environment != NULL)
        {
            
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    CWE134_Uncontrolled_Format_String__char_environment_snprintf_82_base* baseObject = new CWE134_Uncontrolled_Format_String__char_environment_snprintf_82_bad;
    baseObject->action(data);
"
7261,0,CWE590_Free_Memory_Not_on_Heap__delete_long_declare_05.cpp,"    long * data;
    data = NULL; 
    if(staticTrue)
    {
        {
            
            long dataBuffer;
            dataBuffer = 5L;
            data = &dataBuffer;
        }
    }
    printLongLine(*data);
    
"
3044,0,CWE590_Free_Memory_Not_on_Heap__free_struct_declare_14.c,"    twoIntsStruct * data;
    data = NULL; 
    if(globalFive==5)
    {
        {
            
            twoIntsStruct dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i].intOne = 1;
                    dataBuffer[i].intTwo = 1;
                }
            }
            data = dataBuffer;
        }
    }
    printStructLine(&data[0]);
    
"
13067,0,CWE416_Use_After_Free__new_delete_char_43.cpp,"    char * data;
    
    data = NULL;
    badSource(data);
    
    printHexCharLine(*data);
"
14399,0,CWE190_Integer_Overflow__int_listen_socket_preinc_42.c,"    int data;
    
    data = 0;
    data = badSource(data);
    {
        
        ++data;
        int result = data;
        printIntLine(result);
"
3627,0,CWE563_Unused_Variable__unused_init_variable_struct_82_bad.cpp,"Label Definition File: CWE563_Unused_Variable__unused_init_variable.label.xml
Template File: source-sinks-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 563 Unused Variable
 * BadSource:  Initialize data
 * Sinks:
 *    GoodSink: Use data
 *    BadSink : do nothing
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE563_Unused_Variable__unused_init_variable_struct_82.h""

namespace CWE563_Unused_Variable__unused_init_variable_struct_82
{

void CWE563_Unused_Variable__unused_init_variable_struct_82_bad::action(twoIntsStruct data)
{
    
    
    ; 
}

}
"
15049,0,CWE590_Free_Memory_Not_on_Heap__delete_array_int_alloca_04.cpp,"    int * data;
    data = NULL; 
    if(STATIC_CONST_TRUE)
    {
        {
            
            int * dataBuffer = (int *)ALLOCA(100*sizeof(int));
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5;
                }
            }
            data = dataBuffer;
        }
    }
    printIntLine(data[0]);
    
"
8831,0,CWE690_NULL_Deref_From_Return__int_realloc_03.c,"    int * data;
    data = NULL; 
    
    data = (int *)realloc(data, 1*sizeof(int));
    if(5==5)
    {
        
        data[0] = 5;
        printIntLine(data[0]);
        free(data);
"
1191,0,CWE401_Memory_Leak__new_array_TwoIntsClass_08.cpp,"    TwoIntsClass * data;
    data = NULL;
    if(staticReturnsTrue())
    {
        
        data = new TwoIntsClass[100];
        
        data[0].intOne = 0;
        data[0].intTwo = 0;
        printIntLine(data[0].intOne);
        printIntLine(data[0].intTwo);
    }
    if(staticReturnsTrue())
    {
        
        ; 
"
17574,0,CWE690_NULL_Deref_From_Return__struct_realloc_09.c,"    twoIntsStruct * data;
    data = NULL; 
    
    data = (twoIntsStruct *)realloc(data, 1*sizeof(twoIntsStruct));
    if(GLOBAL_CONST_TRUE)
    {
        
        data[0].intOne = 1;
        data[0].intTwo = 1;
        printStructLine(&data[0]);
        free(data);
"
3764,0,CWE590_Free_Memory_Not_on_Heap__delete_array_struct_declare_64a.cpp,"    twoIntsStruct * data;
    data = NULL; 
    {
        
        twoIntsStruct dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i].intOne = 1;
                dataBuffer[i].intTwo = 1;
            }
        }
        data = dataBuffer;
    }
"
7239,0,CWE197_Numeric_Truncation_Error__int_fgets_to_short_22a.c,"    int data;
    
    data = -1;
    CWE197_Numeric_Truncation_Error__int_fgets_to_short_22_badGlobal = 1; 
    data = CWE197_Numeric_Truncation_Error__int_fgets_to_short_22_badSource(data);
    {
        
        short shortData = (short)data;
        printShortLine(shortData);
"
19054,0,CWE401_Memory_Leak__struct_twoIntsStruct_malloc_65a.c,"    struct _twoIntsStruct * data;
    
    void (*funcPtr) (struct _twoIntsStruct *) = CWE401_Memory_Leak__struct_twoIntsStruct_malloc_65b_badSink;
    data = NULL;
    
    data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));
    if (data == NULL) {exit(-1);}
    
    data[0].intOne = 0;
    data[0].intTwo = 0;
    printStructLine((twoIntsStruct *)&data[0]);
    
"
9069,0,CWE416_Use_After_Free__malloc_free_int_62a.cpp,"    int * data;
    
    data = NULL;
    badSource(data);
    
    printIntLine(data[0]);
"
3494,0,CWE690_NULL_Deref_From_Return__fopen_44.c,"    FILE * data;
    
    void (*funcPtr) (FILE *) = badSink;
    
    data = NULL;
    
    data = fopen(""file.txt"", ""w+"");
    
"
17344,0,CWE369_Divide_by_Zero__int_zero_divide_64a.c,"    int data;
    
    data = -1;
    
    data = 0;
"
10405,0,CWE190_Integer_Overflow__short_fscanf_multiply_12.c,"    short data;
    data = 0;
    if(globalReturnsTrueOrFalse())
    {
        
        fscanf (stdin, ""%hd"", &data);
    }
    else
    {
        
        data = 2;
    }
    if(globalReturnsTrueOrFalse())
    {
        if(data > 0) 
        {
            
            short result = data * 2;
            printIntLine(result);
        }
    }
    else
    {
        if(data > 0) 
        {
            
            if (data < (SHRT_MAX/2))
            {
                short result = data * 2;
                printIntLine(result);
            }
            else
            {
                printLine(""data value is too large to perform arithmetic safely."");
            }
        }
"
8095,0,CWE415_Double_Free__new_delete_char_81_bad.cpp,"Label Definition File: CWE415_Double_Free__new_delete.label.xml
Template File: sources-sinks-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 415 Double Free
 * BadSource:  Allocate data using new and Deallocae data using delete
 * GoodSource: Allocate data using new
 * Sinks:
 *    GoodSink: do nothing
 *    BadSink : Deallocate data using delete
 * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE415_Double_Free__new_delete_char_81.h""

namespace CWE415_Double_Free__new_delete_char_81
{

void CWE415_Double_Free__new_delete_char_81_bad::action(char * data) const
{
    
    delete data;
}

}
"
9078,0,CWE190_Integer_Overflow__int_listen_socket_square_54a.c,"    int data;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
2140,0,CWE190_Integer_Overflow__int64_t_max_postinc_54a.c,"    int64_t data;
    data = 0LL;
    
    data = LLONG_MAX;
"
18241,0,CWE415_Double_Free__new_delete_int64_t_04.cpp,"    int64_t * data;
    
    data = NULL;
    if(STATIC_CONST_TRUE)
    {
        data = new int64_t;
        
        delete data;
    }
    if(STATIC_CONST_TRUE)
    {
        
        delete data;
"
8662,0,CWE78_OS_Command_Injection__char_file_system_81a.cpp,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
        
        size_t dataLen = strlen(data);
        FILE * pFile;
        
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
    const CWE78_OS_Command_Injection__char_file_system_81_base& baseObject = CWE78_OS_Command_Injection__char_file_system_81_bad();
"
9754,0,CWE457_Use_of_Uninitialized_Variable__double_array_malloc_no_init_03.c,"    double * data;
    data = (double *)malloc(10*sizeof(double));
    if (data == NULL) {exit(-1);}
    if(5==5)
    {
        
        ; 
    }
    if(5==5)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printDoubleLine(data[i]);
            }
        }
"
462,0,CWE190_Integer_Overflow__short_max_multiply_44.c,"    short data;
    
    void (*funcPtr) (short) = badSink;
    data = 0;
    
    data = SHRT_MAX;
    
"
7671,0,CWE476_NULL_Pointer_Dereference__struct_07.c,"    twoIntsStruct * data;
    if(staticFive==5)
    {
        
        data = NULL;
    }
    if(staticFive==5)
    {
        
        printIntLine(data->intOne);
"
16417,0,CWE190_Integer_Overflow__char_fscanf_square_67a.c,"    char data;
    CWE190_Integer_Overflow__char_fscanf_square_67_structType myStruct;
    data = ' ';
    
    fscanf (stdin, ""%c"", &data);
    myStruct.structFirst = data;
"
2449,0,CWE190_Integer_Overflow__int_rand_multiply_08.c,"    int data;
    
    data = 0;
    if(staticReturnsTrue())
    {
        
        data = RAND32();
    }
    if(staticReturnsTrue())
    {
        if(data > 0) 
        {
            
            int result = data * 2;
            printIntLine(result);
        }
"
7701,0,CWE134_Uncontrolled_Format_String__char_file_snprintf_02.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(1)
    {
        {
            
            size_t dataLen = strlen(data);
            FILE * pFile;
            
            if (100-dataLen > 1)
            {
                pFile = fopen(FILENAME, ""r"");
                if (pFile != NULL)
                {
                    
                    if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                    {
                        printLine(""fgets() failed"");
                        
                        data[dataLen] = '\0';
                    }
                    fclose(pFile);
                }
            }
        }
    }
    if(1)
    {
        {
            char dest[100] = """";
            
            SNPRINTF(dest, 100-1, data);
            printLine(dest);
        }
"
7493,0,CWE401_Memory_Leak__new_int_14.cpp,"    int * data;
    data = NULL;
    if(globalFive==5)
    {
        
        data = new int;
        
        *data = 5;
        printIntLine(*data);
    }
    if(globalFive==5)
    {
        
        ; 
"
13038,0,CWE369_Divide_by_Zero__int_fscanf_divide_43.cpp,"    int data;
    
    data = -1;
    badSource(data);
    
"
2634,1,CWE476_NULL_Pointer_Dereference__binary_if_12.c,"    if(globalReturnsTrueOrFalse())
    {
        {
            twoIntsStruct *twoIntsStructPointer = NULL;
            /* FIX: Use && in the if statement so that if the left side of the expression fails then
             * the right side will not be evaluated */
            if ((twoIntsStructPointer != NULL) && (twoIntsStructPointer->intOne == 5))
            {
                printLine(""intOne == 5"");
            }
        }
    }
    else
    {
        {
            twoIntsStruct *twoIntsStructPointer = NULL;
            /* FIX: Use && in the if statement so that if the left side of the expression fails then
             * the right side will not be evaluated */
            if ((twoIntsStructPointer != NULL) && (twoIntsStructPointer->intOne == 5))
            {
                printLine(""intOne == 5"");
            }
        }
"
12988,0,CWE415_Double_Free__new_delete_int_42.cpp,"    int * data;
    
    data = NULL;
    data = badSource(data);
    
"
15548,0,CWE190_Integer_Overflow__short_rand_multiply_08.c,"    short data;
    data = 0;
    if(staticReturnsTrue())
    {
        
        data = (short)RAND32();
    }
    if(staticReturnsTrue())
    {
        if(data > 0) 
        {
            
            short result = data * 2;
            printIntLine(result);
        }
"
8563,0,CWE401_Memory_Leak__struct_twoIntsStruct_calloc_43.cpp,"    struct _twoIntsStruct * data;
    data = NULL;
    badSource(data);
    
"
10180,0,CWE134_Uncontrolled_Format_String__char_environment_vprintf_18.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    goto source;
source:
    {
        
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        
        if (environment != NULL)
        {
            
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    goto sink;
sink:
"
19002,0,CWE415_Double_Free__new_delete_int64_t_52a.cpp,"    int64_t * data;
    
    data = NULL;
    data = new int64_t;
    
    delete data;
"
7982,0,CWE78_OS_Command_Injection__char_environment_system_52a.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
        
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        
        if (environment != NULL)
        {
            
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
"
18711,0,CWE190_Integer_Overflow__int_connect_socket_multiply_05.c,"    int data;
    
    data = 0;
    if(staticTrue)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(staticTrue)
    {
        if(data > 0) 
        {
            
            int result = data * 2;
            printIntLine(result);
        }
"
16233,0,CWE190_Integer_Overflow__short_rand_multiply_32.c,"    short data;
    short *dataPtr1 = &data;
    short *dataPtr2 = &data;
    data = 0;
    {
        short data = *dataPtr1;
        
        data = (short)RAND32();
        *dataPtr1 = data;
    }
    {
        short data = *dataPtr2;
        if(data > 0) 
        {
            
            short result = data * 2;
            printIntLine(result);
        }
"
16332,1,CWE758_Undefined_Behavior__int64_t_new_use_02.cpp,"    if(0)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            int64_t data;
            data = 5LL;
            int64_t * pointer = new int64_t;
            *pointer = data; 
            {
                int64_t data = *pointer;
                printLongLongLine(data);
            }
            delete pointer;
        }
"
6977,0,CWE197_Numeric_Truncation_Error__short_fgets_05.c,"    short data;
    
    data = -1;
    if(staticTrue)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                
                data = (short)atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
4936,0,CWE562_Return_of_Stack_Variable_Address__return_local_class_member_01.cpp,
4570,0,CWE469_Use_of_Pointer_Subtraction_to_Determine_Size__char_12.c,"    if(globalReturnsTrueOrFalse())
    {
        {
            char string1[] = SOURCE_STRING;
            char string2[] = SOURCE_STRING;
            char * slashInString1;
            size_t indexOfSlashInString1;
            slashInString1 = strchr(string1, '/');
            if (slashInString1 == NULL)
            {
                exit(1);
            }
            
            indexOfSlashInString1 = (size_t)(slashInString1 - string2);
            
            printUnsignedLine(indexOfSlashInString1);
        }
    }
    else
    {
        {
            char string1[] = SOURCE_STRING;
            char * slashInString1;
            size_t indexOfSlashInString1;
            slashInString1 = strchr(string1, '/');
            if (slashInString1 == NULL)
            {
                exit(1);
            }
            
            indexOfSlashInString1 = (size_t)(slashInString1 - string1);
            
            printUnsignedLine(indexOfSlashInString1);
        }
"
4109,0,CWE590_Free_Memory_Not_on_Heap__free_int64_t_alloca_31.c,"    int64_t * data;
    data = NULL; 
    {
        
        int64_t * dataBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5LL;
            }
        }
        data = dataBuffer;
    }
    {
        int64_t * dataCopy = data;
        int64_t * data = dataCopy;
        printLongLongLine(data[0]);
        
        free(data);
"
13913,1,CWE252_Unchecked_Return_Value__char_fgets_17.c,"    int k;
    for(k = 0; k < 1; k++)
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            printLine(""Please enter a string: "");
            
            if (fgets(data, 100, stdin) == NULL)
            {
                printLine(""fgets failed!"");
                exit(1);
            }
            printLine(data);
        }
"
9037,0,CWE190_Integer_Overflow__unsigned_int_max_add_83a.cpp,"    unsigned int data;
    data = 0;
"
17813,0,CWE563_Unused_Variable__unused_init_variable_char_09.c,"    char data;
    
    data = 'C';
    if(GLOBAL_CONST_TRUE)
    {
        
        
        ; 
"
2700,0,CWE563_Unused_Variable__unused_init_variable_int64_t_22a.c,"    int64_t data;
    
    data = 5LL;
    CWE563_Unused_Variable__unused_init_variable_int64_t_22_badGlobal = 1; 
"
7803,0,CWE190_Integer_Overflow__int_connect_socket_add_34.c,"    int data;
    CWE190_Integer_Overflow__int_connect_socket_add_34_unionType myUnion;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    myUnion.unionFirst = data;
    {
        int data = myUnion.unionSecond;
        {
            
            int result = data + 1;
            printIntLine(result);
        }
"
5890,1,CWE252_Unchecked_Return_Value__char_puts_06.c,"    if(STATIC_CONST_FIVE!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        
        if (PUTS(""string"") == EOF)
        {
            printLine(""puts failed!"");
        }
"
9632,0,CWE190_Integer_Overflow__char_fscanf_preinc_18.c,"    char data;
    data = ' ';
    goto source;
source:
    
    fscanf (stdin, ""%c"", &data);
    goto sink;
sink:
    {
        
        ++data;
        char result = data;
        printHexCharLine(result);
"
10109,0,CWE401_Memory_Leak__malloc_realloc_char_16.c,"    while(1)
    {
        {
            char * data = (char *)malloc(100*sizeof(char));
            if (data == NULL) {exit(-1);}
            
            strcpy(data, ""A String"");
            printLine(data);
            
            data = (char *)realloc(data, (130000)*sizeof(char));
            if (data != NULL)
            {
                
                strcpy(data, ""New String"");
                printLine(data);
                free(data);
            }
        }
        break;
"
17195,0,CWE369_Divide_by_Zero__int_rand_modulo_65a.c,"    int data;
    
    void (*funcPtr) (int) = CWE369_Divide_by_Zero__int_rand_modulo_65b_badSink;
    
    data = -1;
    
    data = RAND32();
    
"
19392,1,CWE758_Undefined_Behavior__char_pointer_malloc_use_17.c,"    int k;
    for(k = 0; k < 1; k++)
    {
        {
            char * data;
            char * * pointer = (char * *)malloc(sizeof(char *));
            if (pointer == NULL) {exit(-1);}
            data = ""string"";
            *pointer = data; 
            {
                char * data = *pointer;
                printLine(data);
            }
            free(pointer);
        }
"
16679,0,CWE758_Undefined_Behavior__char_alloca_use_18.c,"    goto sink;
sink:
    {
        char * pointer = (char *)ALLOCA(sizeof(char));
        char data = *pointer; 
        printHexCharLine(data);
"
15792,0,CWE190_Integer_Overflow__char_max_add_42.c,"    char data;
    data = ' ';
    data = badSource(data);
    {
        
        char result = data + 1;
        printHexCharLine(result);
"
14746,0,CWE190_Integer_Overflow__int_fscanf_multiply_45.c,"    int data;
    
    data = 0;
    
    fscanf(stdin, ""%d"", &data);
    CWE190_Integer_Overflow__int_fscanf_multiply_45_badData = data;
"
15827,0,CWE190_Integer_Overflow__short_fscanf_preinc_42.c,"    short data;
    data = 0;
    data = badSource(data);
    {
        
        ++data;
        short result = data;
        printIntLine(result);
"
12850,1,CWE252_Unchecked_Return_Value__char_fscanf_10.c,"    if(globalFalse)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            
            if (fscanf(stdin, ""%99s\0"", data) == EOF)
            {
                printLine(""fscanf failed!"");
            }
        }
"
1130,0,CWE134_Uncontrolled_Format_String__char_console_vfprintf_84a.cpp,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    CWE134_Uncontrolled_Format_String__char_console_vfprintf_84_bad * badObject = new CWE134_Uncontrolled_Format_String__char_console_vfprintf_84_bad(data);
"
8191,0,CWE590_Free_Memory_Not_on_Heap__free_char_static_32.c,"    char * data;
    char * *dataPtr1 = &data;
    char * *dataPtr2 = &data;
    data = NULL; 
    {
        char * data = *dataPtr1;
        {
            
            static char dataBuffer[100];
            memset(dataBuffer, 'A', 100-1); 
            dataBuffer[100-1] = '\0'; 
            data = dataBuffer;
        }
        *dataPtr1 = data;
    }
    {
        char * data = *dataPtr2;
        printLine(data);
        
        free(data);
"
16386,0,CWE369_Divide_by_Zero__int_fgets_modulo_53a.c,"    int data;
    
    data = -1;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
"
12184,0,CWE457_Use_of_Uninitialized_Variable__double_array_alloca_partial_init_62a.cpp,"    double * data;
    data = (double *)ALLOCA(10*sizeof(double));
    badSource(data);
    
    {
        int i;
        for(i=0; i<10; i++)
        {
            printDoubleLine(data[i]);
        }
"
5600,1,CWE758_Undefined_Behavior__int64_t_malloc_use_10.c,"    if(globalTrue)
    {
        {
            int64_t data;
            int64_t * pointer = (int64_t *)malloc(sizeof(int64_t));
            if (pointer == NULL) {exit(-1);}
            data = 5LL;
            *pointer = data; 
            {
                int64_t data = *pointer;
                printLongLongLine(data);
            }
            free(pointer);
        }
"
13352,0,CWE676_Use_of_Potentially_Dangerous_Function__basic_01.cpp,"    {
        char charBuffer[CHAR_BUFFER_SIZE];
        
        
        cin >> charBuffer;
        charBuffer[CHAR_BUFFER_SIZE-1] = '\0';
        printLine(charBuffer);
"
811,0,CWE415_Double_Free__new_delete_array_class_82a.cpp,"    TwoIntsClass * data;
    
    data = NULL;
    data = new TwoIntsClass[100];
    
    delete [] data;
    CWE415_Double_Free__new_delete_array_class_82_base* baseObject = new CWE415_Double_Free__new_delete_array_class_82_bad;
    baseObject->action(data);
"
1879,0,CWE134_Uncontrolled_Format_String__char_console_fprintf_16.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    while(1)
    {
        {
            
            size_t dataLen = strlen(data);
            
            if (100-dataLen > 1)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
                {
                    /* The next few lines remove the carriage return from the string that is
                     * inserted by fgets() */
                    dataLen = strlen(data);
                    if (dataLen > 0 && data[dataLen-1] == '\n')
                    {
                        data[dataLen-1] = '\0';
                    }
                }
                else
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
            }
        }
        break;
    }
    while(1)
    {
        
        fprintf(stdout, data);
        break;
"
12469,0,CWE563_Unused_Variable__unused_value_struct_33.cpp,"    twoIntsStruct data;
    twoIntsStruct &dataRef = data;
    
    data.intOne = 0;
    data.intTwo = 0;
    {
        twoIntsStruct data = dataRef;
        
        data.intOne = 1;
        data.intTwo = 1;
        printStructLine(&data);
"
2271,0,CWE252_Unchecked_Return_Value__char_fscanf_17.c,"    int j;
    for(j = 0; j < 1; j++)
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            
            fscanf(stdin, ""%99s\0"", data);
        }
"
2690,0,CWE690_NULL_Deref_From_Return__int64_t_calloc_66a.c,"    int64_t * data;
    int64_t * dataArray[5];
    data = NULL; 
    
    data = (int64_t *)calloc(1, sizeof(int64_t));
    
    dataArray[2] = data;
"
2442,0,CWE590_Free_Memory_Not_on_Heap__delete_array_int_declare_74a.cpp,"    int * data;
    map<int, int *> dataMap;
    data = NULL; 
    {
        
        int dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5;
            }
        }
        data = dataBuffer;
    }
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
2637,0,CWE369_Divide_by_Zero__float_zero_13.c,"    float data;
    
    data = 0.0F;
    if(GLOBAL_CONST_FIVE==5)
    {
        
        data = 0.0F;
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            
            int result = (int)(100.0 / data);
            printIntLine(result);
        }
"
8637,1,CWE401_Memory_Leak__malloc_realloc_int64_t_08.c,"    if(staticReturnsFalse())
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            int64_t * data = (int64_t *)malloc(100*sizeof(int64_t));
            if (data == NULL) {exit(-1);}
            int64_t * tmpData;
            
            data[0] = 5LL;
            printLongLongLine(data[0]);
            tmpData = (int64_t *)realloc(data, (130000)*sizeof(int64_t));
            /* FIX: Ensure realloc() was successful before assigning data to the memory block
            * allocated with realloc() */
            if (tmpData != NULL)
            {
                data = tmpData;
                
                data[0] = 10LL;
                printLongLongLine(data[0]);
            }
            free(data);
        }
"
2174,0,CWE401_Memory_Leak__struct_twoIntsStruct_calloc_01.c,"    struct _twoIntsStruct * data;
    data = NULL;
    
    data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));
    if (data == NULL) {exit(-1);}
    
    data[0].intOne = 0;
    data[0].intTwo = 0;
    printStructLine((twoIntsStruct *)&data[0]);
    
"
2399,0,CWE190_Integer_Overflow__int_fscanf_postinc_32.c,"    int data;
    int *dataPtr1 = &data;
    int *dataPtr2 = &data;
    
    data = 0;
    {
        int data = *dataPtr1;
        
        fscanf(stdin, ""%d"", &data);
        *dataPtr1 = data;
    }
    {
        int data = *dataPtr2;
        {
            
            data++;
            int result = data;
            printIntLine(result);
        }
"
5661,0,CWE789_Uncontrolled_Mem_Alloc__new_char_connect_socket_62a.cpp,"    size_t data;
    
    data = 0;
    badSource(data);
    {
        char * myString;
        /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
         * for the strcpy() function to not cause a buffer overflow */
        
        if (data > strlen(HELLO_STRING))
        {
            myString = new char[data];
            
            strcpy(myString, HELLO_STRING);
            printLine(myString);
            delete [] myString;
        }
        else
        {
            printLine(""Input is less than the length of the source string"");
        }
"
19265,0,CWE197_Numeric_Truncation_Error__int_fgets_to_short_62a.cpp,"    int data;
    
    data = -1;
    badSource(data);
    {
        
        short shortData = (short)data;
        printShortLine(shortData);
"
13773,0,CWE401_Memory_Leak__new_array_TwoIntsClass_02.cpp,"    TwoIntsClass * data;
    data = NULL;
    if(1)
    {
        
        data = new TwoIntsClass[100];
        
        data[0].intOne = 0;
        data[0].intTwo = 0;
        printIntLine(data[0].intOne);
        printIntLine(data[0].intTwo);
    }
    if(1)
    {
        
        ; 
"
3088,0,CWE78_OS_Command_Injection__char_connect_socket_execlp_84_bad.cpp,"Label Definition File: CWE78_OS_Command_Injection.strings.label.xml
Template File: sources-sink-84_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 78 OS Command Injection
 * BadSource: connect_socket Read data using a connect socket (client side)
 * GoodSource: Fixed string
 * Sinks: execlp
 *    BadSink : execute command with execlp
 * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE78_OS_Command_Injection__char_connect_socket_execlp_84.h""
"
11131,0,CWE78_OS_Command_Injection__char_file_execl_11.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(globalReturnsTrue())
    {
        {
            
            size_t dataLen = strlen(data);
            FILE * pFile;
            
            if (100-dataLen > 1)
            {
                pFile = fopen(FILENAME, ""r"");
                if (pFile != NULL)
                {
                    
                    if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                    {
                        printLine(""fgets() failed"");
                        
                        data[dataLen] = '\0';
                    }
                    fclose(pFile);
                }
            }
        }
    }
    
    
"
16629,0,CWE457_Use_of_Uninitialized_Variable__struct_array_declare_no_init_62a.cpp,"    twoIntsStruct * data;
    twoIntsStruct dataUninitArray[10];
    data = dataUninitArray;
    badSource(data);
    
    {
        int i;
        for(i=0; i<10; i++)
        {
            printIntLine(data[i].intOne);
            printIntLine(data[i].intTwo);
        }
"
16789,0,CWE590_Free_Memory_Not_on_Heap__delete_array_long_alloca_32.cpp,"    long * data;
    long * *dataPtr1 = &data;
    long * *dataPtr2 = &data;
    data = NULL; 
    {
        long * data = *dataPtr1;
        {
            
            long * dataBuffer = (long *)ALLOCA(100*sizeof(long));
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5L;
                }
            }
            data = dataBuffer;
        }
        *dataPtr1 = data;
    }
    {
        long * data = *dataPtr2;
        printLongLine(data[0]);
        
        delete [] data;
"
18244,0,CWE590_Free_Memory_Not_on_Heap__free_int_declare_10.c,"    int * data;
    data = NULL; 
    if(globalTrue)
    {
        {
            
            int dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5;
                }
            }
            data = dataBuffer;
        }
    }
    printIntLine(data[0]);
    
"
17570,0,CWE369_Divide_by_Zero__int_fgets_modulo_82a.cpp,"    int data;
    
    data = -1;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    CWE369_Divide_by_Zero__int_fgets_modulo_82_base* baseObject = new CWE369_Divide_by_Zero__int_fgets_modulo_82_bad;
    baseObject->action(data);
"
1827,0,CWE758_Undefined_Behavior__struct_pointer_new_use_04.cpp,"    if(STATIC_CONST_TRUE)
    {
        {
            twoIntsStruct * * pointer = new twoIntsStruct *;
            twoIntsStruct * data = *pointer; 
            delete pointer;
            printIntLine(data->intOne);
            printIntLine(data->intTwo);
        }
"
636,1,CWE401_Memory_Leak__malloc_realloc_int64_t_11.c,"    if(globalReturnsTrue())
    {
        {
            int64_t * data = (int64_t *)malloc(100*sizeof(int64_t));
            if (data == NULL) {exit(-1);}
            int64_t * tmpData;
            
            data[0] = 5LL;
            printLongLongLine(data[0]);
            tmpData = (int64_t *)realloc(data, (130000)*sizeof(int64_t));
            /* FIX: Ensure realloc() was successful before assigning data to the memory block
            * allocated with realloc() */
            if (tmpData != NULL)
            {
                data = tmpData;
                
                data[0] = 10LL;
                printLongLongLine(data[0]);
            }
            free(data);
        }
"
4122,0,CWE190_Integer_Overflow__int_fscanf_add_67a.c,"    int data;
    CWE190_Integer_Overflow__int_fscanf_add_67_structType myStruct;
    
    data = 0;
    
    fscanf(stdin, ""%d"", &data);
    myStruct.structFirst = data;
"
2758,0,CWE401_Memory_Leak__twoIntsStruct_calloc_09.c,"    twoIntsStruct * data;
    data = NULL;
    if(GLOBAL_CONST_TRUE)
    {
        
        data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));
        if (data == NULL) {exit(-1);}
        
        data[0].intOne = 0;
        data[0].intTwo = 0;
        printStructLine(&data[0]);
    }
    if(GLOBAL_CONST_TRUE)
    {
        
        ; 
"
15384,1,CWE758_Undefined_Behavior__double_pointer_malloc_use_11.c,"    if(globalReturnsFalse())
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            double * data;
            double * * pointer = (double * *)malloc(sizeof(double *));
            if (pointer == NULL) {exit(-1);}
            
            data = (double *)malloc(sizeof(double));
            if (data == NULL) {exit(-1);}
            *data = 5.0;
            *pointer = data; 
            {
                double * data = *pointer;
                printDoubleLine(*data);
            }
            free(pointer);
        }
"
6215,1,CWE476_NULL_Pointer_Dereference__binary_if_14.c,"    if(globalFive!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            twoIntsStruct *twoIntsStructPointer = NULL;
            /* FIX: Use && in the if statement so that if the left side of the expression fails then
             * the right side will not be evaluated */
            if ((twoIntsStructPointer != NULL) && (twoIntsStructPointer->intOne == 5))
            {
                printLine(""intOne == 5"");
            }
        }
"
3527,0,CWE369_Divide_by_Zero__int_rand_divide_04.c,"    int data;
    
    data = -1;
    if(STATIC_CONST_TRUE)
    {
        
        data = RAND32();
    }
    if(STATIC_CONST_TRUE)
    {
        
        printIntLine(100 / data);
"
16815,0,CWE563_Unused_Variable__unused_uninit_variable_int_82a.cpp,"    int data;
    
    ; 
    CWE563_Unused_Variable__unused_uninit_variable_int_82_base* baseObject = new CWE563_Unused_Variable__unused_uninit_variable_int_82_bad;
    baseObject->action(data);
"
5030,0,CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_72a.cpp,"    char * data;
    vector<char *> dataVector;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
10489,0,CWE415_Double_Free__malloc_free_struct_12.c,"    twoIntsStruct * data;
    
    data = NULL;
    if(globalReturnsTrueOrFalse())
    {
        data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
        if (data == NULL) {exit(-1);}
        
        free(data);
    }
    else
    {
        data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
        if (data == NULL) {exit(-1);}
        
    }
    if(globalReturnsTrueOrFalse())
    {
        
        free(data);
    }
    else
    {
        
        
        ; 
"
2753,0,CWE690_NULL_Deref_From_Return__int_calloc_15.c,"    int * data;
    data = NULL; 
    
    data = (int *)calloc(1, sizeof(int));
    switch(6)
    {
    case 6:
        
        data[0] = 5;
        printIntLine(data[0]);
        free(data);
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
7429,0,CWE401_Memory_Leak__new_array_TwoIntsClass_81a.cpp,"    TwoIntsClass * data;
    data = NULL;
    
    data = new TwoIntsClass[100];
    
    data[0].intOne = 0;
    data[0].intTwo = 0;
    printIntLine(data[0].intOne);
    printIntLine(data[0].intTwo);
    const CWE401_Memory_Leak__new_array_TwoIntsClass_81_base& o = CWE401_Memory_Leak__new_array_TwoIntsClass_81_bad();
"
15675,0,CWE590_Free_Memory_Not_on_Heap__free_struct_alloca_81_bad.cpp,"Label Definition File: CWE590_Free_Memory_Not_on_Heap__free.label.xml
Template File: sources-sink-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 590 Free Memory Not on Heap
 * BadSource: alloca Data buffer is allocated on the stack with alloca()
 * GoodSource: Allocate memory on the heap
 * Sinks:
 *    BadSink : Print then free data
 * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE590_Free_Memory_Not_on_Heap__free_struct_alloca_81.h""

namespace CWE590_Free_Memory_Not_on_Heap__free_struct_alloca_81
{

void CWE590_Free_Memory_Not_on_Heap__free_struct_alloca_81_bad::action(twoIntsStruct * data) const
{
    printStructLine(&data[0]);
    
    free(data);
}

}
"
10709,0,CWE190_Integer_Overflow__char_max_multiply_22a.c,"    char data;
    data = ' ';
    
    data = CHAR_MAX;
    CWE190_Integer_Overflow__char_max_multiply_22_badGlobal = 1; 
"
2083,0,CWE369_Divide_by_Zero__float_zero_72a.cpp,"    float data;
    vector<float> dataVector;
    
    data = 0.0F;
    
    data = 0.0F;
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
13390,0,CWE190_Integer_Overflow__char_max_add_12.c,"    char data;
    data = ' ';
    if(globalReturnsTrueOrFalse())
    {
        
        data = CHAR_MAX;
    }
    else
    {
        
        data = 2;
    }
    if(globalReturnsTrueOrFalse())
    {
        {
            
            char result = data + 1;
            printHexCharLine(result);
        }
    }
    else
    {
        
        if (data < CHAR_MAX)
        {
            char result = data + 1;
            printHexCharLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
"
17000,1,CWE758_Undefined_Behavior__struct_pointer_new_use_03.cpp,"    if(5!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            twoIntsStruct * data;
            
            data = new twoIntsStruct;
            data->intOne = 5;
            data->intTwo = 6;
            twoIntsStruct * * pointer = new twoIntsStruct *;
            *pointer = data; 
            {
                twoIntsStruct * data = *pointer;
                printIntLine(data->intOne);
                printIntLine(data->intTwo);
            }
            delete pointer;
        }
"
5286,0,CWE134_Uncontrolled_Format_String__char_environment_printf_16.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    while(1)
    {
        {
            
            size_t dataLen = strlen(data);
            char * environment = GETENV(ENV_VARIABLE);
            
            if (environment != NULL)
            {
                
                strncat(data+dataLen, environment, 100-dataLen-1);
            }
        }
        break;
    }
    while(1)
    {
        
        printf(data);
        break;
"
8628,0,CWE690_NULL_Deref_From_Return__int64_t_malloc_52a.c,"    int64_t * data;
    data = NULL; 
    
    data = (int64_t *)malloc(1*sizeof(int64_t));
"
15628,0,CWE369_Divide_by_Zero__int_rand_divide_43.cpp,"    int data;
    
    data = -1;
    badSource(data);
    
"
16404,0,CWE401_Memory_Leak__new_twoIntsStruct_73a.cpp,"    twoIntsStruct * data;
    list<twoIntsStruct *> dataList;
    data = NULL;
    
    data = new twoIntsStruct;
    
    data->intOne = 0;
    data->intTwo = 0;
    printStructLine(data);
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
15468,1,CWE758_Undefined_Behavior__struct_pointer_malloc_use_08.c,"    if(staticReturnsFalse())
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            twoIntsStruct * data;
            twoIntsStruct * * pointer = (twoIntsStruct * *)malloc(sizeof(twoIntsStruct *));
            if (pointer == NULL) {exit(-1);}
            
            data = (twoIntsStruct *)malloc(sizeof(twoIntsStruct));
            if (data == NULL) {exit(-1);}
            data->intOne = 5;
            data->intTwo = 6;
            *pointer = data; 
            {
                twoIntsStruct * data = *pointer;
                printIntLine(data->intOne);
                printIntLine(data->intTwo);
            }
            free(pointer);
        }
"
4090,0,CWE134_Uncontrolled_Format_String__char_console_printf_68a.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        
        if (100-dataLen > 1)
        {
            
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgets() */
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
                    data[dataLen-1] = '\0';
                }
            }
            else
            {
                printLine(""fgets() failed"");
                
                data[dataLen] = '\0';
            }
        }
    }
    CWE134_Uncontrolled_Format_String__char_console_printf_68_badData = data;
"
18773,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_41.c,"    size_t data;
    
    data = 0;
    
    fscanf(stdin, ""%zu"", &data);
"
2879,0,CWE563_Unused_Variable__unused_value_int_43.cpp,"    int data;
    badSource(data);
    
    data = 10;
"
15958,0,CWE78_OS_Command_Injection__char_environment_execl_03.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(5==5)
    {
        {
            
            size_t dataLen = strlen(data);
            char * environment = GETENV(ENV_VARIABLE);
            
            if (environment != NULL)
            {
                
                strncat(data+dataLen, environment, 100-dataLen-1);
            }
        }
    }
    
    
"
9045,0,CWE190_Integer_Overflow__int_connect_socket_postinc_10.c,"    int data;
    
    data = 0;
    if(globalTrue)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(globalTrue)
    {
        {
            
            data++;
            int result = data;
            printIntLine(result);
        }
"
4103,0,CWE401_Memory_Leak__new_array_TwoIntsClass_03.cpp,"    TwoIntsClass * data;
    data = NULL;
    if(5==5)
    {
        
        data = new TwoIntsClass[100];
        
        data[0].intOne = 0;
        data[0].intTwo = 0;
        printIntLine(data[0].intOne);
        printIntLine(data[0].intTwo);
    }
    if(5==5)
    {
        
        ; 
"
19447,0,CWE590_Free_Memory_Not_on_Heap__delete_long_placement_new_34.cpp,"    long * data;
    unionType myUnion;
    data = NULL; 
    {
        
        char buffer[sizeof(long)];
        long * dataBuffer = new(buffer) long;
        *dataBuffer = 5L;
        data = dataBuffer;
    }
    myUnion.unionFirst = data;
    {
        long * data = myUnion.unionSecond;
        printLongLine(*data);
        
        delete data;
"
11342,0,CWE190_Integer_Overflow__short_fscanf_square_68a.c,"    short data;
    data = 0;
    
    fscanf (stdin, ""%hd"", &data);
    CWE190_Integer_Overflow__short_fscanf_square_68_badData = data;
"
362,0,CWE415_Double_Free__new_delete_array_struct_09.cpp,"    twoIntsStruct * data;
    
    data = NULL;
    if(GLOBAL_CONST_TRUE)
    {
        data = new twoIntsStruct[100];
        
        delete [] data;
    }
    if(GLOBAL_CONST_TRUE)
    {
        
        delete [] data;
"
2614,0,CWE690_NULL_Deref_From_Return__struct_malloc_08.c,"    twoIntsStruct * data;
    data = NULL; 
    
    data = (twoIntsStruct *)malloc(1*sizeof(twoIntsStruct));
    if(staticReturnsTrue())
    {
        
        data[0].intOne = 1;
        data[0].intTwo = 1;
        printStructLine(&data[0]);
        free(data);
"
11338,0,CWE197_Numeric_Truncation_Error__int_connect_socket_to_short_67a.c,"    int data;
    CWE197_Numeric_Truncation_Error__int_connect_socket_to_short_67_structType myStruct;
    
    data = -1;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    myStruct.structFirst = data;
"
10004,0,CWE590_Free_Memory_Not_on_Heap__delete_int_static_31.cpp,"    int * data;
    data = NULL; 
    {
        
        static int dataBuffer;
        dataBuffer = 5;
        data = &dataBuffer;
    }
    {
        int * dataCopy = data;
        int * data = dataCopy;
        printIntLine(*data);
        
        delete data;
"
9757,0,CWE401_Memory_Leak__new_char_63a.cpp,"    char * data;
    data = NULL;
    
    data = new char;
    
    *data = 'A';
    printHexCharLine(*data);
"
15516,0,CWE190_Integer_Overflow__int_fgets_multiply_65a.c,"    int data;
    
    void (*funcPtr) (int) = CWE190_Integer_Overflow__int_fgets_multiply_65b_badSink;
    
    data = 0;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    
"
4141,0,CWE401_Memory_Leak__new_char_11.cpp,"    char * data;
    data = NULL;
    if(globalReturnsTrue())
    {
        
        data = new char;
        
        *data = 'A';
        printHexCharLine(*data);
    }
    if(globalReturnsTrue())
    {
        
        ; 
"
186,0,CWE190_Integer_Overflow__int_fscanf_multiply_06.c,"    int data;
    
    data = 0;
    if(STATIC_CONST_FIVE==5)
    {
        
        fscanf(stdin, ""%d"", &data);
    }
    if(STATIC_CONST_FIVE==5)
    {
        if(data > 0) 
        {
            
            int result = data * 2;
            printIntLine(result);
        }
"
19350,0,CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_13.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(GLOBAL_CONST_FIVE==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET connectSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                
                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                data[dataLen + recvResult / sizeof(char)] = '\0';
                
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        
        fprintf(stdout, data);
"
3824,0,CWE134_Uncontrolled_Format_String__char_file_vfprintf_65a.c,"    char * data;
    
    void (*funcPtr) (char *, ...) = CWE134_Uncontrolled_Format_String__char_file_vfprintf_65b_badVaSink;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        FILE * pFile;
        
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
    
"
2061,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_06.c,"    size_t data;
    
    data = 0;
    if(STATIC_CONST_FIVE==5)
    {
        
        fscanf(stdin, ""%zu"", &data);
    }
    if(STATIC_CONST_FIVE==5)
    {
        {
            char * myString;
            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
             * for the strcpy() function to not cause a buffer overflow */
            
            if (data > strlen(HELLO_STRING))
            {
                myString = (char *)malloc(data*sizeof(char));
                if (myString == NULL) {exit(-1);}
                
                strcpy(myString, HELLO_STRING);
                printLine(myString);
                free(myString);
            }
            else
            {
                printLine(""Input is less than the length of the source string"");
            }
        }
"
18470,0,CWE590_Free_Memory_Not_on_Heap__delete_int_declare_33.cpp,"    int * data;
    int * &dataRef = data;
    data = NULL; 
    {
        
        int dataBuffer;
        dataBuffer = 5;
        data = &dataBuffer;
    }
    {
        int * data = dataRef;
        printIntLine(*data);
        
        delete data;
"
10419,0,CWE190_Integer_Overflow__int64_t_fscanf_square_61a.c,"    int64_t data;
    data = 0LL;
    data = CWE190_Integer_Overflow__int64_t_fscanf_square_61b_badSource(data);
    {
        
        int64_t result = data * data;
        printLongLongLine(result);
"
2448,0,CWE190_Integer_Overflow__unsigned_int_max_multiply_07.c,"    unsigned int data;
    data = 0;
    if(staticFive==5)
    {
        
        data = UINT_MAX;
    }
    if(staticFive==5)
    {
        if(data > 0) 
        {
            
            unsigned int result = data * 2;
            printUnsignedLine(result);
        }
"
5193,0,CWE590_Free_Memory_Not_on_Heap__delete_array_int_static_07.cpp,"    int * data;
    data = NULL; 
    if(staticFive==5)
    {
        {
            
            static int dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5;
                }
            }
            data = dataBuffer;
        }
    }
    printIntLine(data[0]);
    
"
8358,0,CWE401_Memory_Leak__new_char_14.cpp,"    char * data;
    data = NULL;
    if(globalFive==5)
    {
        
        data = new char;
        
        *data = 'A';
        printHexCharLine(*data);
    }
    if(globalFive==5)
    {
        
        ; 
"
3753,0,CWE758_Undefined_Behavior__int64_t_alloca_use_01.c,"    {
        int64_t * pointer = (int64_t *)ALLOCA(sizeof(int64_t));
        int64_t data = *pointer; 
        printLongLongLine(data);
"
1277,0,CWE590_Free_Memory_Not_on_Heap__free_int64_t_alloca_09.c,"    int64_t * data;
    data = NULL; 
    if(GLOBAL_CONST_TRUE)
    {
        {
            
            int64_t * dataBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5LL;
                }
            }
            data = dataBuffer;
        }
    }
    printLongLongLine(data[0]);
    
"
8583,0,CWE190_Integer_Overflow__short_max_preinc_05.c,"    short data;
    data = 0;
    if(staticTrue)
    {
        
        data = SHRT_MAX;
    }
    if(staticTrue)
    {
        {
            
            ++data;
            short result = data;
            printIntLine(result);
        }
"
6560,0,CWE457_Use_of_Uninitialized_Variable__twointsclass_array_new_partial_init_01.cpp,"    TwoIntsClass * data;
    data = new TwoIntsClass[10];
    
    for(int i=0; i<(10/2); i++)
    {
        data[i].intOne = i;
        data[i].intTwo = i;
    }
    
    for(int i=0; i<10; i++)
    {
        printIntLine(data[i].intOne);
        printIntLine(data[i].intTwo);
"
15247,0,CWE457_Use_of_Uninitialized_Variable__double_array_malloc_no_init_16.c,"    double * data;
    data = (double *)malloc(10*sizeof(double));
    if (data == NULL) {exit(-1);}
    while(1)
    {
        
        ; 
        break;
    }
    while(1)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printDoubleLine(data[i]);
            }
        }
        break;
"
18467,0,CWE590_Free_Memory_Not_on_Heap__delete_array_int64_t_alloca_74a.cpp,"    int64_t * data;
    map<int, int64_t *> dataMap;
    data = NULL; 
    {
        
        int64_t * dataBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5LL;
            }
        }
        data = dataBuffer;
    }
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
3017,0,CWE190_Integer_Overflow__int_max_multiply_82_bad.cpp,"Label Definition File: CWE190_Integer_Overflow__int.label.xml
Template File: sources-sinks-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 190 Integer Overflow
 * BadSource: max Set data to the max value for int
 * GoodSource: Set data to a small, non-zero number (two)
 * Sinks: multiply
 *    GoodSink: Ensure there will not be an overflow before multiplying data by 2
 *    BadSink : If data is positive, multiply by 2, which can cause an overflow
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE190_Integer_Overflow__int_max_multiply_82.h""

namespace CWE190_Integer_Overflow__int_max_multiply_82
{

void CWE190_Integer_Overflow__int_max_multiply_82_bad::action(int data)
{
    if(data > 0) 
    {
        
        int result = data * 2;
        printIntLine(result);
    }
}

}
"
14839,1,CWE401_Memory_Leak__malloc_realloc_char_14.c,"    if(globalFive==5)
    {
        {
            char * data = (char *)malloc(100*sizeof(char));
            if (data == NULL) {exit(-1);}
            char * tmpData;
            
            strcpy(data, ""A String"");
            printLine(data);
            tmpData = (char *)realloc(data, (130000)*sizeof(char));
            /* FIX: Ensure realloc() was successful before assigning data to the memory block
            * allocated with realloc() */
            if (tmpData != NULL)
            {
                data = tmpData;
                
                strcpy(data, ""New String"");
                printLine(data);
            }
            free(data);
        }
"
3565,0,CWE401_Memory_Leak__struct_twoIntsStruct_realloc_68a.c,"    struct _twoIntsStruct * data;
    data = NULL;
    
    data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));
    if (data == NULL) {exit(-1);}
    
    data[0].intOne = 0;
    data[0].intTwo = 0;
    printStructLine((twoIntsStruct *)&data[0]);
    CWE401_Memory_Leak__struct_twoIntsStruct_realloc_68_badData = data;
"
10444,0,CWE475_Undefined_Behavior_for_Input_to_API__char_08.c,"    if(staticReturnsTrue())
    {
        {
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            strcpy(data, ""abcdefghijklmnopqrstuvwxyz"");
            
            memcpy(data + 6, data + 4, 10*sizeof(char));
            printLine(data);
        }
"
11780,0,CWE401_Memory_Leak__char_calloc_18.c,"    char * data;
    data = NULL;
    goto source;
source:
    
    data = (char *)calloc(100, sizeof(char));
    if (data == NULL) {exit(-1);}
    
    strcpy(data, ""A String"");
    printLine(data);
    goto sink;
sink:
    
"
5801,0,CWE415_Double_Free__malloc_free_int_53a.c,"    int * data;
    
    data = NULL;
    data = (int *)malloc(100*sizeof(int));
    if (data == NULL) {exit(-1);}
    
    free(data);
"
14119,0,CWE457_Use_of_Uninitialized_Variable__int_array_alloca_no_init_03.c,"    int * data;
    data = (int *)ALLOCA(10*sizeof(int));
    if(5==5)
    {
        
        ; 
    }
    if(5==5)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i]);
            }
        }
"
2009,0,CWE190_Integer_Overflow__int_fscanf_square_82_bad.cpp,"Label Definition File: CWE190_Integer_Overflow__int.label.xml
Template File: sources-sinks-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 190 Integer Overflow
 * BadSource: fscanf Read data from the console using fscanf()
 * GoodSource: Set data to a small, non-zero number (two)
 * Sinks: square
 *    GoodSink: Ensure there will not be an overflow before squaring data
 *    BadSink : Square data, which can lead to overflow
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE190_Integer_Overflow__int_fscanf_square_82.h""

#include <math.h>

namespace CWE190_Integer_Overflow__int_fscanf_square_82
{

void CWE190_Integer_Overflow__int_fscanf_square_82_bad::action(int data)
{
    {
        
        int result = data * data;
        printIntLine(result);
    }
}

}
"
14850,0,CWE190_Integer_Overflow__unsigned_int_max_postinc_52a.c,"    unsigned int data;
    data = 0;
    
    data = UINT_MAX;
"
9356,0,CWE758_Undefined_Behavior__double_pointer_new_use_08.cpp,"    if(staticReturnsTrue())
    {
        {
            double * * pointer = new double *;
            double * data = *pointer; 
            delete pointer;
            printDoubleLine(*data);
        }
"
9920,0,CWE190_Integer_Overflow__int_max_square_08.c,"    int data;
    
    data = 0;
    if(staticReturnsTrue())
    {
        
        data = INT_MAX;
    }
    if(staticReturnsTrue())
    {
        {
            
            int result = data * data;
            printIntLine(result);
        }
"
6511,0,CWE78_OS_Command_Injection__char_file_system_64a.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
        
        size_t dataLen = strlen(data);
        FILE * pFile;
        
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
"
6927,0,CWE590_Free_Memory_Not_on_Heap__delete_array_struct_declare_44.cpp,"    twoIntsStruct * data;
    
    void (*funcPtr) (twoIntsStruct *) = badSink;
    data = NULL; 
    {
        
        twoIntsStruct dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i].intOne = 1;
                dataBuffer[i].intTwo = 1;
            }
        }
        data = dataBuffer;
    }
    
"
16173,0,CWE190_Integer_Overflow__short_fscanf_square_53a.c,"    short data;
    data = 0;
    
    fscanf (stdin, ""%hd"", &data);
"
4736,0,CWE590_Free_Memory_Not_on_Heap__delete_array_char_static_67a.cpp,"    char * data;
    structType myStruct;
    data = NULL; 
    {
        
        static char dataBuffer[100];
        memset(dataBuffer, 'A', 100-1); 
        dataBuffer[100-1] = '\0'; 
        data = dataBuffer;
    }
    myStruct.structFirst = data;
"
5123,0,CWE369_Divide_by_Zero__int_fscanf_divide_08.c,"    int data;
    
    data = -1;
    if(staticReturnsTrue())
    {
        
        fscanf(stdin, ""%d"", &data);
    }
    if(staticReturnsTrue())
    {
        
        printIntLine(100 / data);
"
16419,1,CWE476_NULL_Pointer_Dereference__null_check_after_deref_11.c,"    if(globalReturnsTrue())
    {
        {
            int *intPointer = NULL;
            intPointer = (int *)malloc(sizeof(int));
            *intPointer = 5;
            printIntLine(*intPointer);
            
            *intPointer = 10;
            printIntLine(*intPointer);
        }
"
44,0,CWE190_Integer_Overflow__int_connect_socket_square_72a.cpp,"    int data;
    vector<int> dataVector;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
10240,0,CWE190_Integer_Overflow__int64_t_rand_square_06.c,"    int64_t data;
    data = 0LL;
    if(STATIC_CONST_FIVE==5)
    {
        
        data = (int64_t)RAND64();
    }
    if(STATIC_CONST_FIVE==5)
    {
        {
            
            int64_t result = data * data;
            printLongLongLine(result);
        }
"
4934,1,CWE252_Unchecked_Return_Value__char_remove_04.c,"    if(STATIC_CONST_FALSE)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        
        if (REMOVE(""removemegood.txt"") != 0)
        {
            printLine(""remove failed!"");
        }
"
5016,0,CWE190_Integer_Overflow__int_rand_multiply_16.c,"    int data;
    
    data = 0;
    while(1)
    {
        
        data = RAND32();
        break;
    }
    while(1)
    {
        if(data > 0) 
        {
            
            int result = data * 2;
            printIntLine(result);
        }
        break;
"
12912,0,CWE590_Free_Memory_Not_on_Heap__delete_array_int64_t_declare_01.cpp,"    int64_t * data;
    data = NULL; 
    {
        
        int64_t dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5LL;
            }
        }
        data = dataBuffer;
    }
    printLongLongLine(data[0]);
    
"
13936,0,CWE590_Free_Memory_Not_on_Heap__delete_int_declare_72a.cpp,"    int * data;
    vector<int *> dataVector;
    data = NULL; 
    {
        
        int dataBuffer;
        dataBuffer = 5;
        data = &dataBuffer;
    }
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
7632,0,CWE190_Integer_Overflow__int64_t_fscanf_square_16.c,"    int64_t data;
    data = 0LL;
    while(1)
    {
        
        fscanf (stdin, ""%"" SCNd64, &data);
        break;
    }
    while(1)
    {
        {
            
            int64_t result = data * data;
            printLongLongLine(result);
        }
        break;
"
7682,0,CWE369_Divide_by_Zero__int_fscanf_divide_82_bad.cpp,"Label Definition File: CWE369_Divide_by_Zero__int.label.xml
Template File: sources-sinks-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 369 Divide by Zero
 * BadSource: fscanf Read data from the console using fscanf()
 * GoodSource: Non-zero
 * Sinks: divide
 *    GoodSink: Check for zero before dividing
 *    BadSink : Divide a constant by data
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE369_Divide_by_Zero__int_fscanf_divide_82.h""

namespace CWE369_Divide_by_Zero__int_fscanf_divide_82
{

void CWE369_Divide_by_Zero__int_fscanf_divide_82_bad::action(int data)
{
    
    printIntLine(100 / data);
}

}
"
880,0,CWE401_Memory_Leak__int64_t_malloc_52a.c,"    int64_t * data;
    data = NULL;
    
    data = (int64_t *)malloc(100*sizeof(int64_t));
    if (data == NULL) {exit(-1);}
    
    data[0] = 5LL;
    printLongLongLine(data[0]);
"
10570,0,CWE415_Double_Free__new_delete_int64_t_45.cpp,"    int64_t * data;
    
    data = NULL;
    data = new int64_t;
    
    delete data;
    badData = data;
"
10019,0,CWE476_NULL_Pointer_Dereference__int_14.c,"    int * data;
    if(globalFive==5)
    {
        
        data = NULL;
    }
    if(globalFive==5)
    {
        
        printIntLine(*data);
"
2374,0,CWE457_Use_of_Uninitialized_Variable__twointsclass_array_malloc_partial_init_18.cpp,"    TwoIntsClass * data;
    data = reinterpret_cast<TwoIntsClass *>(malloc(10*sizeof(TwoIntsClass)));
    if (data == NULL) {exit(-1);}
    goto source;
source:
    
    for(int i=0; i<(10/2); i++)
    {
        data[i].intOne = i;
        data[i].intTwo = i;
    }
    goto sink;
sink:
    
    for(int i=0; i<10; i++)
    {
        printIntLine(data[i].intOne);
        printIntLine(data[i].intTwo);
"
13493,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_42.c,"    size_t data;
    
    data = 0;
    data = badSource(data);
    {
        char * myString;
        /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
         * for the strcpy() function to not cause a buffer overflow */
        
        if (data > strlen(HELLO_STRING))
        {
            myString = (char *)malloc(data*sizeof(char));
            if (myString == NULL) {exit(-1);}
            
            strcpy(myString, HELLO_STRING);
            printLine(myString);
            free(myString);
        }
        else
        {
            printLine(""Input is less than the length of the source string"");
        }
"
7189,0,CWE401_Memory_Leak__struct_twoIntsStruct_malloc_54a.c,"    struct _twoIntsStruct * data;
    data = NULL;
    
    data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));
    if (data == NULL) {exit(-1);}
    
    data[0].intOne = 0;
    data[0].intTwo = 0;
    printStructLine((twoIntsStruct *)&data[0]);
"
16992,0,CWE197_Numeric_Truncation_Error__int_fscanf_to_short_02.c,"    int data;
    
    data = -1;
    if(1)
    {
        
        fscanf(stdin, ""%d"", &data);
    }
    {
        
        short shortData = (short)data;
        printShortLine(shortData);
"
1670,0,CWE590_Free_Memory_Not_on_Heap__delete_char_alloca_82a.cpp,"    char * data;
    data = NULL; 
    {
        
        char * dataBuffer = (char *)ALLOCA(sizeof(char));
        *dataBuffer = 'A';
        data = dataBuffer;
    }
    CWE590_Free_Memory_Not_on_Heap__delete_char_alloca_82_base* baseObject = new CWE590_Free_Memory_Not_on_Heap__delete_char_alloca_82_bad;
    baseObject->action(data);
"
1787,0,CWE190_Integer_Overflow__int_fgets_add_66a.c,"    int data;
    int dataArray[5];
    
    data = 0;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    
    dataArray[2] = data;
"
15234,0,CWE252_Unchecked_Return_Value__char_putchar_10.c,"    if(globalTrue)
    {
        
        putchar((int)'A');
"
12346,0,CWE590_Free_Memory_Not_on_Heap__free_struct_static_12.c,"    twoIntsStruct * data;
    data = NULL; 
    if(globalReturnsTrueOrFalse())
    {
        {
            
            static twoIntsStruct dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i].intOne = 1;
                    dataBuffer[i].intTwo = 1;
                }
            }
            data = dataBuffer;
        }
    }
    else
    {
        {
            
            twoIntsStruct * dataBuffer = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
            if (dataBuffer == NULL)
            {
                printLine(""malloc() failed"");
                exit(1);
            }
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i].intOne = 1;
                    dataBuffer[i].intTwo = 1;
                }
            }
            data = dataBuffer;
        }
    }
    printStructLine(&data[0]);
    
"
19548,0,CWE690_NULL_Deref_From_Return__int_realloc_09.c,"    int * data;
    data = NULL; 
    
    data = (int *)realloc(data, 1*sizeof(int));
    if(GLOBAL_CONST_TRUE)
    {
        
        data[0] = 5;
        printIntLine(data[0]);
        free(data);
"
9934,0,CWE78_OS_Command_Injection__char_console_popen_12.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(globalReturnsTrueOrFalse())
    {
        {
            
            size_t dataLen = strlen(data);
            
            if (100-dataLen > 1)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
                {
                    /* The next few lines remove the carriage return from the string that is
                     * inserted by fgets() */
                    dataLen = strlen(data);
"
2482,0,CWE190_Integer_Overflow__short_rand_multiply_13.c,"    short data;
    data = 0;
    if(GLOBAL_CONST_FIVE==5)
    {
        
        data = (short)RAND32();
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        if(data > 0) 
        {
            
            short result = data * 2;
            printIntLine(result);
        }
"
1748,0,CWE665_Improper_Initialization__char_cat_17.c,"    int i;
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    for(i = 0; i < 1; i++)
    {
        
        ; 
    }
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        
        strcat(data, source);
        printLine(data);
"
17827,0,CWE590_Free_Memory_Not_on_Heap__delete_class_placement_new_12.cpp,"    TwoIntsClass * data;
    data = NULL; 
    if(globalReturnsTrueOrFalse())
    {
        {
            
            char buffer[sizeof(TwoIntsClass)];
            TwoIntsClass * dataBuffer = new(buffer) TwoIntsClass;
            dataBuffer->intOne = 2;
            dataBuffer->intTwo = 2;
            data = dataBuffer;
        }
    }
    else
    {
        {
            
            TwoIntsClass * dataBuffer = new TwoIntsClass;
            dataBuffer->intOne = 2;
            dataBuffer->intTwo = 2;
            data = dataBuffer;
        }
    }
    printIntLine(data->intOne);
    
"
5932,0,CWE457_Use_of_Uninitialized_Variable__new_double_array_partial_init_03.cpp,"    double * data;
    data = new double[10];
    if(5==5)
    {
        
        {
            int i;
            for(i=0; i<(10/2); i++)
            {
                data[i] = (double)i;
            }
        }
    }
    if(5==5)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printDoubleLine(data[i]);
            }
        }
        
        delete [] data;
"
3180,0,CWE590_Free_Memory_Not_on_Heap__delete_array_long_static_34.cpp,"    long * data;
    unionType myUnion;
    data = NULL; 
    {
        
        static long dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5L;
            }
        }
        data = dataBuffer;
    }
    myUnion.unionFirst = data;
    {
        long * data = myUnion.unionSecond;
        printLongLine(data[0]);
        
        delete [] data;
"
13882,0,CWE457_Use_of_Uninitialized_Variable__twointsclass_array_new_no_init_64a.cpp,"    TwoIntsClass * data;
    data = new TwoIntsClass[10];
    
    ; 
"
10699,0,CWE457_Use_of_Uninitialized_Variable__double_array_malloc_no_init_09.c,"    double * data;
    data = (double *)malloc(10*sizeof(double));
    if (data == NULL) {exit(-1);}
    if(GLOBAL_CONST_TRUE)
    {
        
        ; 
    }
    if(GLOBAL_CONST_TRUE)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printDoubleLine(data[i]);
            }
        }
"
11874,0,CWE252_Unchecked_Return_Value__char_sscanf_05.c,"    if(staticTrue)
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            
            sscanf(SRC, ""%99s\0"", data);
        }
"
17425,0,CWE401_Memory_Leak__twoIntsStruct_calloc_65a.c,"    twoIntsStruct * data;
    
    void (*funcPtr) (twoIntsStruct *) = CWE401_Memory_Leak__twoIntsStruct_calloc_65b_badSink;
    data = NULL;
    
    data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));
    if (data == NULL) {exit(-1);}
    
    data[0].intOne = 0;
    data[0].intTwo = 0;
    printStructLine(&data[0]);
    
"
12047,0,CWE190_Integer_Overflow__int_fgets_add_01.c,"    int data;
    
    data = 0;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    {
        
        int result = data + 1;
        printIntLine(result);
"
7640,0,CWE690_NULL_Deref_From_Return__long_calloc_31.c,"    long * data;
    data = NULL; 
    
    data = (long *)calloc(1, sizeof(long));
    {
        long * dataCopy = data;
        long * data = dataCopy;
        
        data[0] = 5L;
        printLongLine(data[0]);
        free(data);
"
1897,0,CWE190_Integer_Overflow__char_fscanf_preinc_09.c,"    char data;
    data = ' ';
    if(GLOBAL_CONST_TRUE)
    {
        
        fscanf (stdin, ""%c"", &data);
    }
    if(GLOBAL_CONST_TRUE)
    {
        {
            
            ++data;
            char result = data;
            printHexCharLine(result);
        }
"
4237,1,CWE758_Undefined_Behavior__double_pointer_alloca_use_11.c,"    if(globalReturnsFalse())
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            double * data;
            double * * pointer = (double * *)ALLOCA(sizeof(double *));
            
            data = (double *)malloc(sizeof(double));
            if (data == NULL) {exit(-1);}
            *data = 5.0;
            *pointer = data; 
            {
                double * data = *pointer;
                printDoubleLine(*data);
            }
        }
"
13438,0,CWE563_Unused_Variable__unused_value_int64_t_17.c,"    int i,j;
    int64_t data;
    for(i = 0; i < 1; i++)
    {
        
        data = 5LL;
    }
    for(j = 0; j < 1; j++)
    {
        
        data = 10LL;
        printLongLongLine(data);
"
12026,0,CWE190_Integer_Overflow__int_connect_socket_square_73a.cpp,"    int data;
    list<int> dataList;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
2150,0,CWE590_Free_Memory_Not_on_Heap__delete_array_char_alloca_03.cpp,"    char * data;
    data = NULL; 
    if(5==5)
    {
        {
            
            char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
            memset(dataBuffer, 'A', 100-1); 
            dataBuffer[100-1] = '\0'; 
            data = dataBuffer;
        }
    }
    printLine(data);
    
"
12866,0,CWE476_NULL_Pointer_Dereference__class_73a.cpp,"    TwoIntsClass * data;
    list<TwoIntsClass *> dataList;
    
    data = NULL;
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
745,0,CWE134_Uncontrolled_Format_String__char_file_vfprintf_63a.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        FILE * pFile;
        
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
"
3171,0,CWE690_NULL_Deref_From_Return__char_malloc_42.c,"    char * data;
    data = NULL; 
    data = badSource(data);
    
    strcpy(data, ""Initialize"");
    printLine(data);
"
16510,0,CWE78_OS_Command_Injection__char_connect_socket_system_07.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(staticFive==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET connectSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
"
580,0,CWE415_Double_Free__malloc_free_char_07.c,"    char * data;
    
    data = NULL;
    if(staticFive==5)
    {
        data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        
        free(data);
    }
    if(staticFive==5)
    {
        
        free(data);
"
18246,0,CWE590_Free_Memory_Not_on_Heap__delete_array_long_static_31.cpp,"    long * data;
    data = NULL; 
    {
        
        static long dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5L;
            }
        }
        data = dataBuffer;
    }
    {
        long * dataCopy = data;
        long * data = dataCopy;
        printLongLine(data[0]);
        
        delete [] data;
"
18966,0,CWE415_Double_Free__new_delete_int64_t_21.cpp,"    int64_t * data;
    
    data = NULL;
    data = new int64_t;
    
    delete data;
    badStatic = 1; 
"
6553,0,CWE416_Use_After_Free__malloc_free_char_06.c,"    char * data;
    
    data = NULL;
    if(STATIC_CONST_FIVE==5)
    {
        data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        memset(data, 'A', 100-1);
        data[100-1] = '\0';
        
        free(data);
    }
    if(STATIC_CONST_FIVE==5)
    {
        
        printLine(data);
        
"
7401,0,CWE134_Uncontrolled_Format_String__char_file_snprintf_65a.c,"    char * data;
    
    void (*funcPtr) (char *) = CWE134_Uncontrolled_Format_String__char_file_snprintf_65b_badSink;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        FILE * pFile;
        
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
    
"
15268,0,CWE789_Uncontrolled_Mem_Alloc__new_char_listen_socket_61a.cpp,"    size_t data;
    
    data = 0;
    data = badSource(data);
    {
        char * myString;
        /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
         * for the strcpy() function to not cause a buffer overflow */
        
        if (data > strlen(HELLO_STRING))
        {
            myString = new char[data];
            
            strcpy(myString, HELLO_STRING);
            printLine(myString);
            delete [] myString;
        }
        else
        {
            printLine(""Input is less than the length of the source string"");
        }
"
1807,0,CWE197_Numeric_Truncation_Error__int_fgets_to_short_53a.c,"    int data;
    
    data = -1;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
"
18933,1,CWE758_Undefined_Behavior__char_alloca_use_10.c,"    if(globalTrue)
    {
        {
            char data;
            char * pointer = (char *)ALLOCA(sizeof(char));
            data = 5;
            *pointer = data; 
            {
                char data = *pointer;
                printHexCharLine(data);
            }
        }
"
8765,1,CWE252_Unchecked_Return_Value__char_rename_17.c,"    int k;
    for(k = 0; k < 1; k++)
    {
        
        if (RENAME(OLD_GOOD_FILE_NAME, ""newgoodfilename.txt"") != 0)
        {
            printLine(""rename failed!"");
        }
"
14328,0,CWE590_Free_Memory_Not_on_Heap__delete_array_char_alloca_17.cpp,"    int i;
    char * data;
    data = NULL; 
    for(i = 0; i < 1; i++)
    {
        {
            
            char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
            memset(dataBuffer, 'A', 100-1); 
            dataBuffer[100-1] = '\0'; 
            data = dataBuffer;
        }
    }
    printLine(data);
    
"
19140,0,CWE252_Unchecked_Return_Value__char_remove_10.c,"    if(globalTrue)
    {
        
        REMOVE(""removemebad.txt"");
"
2350,0,CWE415_Double_Free__new_delete_array_int_13.cpp,"    int * data;
    
    data = NULL;
    if(GLOBAL_CONST_FIVE==5)
    {
        data = new int[100];
        
        delete [] data;
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        
        delete [] data;
"
5852,1,CWE758_Undefined_Behavior__char_pointer_new_use_10.cpp,"    if(globalTrue)
    {
        {
            char * data;
            data = ""string"";
            char * * pointer = new char *;
            *pointer = data; 
            {
                char * data = *pointer;
                printLine(data);
            }
            delete pointer;
        }
"
3942,0,CWE416_Use_After_Free__new_delete_array_class_18.cpp,"    TwoIntsClass * data;
    
    data = NULL;
    goto source;
source:
    data = new TwoIntsClass[100];
    {
        size_t i;
        for(i = 0; i < 100; i++)
        {
            data[i].intOne = 1;
            data[i].intTwo = 2;
        }
    }
    
    delete [] data;
    goto sink;
sink:
    
    printIntLine(data[0].intOne);
"
6120,1,CWE758_Undefined_Behavior__int_malloc_use_08.c,"    if(staticReturnsFalse())
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            int data;
            int * pointer = (int *)malloc(sizeof(int));
            if (pointer == NULL) {exit(-1);}
            data = 5;
            *pointer = data; 
            {
                int data = *pointer;
                printIntLine(data);
            }
            free(pointer);
        }
"
12649,0,CWE457_Use_of_Uninitialized_Variable__struct_array_alloca_partial_init_10.c,"    twoIntsStruct * data;
    data = (twoIntsStruct *)ALLOCA(10*sizeof(twoIntsStruct));
    if(globalTrue)
    {
        
        {
            int i;
            for(i=0; i<(10/2); i++)
            {
                data[i].intOne = i;
                data[i].intTwo = i;
            }
        }
    }
    if(globalTrue)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i].intOne);
                printIntLine(data[i].intTwo);
            }
        }
"
17192,0,CWE590_Free_Memory_Not_on_Heap__free_int64_t_alloca_13.c,"    int64_t * data;
    data = NULL; 
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            
            int64_t * dataBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5LL;
                }
            }
            data = dataBuffer;
        }
    }
    printLongLongLine(data[0]);
    
"
2360,0,CWE190_Integer_Overflow__short_rand_add_44.c,"    short data;
    
    void (*funcPtr) (short) = badSink;
    data = 0;
    
    data = (short)RAND32();
    
"
10797,0,CWE190_Integer_Overflow__int64_t_max_add_03.c,"    int64_t data;
    data = 0LL;
    if(5==5)
    {
        
        data = LLONG_MAX;
    }
    if(5==5)
    {
        {
            
            int64_t result = data + 1;
            printLongLongLine(result);
        }
"
15443,0,CWE78_OS_Command_Injection__char_console_system_72a.cpp,"    char * data;
    vector<char *> dataVector;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
        
        size_t dataLen = strlen(data);
        
        if (100-dataLen > 1)
        {
            
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgets() */
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
                    data[dataLen-1] = '\0';
                }
            }
            else
            {
                printLine(""fgets() failed"");
                
                data[dataLen] = '\0';
            }
        }
    }
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
6282,0,CWE676_Use_of_Potentially_Dangerous_Function__basic_15.cpp,"    switch(6)
    {
    case 6:
    {
        char charBuffer[CHAR_BUFFER_SIZE];
        
        
        cin >> charBuffer;
        charBuffer[CHAR_BUFFER_SIZE-1] = '\0';
        printLine(charBuffer);
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
11519,0,CWE415_Double_Free__new_delete_array_struct_11.cpp,"    twoIntsStruct * data;
    
    data = NULL;
    if(globalReturnsTrue())
    {
        data = new twoIntsStruct[100];
        
        delete [] data;
    }
    if(globalReturnsTrue())
    {
        
        delete [] data;
"
8234,0,CWE369_Divide_by_Zero__int_zero_modulo_09.c,"    int data;
    
    data = -1;
    if(GLOBAL_CONST_TRUE)
    {
        
        data = 0;
    }
    if(GLOBAL_CONST_TRUE)
    {
        
        printIntLine(100 % data);
"
10390,0,CWE590_Free_Memory_Not_on_Heap__free_struct_alloca_72a.cpp,"    twoIntsStruct * data;
    vector<twoIntsStruct *> dataVector;
    data = NULL; 
    {
        
        twoIntsStruct * dataBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i].intOne = 1;
                dataBuffer[i].intTwo = 1;
            }
        }
        data = dataBuffer;
    }
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
7743,0,CWE690_NULL_Deref_From_Return__int_realloc_14.c,"    int * data;
    data = NULL; 
    
    data = (int *)realloc(data, 1*sizeof(int));
    if(globalFive==5)
    {
        
        data[0] = 5;
        printIntLine(data[0]);
        free(data);
"
8435,0,CWE416_Use_After_Free__malloc_free_int64_t_01.c,"    int64_t * data;
    
    data = NULL;
    data = (int64_t *)malloc(100*sizeof(int64_t));
    if (data == NULL) {exit(-1);}
    {
        size_t i;
        for(i = 0; i < 100; i++)
        {
            data[i] = 5LL;
        }
    }
    
    free(data);
    
    printLongLongLine(data[0]);
"
13351,0,CWE190_Integer_Overflow__int64_t_max_multiply_14.c,"    int64_t data;
    data = 0LL;
    if(globalFive==5)
    {
        
        data = LLONG_MAX;
    }
    if(globalFive==5)
    {
        if(data > 0) 
        {
            
            int64_t result = data * 2;
            printLongLongLine(result);
        }
"
8609,0,CWE190_Integer_Overflow__int64_t_rand_square_73a.cpp,"    int64_t data;
    list<int64_t> dataList;
    data = 0LL;
    
    data = (int64_t)RAND64();
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
11705,0,CWE190_Integer_Overflow__int_listen_socket_square_52a.c,"    int data;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
4598,0,CWE78_OS_Command_Injection__char_environment_execl_52a.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        
        if (environment != NULL)
        {
            
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
"
7524,0,CWE758_Undefined_Behavior__long_alloca_use_09.c,"    if(GLOBAL_CONST_TRUE)
    {
        {
            long * pointer = (long *)ALLOCA(sizeof(long));
            long data = *pointer; 
            printLongLine(data);
        }
"
11337,0,CWE789_Uncontrolled_Mem_Alloc__new_char_fgets_01.cpp,"    size_t data;
    
    data = 0;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = strtoul(inputBuffer, NULL, 0);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    {
        char * myString;
        /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
         * for the strcpy() function to not cause a buffer overflow */
        
        if (data > strlen(HELLO_STRING))
        {
            myString = new char[data];
            
            strcpy(myString, HELLO_STRING);
            printLine(myString);
            delete [] myString;
        }
        else
        {
            printLine(""Input is less than the length of the source string"");
        }
"
15366,0,CWE758_Undefined_Behavior__int_malloc_use_04.c,"    if(STATIC_CONST_TRUE)
    {
        {
            int * pointer = (int *)malloc(sizeof(int));
            if (pointer == NULL) {exit(-1);}
            int data = *pointer; 
            free(pointer);
            printIntLine(data);
        }
"
3598,0,CWE401_Memory_Leak__int_calloc_11.c,"    int * data;
    data = NULL;
    if(globalReturnsTrue())
    {
        
        data = (int *)calloc(100, sizeof(int));
        if (data == NULL) {exit(-1);}
        
        data[0] = 5;
        printIntLine(data[0]);
    }
    if(globalReturnsTrue())
    {
        
        ; 
"
7433,0,CWE401_Memory_Leak__twoIntsStruct_realloc_17.c,"    int i,j;
    twoIntsStruct * data;
    data = NULL;
    for(i = 0; i < 1; i++)
    {
        
        data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));
        if (data == NULL) {exit(-1);}
        
        data[0].intOne = 0;
        data[0].intTwo = 0;
        printStructLine(&data[0]);
    }
    for(j = 0; j < 1; j++)
    {
        
        ; 
"
4639,0,CWE401_Memory_Leak__int64_t_calloc_52a.c,"    int64_t * data;
    data = NULL;
    
    data = (int64_t *)calloc(100, sizeof(int64_t));
    if (data == NULL) {exit(-1);}
    
    data[0] = 5LL;
    printLongLongLine(data[0]);
"
16777,0,CWE457_Use_of_Uninitialized_Variable__twointsclass_array_malloc_no_init_62a.cpp,"    TwoIntsClass * data;
    data = reinterpret_cast<TwoIntsClass *>(malloc(10*sizeof(TwoIntsClass)));
    if (data == NULL) {exit(-1);}
    badSource(data);
    
    for(int i=0; i<10; i++)
    {
        printIntLine(data[i].intOne);
        printIntLine(data[i].intTwo);
"
16500,0,CWE590_Free_Memory_Not_on_Heap__free_int64_t_static_02.c,"    int64_t * data;
    data = NULL; 
    if(1)
    {
        {
            
            static int64_t dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5LL;
                }
            }
            data = dataBuffer;
        }
    }
    printLongLongLine(data[0]);
    
"
7968,0,CWE457_Use_of_Uninitialized_Variable__twointsclass_14.cpp,"    TwoIntsClass data;
    if(globalFive==5)
    {
        
        ; 
    }
    if(globalFive==5)
    {
        
        printIntLine(data.intOne);
        printIntLine(data.intTwo);
"
15411,0,CWE197_Numeric_Truncation_Error__short_fscanf_82_bad.cpp,"Label Definition File: CWE197_Numeric_Truncation_Error__short.label.xml
Template File: sources-sink-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 197 Numeric Truncation Error
 * BadSource: fscanf Read data from the console using fscanf()
 * GoodSource: Less than CHAR_MAX
 * Sinks:
 *    BadSink : Convert data to a char
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE197_Numeric_Truncation_Error__short_fscanf_82.h""

namespace CWE197_Numeric_Truncation_Error__short_fscanf_82
{

void CWE197_Numeric_Truncation_Error__short_fscanf_82_bad::action(short data)
{
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
    }
}

}
"
4198,0,CWE401_Memory_Leak__strdup_char_44.c,"    char * data;
    
    void (*funcPtr) (char *) = badSink;
    data = NULL;
    {
        char myString[] = ""myString"";
        
        data = strdup(myString);
        
        printLine(data);
    }
    
"
17031,0,CWE197_Numeric_Truncation_Error__short_fgets_03.c,"    short data;
    
    data = -1;
    if(5==5)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                
                data = (short)atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
11924,0,CWE401_Memory_Leak__int_realloc_14.c,"    int * data;
    data = NULL;
    if(globalFive==5)
    {
        
        data = (int *)realloc(data, 100*sizeof(int));
        if (data == NULL) {exit(-1);}
        
        data[0] = 5;
        printIntLine(data[0]);
    }
    if(globalFive==5)
    {
        
        ; 
"
11527,0,CWE190_Integer_Overflow__int_connect_socket_postinc_11.c,"    int data;
    
    data = 0;
    if(globalReturnsTrue())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(globalReturnsTrue())
    {
        {
            
            data++;
            int result = data;
            printIntLine(result);
        }
"
11458,0,CWE197_Numeric_Truncation_Error__short_rand_62a.cpp,"    short data;
    
    data = -1;
    badSource(data);
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
11865,0,CWE401_Memory_Leak__new_array_TwoIntsClass_11.cpp,"    TwoIntsClass * data;
    data = NULL;
    if(globalReturnsTrue())
    {
        
        data = new TwoIntsClass[100];
        
        data[0].intOne = 0;
        data[0].intTwo = 0;
        printIntLine(data[0].intOne);
        printIntLine(data[0].intTwo);
    }
    if(globalReturnsTrue())
    {
        
        ; 
"
2328,0,CWE78_OS_Command_Injection__char_connect_socket_execl_51a.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
1529,0,CWE457_Use_of_Uninitialized_Variable__struct_array_malloc_partial_init_01.c,"    twoIntsStruct * data;
    data = (twoIntsStruct *)malloc(10*sizeof(twoIntsStruct));
    if (data == NULL) {exit(-1);}
    
    {
        int i;
        for(i=0; i<(10/2); i++)
        {
            data[i].intOne = i;
            data[i].intTwo = i;
        }
    }
    
    {
        int i;
        for(i=0; i<10; i++)
        {
            printIntLine(data[i].intOne);
            printIntLine(data[i].intTwo);
        }
"
3165,0,CWE587_Assignment_of_Fixed_Address_to_Pointer__basic_09.c,"    if(GLOBAL_CONST_TRUE)
    {
        {
            
            char *charPointer = (char*)0x400000;
            printHexCharLine(*charPointer);
        }
"
5217,1,CWE758_Undefined_Behavior__char_malloc_use_12.c,"    if(globalReturnsTrueOrFalse())
    {
        {
            char data;
            char * pointer = (char *)malloc(sizeof(char));
            if (pointer == NULL) {exit(-1);}
            data = 5;
            *pointer = data; 
            {
                char data = *pointer;
                printHexCharLine(data);
            }
            free(pointer);
        }
    }
    else
    {
        {
            char data;
            char * pointer = (char *)malloc(sizeof(char));
            if (pointer == NULL) {exit(-1);}
            data = 5;
            *pointer = data; 
            {
                char data = *pointer;
                printHexCharLine(data);
            }
            free(pointer);
        }
"
8314,0,CWE190_Integer_Overflow__int_fscanf_add_83_bad.cpp,"Label Definition File: CWE190_Integer_Overflow__int.label.xml
Template File: sources-sinks-83_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 190 Integer Overflow
 * BadSource: fscanf Read data from the console using fscanf()
 * GoodSource: Set data to a small, non-zero number (two)
 * Sinks: add
 *    GoodSink: Ensure there will not be an overflow before adding 1 to data
 *    BadSink : Add 1 to data, which can cause an overflow
 * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE190_Integer_Overflow__int_fscanf_add_83.h""

namespace CWE190_Integer_Overflow__int_fscanf_add_83
{
CWE190_Integer_Overflow__int_fscanf_add_83_bad::CWE190_Integer_Overflow__int_fscanf_add_83_bad(int dataCopy)
{
    data = dataCopy;
    
    fscanf(stdin, ""%d"", &data);
}

CWE190_Integer_Overflow__int_fscanf_add_83_bad::~CWE190_Integer_Overflow__int_fscanf_add_83_bad()
{
    {
        
        int result = data + 1;
        printIntLine(result);
    }
}
}
"
17821,1,CWE252_Unchecked_Return_Value__char_fscanf_04.c,"    if(STATIC_CONST_TRUE)
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            
            if (fscanf(stdin, ""%99s\0"", data) == EOF)
            {
                printLine(""fscanf failed!"");
            }
        }
"
1857,0,CWE252_Unchecked_Return_Value__char_putchar_07.c,"    if(staticFive==5)
    {
        
        putchar((int)'A');
"
13577,0,CWE590_Free_Memory_Not_on_Heap__delete_array_char_static_81_bad.cpp,"Label Definition File: CWE590_Free_Memory_Not_on_Heap__delete_array.label.xml
Template File: sources-sink-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 590 Free Memory Not on Heap
 * BadSource: static Data buffer is declared static on the stack
 * GoodSource: Allocate memory on the heap
 * Sinks:
 *    BadSink : Print then free data
 * Flow Variant: 81 Data flow: data passed in a parameter to a virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE590_Free_Memory_Not_on_Heap__delete_array_char_static_81.h""

namespace CWE590_Free_Memory_Not_on_Heap__delete_array_char_static_81
{

void CWE590_Free_Memory_Not_on_Heap__delete_array_char_static_81_bad::action(char * data) const
{
    printLine(data);
    
    delete [] data;
}

}
"
3801,0,CWE197_Numeric_Truncation_Error__short_rand_04.c,"    short data;
    
    data = -1;
    if(STATIC_CONST_TRUE)
    {
        
        data = (short)RAND32();
    }
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
16651,0,CWE457_Use_of_Uninitialized_Variable__struct_array_malloc_partial_init_16.c,"    twoIntsStruct * data;
    data = (twoIntsStruct *)malloc(10*sizeof(twoIntsStruct));
    if (data == NULL) {exit(-1);}
    while(1)
    {
        
        {
            int i;
            for(i=0; i<(10/2); i++)
            {
                data[i].intOne = i;
                data[i].intTwo = i;
            }
        }
        break;
    }
    while(1)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i].intOne);
                printIntLine(data[i].intTwo);
            }
        }
        break;
"
7104,0,CWE457_Use_of_Uninitialized_Variable__double_array_malloc_partial_init_10.c,"    double * data;
    data = (double *)malloc(10*sizeof(double));
    if (data == NULL) {exit(-1);}
    if(globalTrue)
    {
        
        {
            int i;
            for(i=0; i<(10/2); i++)
            {
                data[i] = (double)i;
            }
        }
    }
    if(globalTrue)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printDoubleLine(data[i]);
            }
        }
"
10917,0,CWE369_Divide_by_Zero__float_fgets_43.cpp,"    float data;
    
    data = 0.0F;
    badSource(data);
    {
        
        int result = (int)(100.0 / data);
        printIntLine(result);
"
14780,0,CWE78_OS_Command_Injection__char_environment_system_74a.cpp,"    char * data;
    map<int, char *> dataMap;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
        
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        
        if (environment != NULL)
        {
            
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
10335,0,CWE369_Divide_by_Zero__int_connect_socket_modulo_64a.c,"    int data;
    
    data = -1;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
9134,1,CWE758_Undefined_Behavior__double_pointer_alloca_use_04.c,"    if(STATIC_CONST_FALSE)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            double * data;
            double * * pointer = (double * *)ALLOCA(sizeof(double *));
            
            data = (double *)malloc(sizeof(double));
            if (data == NULL) {exit(-1);}
            *data = 5.0;
            *pointer = data; 
            {
                double * data = *pointer;
                printDoubleLine(*data);
            }
        }
"
17219,1,CWE401_Memory_Leak__malloc_realloc_struct_twoIntsStruct_13.c,"    if(GLOBAL_CONST_FIVE==5)
    {
        {
            struct _twoIntsStruct * data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));
            if (data == NULL) {exit(-1);}
            struct _twoIntsStruct * tmpData;
            
            data[0].intOne = 0;
            data[0].intTwo = 0;
            printStructLine((twoIntsStruct *)&data[0]);
            tmpData = (struct _twoIntsStruct *)realloc(data, (130000)*sizeof(struct _twoIntsStruct));
            /* FIX: Ensure realloc() was successful before assigning data to the memory block
            * allocated with realloc() */
            if (tmpData != NULL)
            {
                data = tmpData;
                
                data[0].intOne = 1;
                data[0].intTwo = 1;
                printStructLine((twoIntsStruct *)&data[0]);
            }
            free(data);
        }
"
14726,0,CWE401_Memory_Leak__int64_t_calloc_67a.c,"    int64_t * data;
    CWE401_Memory_Leak__int64_t_calloc_67_structType myStruct;
    data = NULL;
    
    data = (int64_t *)calloc(100, sizeof(int64_t));
    if (data == NULL) {exit(-1);}
    
    data[0] = 5LL;
    printLongLongLine(data[0]);
    myStruct.structFirst = data;
"
13233,0,CWE190_Integer_Overflow__char_fscanf_postinc_16.c,"    char data;
    data = ' ';
    while(1)
    {
        
        fscanf (stdin, ""%c"", &data);
        break;
    }
    while(1)
    {
        {
            
            data++;
            char result = data;
            printHexCharLine(result);
        }
        break;
"
7980,0,CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_53a.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
15115,0,CWE78_OS_Command_Injection__char_console_popen_07.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(staticFive==5)
    {
        {
            
            size_t dataLen = strlen(data);
            
            if (100-dataLen > 1)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
                {
                    /* The next few lines remove the carriage return from the string that is
                     * inserted by fgets() */
                    dataLen = strlen(data);
"
2193,0,CWE590_Free_Memory_Not_on_Heap__free_struct_alloca_04.c,"    twoIntsStruct * data;
    data = NULL; 
    if(STATIC_CONST_TRUE)
    {
        {
            
            twoIntsStruct * dataBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i].intOne = 1;
                    dataBuffer[i].intTwo = 1;
                }
            }
            data = dataBuffer;
        }
    }
    printStructLine(&data[0]);
    
"
4627,0,CWE369_Divide_by_Zero__int_zero_modulo_72a.cpp,"    int data;
    vector<int> dataVector;
    
    data = -1;
    
    data = 0;
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
17472,0,CWE457_Use_of_Uninitialized_Variable__twointsclass_array_new_no_init_15.cpp,"    TwoIntsClass * data;
    data = new TwoIntsClass[10];
    switch(6)
    {
    case 6:
        
        ; 
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
        
        for(int i=0; i<10; i++)
        {
            printIntLine(data[i].intOne);
            printIntLine(data[i].intTwo);
        }
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
1275,1,CWE252_Unchecked_Return_Value__char_putchar_04.c,"    if(STATIC_CONST_FALSE)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        
        if (putchar((int)'A') == EOF)
        {
            printLine(""putchar failed!"");
        }
"
6049,0,CWE401_Memory_Leak__malloc_realloc_twoIntsStruct_11.c,"    if(globalReturnsTrue())
    {
        {
            twoIntsStruct * data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
            if (data == NULL) {exit(-1);}
            
            data[0].intOne = 0;
            data[0].intTwo = 0;
            printStructLine(&data[0]);
            
            data = (twoIntsStruct *)realloc(data, (130000)*sizeof(twoIntsStruct));
            if (data != NULL)
            {
                
                data[0].intOne = 1;
                data[0].intTwo = 1;
                printStructLine(&data[0]);
                free(data);
            }
        }
"
16964,0,CWE590_Free_Memory_Not_on_Heap__delete_array_long_alloca_45.cpp,"    long * data;
    data = NULL; 
    {
        
        long * dataBuffer = (long *)ALLOCA(100*sizeof(long));
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5L;
            }
        }
        data = dataBuffer;
    }
    badData = data;
"
2119,0,CWE467_Use_of_sizeof_on_Pointer_Type__int_07.c,"    if(staticFive==5)
    {
        {
            int * badInt = NULL;
            
            badInt = (int *)malloc(sizeof(badInt));
            if (badInt == NULL) {exit(-1);}
            *badInt = 5;
            printIntLine(*badInt);
            free(badInt);
        }
"
17259,0,CWE401_Memory_Leak__new_array_int_72a.cpp,"    int * data;
    vector<int *> dataVector;
    data = NULL;
    
    data = new int[100];
    
    data[0] = 5;
    printIntLine(data[0]);
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
12209,0,CWE415_Double_Free__new_delete_class_03.cpp,"    TwoIntsClass * data;
    
    data = NULL;
    if(5==5)
    {
        data = new TwoIntsClass;
        
        delete data;
    }
    if(5==5)
    {
        
        delete data;
"
481,0,CWE476_NULL_Pointer_Dereference__long_13.c,"    long * data;
    if(GLOBAL_CONST_FIVE==5)
    {
        
        data = NULL;
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        
        printLongLine(*data);
"
17286,0,CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_63a.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
3402,0,CWE190_Integer_Overflow__short_max_square_53a.c,"    short data;
    data = 0;
    
    data = SHRT_MAX;
"
10922,0,CWE190_Integer_Overflow__unsigned_int_rand_preinc_42.c,"    unsigned int data;
    data = 0;
    data = badSource(data);
    {
        
        ++data;
        unsigned int result = data;
        printUnsignedLine(result);
"
19124,0,CWE415_Double_Free__new_delete_int64_t_18.cpp,"    int64_t * data;
    
    data = NULL;
    goto source;
source:
    data = new int64_t;
    
    delete data;
    goto sink;
sink:
    
"
14303,0,CWE369_Divide_by_Zero__float_fgets_51a.c,"    float data;
    
    data = 0.0F;
    {
        char inputBuffer[CHAR_ARRAY_SIZE];
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = (float)atof(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
"
17732,0,CWE590_Free_Memory_Not_on_Heap__delete_int_placement_new_01.cpp,"    int * data;
    data = NULL; 
    {
        
        char buffer[sizeof(int)];
        int * dataBuffer = new(buffer) int;
        *dataBuffer = 5;
        data = dataBuffer;
    }
    printIntLine(*data);
    
"
18414,0,CWE563_Unused_Variable__unused_value_long_11.c,"    long data;
    if(globalReturnsTrue())
    {
        
        data = 5L;
    }
    if(globalReturnsTrue())
    {
        
        data = 10L;
        printLongLine(data);
"
7932,0,CWE190_Integer_Overflow__int_connect_socket_preinc_15.c,"    int data;
    
    data = 0;
    switch(6)
    {
    case 6:
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
    {
        
        ++data;
        int result = data;
        printIntLine(result);
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
15801,0,CWE690_NULL_Deref_From_Return__int_malloc_32.c,"    int * data;
    int * *dataPtr1 = &data;
    int * *dataPtr2 = &data;
    data = NULL; 
    {
        int * data = *dataPtr1;
        
        data = (int *)malloc(1*sizeof(int));
        *dataPtr1 = data;
    }
    {
        int * data = *dataPtr2;
        
        data[0] = 5;
        printIntLine(data[0]);
        free(data);
"
13537,0,CWE415_Double_Free__new_delete_array_char_01.cpp,"    char * data;
    
    data = NULL;
    data = new char[100];
    
    delete [] data;
    
"
3234,0,CWE78_OS_Command_Injection__char_listen_socket_system_84_bad.cpp,"Label Definition File: CWE78_OS_Command_Injection.one_string.label.xml
Template File: sources-sink-84_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 78 OS Command Injection
 * BadSource: listen_socket Read data using a listen socket (server side)
 * GoodSource: Fixed string
 * Sinks: system
 *    BadSink : Execute command in data using system()
 * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE78_OS_Command_Injection__char_listen_socket_system_84.h""

#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif

#define TCP_PORT 27015
#define LISTEN_BACKLOG 5

#ifdef _WIN32
#define SYSTEM system
#else 
#define SYSTEM system
#endif

namespace CWE78_OS_Command_Injection__char_listen_socket_system_84
{
CWE78_OS_Command_Injection__char_listen_socket_system_84_bad::CWE78_OS_Command_Injection__char_listen_socket_system_84_bad(char * dataCopy)
{
    data = dataCopy;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
}

CWE78_OS_Command_Injection__char_listen_socket_system_84_bad::~CWE78_OS_Command_Injection__char_listen_socket_system_84_bad()
{
    
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
    }
}
}
"
8781,0,CWE190_Integer_Overflow__char_rand_multiply_54a.c,"    char data;
    data = ' ';
    
    data = (char)RAND32();
"
8940,0,CWE401_Memory_Leak__new_struct_twoIntsStruct_44.cpp,"    struct _twoIntsStruct * data;
    
    void (*funcPtr) (struct _twoIntsStruct *) = badSink;
    data = NULL;
    
    data = new struct _twoIntsStruct;
    
    data->intOne = 0;
    data->intTwo = 0;
    printStructLine((twoIntsStruct *)data);
    
"
9872,0,CWE401_Memory_Leak__int64_t_realloc_74a.cpp,"    int64_t * data;
    map<int, int64_t *> dataMap;
    data = NULL;
    
    data = (int64_t *)realloc(data, 100*sizeof(int64_t));
    if (data == NULL) {exit(-1);}
    
    data[0] = 5LL;
    printLongLongLine(data[0]);
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
18180,0,CWE401_Memory_Leak__char_realloc_13.c,"    char * data;
    data = NULL;
    if(GLOBAL_CONST_FIVE==5)
    {
        
        data = (char *)realloc(data, 100*sizeof(char));
        if (data == NULL) {exit(-1);}
        
        strcpy(data, ""A String"");
        printLine(data);
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        
        ; 
"
12361,0,CWE590_Free_Memory_Not_on_Heap__free_long_alloca_34.c,"    long * data;
    CWE590_Free_Memory_Not_on_Heap__free_long_alloca_34_unionType myUnion;
    data = NULL; 
    {
        
        long * dataBuffer = (long *)ALLOCA(100*sizeof(long));
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5L;
            }
        }
        data = dataBuffer;
    }
    myUnion.unionFirst = data;
    {
        long * data = myUnion.unionSecond;
        printLongLine(data[0]);
        
        free(data);
"
11242,0,CWE401_Memory_Leak__new_int_32.cpp,"    int * data;
    int * *dataPtr1 = &data;
    int * *dataPtr2 = &data;
    data = NULL;
    {
        int * data = *dataPtr1;
        
        data = new int;
        
        *data = 5;
        printIntLine(*data);
        *dataPtr1 = data;
    }
    {
        int * data = *dataPtr2;
        
        ; 
"
11767,0,CWE590_Free_Memory_Not_on_Heap__free_struct_static_11.c,"    twoIntsStruct * data;
    data = NULL; 
    if(globalReturnsTrue())
    {
        {
            
            static twoIntsStruct dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i].intOne = 1;
                    dataBuffer[i].intTwo = 1;
                }
            }
            data = dataBuffer;
        }
    }
    printStructLine(&data[0]);
    
"
7974,0,CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_81a.cpp,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    const CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_81_base& baseObject = CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_81_bad();
"
19019,0,CWE190_Integer_Overflow__int_rand_square_84a.cpp,"    int data;
    
    data = 0;
    CWE190_Integer_Overflow__int_rand_square_84_bad * badObject = new CWE190_Integer_Overflow__int_rand_square_84_bad(data);
"
15033,0,CWE197_Numeric_Truncation_Error__short_listen_socket_14.c,"    short data;
    
    data = -1;
    if(globalFive==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = (short)atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
8270,1,CWE758_Undefined_Behavior__struct_pointer_malloc_use_04.c,"    if(STATIC_CONST_TRUE)
    {
        {
            twoIntsStruct * data;
            twoIntsStruct * * pointer = (twoIntsStruct * *)malloc(sizeof(twoIntsStruct *));
            if (pointer == NULL) {exit(-1);}
            
            data = (twoIntsStruct *)malloc(sizeof(twoIntsStruct));
            if (data == NULL) {exit(-1);}
            data->intOne = 5;
            data->intTwo = 6;
            *pointer = data; 
            {
                twoIntsStruct * data = *pointer;
                printIntLine(data->intOne);
                printIntLine(data->intTwo);
            }
            free(pointer);
        }
"
9193,0,CWE590_Free_Memory_Not_on_Heap__delete_char_alloca_31.cpp,"    char * data;
    data = NULL; 
    {
        
        char * dataBuffer = (char *)ALLOCA(sizeof(char));
        *dataBuffer = 'A';
        data = dataBuffer;
    }
    {
        char * dataCopy = data;
        char * data = dataCopy;
        printHexCharLine(*data);
        
        delete data;
"
842,0,CWE457_Use_of_Uninitialized_Variable__struct_43.cpp,"    twoIntsStruct data;
    badSource(data);
    
    printIntLine(data.intOne);
"
12003,0,CWE563_Unused_Variable__unused_uninit_variable_long_81a.cpp,"    long data;
    
    ; 
    const CWE563_Unused_Variable__unused_uninit_variable_long_81_base& baseObject = CWE563_Unused_Variable__unused_uninit_variable_long_81_bad();
"
12652,0,CWE190_Integer_Overflow__int_max_postinc_18.c,"    int data;
    
    data = 0;
    goto source;
source:
    
    data = INT_MAX;
    goto sink;
sink:
    {
        
        data++;
        int result = data;
        printIntLine(result);
"
15786,0,CWE190_Integer_Overflow__unsigned_int_rand_add_43.cpp,"    unsigned int data;
    data = 0;
    badSource(data);
    {
        
        unsigned int result = data + 1;
        printUnsignedLine(result);
"
13415,0,CWE190_Integer_Overflow__char_max_preinc_34.c,"    char data;
    CWE190_Integer_Overflow__char_max_preinc_34_unionType myUnion;
    data = ' ';
    
    data = CHAR_MAX;
    myUnion.unionFirst = data;
    {
        char data = myUnion.unionSecond;
        {
            
            ++data;
            char result = data;
            printHexCharLine(result);
        }
"
17418,0,CWE563_Unused_Variable__unused_uninit_variable_int64_t_16.c,"    int64_t data;
    
    ; 
    while(1)
    {
        
        
        ; 
        break;
"
16929,0,CWE190_Integer_Overflow__short_fscanf_preinc_68a.c,"    short data;
    data = 0;
    
    fscanf (stdin, ""%hd"", &data);
    CWE190_Integer_Overflow__short_fscanf_preinc_68_badData = data;
"
18766,0,CWE563_Unused_Variable__unused_uninit_variable_int_84_bad.cpp,"Label Definition File: CWE563_Unused_Variable__unused_uninit_variable.label.xml
Template File: source-sinks-84_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 563 Unused Variable
 * BadSource:  Initialize data
 * Sinks:
 *    GoodSink: Initialize, then use data
 *    BadSink : Do nothing
 * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE563_Unused_Variable__unused_uninit_variable_int_84.h""

namespace CWE563_Unused_Variable__unused_uninit_variable_int_84
{
CWE563_Unused_Variable__unused_uninit_variable_int_84_bad::CWE563_Unused_Variable__unused_uninit_variable_int_84_bad(int dataCopy)
{
    data = dataCopy;
    
    ; 
}

CWE563_Unused_Variable__unused_uninit_variable_int_84_bad::~CWE563_Unused_Variable__unused_uninit_variable_int_84_bad()
{
    
    
    ; 
}
}
"
3160,0,CWE401_Memory_Leak__new_array_TwoIntsClass_63a.cpp,"    TwoIntsClass * data;
    data = NULL;
    
    data = new TwoIntsClass[100];
    
    data[0].intOne = 0;
    data[0].intTwo = 0;
    printIntLine(data[0].intOne);
    printIntLine(data[0].intTwo);
"
9697,0,CWE563_Unused_Variable__unused_uninit_variable_char_82_bad.cpp,"Label Definition File: CWE563_Unused_Variable__unused_uninit_variable.label.xml
Template File: source-sinks-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 563 Unused Variable
 * BadSource:  Initialize data
 * Sinks:
 *    GoodSink: Initialize, then use data
 *    BadSink : Do nothing
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE563_Unused_Variable__unused_uninit_variable_char_82.h""

namespace CWE563_Unused_Variable__unused_uninit_variable_char_82
{

void CWE563_Unused_Variable__unused_uninit_variable_char_82_bad::action(char data)
{
    
    
    ; 
}

}
"
14149,0,CWE690_NULL_Deref_From_Return__long_malloc_68a.c,"    long * data;
    data = NULL; 
    
    data = (long *)malloc(1*sizeof(long));
    CWE690_NULL_Deref_From_Return__long_malloc_68_badDataForBadSink = data;
"
2914,0,CWE190_Integer_Overflow__short_rand_square_53a.c,"    short data;
    data = 0;
    
    data = (short)RAND32();
"
8614,0,CWE190_Integer_Overflow__short_rand_multiply_83a.cpp,"    short data;
    data = 0;
"
3225,0,CWE190_Integer_Overflow__int_connect_socket_add_82a.cpp,"    int data;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    CWE190_Integer_Overflow__int_connect_socket_add_82_base* baseObject = new CWE190_Integer_Overflow__int_connect_socket_add_82_bad;
    baseObject->action(data);
"
2699,0,CWE369_Divide_by_Zero__int_fscanf_modulo_12.c,"    int data;
    
    data = -1;
    if(globalReturnsTrueOrFalse())
    {
        
        fscanf(stdin, ""%d"", &data);
    }
    else
    {
        
        data = 7;
    }
    if(globalReturnsTrueOrFalse())
    {
        
        printIntLine(100 % data);
    }
    else
    {
        
        if( data != 0 )
        {
            printIntLine(100 % data);
        }
        else
        {
            printLine(""This would result in a divide by zero"");
        }
"
16819,0,CWE190_Integer_Overflow__short_fscanf_multiply_03.c,"    short data;
    data = 0;
    if(5==5)
    {
        
        fscanf (stdin, ""%hd"", &data);
    }
    if(5==5)
    {
        if(data > 0) 
        {
            
            short result = data * 2;
            printIntLine(result);
        }
"
9195,0,CWE252_Unchecked_Return_Value__char_fputs_15.c,"    switch(6)
    {
    case 6:
        
        fputs(""string"", stdout);
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
15375,0,CWE252_Unchecked_Return_Value__char_scanf_15.c,"    switch(6)
    {
    case 6:
    {
        /* By initializing dataBuffer, we ensure this will not be the
         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
        char dataBuffer[100] = """";
        char * data = dataBuffer;
        
        scanf(""%99s\0"", data);
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
651,0,CWE197_Numeric_Truncation_Error__int_rand_to_char_65a.c,"    int data;
    
    void (*funcPtr) (int) = CWE197_Numeric_Truncation_Error__int_rand_to_char_65b_badSink;
    
    data = -1;
    
    data = RAND32();
    
"
6648,0,CWE190_Integer_Overflow__char_max_postinc_65a.c,"    char data;
    
    void (*funcPtr) (char) = CWE190_Integer_Overflow__char_max_postinc_65b_badSink;
    data = ' ';
    
    data = CHAR_MAX;
    
"
15751,0,CWE415_Double_Free__new_delete_class_31.cpp,"    TwoIntsClass * data;
    
    data = NULL;
    data = new TwoIntsClass;
    
    delete data;
    {
        TwoIntsClass * dataCopy = data;
        TwoIntsClass * data = dataCopy;
        
        delete data;
"
18908,0,CWE134_Uncontrolled_Format_String__char_console_snprintf_67a.c,"    char * data;
    CWE134_Uncontrolled_Format_String__char_console_snprintf_67_structType myStruct;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        
        if (100-dataLen > 1)
        {
            
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgets() */
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
                    data[dataLen-1] = '\0';
                }
            }
            else
            {
                printLine(""fgets() failed"");
                
                data[dataLen] = '\0';
            }
        }
    }
    myStruct.structFirst = data;
"
18892,0,CWE190_Integer_Overflow__int_fscanf_preinc_12.c,"    int data;
    
    data = 0;
    if(globalReturnsTrueOrFalse())
    {
        
        fscanf(stdin, ""%d"", &data);
    }
    else
    {
        
        data = 2;
    }
    if(globalReturnsTrueOrFalse())
    {
        {
            
            ++data;
            int result = data;
            printIntLine(result);
        }
    }
    else
    {
        
        if (data < INT_MAX)
        {
            ++data;
            int result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
"
11856,0,CWE457_Use_of_Uninitialized_Variable__new_struct_array_no_init_16.cpp,"    twoIntsStruct * data;
    data = new twoIntsStruct[10];
    while(1)
    {
        
        ; 
        break;
    }
    while(1)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i].intOne);
                printIntLine(data[i].intTwo);
            }
        }
        
        delete [] data;
        break;
"
14372,0,CWE369_Divide_by_Zero__int_zero_divide_68a.c,"    int data;
    
    data = -1;
    
    data = 0;
    CWE369_Divide_by_Zero__int_zero_divide_68_badData = data;
"
16071,0,CWE590_Free_Memory_Not_on_Heap__delete_long_static_64a.cpp,"    long * data;
    data = NULL; 
    {
        
        static long dataBuffer;
        dataBuffer = 5L;
        data = &dataBuffer;
    }
"
18344,0,CWE401_Memory_Leak__struct_twoIntsStruct_calloc_32.c,"    struct _twoIntsStruct * data;
    struct _twoIntsStruct * *dataPtr1 = &data;
    struct _twoIntsStruct * *dataPtr2 = &data;
    data = NULL;
    {
        struct _twoIntsStruct * data = *dataPtr1;
        
        data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));
        if (data == NULL) {exit(-1);}
        
        data[0].intOne = 0;
        data[0].intTwo = 0;
        printStructLine((twoIntsStruct *)&data[0]);
        *dataPtr1 = data;
    }
    {
        struct _twoIntsStruct * data = *dataPtr2;
        
        ; 
"
14136,0,CWE690_NULL_Deref_From_Return__long_calloc_15.c,"    long * data;
    data = NULL; 
    
    data = (long *)calloc(1, sizeof(long));
    switch(6)
    {
    case 6:
        
        data[0] = 5L;
        printLongLine(data[0]);
        free(data);
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
19128,0,CWE190_Integer_Overflow__int_rand_square_16.c,"    int data;
    
    data = 0;
    while(1)
    {
        
        data = RAND32();
        break;
    }
    while(1)
    {
        {
            
            int result = data * data;
            printIntLine(result);
        }
        break;
"
5487,0,CWE401_Memory_Leak__new_struct_twoIntsStruct_03.cpp,"    struct _twoIntsStruct * data;
    data = NULL;
    if(5==5)
    {
        
        data = new struct _twoIntsStruct;
        
        data->intOne = 0;
        data->intTwo = 0;
        printStructLine((twoIntsStruct *)data);
    }
    if(5==5)
    {
        
        ; 
"
16723,0,CWE416_Use_After_Free__new_delete_array_int64_t_03.cpp,"    int64_t * data;
    
    data = NULL;
    if(5==5)
    {
        data = new int64_t[100];
        {
            size_t i;
            for(i = 0; i < 100; i++)
            {
                data[i] = 5LL;
            }
        }
        
        delete [] data;
    }
    if(5==5)
    {
        
        printLongLongLine(data[0]);
        
"
3706,0,CWE190_Integer_Overflow__char_fscanf_preinc_21.c,"    char data;
    data = ' ';
    
    fscanf (stdin, ""%c"", &data);
    badStatic = 1; 
"
5473,0,CWE690_NULL_Deref_From_Return__int64_t_malloc_09.c,"    int64_t * data;
    data = NULL; 
    
    data = (int64_t *)malloc(1*sizeof(int64_t));
    if(GLOBAL_CONST_TRUE)
    {
        
        data[0] = 5LL;
        printLongLongLine(data[0]);
        free(data);
"
15335,1,CWE758_Undefined_Behavior__double_pointer_alloca_use_05.c,"    if(staticFalse)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            double * data;
            double * * pointer = (double * *)ALLOCA(sizeof(double *));
            
            data = (double *)malloc(sizeof(double));
            if (data == NULL) {exit(-1);}
            *data = 5.0;
            *pointer = data; 
            {
                double * data = *pointer;
                printDoubleLine(*data);
            }
        }
"
18666,0,CWE190_Integer_Overflow__int64_t_rand_multiply_53a.c,"    int64_t data;
    data = 0LL;
    
    data = (int64_t)RAND64();
"
16594,0,CWE690_NULL_Deref_From_Return__int64_t_calloc_11.c,"    int64_t * data;
    data = NULL; 
    
    data = (int64_t *)calloc(1, sizeof(int64_t));
    if(globalReturnsTrue())
    {
        
        data[0] = 5LL;
        printLongLongLine(data[0]);
        free(data);
"
11497,0,CWE590_Free_Memory_Not_on_Heap__free_struct_alloca_10.c,"    twoIntsStruct * data;
    data = NULL; 
    if(globalTrue)
    {
        {
            
            twoIntsStruct * dataBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i].intOne = 1;
                    dataBuffer[i].intTwo = 1;
                }
            }
            data = dataBuffer;
        }
    }
    printStructLine(&data[0]);
    
"
8567,0,CWE134_Uncontrolled_Format_String__char_console_vfprintf_04.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(STATIC_CONST_TRUE)
    {
        {
            
            size_t dataLen = strlen(data);
            
            if (100-dataLen > 1)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
                {
                    /* The next few lines remove the carriage return from the string that is
                     * inserted by fgets() */
                    dataLen = strlen(data);
                    if (dataLen > 0 && data[dataLen-1] == '\n')
                    {
                        data[dataLen-1] = '\0';
                    }
                }
                else
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
            }
        }
    }
    if(STATIC_CONST_TRUE)
    {
        badVaSinkB(data, data);
"
794,0,CWE78_OS_Command_Injection__char_file_popen_18.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    goto source;
source:
    {
        
        size_t dataLen = strlen(data);
        FILE * pFile;
        
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
    {
        FILE *pipe;
        
        pipe = POPEN(data, ""w"");
        if (pipe != NULL)
        {
            PCLOSE(pipe);
        }
"
10815,0,CWE197_Numeric_Truncation_Error__short_fgets_83a.cpp,"    short data;
    
    data = -1;
"
3859,0,CWE590_Free_Memory_Not_on_Heap__delete_int64_t_placement_new_72a.cpp,"    int64_t * data;
    vector<int64_t *> dataVector;
    data = NULL; 
    {
        
        char buffer[sizeof(int64_t)];
        int64_t * dataBuffer = new(buffer) int64_t;
        *dataBuffer = 5LL;
        data = dataBuffer;
    }
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
19493,0,CWE758_Undefined_Behavior__int_pointer_new_use_09.cpp,"    if(GLOBAL_CONST_TRUE)
    {
        {
            int * * pointer = new int *;
            int * data = *pointer; 
            delete pointer;
            printIntLine(*data);
        }
"
16685,0,CWE590_Free_Memory_Not_on_Heap__delete_class_declare_06.cpp,"    TwoIntsClass * data;
    data = NULL; 
    if(STATIC_CONST_FIVE==5)
    {
        {
            
            TwoIntsClass dataBuffer;
            dataBuffer.intOne = 1;
            dataBuffer.intTwo = 1;
            data = &dataBuffer;
        }
    }
    printIntLine(data->intOne);
    
"
13137,0,CWE134_Uncontrolled_Format_String__char_console_vprintf_41.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        
        if (100-dataLen > 1)
        {
            
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgets() */
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
                    data[dataLen-1] = '\0';
                }
            }
            else
            {
                printLine(""fgets() failed"");
                
                data[dataLen] = '\0';
            }
        }
    }
"
6179,0,CWE190_Integer_Overflow__int_fgets_preinc_12.c,"    int data;
    
    data = 0;
    if(globalReturnsTrueOrFalse())
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    else
    {
        
        data = 2;
    }
    if(globalReturnsTrueOrFalse())
    {
        {
            
            ++data;
            int result = data;
            printIntLine(result);
        }
    }
    else
    {
        
        if (data < INT_MAX)
        {
            ++data;
            int result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
"
17596,0,CWE369_Divide_by_Zero__int_listen_socket_divide_64a.c,"    int data;
    
    data = -1;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
10223,0,CWE369_Divide_by_Zero__int_rand_divide_62a.cpp,"    int data;
    
    data = -1;
    badSource(data);
    
"
13567,0,CWE590_Free_Memory_Not_on_Heap__delete_int_static_18.cpp,"    int * data;
    data = NULL; 
    goto source;
source:
    {
        
        static int dataBuffer;
        dataBuffer = 5;
        data = &dataBuffer;
    }
    printIntLine(*data);
    
"
15878,0,CWE590_Free_Memory_Not_on_Heap__delete_array_int_declare_54a.cpp,"    int * data;
    data = NULL; 
    {
        
        int dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5;
            }
        }
        data = dataBuffer;
    }
"
8879,0,CWE401_Memory_Leak__new_int_53a.cpp,"    int * data;
    data = NULL;
    
    data = new int;
    
    *data = 5;
    printIntLine(*data);
"
7276,0,CWE457_Use_of_Uninitialized_Variable__int_43.cpp,"    int data;
    badSource(data);
    
"
13871,0,CWE415_Double_Free__new_delete_array_int64_t_83_bad.cpp,"Label Definition File: CWE415_Double_Free__new_delete_array.label.xml
Template File: sources-sinks-83_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 415 Double Free
 * BadSource:  Allocate data using new and Deallocae data using delete
 * GoodSource: Allocate data using new
 * Sinks:
 *    GoodSink: do nothing
 *    BadSink : Deallocate data using delete
 * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE415_Double_Free__new_delete_array_int64_t_83.h""

namespace CWE415_Double_Free__new_delete_array_int64_t_83
{
CWE415_Double_Free__new_delete_array_int64_t_83_bad::CWE415_Double_Free__new_delete_array_int64_t_83_bad(int64_t * dataCopy)
{
    data = dataCopy;
    data = new int64_t[100];
    
    delete [] data;
}

CWE415_Double_Free__new_delete_array_int64_t_83_bad::~CWE415_Double_Free__new_delete_array_int64_t_83_bad()
{
    
    delete [] data;
}
}
"
4209,0,CWE190_Integer_Overflow__int_max_square_53a.c,"    int data;
    
    data = 0;
    
    data = INT_MAX;
"
8892,1,CWE758_Undefined_Behavior__double_pointer_malloc_use_04.c,"    if(STATIC_CONST_TRUE)
    {
        {
            double * data;
            double * * pointer = (double * *)malloc(sizeof(double *));
            if (pointer == NULL) {exit(-1);}
            
            data = (double *)malloc(sizeof(double));
            if (data == NULL) {exit(-1);}
            *data = 5.0;
            *pointer = data; 
            {
                double * data = *pointer;
                printDoubleLine(*data);
            }
            free(pointer);
        }
"
18310,0,CWE197_Numeric_Truncation_Error__int_fgets_to_short_72a.cpp,"    int data;
    vector<int> dataVector;
    
    data = -1;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
13478,0,CWE563_Unused_Variable__unused_value_long_83_bad.cpp,"Label Definition File: CWE563_Unused_Variable__unused_value.label.xml
Template File: sources-sinks-83_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 563 Unused Variable
 * BadSource:  Initialize data
 * GoodSource: Initialize and use data
 * Sinks:
 *    GoodSink: Use data
 *    BadSink : Initialize and use data
 * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE563_Unused_Variable__unused_value_long_83.h""

namespace CWE563_Unused_Variable__unused_value_long_83
{
CWE563_Unused_Variable__unused_value_long_83_bad::CWE563_Unused_Variable__unused_value_long_83_bad(long dataCopy)
{
    data = dataCopy;
    
    data = 5L;
}

CWE563_Unused_Variable__unused_value_long_83_bad::~CWE563_Unused_Variable__unused_value_long_83_bad()
{
    
    data = 10L;
    printLongLine(data);
}
}
"
7222,0,CWE416_Use_After_Free__new_delete_struct_09.cpp,"    twoIntsStruct * data;
    
    data = NULL;
    if(GLOBAL_CONST_TRUE)
    {
        data = new twoIntsStruct;
        data->intOne = 1;
        data->intTwo = 2;
        
        delete data;
    }
    if(GLOBAL_CONST_TRUE)
    {
        
        printStructLine(data);
        
"
13152,0,CWE190_Integer_Overflow__short_max_add_06.c,"    short data;
    data = 0;
    if(STATIC_CONST_FIVE==5)
    {
        
        data = SHRT_MAX;
    }
    if(STATIC_CONST_FIVE==5)
    {
        {
            
            short result = data + 1;
            printIntLine(result);
        }
"
10588,0,CWE78_OS_Command_Injection__char_environment_execlp_03.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(5==5)
    {
        {
            
            size_t dataLen = strlen(data);
            char * environment = GETENV(ENV_VARIABLE);
            
            if (environment != NULL)
            {
                
                strncat(data+dataLen, environment, 100-dataLen-1);
            }
        }
    }
    /* execlp - searches for the location of the command among
     * the directories specified by the PATH environment variable */
    
"
15820,0,CWE457_Use_of_Uninitialized_Variable__twointsclass_17.cpp,"    int i,j;
    TwoIntsClass data;
    for(i = 0; i < 1; i++)
    {
        
        ; 
    }
    for(j = 0; j < 1; j++)
    {
        
        printIntLine(data.intOne);
        printIntLine(data.intTwo);
"
5148,0,CWE190_Integer_Overflow__int_fgets_add_84a.cpp,"    int data;
    
    data = 0;
    CWE190_Integer_Overflow__int_fgets_add_84_bad * badObject = new CWE190_Integer_Overflow__int_fgets_add_84_bad(data);
"
2055,1,CWE252_Unchecked_Return_Value__char_fputc_08.c,"    if(staticReturnsTrue())
    {
        
        if (fputc((int)'A', stdout) == EOF)
        {
            printLine(""fputc failed!"");
        }
"
6013,0,CWE415_Double_Free__malloc_free_struct_08.c,"    twoIntsStruct * data;
    
    data = NULL;
    if(staticReturnsTrue())
    {
        data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
        if (data == NULL) {exit(-1);}
        
        free(data);
    }
    if(staticReturnsTrue())
    {
        
        free(data);
"
695,0,CWE190_Integer_Overflow__unsigned_int_fscanf_square_44.c,"    unsigned int data;
    
    void (*funcPtr) (unsigned int) = badSink;
    data = 0;
    
    fscanf (stdin, ""%u"", &data);
    
"
4120,0,CWE590_Free_Memory_Not_on_Heap__delete_array_long_alloca_02.cpp,"    long * data;
    data = NULL; 
    if(1)
    {
        {
            
            long * dataBuffer = (long *)ALLOCA(100*sizeof(long));
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5L;
                }
            }
            data = dataBuffer;
        }
    }
    printLongLine(data[0]);
    
"
11367,0,CWE190_Integer_Overflow__int_fgets_add_83_bad.cpp,"Label Definition File: CWE190_Integer_Overflow__int.label.xml
Template File: sources-sinks-83_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 190 Integer Overflow
 * BadSource: fgets Read data from the console using fgets()
 * GoodSource: Set data to a small, non-zero number (two)
 * Sinks: add
 *    GoodSink: Ensure there will not be an overflow before adding 1 to data
 *    BadSink : Add 1 to data, which can cause an overflow
 * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE190_Integer_Overflow__int_fgets_add_83.h""

#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)

namespace CWE190_Integer_Overflow__int_fgets_add_83
{
CWE190_Integer_Overflow__int_fgets_add_83_bad::CWE190_Integer_Overflow__int_fgets_add_83_bad(int dataCopy)
{
    data = dataCopy;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
}

CWE190_Integer_Overflow__int_fgets_add_83_bad::~CWE190_Integer_Overflow__int_fgets_add_83_bad()
{
    {
        
        int result = data + 1;
        printIntLine(result);
    }
}
}
"
19401,0,CWE190_Integer_Overflow__int_connect_socket_square_81_bad.cpp,"Label Definition File: CWE190_Integer_Overflow__int.label.xml
Template File: sources-sinks-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 190 Integer Overflow
 * BadSource: connect_socket Read data using a connect socket (client side)
 * GoodSource: Set data to a small, non-zero number (two)
 * Sinks: square
 *    GoodSink: Ensure there will not be an overflow before squaring data
 *    BadSink : Square data, which can lead to overflow
 * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE190_Integer_Overflow__int_connect_socket_square_81.h""

#include <math.h>

namespace CWE190_Integer_Overflow__int_connect_socket_square_81
{

void CWE190_Integer_Overflow__int_connect_socket_square_81_bad::action(int data) const
{
    {
        
        int result = data * data;
        printIntLine(result);
    }
}

}
"
6171,0,CWE190_Integer_Overflow__int_fgets_postinc_08.c,"    int data;
    
    data = 0;
    if(staticReturnsTrue())
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    if(staticReturnsTrue())
    {
        {
            
            data++;
            int result = data;
            printIntLine(result);
        }
"
9696,0,CWE78_OS_Command_Injection__char_console_system_08.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(staticReturnsTrue())
    {
        {
            
            size_t dataLen = strlen(data);
            
            if (100-dataLen > 1)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
                {
                    /* The next few lines remove the carriage return from the string that is
                     * inserted by fgets() */
                    dataLen = strlen(data);
"
14814,0,CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_81_bad.cpp,"Label Definition File: CWE789_Uncontrolled_Mem_Alloc__new.label.xml
Template File: sources-sinks-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: fscanf Read data from the console using fscanf()
 * GoodSource: Small number greater than zero
 * Sinks:
 *    GoodSink: Allocate memory with new [] and check the size of the memory to be allocated
 *    BadSink : Allocate memory with new [], but incorrectly check the size of the memory to be allocated
 * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_81.h""

#define HELLO_STRING ""hello""

namespace CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_81
{

void CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_81_bad::action(size_t data) const
{
    {
        char * myString;
        /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
         * for the strcpy() function to not cause a buffer overflow */
        
        if (data > strlen(HELLO_STRING))
        {
            myString = new char[data];
            
            strcpy(myString, HELLO_STRING);
            printLine(myString);
            delete [] myString;
        }
        else
        {
            printLine(""Input is less than the length of the source string"");
        }
    }
}

}
"
3031,0,CWE190_Integer_Overflow__int_connect_socket_add_42.c,"    int data;
    
    data = 0;
    data = badSource(data);
    {
        
        int result = data + 1;
        printIntLine(result);
"
18905,0,CWE590_Free_Memory_Not_on_Heap__delete_array_int64_t_declare_14.cpp,"    int64_t * data;
    data = NULL; 
    if(globalFive==5)
    {
        {
            
            int64_t dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5LL;
                }
            }
            data = dataBuffer;
        }
    }
    printLongLongLine(data[0]);
    
"
2992,0,CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_82a.cpp,"    int data;
    
    data = -1;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_82_base* baseObject = new CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_82_bad;
    baseObject->action(data);
"
7412,0,CWE789_Uncontrolled_Mem_Alloc__new_char_fgets_42.cpp,"    size_t data;
    
    data = 0;
    data = badSource(data);
    {
        char * myString;
        /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
         * for the strcpy() function to not cause a buffer overflow */
        
        if (data > strlen(HELLO_STRING))
        {
            myString = new char[data];
            
            strcpy(myString, HELLO_STRING);
            printLine(myString);
            delete [] myString;
        }
        else
        {
            printLine(""Input is less than the length of the source string"");
        }
"
241,0,CWE758_Undefined_Behavior__struct_pointer_alloca_use_09.c,"    if(GLOBAL_CONST_TRUE)
    {
        {
            twoIntsStruct * * pointer = (twoIntsStruct * *)ALLOCA(sizeof(twoIntsStruct *));
            twoIntsStruct * data = *pointer; 
            printIntLine(data->intOne);
            printIntLine(data->intTwo);
        }
"
3289,0,CWE789_Uncontrolled_Mem_Alloc__new_char_listen_socket_17.cpp,"    int i,j;
    size_t data;
    
    data = 0;
    for(i = 0; i < 1; i++)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = strtoul(inputBuffer, NULL, 0);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    for(j = 0; j < 1; j++)
    {
        {
            char * myString;
            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
             * for the strcpy() function to not cause a buffer overflow */
            
            if (data > strlen(HELLO_STRING))
            {
                myString = new char[data];
                
                strcpy(myString, HELLO_STRING);
                printLine(myString);
                delete [] myString;
            }
            else
            {
                printLine(""Input is less than the length of the source string"");
            }
        }
"
18688,1,CWE252_Unchecked_Return_Value__char_fgets_07.c,"    if(staticFive==5)
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            printLine(""Please enter a string: "");
            
            if (fgets(data, 100, stdin) == NULL)
            {
                printLine(""fgets failed!"");
                exit(1);
            }
            printLine(data);
        }
"
10544,0,CWE590_Free_Memory_Not_on_Heap__delete_char_declare_82a.cpp,"    char * data;
    data = NULL; 
    {
        
        char dataBuffer;
        dataBuffer = 'A';
        data = &dataBuffer;
    }
    CWE590_Free_Memory_Not_on_Heap__delete_char_declare_82_base* baseObject = new CWE590_Free_Memory_Not_on_Heap__delete_char_declare_82_bad;
    baseObject->action(data);
"
8287,0,CWE690_NULL_Deref_From_Return__char_malloc_31.c,"    char * data;
    data = NULL; 
    
    data = (char *)malloc(20*sizeof(char));
    {
        char * dataCopy = data;
        char * data = dataCopy;
        
        strcpy(data, ""Initialize"");
        printLine(data);
        free(data);
"
15521,0,CWE369_Divide_by_Zero__int_fgets_divide_63a.c,"    int data;
    
    data = -1;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
"
11954,0,CWE758_Undefined_Behavior__struct_pointer_malloc_use_11.c,"    if(globalReturnsTrue())
    {
        {
            twoIntsStruct * * pointer = (twoIntsStruct * *)malloc(sizeof(twoIntsStruct *));
            if (pointer == NULL) {exit(-1);}
            twoIntsStruct * data = *pointer; 
            free(pointer);
            printIntLine(data->intOne);
            printIntLine(data->intTwo);
        }
"
15360,0,CWE369_Divide_by_Zero__int_listen_socket_divide_83_bad.cpp,"Label Definition File: CWE369_Divide_by_Zero__int.label.xml
Template File: sources-sinks-83_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 369 Divide by Zero
 * BadSource: listen_socket Read data using a listen socket (server side)
 * GoodSource: Non-zero
 * Sinks: divide
 *    GoodSink: Check for zero before dividing
 *    BadSink : Divide a constant by data
 * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE369_Divide_by_Zero__int_listen_socket_divide_83.h""

#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif

#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)

namespace CWE369_Divide_by_Zero__int_listen_socket_divide_83
{
CWE369_Divide_by_Zero__int_listen_socket_divide_83_bad::CWE369_Divide_by_Zero__int_listen_socket_divide_83_bad(int dataCopy)
{
    data = dataCopy;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
}

CWE369_Divide_by_Zero__int_listen_socket_divide_83_bad::~CWE369_Divide_by_Zero__int_listen_socket_divide_83_bad()
{
    
    printIntLine(100 / data);
}
}
"
17389,0,CWE563_Unused_Variable__unused_value_int_18.c,"    int data;
    goto source;
source:
    
    data = 5;
    goto sink;
sink:
    
    data = 10;
"
16447,0,CWE590_Free_Memory_Not_on_Heap__free_char_static_54a.c,"    char * data;
    data = NULL; 
    {
        
        static char dataBuffer[100];
        memset(dataBuffer, 'A', 100-1); 
        dataBuffer[100-1] = '\0'; 
        data = dataBuffer;
    }
"
925,1,CWE758_Undefined_Behavior__struct_pointer_alloca_use_11.c,"    if(globalReturnsFalse())
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            twoIntsStruct * data;
            twoIntsStruct * * pointer = (twoIntsStruct * *)ALLOCA(sizeof(twoIntsStruct *));
            
            data = (twoIntsStruct *)malloc(sizeof(twoIntsStruct));
            if (data == NULL) {exit(-1);}
            data->intOne = 5;
            data->intTwo = 6;
            *pointer = data; 
            {
                twoIntsStruct * data = *pointer;
                printIntLine(data->intOne);
                printIntLine(data->intTwo);
            }
        }
"
6204,0,CWE190_Integer_Overflow__int64_t_fscanf_multiply_65a.c,"    int64_t data;
    
    void (*funcPtr) (int64_t) = CWE190_Integer_Overflow__int64_t_fscanf_multiply_65b_badSink;
    data = 0LL;
    
    fscanf (stdin, ""%"" SCNd64, &data);
    
"
8747,0,CWE590_Free_Memory_Not_on_Heap__free_int_static_09.c,"    int * data;
    data = NULL; 
    if(GLOBAL_CONST_TRUE)
    {
        {
            
            static int dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5;
                }
            }
            data = dataBuffer;
        }
    }
    printIntLine(data[0]);
    
"
7330,0,CWE190_Integer_Overflow__int_max_postinc_41.c,"    int data;
    
    data = 0;
    
    data = INT_MAX;
"
15283,0,CWE190_Integer_Overflow__int_fgets_multiply_17.c,"    int i,j;
    int data;
    
    data = 0;
    for(i = 0; i < 1; i++)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    for(j = 0; j < 1; j++)
    {
        if(data > 0) 
        {
            
            int result = data * 2;
            printIntLine(result);
        }
"
18457,0,CWE369_Divide_by_Zero__int_fgets_modulo_17.c,"    int i,j;
    int data;
    
    data = -1;
    for(i = 0; i < 1; i++)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    for(j = 0; j < 1; j++)
    {
        
        printIntLine(100 % data);
"
16161,0,CWE134_Uncontrolled_Format_String__char_listen_socket_printf_14.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(globalFive==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                data[dataLen + recvResult / sizeof(char)] = '\0';
                
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(globalFive==5)
    {
        
        printf(data);
"
7326,0,CWE401_Memory_Leak__strdup_char_02.c,"    char * data;
    data = NULL;
    if(1)
    {
        {
            char myString[] = ""myString"";
            
            data = strdup(myString);
            
            printLine(data);
        }
    }
    if(1)
    {
        
        
        ; 
"
3503,0,CWE590_Free_Memory_Not_on_Heap__delete_array_int64_t_static_10.cpp,"    int64_t * data;
    data = NULL; 
    if(globalTrue)
    {
        {
            
            static int64_t dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5LL;
                }
            }
            data = dataBuffer;
        }
    }
    printLongLongLine(data[0]);
    
"
9232,0,CWE758_Undefined_Behavior__class_new_use_09.cpp,"    if(GLOBAL_CONST_TRUE)
    {
        {
            TwoIntsClass * pointer = new TwoIntsClass;
            TwoIntsClass data = *pointer; 
            delete pointer;
            printIntLine(data.intOne);
            printIntLine(data.intTwo);
        }
"
661,0,CWE369_Divide_by_Zero__int_fscanf_divide_53a.c,"    int data;
    
    data = -1;
    
    fscanf(stdin, ""%d"", &data);
"
13418,0,CWE590_Free_Memory_Not_on_Heap__free_int64_t_static_11.c,"    int64_t * data;
    data = NULL; 
    if(globalReturnsTrue())
    {
        {
            
            static int64_t dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5LL;
                }
            }
            data = dataBuffer;
        }
    }
    printLongLongLine(data[0]);
    
"
7669,0,CWE457_Use_of_Uninitialized_Variable__struct_array_alloca_no_init_05.c,"    twoIntsStruct * data;
    data = (twoIntsStruct *)ALLOCA(10*sizeof(twoIntsStruct));
    if(staticTrue)
    {
        
        ; 
    }
    if(staticTrue)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i].intOne);
                printIntLine(data[i].intTwo);
            }
        }
"
9452,1,CWE252_Unchecked_Return_Value__char_scanf_07.c,"    if(staticFive==5)
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            
            if (scanf(""%99s\0"", data) == EOF)
            {
                printLine(""scanf failed!"");
            }
        }
"
6163,0,CWE190_Integer_Overflow__short_fscanf_add_06.c,"    short data;
    data = 0;
    if(STATIC_CONST_FIVE==5)
    {
        
        fscanf (stdin, ""%hd"", &data);
    }
    if(STATIC_CONST_FIVE==5)
    {
        {
            
            short result = data + 1;
            printIntLine(result);
        }
"
18697,0,CWE415_Double_Free__new_delete_long_17.cpp,"    int i,j;
    long * data;
    
    data = NULL;
    for(i = 0; i < 1; i++)
    {
        data = new long;
        
        delete data;
    }
    for(j = 0; j < 1; j++)
    {
        
        delete data;
"
17126,0,CWE190_Integer_Overflow__char_rand_add_45.c,"    char data;
    data = ' ';
    
    data = (char)RAND32();
    CWE190_Integer_Overflow__char_rand_add_45_badData = data;
"
10361,1,CWE476_NULL_Pointer_Dereference__deref_after_check_12.c,"    if(globalReturnsTrueOrFalse())
    {
        {
            
            int *intPointer = NULL;
            if (intPointer == NULL)
            {
                printLine(""pointer is NULL"");
            }
        }
    }
    else
    {
        {
            
            int *intPointer = NULL;
            if (intPointer == NULL)
            {
                printLine(""pointer is NULL"");
            }
        }
"
10896,0,CWE369_Divide_by_Zero__float_rand_61a.c,"    float data;
    
    data = 0.0F;
    data = CWE369_Divide_by_Zero__float_rand_61b_badSource(data);
    {
        
        int result = (int)(100.0 / data);
        printIntLine(result);
"
763,0,CWE369_Divide_by_Zero__float_fscanf_18.c,"    float data;
    
    data = 0.0F;
    goto source;
source:
    
    fscanf (stdin, ""%f"", &data);
    goto sink;
sink:
    {
        
        int result = (int)(100.0 / data);
        printIntLine(result);
"
9896,0,CWE369_Divide_by_Zero__float_listenSocket_54a.c,"    float data;
    
    data = 0.0F;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = (float)atof(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
16344,0,CWE190_Integer_Overflow__short_rand_square_08.c,"    short data;
    data = 0;
    if(staticReturnsTrue())
    {
        
        data = (short)RAND32();
    }
    if(staticReturnsTrue())
    {
        {
            
            short result = data * data;
            printIntLine(result);
        }
"
8695,0,CWE401_Memory_Leak__struct_twoIntsStruct_realloc_81_bad.cpp,"Label Definition File: CWE401_Memory_Leak.c.label.xml
Template File: sources-sinks-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 401 Memory Leak
 * BadSource: realloc Allocate data using realloc()
 * GoodSource: Allocate data on the stack
 * Sinks:
 *    GoodSink: call free() on data
 *    BadSink : no deallocation of data
 * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE401_Memory_Leak__struct_twoIntsStruct_realloc_81.h""

namespace CWE401_Memory_Leak__struct_twoIntsStruct_realloc_81
{

void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_81_bad::action(struct _twoIntsStruct * data) const
{
    
    ; 
}

}
"
16324,0,CWE590_Free_Memory_Not_on_Heap__delete_char_static_08.cpp,"    char * data;
    data = NULL; 
    if(staticReturnsTrue())
    {
        {
            
            static char dataBuffer;
            dataBuffer = 'A';
            data = &dataBuffer;
        }
    }
    printHexCharLine(*data);
    
"
13393,0,CWE416_Use_After_Free__malloc_free_long_13.c,"    long * data;
    
    data = NULL;
    if(GLOBAL_CONST_FIVE==5)
    {
        data = (long *)malloc(100*sizeof(long));
        if (data == NULL) {exit(-1);}
        {
            size_t i;
            for(i = 0; i < 100; i++)
            {
                data[i] = 5L;
            }
        }
        
        free(data);
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        
        printLongLine(data[0]);
        
"
11066,0,CWE690_NULL_Deref_From_Return__int_realloc_10.c,"    int * data;
    data = NULL; 
    
    data = (int *)realloc(data, 1*sizeof(int));
    if(globalTrue)
    {
        
        data[0] = 5;
        printIntLine(data[0]);
        free(data);
"
3170,0,CWE415_Double_Free__malloc_free_long_74a.cpp,"    long * data;
    map<int, long *> dataMap;
    
    data = NULL;
    data = (long *)malloc(100*sizeof(long));
    if (data == NULL) {exit(-1);}
    
    free(data);
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
17619,0,CWE690_NULL_Deref_From_Return__struct_realloc_15.c,"    twoIntsStruct * data;
    data = NULL; 
    
    data = (twoIntsStruct *)realloc(data, 1*sizeof(twoIntsStruct));
    switch(6)
    {
    case 6:
        
        data[0].intOne = 1;
        data[0].intTwo = 1;
        printStructLine(&data[0]);
        free(data);
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
1665,0,CWE457_Use_of_Uninitialized_Variable__struct_07.c,"    twoIntsStruct data;
    if(staticFive==5)
    {
        
        ; 
    }
    if(staticFive==5)
    {
        
        printIntLine(data.intOne);
        printIntLine(data.intTwo);
"
11895,0,CWE190_Integer_Overflow__unsigned_int_rand_multiply_07.c,"    unsigned int data;
    data = 0;
    if(staticFive==5)
    {
        
        data = (unsigned int)RAND32();
    }
    if(staticFive==5)
    {
        if(data > 0) 
        {
            
            unsigned int result = data * 2;
            printUnsignedLine(result);
        }
"
7148,0,CWE190_Integer_Overflow__int_listen_socket_multiply_07.c,"    int data;
    
    data = 0;
    if(staticFive==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(staticFive==5)
    {
        if(data > 0) 
        {
            
            int result = data * 2;
            printIntLine(result);
        }
"
4566,0,CWE78_OS_Command_Injection__char_file_execl_72a.cpp,"    char * data;
    vector<char *> dataVector;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        FILE * pFile;
        
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
6703,1,CWE758_Undefined_Behavior__double_pointer_malloc_use_07.c,"    if(staticFive==5)
    {
        {
            double * data;
            double * * pointer = (double * *)malloc(sizeof(double *));
            if (pointer == NULL) {exit(-1);}
            
            data = (double *)malloc(sizeof(double));
            if (data == NULL) {exit(-1);}
            *data = 5.0;
            *pointer = data; 
            {
                double * data = *pointer;
                printDoubleLine(*data);
            }
            free(pointer);
        }
"
586,0,CWE190_Integer_Overflow__unsigned_int_rand_square_15.c,"    unsigned int data;
    data = 0;
    switch(6)
    {
    case 6:
        
        data = (unsigned int)RAND32();
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
    {
        
        unsigned int result = data * data;
        printUnsignedLine(result);
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
573,0,CWE415_Double_Free__new_delete_array_class_10.cpp,"    TwoIntsClass * data;
    
    data = NULL;
    if(globalTrue)
    {
        data = new TwoIntsClass[100];
        
        delete [] data;
    }
    if(globalTrue)
    {
        
        delete [] data;
"
421,0,CWE415_Double_Free__malloc_free_int64_t_62a.cpp,"    int64_t * data;
    
    data = NULL;
    badSource(data);
    
"
9762,1,CWE758_Undefined_Behavior__int_pointer_alloca_use_11.c,"    if(globalReturnsFalse())
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            int * data;
            int * * pointer = (int * *)ALLOCA(sizeof(int *));
            
            data = (int *)malloc(sizeof(int));
            if (data == NULL) {exit(-1);}
            *data = 5;
            *pointer = data; 
            {
                int * data = *pointer;
                printIntLine(*data);
            }
        }
"
19323,0,CWE401_Memory_Leak__new_TwoIntsClass_65a.cpp,"    TwoIntsClass * data;
    
    void (*funcPtr) (TwoIntsClass *) = badSink;
    data = NULL;
    
    data = new TwoIntsClass;
    
    data->intOne = 0;
    data->intTwo = 0;
    printIntLine(data->intOne);
    printIntLine(data->intTwo);
    
"
2976,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_84a.cpp,"    size_t data;
    
    data = 0;
    CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_84_bad * badObject = new CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_84_bad(data);
"
13560,0,CWE590_Free_Memory_Not_on_Heap__delete_struct_alloca_17.cpp,"    int i;
    twoIntsStruct * data;
    data = NULL; 
    for(i = 0; i < 1; i++)
    {
        {
            
            twoIntsStruct * dataBuffer = (twoIntsStruct *)ALLOCA(sizeof(twoIntsStruct));
            dataBuffer->intOne = 1;
            dataBuffer->intTwo = 1;
            data = dataBuffer;
        }
    }
    printStructLine(data);
    
"
16299,0,CWE563_Unused_Variable__unused_init_variable_struct_09.c,"    twoIntsStruct data;
    
    data.intOne = 0;
    data.intTwo = 0;
    if(GLOBAL_CONST_TRUE)
    {
        
        
        ; 
"
12970,0,CWE590_Free_Memory_Not_on_Heap__delete_array_class_static_05.cpp,"    TwoIntsClass * data;
    data = NULL; 
    if(staticTrue)
    {
        {
            
            static TwoIntsClass dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i].intOne = 1;
                    dataBuffer[i].intTwo = 1;
                }
            }
            data = dataBuffer;
        }
    }
    printIntLine(data[0].intOne);
    
"
12880,0,CWE190_Integer_Overflow__int_rand_square_32.c,"    int data;
    int *dataPtr1 = &data;
    int *dataPtr2 = &data;
    
    data = 0;
    {
        int data = *dataPtr1;
        
        data = RAND32();
        *dataPtr1 = data;
    }
    {
        int data = *dataPtr2;
        {
            
            int result = data * data;
            printIntLine(result);
        }
"
1527,0,CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_51a.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
18348,0,CWE190_Integer_Overflow__int_connect_socket_postinc_22a.c,"    int data;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    CWE190_Integer_Overflow__int_connect_socket_postinc_22_badGlobal = 1; 
"
7911,0,CWE134_Uncontrolled_Format_String__char_console_vfprintf_10.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(globalTrue)
    {
        {
            
            size_t dataLen = strlen(data);
            
            if (100-dataLen > 1)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
                {
                    /* The next few lines remove the carriage return from the string that is
                     * inserted by fgets() */
                    dataLen = strlen(data);
                    if (dataLen > 0 && data[dataLen-1] == '\n')
                    {
                        data[dataLen-1] = '\0';
                    }
                }
                else
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
            }
        }
    }
    if(globalTrue)
    {
        badVaSinkB(data, data);
"
4842,0,CWE190_Integer_Overflow__int_listen_socket_add_31.c,"    int data;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    {
        int dataCopy = data;
        int data = dataCopy;
        {
            
            int result = data + 1;
            printIntLine(result);
        }
"
15091,0,CWE415_Double_Free__new_delete_array_struct_22a.cpp,"    twoIntsStruct * data;
    
    data = NULL;
    data = new twoIntsStruct[100];
    
    delete [] data;
    badGlobal = 1; 
"
2650,0,CWE457_Use_of_Uninitialized_Variable__int_array_alloca_partial_init_17.c,"    int i,j;
    int * data;
    data = (int *)ALLOCA(10*sizeof(int));
    for(i = 0; i < 1; i++)
    {
        
        {
            int i;
            for(i=0; i<(10/2); i++)
            {
                data[i] = i;
            }
        }
    }
    for(j = 0; j < 1; j++)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i]);
            }
        }
"
13996,0,CWE197_Numeric_Truncation_Error__int_listen_socket_to_char_84a.cpp,"    int data;
    
    data = -1;
    CWE197_Numeric_Truncation_Error__int_listen_socket_to_char_84_bad * badObject = new CWE197_Numeric_Truncation_Error__int_listen_socket_to_char_84_bad(data);
"
9643,0,CWE690_NULL_Deref_From_Return__struct_realloc_82_bad.cpp,"Label Definition File: CWE690_NULL_Deref_From_Return.free.label.xml
Template File: source-sinks-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 690 Unchecked Return Value To NULL Pointer
 * BadSource: realloc Allocate data using realloc()
 * Sinks:
 *    GoodSink: Check to see if the data allocation failed and if not, use data
 *    BadSink : Don't check for NULL and use data
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE690_NULL_Deref_From_Return__struct_realloc_82.h""

namespace CWE690_NULL_Deref_From_Return__struct_realloc_82
{

void CWE690_NULL_Deref_From_Return__struct_realloc_82_bad::action(twoIntsStruct * data)
{
    
    data[0].intOne = 1;
    data[0].intTwo = 1;
    printStructLine(&data[0]);
    free(data);
}

}
"
16150,0,CWE369_Divide_by_Zero__int_rand_modulo_14.c,"    int data;
    
    data = -1;
    if(globalFive==5)
    {
        
        data = RAND32();
    }
    if(globalFive==5)
    {
        
        printIntLine(100 % data);
"
8797,0,CWE197_Numeric_Truncation_Error__int_rand_to_short_67a.c,"    int data;
    CWE197_Numeric_Truncation_Error__int_rand_to_short_67_structType myStruct;
    
    data = -1;
    
    data = RAND32();
    myStruct.structFirst = data;
"
13120,0,CWE758_Undefined_Behavior__char_pointer_malloc_use_17.c,"    int j;
    for(j = 0; j < 1; j++)
    {
        {
            char * * pointer = (char * *)malloc(sizeof(char *));
            if (pointer == NULL) {exit(-1);}
            char * data = *pointer; 
            free(pointer);
            printLine(data);
        }
"
5196,0,CWE190_Integer_Overflow__short_rand_square_84_bad.cpp,"Label Definition File: CWE190_Integer_Overflow.label.xml
Template File: sources-sinks-84_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 190 Integer Overflow
 * BadSource: rand Set data to result of rand()
 * GoodSource: Set data to a small, non-zero number (two)
 * Sinks: square
 *    GoodSink: Ensure there will not be an overflow before squaring data
 *    BadSink : Square data, which can lead to overflow
 * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE190_Integer_Overflow__short_rand_square_84.h""

#include <math.h>

namespace CWE190_Integer_Overflow__short_rand_square_84
{
CWE190_Integer_Overflow__short_rand_square_84_bad::CWE190_Integer_Overflow__short_rand_square_84_bad(short dataCopy)
{
    data = dataCopy;
    
    data = (short)RAND32();
}

CWE190_Integer_Overflow__short_rand_square_84_bad::~CWE190_Integer_Overflow__short_rand_square_84_bad()
{
    {
        
        short result = data * data;
        printIntLine(result);
    }
}
}
"
12885,0,CWE590_Free_Memory_Not_on_Heap__delete_int64_t_placement_new_34.cpp,"    int64_t * data;
    unionType myUnion;
    data = NULL; 
    {
        
        char buffer[sizeof(int64_t)];
        int64_t * dataBuffer = new(buffer) int64_t;
        *dataBuffer = 5LL;
        data = dataBuffer;
    }
    myUnion.unionFirst = data;
    {
        int64_t * data = myUnion.unionSecond;
        printLongLongLine(*data);
        
        delete data;
"
8773,0,CWE690_NULL_Deref_From_Return__struct_malloc_63a.c,"    twoIntsStruct * data;
    data = NULL; 
    
    data = (twoIntsStruct *)malloc(1*sizeof(twoIntsStruct));
"
14922,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_72a.cpp,"    size_t data;
    vector<size_t> dataVector;
    
    data = 0;
    
    data = rand();
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
4530,1,CWE758_Undefined_Behavior__int_malloc_use_13.c,"    if(GLOBAL_CONST_FIVE!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            int data;
            int * pointer = (int *)malloc(sizeof(int));
            if (pointer == NULL) {exit(-1);}
            data = 5;
            *pointer = data; 
            {
                int data = *pointer;
                printIntLine(data);
            }
            free(pointer);
        }
"
2748,1,CWE758_Undefined_Behavior__int_new_use_14.cpp,"    if(globalFive!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            int data;
            data = 5;
            int * pointer = new int;
            *pointer = data; 
            {
                int data = *pointer;
                printIntLine(data);
            }
            delete pointer;
        }
"
3708,1,CWE252_Unchecked_Return_Value__char_snprintf_11.c,"    if(globalReturnsFalse())
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            
            if (SNPRINTF(data,100-strlen(SRC)-1, ""%s\n"", SRC) < 0)
            {
                printLine(""snprintf failed!"");
            }
        }
"
9565,1,CWE252_Unchecked_Return_Value__char_fwrite_10.c,"    if(globalTrue)
    {
        
        if (fwrite((char *)""string"", sizeof(char), strlen(""string""), stdout) != strlen(""string""))
        {
            printLine(""fwrite failed!"");
        }
"
2007,0,CWE252_Unchecked_Return_Value__char_fprintf_05.c,"    if(staticTrue)
    {
        
        fprintf(stdout, ""%s\n"", ""string"");
"
7360,0,CWE401_Memory_Leak__struct_twoIntsStruct_realloc_82a.cpp,"    struct _twoIntsStruct * data;
    data = NULL;
    
    data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));
    if (data == NULL) {exit(-1);}
    
    data[0].intOne = 0;
    data[0].intTwo = 0;
    printStructLine((twoIntsStruct *)&data[0]);
    CWE401_Memory_Leak__struct_twoIntsStruct_realloc_82_base* baseObject = new CWE401_Memory_Leak__struct_twoIntsStruct_realloc_82_bad;
    baseObject->action(data);
"
11983,0,CWE190_Integer_Overflow__int_fscanf_preinc_52a.c,"    int data;
    
    data = 0;
    
    fscanf(stdin, ""%d"", &data);
"
16464,0,CWE690_NULL_Deref_From_Return__long_malloc_83_bad.cpp,"Label Definition File: CWE690_NULL_Deref_From_Return.free.label.xml
Template File: source-sinks-83_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 690 Unchecked Return Value To NULL Pointer
 * BadSource: malloc Allocate data using malloc()
 * Sinks:
 *    GoodSink: Check to see if the data allocation failed and if not, use data
 *    BadSink : Don't check for NULL and use data
 * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE690_NULL_Deref_From_Return__long_malloc_83.h""

namespace CWE690_NULL_Deref_From_Return__long_malloc_83
{
CWE690_NULL_Deref_From_Return__long_malloc_83_bad::CWE690_NULL_Deref_From_Return__long_malloc_83_bad(long * dataCopy)
{
    data = dataCopy;
    
    data = (long *)malloc(1*sizeof(long));
}

CWE690_NULL_Deref_From_Return__long_malloc_83_bad::~CWE690_NULL_Deref_From_Return__long_malloc_83_bad()
{
    
    data[0] = 5L;
    printLongLine(data[0]);
    free(data);
}
}
"
9097,0,CWE563_Unused_Variable__unused_value_struct_82_bad.cpp,"Label Definition File: CWE563_Unused_Variable__unused_value.label.xml
Template File: sources-sinks-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 563 Unused Variable
 * BadSource:  Initialize data
 * GoodSource: Initialize and use data
 * Sinks:
 *    GoodSink: Use data
 *    BadSink : Initialize and use data
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE563_Unused_Variable__unused_value_struct_82.h""

namespace CWE563_Unused_Variable__unused_value_struct_82
{

void CWE563_Unused_Variable__unused_value_struct_82_bad::action(twoIntsStruct data)
{
    
    data.intOne = 1;
    data.intTwo = 1;
    printStructLine(&data);
}

}
"
1712,0,CWE590_Free_Memory_Not_on_Heap__delete_array_struct_declare_68a.cpp,"    twoIntsStruct * data;
    data = NULL; 
    {
        
        twoIntsStruct dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i].intOne = 1;
                dataBuffer[i].intTwo = 1;
            }
        }
        data = dataBuffer;
    }
    CWE590_Free_Memory_Not_on_Heap__delete_array_struct_declare_68_badData = data;
"
759,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_67a.c,"    size_t data;
    CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_67_structType myStruct;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = strtoul(inputBuffer, NULL, 0);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    myStruct.structFirst = data;
"
8769,0,CWE690_NULL_Deref_From_Return__char_realloc_67a.c,"    char * data;
    CWE690_NULL_Deref_From_Return__char_realloc_67_structType myStruct;
    data = NULL; 
    
    data = (char *)realloc(data, 20*sizeof(char));
    myStruct.structFirst = data;
"
10930,0,CWE369_Divide_by_Zero__int_connect_socket_divide_43.cpp,"    int data;
    
    data = -1;
    badSource(data);
    
"
14789,0,CWE457_Use_of_Uninitialized_Variable__char_pointer_07.c,"    char * data;
    if(staticFive==5)
    {
        
        ; 
    }
    if(staticFive==5)
    {
        
        printLine(data);
"
18340,0,CWE401_Memory_Leak__char_calloc_74a.cpp,"    char * data;
    map<int, char *> dataMap;
    data = NULL;
    
    data = (char *)calloc(100, sizeof(char));
    if (data == NULL) {exit(-1);}
    
    strcpy(data, ""A String"");
    printLine(data);
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
18529,0,CWE401_Memory_Leak__new_char_06.cpp,"    char * data;
    data = NULL;
    if(STATIC_CONST_FIVE==5)
    {
        
        data = new char;
        
        *data = 'A';
        printHexCharLine(*data);
    }
    if(STATIC_CONST_FIVE==5)
    {
        
        ; 
"
17090,1,CWE252_Unchecked_Return_Value__char_remove_05.c,"    if(staticTrue)
    {
        
        if (REMOVE(""removemegood.txt"") != 0)
        {
            printLine(""remove failed!"");
        }
"
7038,1,CWE758_Undefined_Behavior__struct_alloca_use_07.c,"    if(staticFive!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            twoIntsStruct data;
            twoIntsStruct * pointer = (twoIntsStruct *)ALLOCA(sizeof(twoIntsStruct));
            data.intOne = 1;
            data.intTwo = 2;
            *pointer = data; 
            {
                twoIntsStruct data = *pointer;
                printIntLine(data.intOne);
                printIntLine(data.intTwo);
            }
        }
"
15765,0,CWE563_Unused_Variable__unused_init_variable_long_82_bad.cpp,"Label Definition File: CWE563_Unused_Variable__unused_init_variable.label.xml
Template File: source-sinks-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 563 Unused Variable
 * BadSource:  Initialize data
 * Sinks:
 *    GoodSink: Use data
 *    BadSink : do nothing
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE563_Unused_Variable__unused_init_variable_long_82.h""

namespace CWE563_Unused_Variable__unused_init_variable_long_82
{

void CWE563_Unused_Variable__unused_init_variable_long_82_bad::action(long data)
{
    
    
    ; 
}

}
"
14939,0,CWE590_Free_Memory_Not_on_Heap__free_struct_static_07.c,"    twoIntsStruct * data;
    data = NULL; 
    if(staticFive==5)
    {
        {
            
            static twoIntsStruct dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i].intOne = 1;
                    dataBuffer[i].intTwo = 1;
                }
            }
            data = dataBuffer;
        }
    }
    printStructLine(&data[0]);
    
"
19424,0,CWE690_NULL_Deref_From_Return__int64_t_malloc_81_bad.cpp,"Label Definition File: CWE690_NULL_Deref_From_Return.free.label.xml
Template File: source-sinks-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 690 Unchecked Return Value To NULL Pointer
 * BadSource: malloc Allocate data using malloc()
 * Sinks:
 *    GoodSink: Check to see if the data allocation failed and if not, use data
 *    BadSink : Don't check for NULL and use data
 * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE690_NULL_Deref_From_Return__int64_t_malloc_81.h""

namespace CWE690_NULL_Deref_From_Return__int64_t_malloc_81
{

void CWE690_NULL_Deref_From_Return__int64_t_malloc_81_bad::action(int64_t * data) const
{
    
    data[0] = 5LL;
    printLongLongLine(data[0]);
    free(data);
}

}
"
5974,0,CWE590_Free_Memory_Not_on_Heap__delete_array_struct_declare_15.cpp,"    twoIntsStruct * data;
    data = NULL; 
    switch(6)
    {
    case 6:
    {
        
        twoIntsStruct dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i].intOne = 1;
                dataBuffer[i].intTwo = 1;
            }
        }
        data = dataBuffer;
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    printStructLine(&data[0]);
    
"
15005,0,CWE590_Free_Memory_Not_on_Heap__delete_class_static_63a.cpp,"    TwoIntsClass * data;
    data = NULL; 
    {
        
        static TwoIntsClass dataBuffer;
        dataBuffer.intOne = 1;
        dataBuffer.intTwo = 1;
        data = &dataBuffer;
    }
"
10592,0,CWE590_Free_Memory_Not_on_Heap__delete_array_char_alloca_31.cpp,"    char * data;
    data = NULL; 
    {
        
        char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
        memset(dataBuffer, 'A', 100-1); 
        dataBuffer[100-1] = '\0'; 
        data = dataBuffer;
    }
    {
        char * dataCopy = data;
        char * data = dataCopy;
        printLine(data);
        
        delete [] data;
"
14508,0,CWE197_Numeric_Truncation_Error__int_fscanf_to_short_51a.c,"    int data;
    
    data = -1;
    
    fscanf(stdin, ""%d"", &data);
"
2144,0,CWE78_OS_Command_Injection__char_console_popen_52a.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
        
        size_t dataLen = strlen(data);
        
        if (100-dataLen > 1)
        {
            
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgets() */
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
                    data[dataLen-1] = '\0';
                }
            }
            else
            {
                printLine(""fgets() failed"");
                
                data[dataLen] = '\0';
            }
        }
    }
"
18248,0,CWE190_Integer_Overflow__int64_t_fscanf_square_13.c,"    int64_t data;
    data = 0LL;
    if(GLOBAL_CONST_FIVE==5)
    {
        
        fscanf (stdin, ""%"" SCNd64, &data);
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            
            int64_t result = data * data;
            printLongLongLine(result);
        }
"
748,0,CWE190_Integer_Overflow__char_rand_preinc_14.c,"    char data;
    data = ' ';
    if(globalFive==5)
    {
        
        data = (char)RAND32();
    }
    if(globalFive==5)
    {
        {
            
            ++data;
            char result = data;
            printHexCharLine(result);
        }
"
19282,0,CWE252_Unchecked_Return_Value__char_sscanf_11.c,"    if(globalReturnsTrue())
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            
            sscanf(SRC, ""%99s\0"", data);
        }
"
7266,0,CWE401_Memory_Leak__new_TwoIntsClass_15.cpp,"    TwoIntsClass * data;
    data = NULL;
    switch(6)
    {
    case 6:
        
        data = new TwoIntsClass;
        
        data->intOne = 0;
        data->intTwo = 0;
        printIntLine(data->intOne);
        printIntLine(data->intTwo);
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
        
        ; 
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
10997,0,CWE369_Divide_by_Zero__int_connect_socket_divide_41.c,"    int data;
    
    data = -1;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
1353,0,CWE401_Memory_Leak__struct_twoIntsStruct_calloc_12.c,"    struct _twoIntsStruct * data;
    data = NULL;
    if(globalReturnsTrueOrFalse())
    {
        
        data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));
        if (data == NULL) {exit(-1);}
        
        data[0].intOne = 0;
        data[0].intTwo = 0;
        printStructLine((twoIntsStruct *)&data[0]);
    }
    else
    {
        
        data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));
        
        data[0].intOne = 0;
        data[0].intTwo = 0;
        printStructLine((twoIntsStruct *)&data[0]);
    }
    if(globalReturnsTrueOrFalse())
    {
        
        ; 
    }
    else
    {
        
        free(data);
"
11322,0,CWE134_Uncontrolled_Format_String__char_file_printf_82_bad.cpp,"Label Definition File: CWE134_Uncontrolled_Format_String.label.xml
Template File: sources-sinks-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 134 Uncontrolled Format String
 * BadSource: file Read input from a file
 * GoodSource: Copy a fixed string into data
 * Sinks: printf
 *    GoodSink: printf with ""%s"" as the first argument and data as the second
 *    BadSink : printf with only data as an argument
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE134_Uncontrolled_Format_String__char_file_printf_82.h""

namespace CWE134_Uncontrolled_Format_String__char_file_printf_82
{

void CWE134_Uncontrolled_Format_String__char_file_printf_82_bad::action(char * data)
{
    
    printf(data);
}

}
"
11508,0,CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_32.c,"    char * data;
    char * *dataPtr1 = &data;
    char * *dataPtr2 = &data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        char * data = *dataPtr1;
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET connectSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                
                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                data[dataLen + recvResult / sizeof(char)] = '\0';
                
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
        *dataPtr1 = data;
    }
    {
        char * data = *dataPtr2;
        badVaSink(data, data);
"
3812,0,CWE190_Integer_Overflow__int_listen_socket_add_82a.cpp,"    int data;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    CWE190_Integer_Overflow__int_listen_socket_add_82_base* baseObject = new CWE190_Integer_Overflow__int_listen_socket_add_82_bad;
    baseObject->action(data);
"
15141,0,CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_65a.c,"    unsigned int data;
    
    void (*funcPtr) (unsigned int) = CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_65b_badSink;
    data = 0;
    
    fscanf (stdin, ""%u"", &data);
    
"
7156,0,CWE476_NULL_Pointer_Dereference__deref_after_check_13.c,"    if(GLOBAL_CONST_FIVE==5)
    {
        {
            
            int *intPointer = NULL;
            if (intPointer == NULL)
            {
                printIntLine(*intPointer);
            }
        }
"
197,0,CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_82a.cpp,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_82_base* baseObject = new CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_82_bad;
    baseObject->action(data);
"
6065,0,CWE190_Integer_Overflow__int_fgets_square_41.c,"    int data;
    
    data = 0;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
"
12605,0,CWE590_Free_Memory_Not_on_Heap__delete_array_long_alloca_82_bad.cpp,"Label Definition File: CWE590_Free_Memory_Not_on_Heap__delete_array.label.xml
Template File: sources-sink-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 590 Free Memory Not on Heap
 * BadSource: alloca Data buffer is allocated on the stack with alloca()
 * GoodSource: Allocate memory on the heap
 * Sinks:
 *    BadSink : Print then free data
 * Flow Variant: 82 Data flow: data passed in a parameter to a virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE590_Free_Memory_Not_on_Heap__delete_array_long_alloca_82.h""

namespace CWE590_Free_Memory_Not_on_Heap__delete_array_long_alloca_82
{

void CWE590_Free_Memory_Not_on_Heap__delete_array_long_alloca_82_bad::action(long * data)
{
    printLongLine(data[0]);
    
    delete [] data;
}

}
"
4434,0,CWE78_OS_Command_Injection__char_console_system_15.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    switch(6)
    {
    case 6:
    {
        
        size_t dataLen = strlen(data);
        
        if (100-dataLen > 1)
        {
            
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgets() */
"
2668,0,CWE416_Use_After_Free__new_delete_array_class_04.cpp,"    TwoIntsClass * data;
    
    data = NULL;
    if(STATIC_CONST_TRUE)
    {
        data = new TwoIntsClass[100];
        {
            size_t i;
            for(i = 0; i < 100; i++)
            {
                data[i].intOne = 1;
                data[i].intTwo = 2;
            }
        }
        
        delete [] data;
    }
    if(STATIC_CONST_TRUE)
    {
        
        printIntLine(data[0].intOne);
        
"
9217,0,CWE190_Integer_Overflow__int64_t_fscanf_preinc_10.c,"    int64_t data;
    data = 0LL;
    if(globalTrue)
    {
        
        fscanf (stdin, ""%"" SCNd64, &data);
    }
    if(globalTrue)
    {
        {
            
            ++data;
            int64_t result = data;
            printLongLongLine(result);
        }
"
12032,0,CWE690_NULL_Deref_From_Return__long_realloc_73a.cpp,"    long * data;
    list<long *> dataList;
    data = NULL; 
    
    data = (long *)realloc(data, 1*sizeof(long));
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
14242,0,CWE789_Uncontrolled_Mem_Alloc__new_char_rand_82_bad.cpp,"Label Definition File: CWE789_Uncontrolled_Mem_Alloc__new.label.xml
Template File: sources-sinks-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: rand Set data to result of rand(), which may be zero
 * GoodSource: Small number greater than zero
 * Sinks:
 *    GoodSink: Allocate memory with new [] and check the size of the memory to be allocated
 *    BadSink : Allocate memory with new [], but incorrectly check the size of the memory to be allocated
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE789_Uncontrolled_Mem_Alloc__new_char_rand_82.h""

#define HELLO_STRING ""hello""

namespace CWE789_Uncontrolled_Mem_Alloc__new_char_rand_82
{

void CWE789_Uncontrolled_Mem_Alloc__new_char_rand_82_bad::action(size_t data)
{
    {
        char * myString;
        /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
         * for the strcpy() function to not cause a buffer overflow */
        
        if (data > strlen(HELLO_STRING))
        {
            myString = new char[data];
            
            strcpy(myString, HELLO_STRING);
            printLine(myString);
            delete [] myString;
        }
        else
        {
            printLine(""Input is less than the length of the source string"");
        }
    }
}

}
"
12153,0,CWE134_Uncontrolled_Format_String__char_environment_snprintf_05.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(staticTrue)
    {
        {
            
            size_t dataLen = strlen(data);
            char * environment = GETENV(ENV_VARIABLE);
            
            if (environment != NULL)
            {
                
                strncat(data+dataLen, environment, 100-dataLen-1);
            }
        }
    }
    if(staticTrue)
    {
        {
            char dest[100] = """";
            
            SNPRINTF(dest, 100-1, data);
            printLine(dest);
        }
"
2538,1,CWE758_Undefined_Behavior__char_pointer_new_use_15.cpp,"    switch(6)
    {
    case 6:
    {
        char * data;
        data = ""string"";
        char * * pointer = new char *;
        *pointer = data; 
        {
            char * data = *pointer;
            printLine(data);
        }
        delete pointer;
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
17689,0,CWE190_Integer_Overflow__int64_t_rand_add_15.c,"    int64_t data;
    data = 0LL;
    switch(6)
    {
    case 6:
        
        data = (int64_t)RAND64();
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
    {
        
        int64_t result = data + 1;
        printLongLongLine(result);
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
2264,0,CWE78_OS_Command_Injection__char_file_system_82_bad.cpp,"Label Definition File: CWE78_OS_Command_Injection.one_string.label.xml
Template File: sources-sink-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 78 OS Command Injection
 * BadSource: file Read input from a file
 * GoodSource: Fixed string
 * Sinks: system
 *    BadSink : Execute command in data using system()
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE78_OS_Command_Injection__char_file_system_82.h""

#ifdef _WIN32
#define SYSTEM system
#else 
#define SYSTEM system
#endif

namespace CWE78_OS_Command_Injection__char_file_system_82
{

void CWE78_OS_Command_Injection__char_file_system_82_bad::action(char * data)
{
    
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
    }
}

}
"
12941,0,CWE190_Integer_Overflow__short_rand_multiply_54a.c,"    short data;
    data = 0;
    
    data = (short)RAND32();
"
16126,0,CWE590_Free_Memory_Not_on_Heap__free_struct_alloca_82a.cpp,"    twoIntsStruct * data;
    data = NULL; 
    {
        
        twoIntsStruct * dataBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i].intOne = 1;
                dataBuffer[i].intTwo = 1;
            }
        }
        data = dataBuffer;
    }
    CWE590_Free_Memory_Not_on_Heap__free_struct_alloca_82_base* baseObject = new CWE590_Free_Memory_Not_on_Heap__free_struct_alloca_82_bad;
    baseObject->action(data);
"
7132,0,CWE590_Free_Memory_Not_on_Heap__delete_struct_placement_new_82a.cpp,"    twoIntsStruct * data;
    data = NULL; 
    {
        
        char buffer[sizeof(twoIntsStruct)];
        twoIntsStruct * dataBuffer = new(buffer) twoIntsStruct;
        dataBuffer->intOne = 1;
        dataBuffer->intTwo = 1;
        data = dataBuffer;
    }
    CWE590_Free_Memory_Not_on_Heap__delete_struct_placement_new_82_base* baseObject = new CWE590_Free_Memory_Not_on_Heap__delete_struct_placement_new_82_bad;
    baseObject->action(data);
"
6165,0,CWE590_Free_Memory_Not_on_Heap__delete_long_placement_new_54a.cpp,"    long * data;
    data = NULL; 
    {
        
        char buffer[sizeof(long)];
        long * dataBuffer = new(buffer) long;
        *dataBuffer = 5L;
        data = dataBuffer;
    }
"
8218,0,CWE190_Integer_Overflow__int64_t_fscanf_add_09.c,"    int64_t data;
    data = 0LL;
    if(GLOBAL_CONST_TRUE)
    {
        
        fscanf (stdin, ""%"" SCNd64, &data);
    }
    if(GLOBAL_CONST_TRUE)
    {
        {
            
            int64_t result = data + 1;
            printLongLongLine(result);
        }
"
19234,0,CWE190_Integer_Overflow__short_max_postinc_11.c,"    short data;
    data = 0;
    if(globalReturnsTrue())
    {
        
        data = SHRT_MAX;
    }
    if(globalReturnsTrue())
    {
        {
            
            data++;
            short result = data;
            printIntLine(result);
        }
"
653,0,CWE590_Free_Memory_Not_on_Heap__free_struct_declare_09.c,"    twoIntsStruct * data;
    data = NULL; 
    if(GLOBAL_CONST_TRUE)
    {
        {
            
            twoIntsStruct dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i].intOne = 1;
                    dataBuffer[i].intTwo = 1;
                }
            }
            data = dataBuffer;
        }
    }
    printStructLine(&data[0]);
    
"
18701,0,CWE457_Use_of_Uninitialized_Variable__new_double_array_partial_init_15.cpp,"    double * data;
    data = new double[10];
    switch(6)
    {
    case 6:
        
    {
        int i;
        for(i=0; i<(10/2); i++)
        {
            data[i] = (double)i;
        }
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
        
    {
        int i;
        for(i=0; i<10; i++)
        {
            printDoubleLine(data[i]);
        }
    }
    
    delete [] data;
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
7851,1,CWE758_Undefined_Behavior__int64_t_alloca_use_03.c,"    if(5==5)
    {
        {
            int64_t data;
            int64_t * pointer = (int64_t *)ALLOCA(sizeof(int64_t));
            data = 5LL;
            *pointer = data; 
            {
                int64_t data = *pointer;
                printLongLongLine(data);
            }
        }
"
8187,1,CWE467_Use_of_sizeof_on_Pointer_Type__short_15.c,"    switch(5)
    {
    case 6:
        
        printLine(""Benign, fixed string"");
        break;
    default:
    {
        short * goodShort = NULL;
        
        goodShort = (short *)malloc(sizeof(*goodShort));
        if (goodShort == NULL) {exit(-1);}
        *goodShort = 6;
        printShortLine(*goodShort);
        free(goodShort);
    }
    break;
"
17379,0,CWE78_OS_Command_Injection__char_connect_socket_execlp_14.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(globalFive==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET connectSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
"
1418,1,CWE475_Undefined_Behavior_for_Input_to_API__char_13.c,"    if(GLOBAL_CONST_FIVE!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            strcpy(data, ""abcdefghijklmnopqrstuvwxyz"");
            
            memmove(data + 6, data + 4, 10*sizeof(char));
            printLine(data);
        }
"
14171,0,CWE457_Use_of_Uninitialized_Variable__new_int_array_partial_init_02.cpp,"    int * data;
    data = new int[10];
    if(1)
    {
        
        {
            int i;
            for(i=0; i<(10/2); i++)
            {
                data[i] = i;
            }
        }
    }
    if(1)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i]);
            }
        }
        
        delete [] data;
"
11869,0,CWE457_Use_of_Uninitialized_Variable__twointsclass_array_new_no_init_12.cpp,"    TwoIntsClass * data;
    data = new TwoIntsClass[10];
    if(globalReturnsTrueOrFalse())
    {
        
        ; 
    }
    else
    {
        
        for(int i=0; i<10; i++)
        {
            data[i].intOne = i;
            data[i].intTwo = i;
        }
    }
    if(globalReturnsTrueOrFalse())
    {
        
        for(int i=0; i<10; i++)
        {
            printIntLine(data[i].intOne);
            printIntLine(data[i].intTwo);
        }
    }
    else
    {
        
        for(int i=0; i<10; i++)
        {
            data[i].intOne = i;
            data[i].intTwo = i;
        }
        for(int i=0; i<10; i++)
        {
            printIntLine(data[i].intOne);
            printIntLine(data[i].intTwo);
        }
"
15323,0,CWE690_NULL_Deref_From_Return__int64_t_malloc_61a.c,"    int64_t * data;
    data = NULL; 
    data = CWE690_NULL_Deref_From_Return__int64_t_malloc_61b_badSource(data);
    
    data[0] = 5LL;
    printLongLongLine(data[0]);
"
7134,0,CWE690_NULL_Deref_From_Return__struct_malloc_82a.cpp,"    twoIntsStruct * data;
    data = NULL; 
    
    data = (twoIntsStruct *)malloc(1*sizeof(twoIntsStruct));
    CWE690_NULL_Deref_From_Return__struct_malloc_82_base* baseObject = new CWE690_NULL_Deref_From_Return__struct_malloc_82_bad;
    baseObject->action(data);
"
14129,1,CWE758_Undefined_Behavior__struct_alloca_use_04.c,"    if(STATIC_CONST_FALSE)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            twoIntsStruct data;
            twoIntsStruct * pointer = (twoIntsStruct *)ALLOCA(sizeof(twoIntsStruct));
            data.intOne = 1;
            data.intTwo = 2;
            *pointer = data; 
            {
                twoIntsStruct data = *pointer;
                printIntLine(data.intOne);
                printIntLine(data.intTwo);
            }
        }
"
11183,0,CWE590_Free_Memory_Not_on_Heap__free_struct_declare_31.c,"    twoIntsStruct * data;
    data = NULL; 
    {
        
        twoIntsStruct dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i].intOne = 1;
                dataBuffer[i].intTwo = 1;
            }
        }
        data = dataBuffer;
    }
    {
        twoIntsStruct * dataCopy = data;
        twoIntsStruct * data = dataCopy;
        printStructLine(&data[0]);
        
        free(data);
"
17845,0,CWE590_Free_Memory_Not_on_Heap__delete_array_long_static_66a.cpp,"    long * data;
    long * dataArray[5];
    data = NULL; 
    {
        
        static long dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5L;
            }
        }
        data = dataBuffer;
    }
    
    dataArray[2] = data;
"
5889,0,CWE134_Uncontrolled_Format_String__char_environment_snprintf_32.c,"    char * data;
    char * *dataPtr1 = &data;
    char * *dataPtr2 = &data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        char * data = *dataPtr1;
        {
            
            size_t dataLen = strlen(data);
            char * environment = GETENV(ENV_VARIABLE);
            
            if (environment != NULL)
            {
                
                strncat(data+dataLen, environment, 100-dataLen-1);
            }
        }
        *dataPtr1 = data;
    }
    {
        char * data = *dataPtr2;
        {
            char dest[100] = """";
            
            SNPRINTF(dest, 100-1, data);
            printLine(dest);
        }
"
4063,0,CWE401_Memory_Leak__malloc_realloc_struct_twoIntsStruct_16.c,"    while(1)
    {
        {
            struct _twoIntsStruct * data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));
            if (data == NULL) {exit(-1);}
            
            data[0].intOne = 0;
            data[0].intTwo = 0;
            printStructLine((twoIntsStruct *)&data[0]);
            
            data = (struct _twoIntsStruct *)realloc(data, (130000)*sizeof(struct _twoIntsStruct));
            if (data != NULL)
            {
                
                data[0].intOne = 1;
                data[0].intTwo = 1;
                printStructLine((twoIntsStruct *)&data[0]);
                free(data);
            }
        }
        break;
"
14820,0,CWE190_Integer_Overflow__short_rand_add_04.c,"    short data;
    data = 0;
    if(STATIC_CONST_TRUE)
    {
        
        data = (short)RAND32();
    }
    if(STATIC_CONST_TRUE)
    {
        {
            
            short result = data + 1;
            printIntLine(result);
        }
"
1925,0,CWE190_Integer_Overflow__int_rand_add_72a.cpp,"    int data;
    vector<int> dataVector;
    
    data = 0;
    
    data = RAND32();
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
13803,0,CWE190_Integer_Overflow__int_connect_socket_postinc_66a.c,"    int data;
    int dataArray[5];
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
    dataArray[2] = data;
"
13516,0,CWE369_Divide_by_Zero__float_fscanf_05.c,"    float data;
    
    data = 0.0F;
    if(staticTrue)
    {
        
        fscanf (stdin, ""%f"", &data);
    }
    if(staticTrue)
    {
        {
            
            int result = (int)(100.0 / data);
            printIntLine(result);
        }
"
12662,0,CWE416_Use_After_Free__new_delete_array_int64_t_63a.cpp,"    int64_t * data;
    
    data = NULL;
    data = new int64_t[100];
    {
        size_t i;
        for(i = 0; i < 100; i++)
        {
            data[i] = 5LL;
        }
    }
    
    delete [] data;
"
19347,0,CWE190_Integer_Overflow__short_fscanf_multiply_51a.c,"    short data;
    data = 0;
    
    fscanf (stdin, ""%hd"", &data);
"
7661,0,CWE369_Divide_by_Zero__int_fscanf_modulo_81a.cpp,"    int data;
    
    data = -1;
    
    fscanf(stdin, ""%d"", &data);
    const CWE369_Divide_by_Zero__int_fscanf_modulo_81_base& baseObject = CWE369_Divide_by_Zero__int_fscanf_modulo_81_bad();
"
72,0,CWE78_OS_Command_Injection__char_connect_socket_system_54a.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
8720,0,CWE590_Free_Memory_Not_on_Heap__delete_array_long_static_33.cpp,"    long * data;
    long * &dataRef = data;
    data = NULL; 
    {
        
        static long dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5L;
            }
        }
        data = dataBuffer;
    }
    {
        long * data = dataRef;
        printLongLine(data[0]);
        
        delete [] data;
"
19314,0,CWE563_Unused_Variable__unused_uninit_variable_char_74a.cpp,"    char data;
    map<int, char> dataMap;
    
    ; 
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
8903,0,CWE190_Integer_Overflow__int_fscanf_add_02.c,"    int data;
    
    data = 0;
    if(1)
    {
        
        fscanf(stdin, ""%d"", &data);
    }
    if(1)
    {
        {
            
            int result = data + 1;
            printIntLine(result);
        }
"
17650,0,CWE190_Integer_Overflow__char_max_multiply_84_bad.cpp,"Label Definition File: CWE190_Integer_Overflow.label.xml
Template File: sources-sinks-84_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 190 Integer Overflow
 * BadSource: max Set data to the max value for char
 * GoodSource: Set data to a small, non-zero number (two)
 * Sinks: multiply
 *    GoodSink: Ensure there will not be an overflow before multiplying data by 2
 *    BadSink : If data is positive, multiply by 2, which can cause an overflow
 * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE190_Integer_Overflow__char_max_multiply_84.h""

namespace CWE190_Integer_Overflow__char_max_multiply_84
{
CWE190_Integer_Overflow__char_max_multiply_84_bad::CWE190_Integer_Overflow__char_max_multiply_84_bad(char dataCopy)
{
    data = dataCopy;
    
    data = CHAR_MAX;
}

CWE190_Integer_Overflow__char_max_multiply_84_bad::~CWE190_Integer_Overflow__char_max_multiply_84_bad()
{
    if(data > 0) 
    {
        
        char result = data * 2;
        printHexCharLine(result);
    }
}
}
"
4262,0,CWE190_Integer_Overflow__char_fscanf_postinc_18.c,"    char data;
    data = ' ';
    goto source;
source:
    
    fscanf (stdin, ""%c"", &data);
    goto sink;
sink:
    {
        
        data++;
        char result = data;
        printHexCharLine(result);
"
17381,0,CWE563_Unused_Variable__unused_uninit_variable_int_21.c,"    int data;
    
    ; 
    badStatic = 1; 
"
4841,0,CWE252_Unchecked_Return_Value__char_putchar_04.c,"    if(STATIC_CONST_TRUE)
    {
        
        putchar((int)'A');
"
14003,0,CWE190_Integer_Overflow__int64_t_rand_square_17.c,"    int i,j;
    int64_t data;
    data = 0LL;
    for(i = 0; i < 1; i++)
    {
        
        data = (int64_t)RAND64();
    }
    for(j = 0; j < 1; j++)
    {
        {
            
            int64_t result = data * data;
            printLongLongLine(result);
        }
"
10865,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_64a.c,"    size_t data;
    
    data = 0;
    
    data = rand();
"
16018,0,CWE78_OS_Command_Injection__char_connect_socket_popen_34.c,"    char * data;
    CWE78_OS_Command_Injection__char_connect_socket_popen_34_unionType myUnion;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
"
2773,0,CWE416_Use_After_Free__malloc_free_int_18.c,"    int * data;
    
    data = NULL;
    goto source;
source:
    data = (int *)malloc(100*sizeof(int));
    if (data == NULL) {exit(-1);}
    {
        size_t i;
        for(i = 0; i < 100; i++)
        {
            data[i] = 5;
        }
    }
    
    free(data);
    goto sink;
sink:
    
    printIntLine(data[0]);
"
16095,0,CWE190_Integer_Overflow__unsigned_int_fscanf_square_21.c,"    unsigned int data;
    data = 0;
    
    fscanf (stdin, ""%u"", &data);
    badStatic = 1; 
"
17218,0,CWE590_Free_Memory_Not_on_Heap__delete_array_int64_t_static_66a.cpp,"    int64_t * data;
    int64_t * dataArray[5];
    data = NULL; 
    {
        
        static int64_t dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5LL;
            }
        }
        data = dataBuffer;
    }
    
    dataArray[2] = data;
"
8223,0,CWE401_Memory_Leak__new_array_struct_twoIntsStruct_21.cpp,"    struct _twoIntsStruct * data;
    data = NULL;
    
    data = new struct _twoIntsStruct[100];
    
    data[0].intOne = 0;
    data[0].intTwo = 0;
    printStructLine((twoIntsStruct *)&data[0]);
    badStatic = 1; 
"
12962,0,CWE476_NULL_Pointer_Dereference__long_73a.cpp,"    long * data;
    list<long *> dataList;
    
    data = NULL;
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
16059,0,CWE190_Integer_Overflow__unsigned_int_max_preinc_15.c,"    unsigned int data;
    data = 0;
    switch(6)
    {
    case 6:
        
        data = UINT_MAX;
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
    {
        
        ++data;
        unsigned int result = data;
        printUnsignedLine(result);
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
8718,1,CWE252_Unchecked_Return_Value__char_fputc_06.c,"    if(STATIC_CONST_FIVE==5)
    {
        
        if (fputc((int)'A', stdout) == EOF)
        {
            printLine(""fputc failed!"");
        }
"
15577,0,CWE415_Double_Free__new_delete_int_31.cpp,"    int * data;
    
    data = NULL;
    data = new int;
    
    delete data;
    {
        int * dataCopy = data;
        int * data = dataCopy;
        
        delete data;
"
3440,1,CWE467_Use_of_sizeof_on_Pointer_Type__char_06.c,"    if(STATIC_CONST_FIVE==5)
    {
        {
            char * goodChar = NULL;
            
            goodChar = (char *)malloc(sizeof(*goodChar));
            if (goodChar == NULL) {exit(-1);}
            *goodChar = 'G';
            printHexCharLine(*goodChar);
            free(goodChar);
        }
"
14538,0,CWE590_Free_Memory_Not_on_Heap__delete_array_char_static_44.cpp,"    char * data;
    
    void (*funcPtr) (char *) = badSink;
    data = NULL; 
    {
        
        static char dataBuffer[100];
        memset(dataBuffer, 'A', 100-1); 
        dataBuffer[100-1] = '\0'; 
        data = dataBuffer;
    }
    
"
19550,0,CWE369_Divide_by_Zero__int_fscanf_modulo_31.c,"    int data;
    
    data = -1;
    
    fscanf(stdin, ""%d"", &data);
    {
        int dataCopy = data;
        int data = dataCopy;
        
        printIntLine(100 % data);
"
1048,0,CWE590_Free_Memory_Not_on_Heap__delete_struct_declare_82_bad.cpp,"Label Definition File: CWE590_Free_Memory_Not_on_Heap__delete.nonpointer.label.xml
Template File: sources-sink-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 590 Free Memory Not on Heap
 * BadSource: declare Data buffer is declared on the stack
 * GoodSource: Allocate memory on the heap
 * Sinks:
 *    BadSink : Print then free data
 * Flow Variant: 82 Data flow: data passed in a parameter to a virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE590_Free_Memory_Not_on_Heap__delete_struct_declare_82.h""

namespace CWE590_Free_Memory_Not_on_Heap__delete_struct_declare_82
{

void CWE590_Free_Memory_Not_on_Heap__delete_struct_declare_82_bad::action(twoIntsStruct * data)
{
    printStructLine(data);
    
    delete data;
}

}
"
12442,0,CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_21.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    badStatic = 1; 
"
9579,0,CWE590_Free_Memory_Not_on_Heap__delete_class_static_54a.cpp,"    TwoIntsClass * data;
    data = NULL; 
    {
        
        static TwoIntsClass dataBuffer;
        dataBuffer.intOne = 1;
        dataBuffer.intTwo = 1;
        data = &dataBuffer;
    }
"
9822,0,CWE401_Memory_Leak__struct_twoIntsStruct_realloc_62a.cpp,"    struct _twoIntsStruct * data;
    data = NULL;
    badSource(data);
    
"
3658,0,CWE563_Unused_Variable__unused_init_variable_int64_t_73a.cpp,"    int64_t data;
    list<int64_t> dataList;
    
    data = 5LL;
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
16994,0,CWE590_Free_Memory_Not_on_Heap__delete_struct_declare_08.cpp,"    twoIntsStruct * data;
    data = NULL; 
    if(staticReturnsTrue())
    {
        {
            
            twoIntsStruct dataBuffer;
            dataBuffer.intOne = 1;
            dataBuffer.intTwo = 1;
            data = &dataBuffer;
        }
    }
    printStructLine(data);
    
"
12182,0,CWE78_OS_Command_Injection__char_connect_socket_popen_31.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
"
18541,0,CWE190_Integer_Overflow__int_listen_socket_preinc_52a.c,"    int data;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
18021,0,CWE401_Memory_Leak__new_int_65a.cpp,"    int * data;
    
    void (*funcPtr) (int *) = badSink;
    data = NULL;
    
    data = new int;
    
    *data = 5;
    printIntLine(*data);
    
"
11268,0,CWE563_Unused_Variable__unused_uninit_variable_char_81_bad.cpp,"Label Definition File: CWE563_Unused_Variable__unused_uninit_variable.label.xml
Template File: source-sinks-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 563 Unused Variable
 * BadSource:  Initialize data
 * Sinks:
 *    GoodSink: Initialize, then use data
 *    BadSink : Do nothing
 * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE563_Unused_Variable__unused_uninit_variable_char_81.h""

namespace CWE563_Unused_Variable__unused_uninit_variable_char_81
{

void CWE563_Unused_Variable__unused_uninit_variable_char_81_bad::action(char data) const
{
    
    
    ; 
}

}
"
7046,0,CWE190_Integer_Overflow__int_connect_socket_add_53a.c,"    int data;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
16659,0,CWE415_Double_Free__malloc_free_int_12.c,"    int * data;
    
    data = NULL;
    if(globalReturnsTrueOrFalse())
    {
        data = (int *)malloc(100*sizeof(int));
        if (data == NULL) {exit(-1);}
        
        free(data);
    }
    else
    {
        data = (int *)malloc(100*sizeof(int));
        if (data == NULL) {exit(-1);}
        
    }
    if(globalReturnsTrueOrFalse())
    {
        
        free(data);
    }
    else
    {
        
        
        ; 
"
8015,0,CWE190_Integer_Overflow__int_connect_socket_square_22a.c,"    int data;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    CWE190_Integer_Overflow__int_connect_socket_square_22_badGlobal = 1; 
"
10349,0,CWE78_OS_Command_Injection__char_listen_socket_system_03.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(5==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                data[dataLen + recvResult / sizeof(char)] = '\0';
                
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
"
1756,0,CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_42.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    data = badSource(data);
"
2960,0,CWE78_OS_Command_Injection__char_environment_system_61a.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    data = CWE78_OS_Command_Injection__char_environment_system_61b_badSource(data);
    
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
"
10005,1,CWE758_Undefined_Behavior__class_pointer_new_use_11.cpp,"    if(globalReturnsTrue())
    {
        {
            TwoIntsClass * data;
            
            data = new TwoIntsClass;
            data->intOne = 5;
            data->intTwo = 6;
            TwoIntsClass * * pointer = new TwoIntsClass *;
            *pointer = data; 
            {
                TwoIntsClass * data = *pointer;
                printIntLine(data->intOne);
                printIntLine(data->intTwo);
            }
            delete pointer;
        }
"
4480,0,CWE457_Use_of_Uninitialized_Variable__twointsclass_array_declare_partial_init_43.cpp,"    TwoIntsClass * data;
    TwoIntsClass dataUninitArray[10];
    data = dataUninitArray;
    badSource(data);
    
    for(int i=0; i<10; i++)
    {
        printIntLine(data[i].intOne);
        printIntLine(data[i].intTwo);
"
18386,1,CWE758_Undefined_Behavior__long_malloc_use_14.c,"    if(globalFive==5)
    {
        {
            long data;
            long * pointer = (long *)malloc(sizeof(long));
            if (pointer == NULL) {exit(-1);}
            data = 5L;
            *pointer = data; 
            {
                long data = *pointer;
                printLongLine(data);
            }
            free(pointer);
        }
"
5749,0,CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_15.c,"    unsigned int data;
    data = 0;
    switch(6)
    {
    case 6:
        
        fscanf (stdin, ""%u"", &data);
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
    {
        
        ++data;
        unsigned int result = data;
        printUnsignedLine(result);
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
18531,0,CWE457_Use_of_Uninitialized_Variable__double_05.c,"    double data;
    if(staticTrue)
    {
        
        ; 
    }
    if(staticTrue)
    {
        
        printDoubleLine(data);
"
10182,0,CWE369_Divide_by_Zero__int_connect_socket_modulo_84_bad.cpp,"Label Definition File: CWE369_Divide_by_Zero__int.label.xml
Template File: sources-sinks-84_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 369 Divide by Zero
 * BadSource: connect_socket Read data using a connect socket (client side)
 * GoodSource: Non-zero
 * Sinks: modulo
 *    GoodSink: Check for zero before modulo
 *    BadSink : Modulo a constant with data
 * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE369_Divide_by_Zero__int_connect_socket_modulo_84.h""

#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif

#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)

namespace CWE369_Divide_by_Zero__int_connect_socket_modulo_84
{
CWE369_Divide_by_Zero__int_connect_socket_modulo_84_bad::CWE369_Divide_by_Zero__int_connect_socket_modulo_84_bad(int dataCopy)
{
    data = dataCopy;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
}

CWE369_Divide_by_Zero__int_connect_socket_modulo_84_bad::~CWE369_Divide_by_Zero__int_connect_socket_modulo_84_bad()
{
    
    printIntLine(100 % data);
}
}
"
2818,0,CWE401_Memory_Leak__new_twoIntsStruct_33.cpp,"    twoIntsStruct * data;
    twoIntsStruct * &dataRef = data;
    data = NULL;
    
    data = new twoIntsStruct;
    
    data->intOne = 0;
    data->intTwo = 0;
    printStructLine(data);
    {
        twoIntsStruct * data = dataRef;
        
        ; 
"
5976,0,CWE590_Free_Memory_Not_on_Heap__free_int64_t_declare_15.c,"    int64_t * data;
    data = NULL; 
    switch(6)
    {
    case 6:
    {
        
        int64_t dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5LL;
            }
        }
        data = dataBuffer;
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    printLongLongLine(data[0]);
    
"
17454,0,CWE476_NULL_Pointer_Dereference__class_32.cpp,"    TwoIntsClass * data;
    TwoIntsClass * *dataPtr1 = &data;
    TwoIntsClass * *dataPtr2 = &data;
    {
        TwoIntsClass * data = *dataPtr1;
        
        data = NULL;
        *dataPtr1 = data;
    }
    {
        TwoIntsClass * data = *dataPtr2;
        
        printIntLine(data->intOne);
        
        delete data;
"
14207,0,CWE457_Use_of_Uninitialized_Variable__double_array_alloca_partial_init_11.c,"    double * data;
    data = (double *)ALLOCA(10*sizeof(double));
    if(globalReturnsTrue())
    {
        
        {
            int i;
            for(i=0; i<(10/2); i++)
            {
                data[i] = (double)i;
            }
        }
    }
    if(globalReturnsTrue())
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printDoubleLine(data[i]);
            }
        }
"
4264,0,CWE369_Divide_by_Zero__int_listen_socket_modulo_02.c,"    int data;
    
    data = -1;
    if(1)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(1)
    {
        
        printIntLine(100 % data);
"
2273,1,CWE401_Memory_Leak__malloc_realloc_int_07.c,"    if(staticFive==5)
    {
        {
            int * data = (int *)malloc(100*sizeof(int));
            if (data == NULL) {exit(-1);}
            int * tmpData;
            
            data[0] = 5;
            printIntLine(data[0]);
            tmpData = (int *)realloc(data, (130000)*sizeof(int));
            /* FIX: Ensure realloc() was successful before assigning data to the memory block
            * allocated with realloc() */
            if (tmpData != NULL)
            {
                data = tmpData;
                
                data[0] = 10;
                printIntLine(data[0]);
            }
            free(data);
        }
"
13477,0,CWE590_Free_Memory_Not_on_Heap__delete_array_long_static_65a.cpp,"    long * data;
    
    void (*funcPtr) (long *) = badSink;
    data = NULL; 
    {
        
        static long dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5L;
            }
        }
        data = dataBuffer;
    }
    
"
10867,0,CWE369_Divide_by_Zero__float_fgets_05.c,"    float data;
    
    data = 0.0F;
    if(staticTrue)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE];
            
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                
                data = (float)atof(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    if(staticTrue)
    {
        {
            
            int result = (int)(100.0 / data);
            printIntLine(result);
        }
"
14570,0,CWE789_Uncontrolled_Mem_Alloc__new_char_connect_socket_45.cpp,"    size_t data;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = strtoul(inputBuffer, NULL, 0);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    badData = data;
"
13263,0,CWE590_Free_Memory_Not_on_Heap__delete_array_struct_declare_66a.cpp,"    twoIntsStruct * data;
    twoIntsStruct * dataArray[5];
    data = NULL; 
    {
        
        twoIntsStruct dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i].intOne = 1;
                dataBuffer[i].intTwo = 1;
            }
        }
        data = dataBuffer;
    }
    
    dataArray[2] = data;
"
17095,1,CWE758_Undefined_Behavior__char_malloc_use_14.c,"    if(globalFive!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            char data;
            char * pointer = (char *)malloc(sizeof(char));
            if (pointer == NULL) {exit(-1);}
            data = 5;
            *pointer = data; 
            {
                char data = *pointer;
                printHexCharLine(data);
            }
            free(pointer);
        }
"
7426,0,CWE457_Use_of_Uninitialized_Variable__int_array_alloca_no_init_13.c,"    int * data;
    data = (int *)ALLOCA(10*sizeof(int));
    if(GLOBAL_CONST_FIVE==5)
    {
        
        ; 
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i]);
            }
        }
"
5596,0,CWE197_Numeric_Truncation_Error__short_rand_13.c,"    short data;
    
    data = -1;
    if(GLOBAL_CONST_FIVE==5)
    {
        
        data = (short)RAND32();
    }
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
8627,0,CWE134_Uncontrolled_Format_String__char_file_vprintf_33.cpp,"    char * data;
    char * &dataRef = data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        FILE * pFile;
        
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
    {
        char * data = dataRef;
        badVaSink(data, data);
"
8277,0,CWE197_Numeric_Truncation_Error__int_large_to_short_45.c,"    int data;
    
    data = -1;
    
    data = SHRT_MAX + 5;
    CWE197_Numeric_Truncation_Error__int_large_to_short_45_badData = data;
"
15355,0,CWE457_Use_of_Uninitialized_Variable__new_double_array_partial_init_18.cpp,"    double * data;
    data = new double[10];
    goto source;
source:
    
    {
        int i;
        for(i=0; i<(10/2); i++)
        {
            data[i] = (double)i;
        }
    }
    goto sink;
sink:
    
    {
        int i;
        for(i=0; i<10; i++)
        {
            printDoubleLine(data[i]);
        }
    }
    
"
8744,0,CWE590_Free_Memory_Not_on_Heap__delete_int64_t_placement_new_12.cpp,"    int64_t * data;
    data = NULL; 
    if(globalReturnsTrueOrFalse())
    {
        {
            
            char buffer[sizeof(int64_t)];
            int64_t * dataBuffer = new(buffer) int64_t;
            *dataBuffer = 5LL;
            data = dataBuffer;
        }
    }
    else
    {
        {
            
            int64_t * dataBuffer = new int64_t;
            *dataBuffer = 5LL;
            data = dataBuffer;
        }
    }
    printLongLongLine(*data);
    
"
19437,0,CWE369_Divide_by_Zero__int_rand_divide_67a.c,"    int data;
    CWE369_Divide_by_Zero__int_rand_divide_67_structType myStruct;
    
    data = -1;
    
    data = RAND32();
    myStruct.structFirst = data;
"
1647,0,CWE563_Unused_Variable__unused_init_variable_struct_04.c,"    twoIntsStruct data;
    
    data.intOne = 0;
    data.intTwo = 0;
    if(STATIC_CONST_TRUE)
    {
        
        
        ; 
"
12293,0,CWE415_Double_Free__new_delete_array_long_64a.cpp,"    long * data;
    
    data = NULL;
    data = new long[100];
    
    delete [] data;
"
17558,0,CWE415_Double_Free__malloc_free_struct_06.c,"    twoIntsStruct * data;
    
    data = NULL;
    if(STATIC_CONST_FIVE==5)
    {
        data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
        if (data == NULL) {exit(-1);}
        
        free(data);
    }
    if(STATIC_CONST_FIVE==5)
    {
        
        free(data);
"
2352,0,CWE190_Integer_Overflow__int_listen_socket_postinc_34.c,"    int data;
    CWE190_Integer_Overflow__int_listen_socket_postinc_34_unionType myUnion;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    myUnion.unionFirst = data;
    {
        int data = myUnion.unionSecond;
        {
            
            data++;
            int result = data;
            printIntLine(result);
        }
"
6540,0,CWE190_Integer_Overflow__int64_t_fscanf_preinc_11.c,"    int64_t data;
    data = 0LL;
    if(globalReturnsTrue())
    {
        
        fscanf (stdin, ""%"" SCNd64, &data);
    }
    if(globalReturnsTrue())
    {
        {
            
            ++data;
            int64_t result = data;
            printLongLongLine(result);
        }
"
16498,0,CWE78_OS_Command_Injection__char_console_execl_05.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(staticTrue)
    {
        {
            
            size_t dataLen = strlen(data);
            
            if (100-dataLen > 1)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
                {
                    /* The next few lines remove the carriage return from the string that is
                     * inserted by fgets() */
                    dataLen = strlen(data);
"
8950,0,CWE590_Free_Memory_Not_on_Heap__delete_long_declare_53a.cpp,"    long * data;
    data = NULL; 
    {
        
        long dataBuffer;
        dataBuffer = 5L;
        data = &dataBuffer;
    }
"
9925,0,CWE590_Free_Memory_Not_on_Heap__delete_array_class_declare_11.cpp,"    TwoIntsClass * data;
    data = NULL; 
    if(globalReturnsTrue())
    {
        {
            
            TwoIntsClass dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i].intOne = 1;
                    dataBuffer[i].intTwo = 1;
                }
            }
            data = dataBuffer;
        }
    }
    printIntLine(data[0].intOne);
    
"
16887,0,CWE190_Integer_Overflow__char_max_add_84_bad.cpp,"Label Definition File: CWE190_Integer_Overflow.label.xml
Template File: sources-sinks-84_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 190 Integer Overflow
 * BadSource: max Set data to the max value for char
 * GoodSource: Set data to a small, non-zero number (two)
 * Sinks: add
 *    GoodSink: Ensure there will not be an overflow before adding 1 to data
 *    BadSink : Add 1 to data, which can cause an overflow
 * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE190_Integer_Overflow__char_max_add_84.h""

namespace CWE190_Integer_Overflow__char_max_add_84
{
CWE190_Integer_Overflow__char_max_add_84_bad::CWE190_Integer_Overflow__char_max_add_84_bad(char dataCopy)
{
    data = dataCopy;
    
    data = CHAR_MAX;
}

CWE190_Integer_Overflow__char_max_add_84_bad::~CWE190_Integer_Overflow__char_max_add_84_bad()
{
    {
        
        char result = data + 1;
        printHexCharLine(result);
    }
}
}
"
3871,0,CWE690_NULL_Deref_From_Return__struct_calloc_02.c,"    twoIntsStruct * data;
    data = NULL; 
    
    data = (twoIntsStruct *)calloc(1, sizeof(twoIntsStruct));
    if(1)
    {
        
        data[0].intOne = 1;
        data[0].intTwo = 1;
        printStructLine(&data[0]);
        free(data);
"
4640,0,CWE78_OS_Command_Injection__char_connect_socket_execlp_11.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(globalReturnsTrue())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET connectSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
"
6820,0,CWE78_OS_Command_Injection__char_console_execlp_32.c,"    char * data;
    char * *dataPtr1 = &data;
    char * *dataPtr2 = &data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        char * data = *dataPtr1;
        {
            
            size_t dataLen = strlen(data);
            
            if (100-dataLen > 1)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
                {
                    /* The next few lines remove the carriage return from the string that is
"
8127,0,CWE563_Unused_Variable__unused_value_struct_17.c,"    int i,j;
    twoIntsStruct data;
    for(i = 0; i < 1; i++)
    {
        
        data.intOne = 0;
        data.intTwo = 0;
    }
    for(j = 0; j < 1; j++)
    {
        
        data.intOne = 1;
        data.intTwo = 1;
        printStructLine(&data);
"
2954,1,CWE758_Undefined_Behavior__struct_pointer_malloc_use_02.c,"    if(0)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            twoIntsStruct * data;
            twoIntsStruct * * pointer = (twoIntsStruct * *)malloc(sizeof(twoIntsStruct *));
            if (pointer == NULL) {exit(-1);}
            
            data = (twoIntsStruct *)malloc(sizeof(twoIntsStruct));
            if (data == NULL) {exit(-1);}
            data->intOne = 5;
            data->intTwo = 6;
            *pointer = data; 
            {
                twoIntsStruct * data = *pointer;
                printIntLine(data->intOne);
                printIntLine(data->intTwo);
            }
            free(pointer);
        }
"
12259,1,CWE252_Unchecked_Return_Value__char_rename_13.c,"    if(GLOBAL_CONST_FIVE==5)
    {
        
        if (RENAME(OLD_GOOD_FILE_NAME, ""newgoodfilename.txt"") != 0)
        {
            printLine(""rename failed!"");
        }
"
1666,1,CWE252_Unchecked_Return_Value__char_snprintf_01.c,"    {
        /* By initializing dataBuffer, we ensure this will not be the
         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
        char dataBuffer[100] = """";
        char * data = dataBuffer;
        
        if (SNPRINTF(data,100-strlen(SRC)-1, ""%s\n"", SRC) < 0)
        {
            printLine(""snprintf failed!"");
        }
"
1904,0,CWE415_Double_Free__new_delete_array_class_54a.cpp,"    TwoIntsClass * data;
    
    data = NULL;
    data = new TwoIntsClass[100];
    
    delete [] data;
"
9528,0,CWE190_Integer_Overflow__short_max_add_53a.c,"    short data;
    data = 0;
    
    data = SHRT_MAX;
"
15929,0,CWE401_Memory_Leak__new_twoIntsStruct_81_bad.cpp,"Label Definition File: CWE401_Memory_Leak__new.label.xml
Template File: sources-sinks-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 401 Memory Leak
 * BadSource:  Allocate data using new
 * GoodSource: Allocate data on the stack
 * Sinks:
 *    GoodSink: call delete on data
 *    BadSink : no deallocation of data
 * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE401_Memory_Leak__new_twoIntsStruct_81.h""

namespace CWE401_Memory_Leak__new_twoIntsStruct_81
{

void CWE401_Memory_Leak__new_twoIntsStruct_81_bad::action(twoIntsStruct * data) const
{
    
    ; 
}

}
"
8016,1,CWE252_Unchecked_Return_Value__char_puts_14.c,"    if(globalFive!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        
        if (PUTS(""string"") == EOF)
        {
            printLine(""puts failed!"");
        }
"
14774,0,CWE789_Uncontrolled_Mem_Alloc__new_char_connect_socket_83a.cpp,"    size_t data;
    
    data = 0;
"
2423,0,CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_22a.cpp,"    size_t data;
    
    data = 0;
    
    fscanf(stdin, ""%zu"", &data);
    badGlobal = 1; 
"
4867,0,CWE457_Use_of_Uninitialized_Variable__struct_array_declare_partial_init_12.c,"    twoIntsStruct * data;
    twoIntsStruct dataUninitArray[10];
    data = dataUninitArray;
    if(globalReturnsTrueOrFalse())
    {
        
        {
            int i;
            for(i=0; i<(10/2); i++)
            {
                data[i].intOne = i;
                data[i].intTwo = i;
            }
        }
    }
    else
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                data[i].intOne = i;
                data[i].intTwo = i;
            }
        }
    }
    if(globalReturnsTrueOrFalse())
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i].intOne);
                printIntLine(data[i].intTwo);
            }
        }
    }
    else
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                data[i].intOne = i;
                data[i].intTwo = i;
            }
        }
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i].intOne);
                printIntLine(data[i].intTwo);
            }
        }
"
1112,0,CWE190_Integer_Overflow__short_max_add_63a.c,"    short data;
    data = 0;
    
    data = SHRT_MAX;
"
19260,0,CWE415_Double_Free__new_delete_int_32.cpp,"    int * data;
    int * *dataPtr1 = &data;
    int * *dataPtr2 = &data;
    
    data = NULL;
    {
        int * data = *dataPtr1;
        data = new int;
        
        delete data;
        *dataPtr1 = data;
    }
    {
        int * data = *dataPtr2;
        
        delete data;
"
1771,0,CWE190_Integer_Overflow__int_fscanf_postinc_64a.c,"    int data;
    
    data = 0;
    
    fscanf(stdin, ""%d"", &data);
"
5409,0,CWE401_Memory_Leak__virtual_destructor_01_bad.cpp," * 
 * */

#include ""std_testcase.h""

namespace CWE401_Memory_Leak__virtual_destructor_01
{

#ifndef OMITBAD

class BadBaseClass
{
    public:
        BadBaseClass()
        { 
            printLine(""Constructor: BadBaseClass"");
        }
        
        /* FLAW: Non-virtual destructor - the destructor of the 
         * derived class will not be called */
        ~BadBaseClass()
        { 
            printLine(""Destructor : BadBaseClass"");
        }
};

class BadDerivedClass: public BadBaseClass
{
    public:
        BadDerivedClass(const char * name)
        {
            printLine(""Constructor: BadDerivedClass"");
            if (name)
            {
                this->name = new char[strlen(name) + 1];
                strcpy(this->name, name);
                printLine(this->name);
            }
            else
            {
                this->name = new char[1];
                *(this->name) = '\0';
            }
        }
        
        ~BadDerivedClass()
        {
            
            printLine(""Destructor : BadDerivedClass"");
            delete [] name;
        }

        
        BadDerivedClass(BadDerivedClass &derivedClassObject)
        { 
            this->name = new char[strlen(derivedClassObject.name) + 1];
            strcpy(this->name, derivedClassObject.name);
        }

        
        BadDerivedClass& operator=(const BadDerivedClass &derivedClassObject)
        { 
            if (&derivedClassObject != this) 
            { 
                this->name = new char[strlen(derivedClassObject.name) + 1];
                strcpy(this->name, derivedClassObject.name);
            } 
            return *this; 
        }

    private:
        char * name;
};

void bad()
{
    BadBaseClass * baseClassObject = new BadDerivedClass(""BadClass"");

    delete baseClassObject;
}

#endif 

} 

/* Below is the main(). It is only used when building this testcase on 
 * its own for testing or for building a binary to use in testing binary 
 * analysis tools. It is not used when compiling all the testcases as one 
 * application, which is how source code analysis tools are tested. 
 */ 

#ifdef INCLUDEMAIN

using namespace CWE401_Memory_Leak__virtual_destructor_01; 

int main(int argc, char * argv[])
{
    
    srand( (unsigned)time(NULL) );
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}

"
5652,0,CWE401_Memory_Leak__int64_t_calloc_11.c,"    int64_t * data;
    data = NULL;
    if(globalReturnsTrue())
    {
        
        data = (int64_t *)calloc(100, sizeof(int64_t));
        if (data == NULL) {exit(-1);}
        
        data[0] = 5LL;
        printLongLongLine(data[0]);
    }
    if(globalReturnsTrue())
    {
        
        ; 
"
11729,0,CWE134_Uncontrolled_Format_String__char_listen_socket_printf_33.cpp,"    char * data;
    char * &dataRef = data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    {
        char * data = dataRef;
        
        printf(data);
"
10801,0,CWE369_Divide_by_Zero__int_zero_divide_05.c,"    int data;
    
    data = -1;
    if(staticTrue)
    {
        
        data = 0;
    }
    if(staticTrue)
    {
        
        printIntLine(100 / data);
"
2166,0,CWE190_Integer_Overflow__int_rand_square_08.c,"    int data;
    
    data = 0;
    if(staticReturnsTrue())
    {
        
        data = RAND32();
    }
    if(staticReturnsTrue())
    {
        {
            
            int result = data * data;
            printIntLine(result);
        }
"
4523,0,CWE190_Integer_Overflow__char_max_add_33.cpp,"    char data;
    char &dataRef = data;
    data = ' ';
    
    data = CHAR_MAX;
    {
        char data = dataRef;
        {
            
            char result = data + 1;
            printHexCharLine(result);
        }
"
2311,0,CWE563_Unused_Variable__unused_uninit_variable_struct_84_bad.cpp,"Label Definition File: CWE563_Unused_Variable__unused_uninit_variable.label.xml
Template File: source-sinks-84_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 563 Unused Variable
 * BadSource:  Initialize data
 * Sinks:
 *    GoodSink: Initialize, then use data
 *    BadSink : Do nothing
 * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE563_Unused_Variable__unused_uninit_variable_struct_84.h""

namespace CWE563_Unused_Variable__unused_uninit_variable_struct_84
{
CWE563_Unused_Variable__unused_uninit_variable_struct_84_bad::CWE563_Unused_Variable__unused_uninit_variable_struct_84_bad(twoIntsStruct dataCopy)
{
    data = dataCopy;
    
    ; 
}

CWE563_Unused_Variable__unused_uninit_variable_struct_84_bad::~CWE563_Unused_Variable__unused_uninit_variable_struct_84_bad()
{
    
    
    ; 
}
}
"
8044,0,CWE190_Integer_Overflow__int_fscanf_multiply_74a.cpp,"    int data;
    map<int, int> dataMap;
    
    data = 0;
    
    fscanf(stdin, ""%d"", &data);
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
4359,0,CWE134_Uncontrolled_Format_String__char_console_vfprintf_52a.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        
        if (100-dataLen > 1)
        {
            
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgets() */
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
                    data[dataLen-1] = '\0';
                }
            }
            else
            {
                printLine(""fgets() failed"");
                
                data[dataLen] = '\0';
            }
        }
    }
"
7376,0,CWE476_NULL_Pointer_Dereference__int_81a.cpp,"    int * data;
    
    data = NULL;
    const CWE476_NULL_Pointer_Dereference__int_81_base& baseObject = CWE476_NULL_Pointer_Dereference__int_81_bad();
"
15210,0,CWE134_Uncontrolled_Format_String__char_file_vprintf_21.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        FILE * pFile;
        
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
    badStatic = 1; 
"
13532,0,CWE252_Unchecked_Return_Value__char_scanf_14.c,"    if(globalFive==5)
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            
            scanf(""%99s\0"", data);
        }
"
4625,0,CWE134_Uncontrolled_Format_String__char_file_snprintf_04.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(STATIC_CONST_TRUE)
    {
        {
            
            size_t dataLen = strlen(data);
            FILE * pFile;
            
            if (100-dataLen > 1)
            {
                pFile = fopen(FILENAME, ""r"");
                if (pFile != NULL)
                {
                    
                    if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                    {
                        printLine(""fgets() failed"");
                        
                        data[dataLen] = '\0';
                    }
                    fclose(pFile);
                }
            }
        }
    }
    if(STATIC_CONST_TRUE)
    {
        {
            char dest[100] = """";
            
            SNPRINTF(dest, 100-1, data);
            printLine(dest);
        }
"
15236,0,CWE190_Integer_Overflow__int64_t_max_add_53a.c,"    int64_t data;
    data = 0LL;
    
    data = LLONG_MAX;
"
14058,0,CWE190_Integer_Overflow__char_max_add_10.c,"    char data;
    data = ' ';
    if(globalTrue)
    {
        
        data = CHAR_MAX;
    }
    if(globalTrue)
    {
        {
            
            char result = data + 1;
            printHexCharLine(result);
        }
"
1503,0,CWE190_Integer_Overflow__short_max_add_74a.cpp,"    short data;
    map<int, short> dataMap;
    data = 0;
    
    data = SHRT_MAX;
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
13622,0,CWE190_Integer_Overflow__char_max_preinc_41.c,"    char data;
    data = ' ';
    
    data = CHAR_MAX;
"
12919,0,CWE190_Integer_Overflow__int_listen_socket_multiply_04.c,"    int data;
    
    data = 0;
    if(STATIC_CONST_TRUE)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(STATIC_CONST_TRUE)
    {
        if(data > 0) 
        {
            
            int result = data * 2;
            printIntLine(result);
        }
"
12399,1,CWE252_Unchecked_Return_Value__char_snprintf_03.c,"    if(5==5)
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            
            if (SNPRINTF(data,100-strlen(SRC)-1, ""%s\n"", SRC) < 0)
            {
                printLine(""snprintf failed!"");
            }
        }
"
2337,0,CWE197_Numeric_Truncation_Error__short_fgets_62a.cpp,"    short data;
    
    data = -1;
    badSource(data);
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
5401,0,CWE401_Memory_Leak__char_realloc_16.c,"    char * data;
    data = NULL;
    while(1)
    {
        
        data = (char *)realloc(data, 100*sizeof(char));
        if (data == NULL) {exit(-1);}
        
        strcpy(data, ""A String"");
        printLine(data);
        break;
    }
    while(1)
    {
        
        ; 
        break;
"
2515,0,CWE590_Free_Memory_Not_on_Heap__delete_long_placement_new_45.cpp,"    long * data;
    data = NULL; 
    {
        
        char buffer[sizeof(long)];
        long * dataBuffer = new(buffer) long;
        *dataBuffer = 5L;
        data = dataBuffer;
    }
    badData = data;
"
3777,0,CWE590_Free_Memory_Not_on_Heap__delete_array_long_static_03.cpp,"    long * data;
    data = NULL; 
    if(5==5)
    {
        {
            
            static long dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5L;
                }
            }
            data = dataBuffer;
        }
    }
    printLongLine(data[0]);
    
"
3519,0,CWE401_Memory_Leak__malloc_realloc_int64_t_05.c,"    if(staticTrue)
    {
        {
            int64_t * data = (int64_t *)malloc(100*sizeof(int64_t));
            if (data == NULL) {exit(-1);}
            
            data[0] = 5LL;
            printLongLongLine(data[0]);
            
            data = (int64_t *)realloc(data, (130000)*sizeof(int64_t));
            if (data != NULL)
            {
                
                data[0] = 10LL;
                printLongLongLine(data[0]);
                free(data);
            }
        }
"
9803,0,CWE590_Free_Memory_Not_on_Heap__free_char_declare_67a.c,"    char * data;
    CWE590_Free_Memory_Not_on_Heap__free_char_declare_67_structType myStruct;
    data = NULL; 
    {
        
        char dataBuffer[100];
        memset(dataBuffer, 'A', 100-1); 
        dataBuffer[100-1] = '\0'; 
        data = dataBuffer;
    }
    myStruct.structFirst = data;
"
11181,0,CWE563_Unused_Variable__unused_uninit_variable_char_06.c,"    char data;
    
    ; 
    if(STATIC_CONST_FIVE==5)
    {
        
        
        ; 
"
5352,0,CWE190_Integer_Overflow__int_connect_socket_multiply_84_bad.cpp,"Label Definition File: CWE190_Integer_Overflow__int.label.xml
Template File: sources-sinks-84_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 190 Integer Overflow
 * BadSource: connect_socket Read data using a connect socket (client side)
 * GoodSource: Set data to a small, non-zero number (two)
 * Sinks: multiply
 *    GoodSink: Ensure there will not be an overflow before multiplying data by 2
 *    BadSink : If data is positive, multiply by 2, which can cause an overflow
 * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE190_Integer_Overflow__int_connect_socket_multiply_84.h""

#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif

#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)

namespace CWE190_Integer_Overflow__int_connect_socket_multiply_84
{
CWE190_Integer_Overflow__int_connect_socket_multiply_84_bad::CWE190_Integer_Overflow__int_connect_socket_multiply_84_bad(int dataCopy)
{
    data = dataCopy;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
}

CWE190_Integer_Overflow__int_connect_socket_multiply_84_bad::~CWE190_Integer_Overflow__int_connect_socket_multiply_84_bad()
{
    if(data > 0) 
    {
        
        int result = data * 2;
        printIntLine(result);
    }
}
}
"
14137,0,CWE415_Double_Free__malloc_free_int64_t_65a.c,"    int64_t * data;
    
    void (*funcPtr) (int64_t *) = CWE415_Double_Free__malloc_free_int64_t_65b_badSink;
    
    data = NULL;
    data = (int64_t *)malloc(100*sizeof(int64_t));
    if (data == NULL) {exit(-1);}
    
    free(data);
    
"
15582,0,CWE78_OS_Command_Injection__char_console_system_74a.cpp,"    char * data;
    map<int, char *> dataMap;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
        
        size_t dataLen = strlen(data);
        
        if (100-dataLen > 1)
        {
            
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgets() */
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
                    data[dataLen-1] = '\0';
                }
            }
            else
            {
                printLine(""fgets() failed"");
                
                data[dataLen] = '\0';
            }
        }
    }
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
961,0,CWE190_Integer_Overflow__int_listen_socket_add_83a.cpp,"    int data;
    
    data = 0;
"
7512,0,CWE190_Integer_Overflow__char_rand_postinc_68a.c,"    char data;
    data = ' ';
    
    data = (char)RAND32();
    CWE190_Integer_Overflow__char_rand_postinc_68_badData = data;
"
5307,0,CWE190_Integer_Overflow__short_max_multiply_18.c,"    short data;
    data = 0;
    goto source;
source:
    
    data = SHRT_MAX;
    goto sink;
sink:
    if(data > 0) 
    {
        
        short result = data * 2;
        printIntLine(result);
"
13238,0,CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_67a.c,"    char * data;
    CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_67_structType myStruct;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    myStruct.structFirst = data;
"
15227,0,CWE190_Integer_Overflow__int_max_preinc_65a.c,"    int data;
    
    void (*funcPtr) (int) = CWE190_Integer_Overflow__int_max_preinc_65b_badSink;
    
    data = 0;
    
    data = INT_MAX;
    
"
14290,0,CWE590_Free_Memory_Not_on_Heap__delete_char_declare_11.cpp,"    char * data;
    data = NULL; 
    if(globalReturnsTrue())
    {
        {
            
            char dataBuffer;
            dataBuffer = 'A';
            data = &dataBuffer;
        }
    }
    printHexCharLine(*data);
    
"
3118,0,CWE401_Memory_Leak__new_twoIntsStruct_06.cpp,"    twoIntsStruct * data;
    data = NULL;
    if(STATIC_CONST_FIVE==5)
    {
        
        data = new twoIntsStruct;
        
        data->intOne = 0;
        data->intTwo = 0;
        printStructLine(data);
    }
    if(STATIC_CONST_FIVE==5)
    {
        
        ; 
"
8373,0,CWE416_Use_After_Free__return_freed_ptr_11.c,"    if(globalReturnsTrue())
    {
        {
            
            char * reversedString = helperBad(""BadSink"");
            printLine(reversedString);
            /* free(reversedString);
             * This call to free() was removed because we want the tool to detect the use after free,
             * but we don't want that function to be free(). Essentially we want to avoid a double free
             */
        }
"
17030,0,CWE190_Integer_Overflow__int_fgets_square_32.c,"    int data;
    int *dataPtr1 = &data;
    int *dataPtr2 = &data;
    
    data = 0;
    {
        int data = *dataPtr1;
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
        *dataPtr1 = data;
    }
    {
        int data = *dataPtr2;
        {
            
            int result = data * data;
            printIntLine(result);
        }
"
6371,0,CWE197_Numeric_Truncation_Error__short_fgets_72a.cpp,"    short data;
    vector<short> dataVector;
    
    data = -1;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = (short)atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
1919,1,CWE401_Memory_Leak__destructor_01_good1.cpp,"    GoodClass goodClassObject (""GoodClass"");

"
7432,0,CWE190_Integer_Overflow__int_connect_socket_square_84a.cpp,"    int data;
    
    data = 0;
    CWE190_Integer_Overflow__int_connect_socket_square_84_bad * badObject = new CWE190_Integer_Overflow__int_connect_socket_square_84_bad(data);
"
8302,0,CWE587_Assignment_of_Fixed_Address_to_Pointer__basic_18.c,"    goto sink;
sink:
    {
        
        char *charPointer = (char*)0x400000;
        printHexCharLine(*charPointer);
"
16481,0,CWE190_Integer_Overflow__char_rand_multiply_66a.c,"    char data;
    char dataArray[5];
    data = ' ';
    
    data = (char)RAND32();
    
    dataArray[2] = data;
"
7137,0,CWE457_Use_of_Uninitialized_Variable__double_pointer_06.c,"    double * data;
    if(STATIC_CONST_FIVE==5)
    {
        
        ; 
    }
    if(STATIC_CONST_FIVE==5)
    {
        
        printDoubleLine(*data);
"
10412,0,CWE416_Use_After_Free__malloc_free_int64_t_04.c,"    int64_t * data;
    
    data = NULL;
    if(STATIC_CONST_TRUE)
    {
        data = (int64_t *)malloc(100*sizeof(int64_t));
        if (data == NULL) {exit(-1);}
        {
            size_t i;
            for(i = 0; i < 100; i++)
            {
                data[i] = 5LL;
            }
        }
        
        free(data);
    }
    if(STATIC_CONST_TRUE)
    {
        
        printLongLongLine(data[0]);
        
"
13206,0,CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_31.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    {
        char * dataCopy = data;
        char * data = dataCopy;
        badVaSink(data, data);
"
8981,0,CWE252_Unchecked_Return_Value__char_fscanf_18.c,"    goto sink;
sink:
    {
        /* By initializing dataBuffer, we ensure this will not be the
         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
        char dataBuffer[100] = """";
        char * data = dataBuffer;
        
        fscanf(stdin, ""%99s\0"", data);
"
10673,0,CWE134_Uncontrolled_Format_String__char_console_vfprintf_82_bad.cpp,"Label Definition File: CWE134_Uncontrolled_Format_String.vasinks.label.xml
Template File: sources-vasinks-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 134 Uncontrolled Format String
 * BadSource: console Read input from the console
 * GoodSource: Copy a fixed string into data
 * Sinks: vfprintf
 *    GoodSink: vfprintf with a format string
 *    BadSink : vfprintf without a format string
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include <stdarg.h>
#include ""std_testcase.h""
#include ""CWE134_Uncontrolled_Format_String__char_console_vfprintf_82.h""

namespace CWE134_Uncontrolled_Format_String__char_console_vfprintf_82
{

static void badVaSink(char * data, ...)
{
    {
        va_list args;
        va_start(args, data);
        
        vfprintf(stdout, data, args);
        va_end(args);
    }
}

void CWE134_Uncontrolled_Format_String__char_console_vfprintf_82_bad::action(char * data)
{
    badVaSink(data, data);
}

}
"
13335,0,CWE563_Unused_Variable__unused_uninit_variable_int64_t_21.c,"    int64_t data;
    
    ; 
    badStatic = 1; 
"
3293,0,CWE190_Integer_Overflow__int64_t_fscanf_square_68a.c,"    int64_t data;
    data = 0LL;
    
    fscanf (stdin, ""%"" SCNd64, &data);
    CWE190_Integer_Overflow__int64_t_fscanf_square_68_badData = data;
"
14236,0,CWE369_Divide_by_Zero__int_fscanf_divide_18.c,"    int data;
    
    data = -1;
    goto source;
source:
    
    fscanf(stdin, ""%d"", &data);
    goto sink;
sink:
    
"
6939,0,CWE415_Double_Free__malloc_free_int_74a.cpp,"    int * data;
    map<int, int *> dataMap;
    
    data = NULL;
    data = (int *)malloc(100*sizeof(int));
    if (data == NULL) {exit(-1);}
    
    free(data);
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
19025,0,CWE252_Unchecked_Return_Value__char_snprintf_05.c,"    if(staticTrue)
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            
            SNPRINTF(data,100-strlen(SRC)-1, ""%s\n"", SRC);
        }
"
12893,0,CWE252_Unchecked_Return_Value__char_snprintf_04.c,"    if(STATIC_CONST_TRUE)
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            
            SNPRINTF(data,100-strlen(SRC)-1, ""%s\n"", SRC);
        }
"
7656,0,CWE690_NULL_Deref_From_Return__char_realloc_68a.c,"    char * data;
    data = NULL; 
    
    data = (char *)realloc(data, 20*sizeof(char));
    CWE690_NULL_Deref_From_Return__char_realloc_68_badDataForBadSink = data;
"
17128,0,CWE416_Use_After_Free__new_delete_int_18.cpp,"    int * data;
    
    data = NULL;
    goto source;
source:
    data = new int;
    *data = 5;
    
    delete data;
    goto sink;
sink:
    
    printIntLine(*data);
"
5838,0,CWE369_Divide_by_Zero__int_listen_socket_modulo_03.c,"    int data;
    
    data = -1;
    if(5==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(5==5)
    {
        
        printIntLine(100 % data);
"
18941,0,CWE78_OS_Command_Injection__char_listen_socket_execlp_82a.cpp,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    CWE78_OS_Command_Injection__char_listen_socket_execlp_82_base* baseObject = new CWE78_OS_Command_Injection__char_listen_socket_execlp_82_bad;
    baseObject->action(data);
"
715,1,CWE758_Undefined_Behavior__struct_pointer_new_use_11.cpp,"    if(globalReturnsFalse())
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            twoIntsStruct * data;
            
            data = new twoIntsStruct;
            data->intOne = 5;
            data->intTwo = 6;
            twoIntsStruct * * pointer = new twoIntsStruct *;
            *pointer = data; 
            {
                twoIntsStruct * data = *pointer;
                printIntLine(data->intOne);
                printIntLine(data->intTwo);
            }
            delete pointer;
        }
"
6579,0,CWE190_Integer_Overflow__int_fgets_add_45.c,"    int data;
    
    data = 0;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    CWE190_Integer_Overflow__int_fgets_add_45_badData = data;
"
12611,0,CWE190_Integer_Overflow__char_fscanf_multiply_43.cpp,"    char data;
    data = ' ';
    badSource(data);
    if(data > 0) 
    {
        
        char result = data * 2;
        printHexCharLine(result);
"
17408,0,CWE190_Integer_Overflow__char_rand_square_31.c,"    char data;
    data = ' ';
    
    data = (char)RAND32();
    {
        char dataCopy = data;
        char data = dataCopy;
        {
            
            char result = data * data;
            printHexCharLine(result);
        }
"
13555,0,CWE758_Undefined_Behavior__long_alloca_use_15.c,"    switch(6)
    {
    case 6:
    {
        long * pointer = (long *)ALLOCA(sizeof(long));
        long data = *pointer; 
        printLongLine(data);
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
12982,0,CWE190_Integer_Overflow__int_max_square_11.c,"    int data;
    
    data = 0;
    if(globalReturnsTrue())
    {
        
        data = INT_MAX;
    }
    if(globalReturnsTrue())
    {
        {
            
            int result = data * data;
            printIntLine(result);
        }
"
8687,1,CWE758_Undefined_Behavior__char_malloc_use_17.c,"    int k;
    for(k = 0; k < 1; k++)
    {
        {
            char data;
            char * pointer = (char *)malloc(sizeof(char));
            if (pointer == NULL) {exit(-1);}
            data = 5;
            *pointer = data; 
            {
                char data = *pointer;
                printHexCharLine(data);
            }
            free(pointer);
        }
"
13258,0,CWE415_Double_Free__malloc_free_int64_t_45.c,"    int64_t * data;
    
    data = NULL;
    data = (int64_t *)malloc(100*sizeof(int64_t));
    if (data == NULL) {exit(-1);}
    
    free(data);
    CWE415_Double_Free__malloc_free_int64_t_45_badData = data;
"
12907,0,CWE190_Integer_Overflow__short_max_multiply_63a.c,"    short data;
    data = 0;
    
    data = SHRT_MAX;
"
9788,1,CWE758_Undefined_Behavior__int_pointer_malloc_use_11.c,"    if(globalReturnsFalse())
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            int * data;
            int * * pointer = (int * *)malloc(sizeof(int *));
            if (pointer == NULL) {exit(-1);}
            
            data = (int *)malloc(sizeof(int));
            if (data == NULL) {exit(-1);}
            *data = 5;
            *pointer = data; 
            {
                int * data = *pointer;
                printIntLine(*data);
            }
            free(pointer);
        }
"
13157,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_04.c,"    size_t data;
    
    data = 0;
    if(STATIC_CONST_TRUE)
    {
        
        data = rand();
    }
    if(STATIC_CONST_TRUE)
    {
        {
            char * myString;
            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
             * for the strcpy() function to not cause a buffer overflow */
            
            if (data > strlen(HELLO_STRING))
            {
                myString = (char *)malloc(data*sizeof(char));
                if (myString == NULL) {exit(-1);}
                
                strcpy(myString, HELLO_STRING);
                printLine(myString);
                free(myString);
            }
            else
            {
                printLine(""Input is less than the length of the source string"");
            }
        }
"
5990,0,CWE190_Integer_Overflow__int_connect_socket_add_81a.cpp,"    int data;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    const CWE190_Integer_Overflow__int_connect_socket_add_81_base& baseObject = CWE190_Integer_Overflow__int_connect_socket_add_81_bad();
"
1622,0,CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_81a.cpp,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    const CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_81_base& baseObject = CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_81_bad();
"
19412,0,CWE78_OS_Command_Injection__char_console_popen_09.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(GLOBAL_CONST_TRUE)
    {
        {
            
            size_t dataLen = strlen(data);
            
            if (100-dataLen > 1)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
                {
                    /* The next few lines remove the carriage return from the string that is
                     * inserted by fgets() */
                    dataLen = strlen(data);
"
10813,0,CWE416_Use_After_Free__new_delete_array_long_01.cpp,"    long * data;
    
    data = NULL;
    data = new long[100];
    {
        size_t i;
        for(i = 0; i < 100; i++)
        {
            data[i] = 5L;
        }
    }
    
    delete [] data;
    
    printLongLine(data[0]);
"
10682,0,CWE590_Free_Memory_Not_on_Heap__free_struct_alloca_02.c,"    twoIntsStruct * data;
    data = NULL; 
    if(1)
    {
        {
            
            twoIntsStruct * dataBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i].intOne = 1;
                    dataBuffer[i].intTwo = 1;
                }
            }
            data = dataBuffer;
        }
    }
    printStructLine(&data[0]);
    
"
18550,0,CWE78_OS_Command_Injection__char_environment_system_13.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            
            size_t dataLen = strlen(data);
            char * environment = GETENV(ENV_VARIABLE);
            
            if (environment != NULL)
            {
                
                strncat(data+dataLen, environment, 100-dataLen-1);
            }
        }
    }
    
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
"
9210,0,CWE758_Undefined_Behavior__int_pointer_malloc_use_07.c,"    if(staticFive==5)
    {
        {
            int * * pointer = (int * *)malloc(sizeof(int *));
            if (pointer == NULL) {exit(-1);}
            int * data = *pointer; 
            free(pointer);
            printIntLine(*data);
        }
"
12986,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_72a.cpp,"    size_t data;
    vector<size_t> dataVector;
    
    data = 0;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = strtoul(inputBuffer, NULL, 0);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
2010,0,CWE369_Divide_by_Zero__float_connect_socket_10.c,"    float data;
    
    data = 0.0F;
    if(globalTrue)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = (float)atof(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(globalTrue)
    {
        {
            
            int result = (int)(100.0 / data);
            printIntLine(result);
        }
"
2156,0,CWE563_Unused_Variable__unused_value_int_02.c,"    int data;
    if(1)
    {
        
        data = 5;
    }
    if(1)
    {
        
        data = 10;
        printIntLine(data);
"
13389,0,CWE190_Integer_Overflow__char_max_square_01.c,"    char data;
    data = ' ';
    
    data = CHAR_MAX;
    {
        
        char result = data * data;
        printHexCharLine(result);
"
19271,0,CWE457_Use_of_Uninitialized_Variable__struct_array_declare_no_init_08.c,"    twoIntsStruct * data;
    twoIntsStruct dataUninitArray[10];
    data = dataUninitArray;
    if(staticReturnsTrue())
    {
        
        ; 
    }
    if(staticReturnsTrue())
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i].intOne);
                printIntLine(data[i].intTwo);
            }
        }
"
1568,0,CWE457_Use_of_Uninitialized_Variable__double_array_malloc_no_init_06.c,"    double * data;
    data = (double *)malloc(10*sizeof(double));
    if (data == NULL) {exit(-1);}
    if(STATIC_CONST_FIVE==5)
    {
        
        ; 
    }
    if(STATIC_CONST_FIVE==5)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printDoubleLine(data[i]);
            }
        }
"
16246,0,CWE401_Memory_Leak__twoIntsStruct_realloc_18.c,"    twoIntsStruct * data;
    data = NULL;
    goto source;
source:
    
    data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));
    if (data == NULL) {exit(-1);}
    
    data[0].intOne = 0;
    data[0].intTwo = 0;
    printStructLine(&data[0]);
    goto sink;
sink:
    
"
14497,0,CWE190_Integer_Overflow__char_rand_preinc_05.c,"    char data;
    data = ' ';
    if(staticTrue)
    {
        
        data = (char)RAND32();
    }
    if(staticTrue)
    {
        {
            
            ++data;
            char result = data;
            printHexCharLine(result);
        }
"
7233,0,CWE415_Double_Free__malloc_free_struct_41.c,"    twoIntsStruct * data;
    
    data = NULL;
    data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
    if (data == NULL) {exit(-1);}
    
    free(data);
"
4910,0,CWE190_Integer_Overflow__char_max_postinc_14.c,"    char data;
    data = ' ';
    if(globalFive==5)
    {
        
        data = CHAR_MAX;
    }
    if(globalFive==5)
    {
        {
            
            data++;
            char result = data;
            printHexCharLine(result);
        }
"
6614,0,CWE758_Undefined_Behavior__int64_t_malloc_use_10.c,"    if(globalTrue)
    {
        {
            int64_t * pointer = (int64_t *)malloc(sizeof(int64_t));
            if (pointer == NULL) {exit(-1);}
            int64_t data = *pointer; 
            free(pointer);
            printLongLongLine(data);
        }
"
15109,0,CWE197_Numeric_Truncation_Error__short_fgets_07.c,"    short data;
    
    data = -1;
    if(staticFive==5)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                
                data = (short)atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
14596,0,CWE369_Divide_by_Zero__float_listenSocket_34.c,"    float data;
    CWE369_Divide_by_Zero__float_listenSocket_34_unionType myUnion;
    
    data = 0.0F;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = (float)atof(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    myUnion.unionFirst = data;
    {
        float data = myUnion.unionSecond;
        {
            
            int result = (int)(100.0 / data);
            printIntLine(result);
        }
"
7521,0,CWE690_NULL_Deref_From_Return__int64_t_calloc_13.c,"    int64_t * data;
    data = NULL; 
    
    data = (int64_t *)calloc(1, sizeof(int64_t));
    if(GLOBAL_CONST_FIVE==5)
    {
        
        data[0] = 5LL;
        printLongLongLine(data[0]);
        free(data);
"
11559,0,CWE190_Integer_Overflow__unsigned_int_fscanf_square_14.c,"    unsigned int data;
    data = 0;
    if(globalFive==5)
    {
        
        fscanf (stdin, ""%u"", &data);
    }
    if(globalFive==5)
    {
        {
            
            unsigned int result = data * data;
            printUnsignedLine(result);
        }
"
19249,0,CWE252_Unchecked_Return_Value__char_fscanf_13.c,"    if(GLOBAL_CONST_FIVE==5)
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            
            fscanf(stdin, ""%99s\0"", data);
        }
"
16716,0,CWE369_Divide_by_Zero__int_zero_divide_08.c,"    int data;
    
    data = -1;
    if(staticReturnsTrue())
    {
        
        data = 0;
    }
    if(staticReturnsTrue())
    {
        
        printIntLine(100 / data);
"
19036,0,CWE190_Integer_Overflow__int64_t_fscanf_square_53a.c,"    int64_t data;
    data = 0LL;
    
    fscanf (stdin, ""%"" SCNd64, &data);
"
14369,0,CWE134_Uncontrolled_Format_String__char_console_printf_08.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(staticReturnsTrue())
    {
        {
            
            size_t dataLen = strlen(data);
            
            if (100-dataLen > 1)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
                {
                    /* The next few lines remove the carriage return from the string that is
                     * inserted by fgets() */
                    dataLen = strlen(data);
                    if (dataLen > 0 && data[dataLen-1] == '\n')
                    {
                        data[dataLen-1] = '\0';
                    }
                }
                else
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
            }
        }
    }
    if(staticReturnsTrue())
    {
        
        printf(data);
"
4315,0,CWE457_Use_of_Uninitialized_Variable__int_array_malloc_no_init_13.c,"    int * data;
    data = (int *)malloc(10*sizeof(int));
    if (data == NULL) {exit(-1);}
    if(GLOBAL_CONST_FIVE==5)
    {
        
        ; 
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i]);
            }
        }
"
3061,0,CWE190_Integer_Overflow__int64_t_rand_multiply_06.c,"    int64_t data;
    data = 0LL;
    if(STATIC_CONST_FIVE==5)
    {
        
        data = (int64_t)RAND64();
    }
    if(STATIC_CONST_FIVE==5)
    {
        if(data > 0) 
        {
            
            int64_t result = data * 2;
            printLongLongLine(result);
        }
"
491,1,CWE758_Undefined_Behavior__double_pointer_malloc_use_10.c,"    if(globalTrue)
    {
        {
            double * data;
            double * * pointer = (double * *)malloc(sizeof(double *));
            if (pointer == NULL) {exit(-1);}
            
            data = (double *)malloc(sizeof(double));
            if (data == NULL) {exit(-1);}
            *data = 5.0;
            *pointer = data; 
            {
                double * data = *pointer;
                printDoubleLine(*data);
            }
            free(pointer);
        }
"
7355,1,CWE252_Unchecked_Return_Value__char_sscanf_15.c,"    switch(6)
    {
    case 6:
    {
        /* By initializing dataBuffer, we ensure this will not be the
         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
        char dataBuffer[100] = """";
        char * data = dataBuffer;
        
        if (sscanf(SRC, ""%99s\0"", data) == EOF)
        {
            printLine(""sscanf failed!"");
        }
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
14025,0,CWE78_OS_Command_Injection__char_environment_execl_82_bad.cpp,"Label Definition File: CWE78_OS_Command_Injection.strings.label.xml
Template File: sources-sink-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 78 OS Command Injection
 * BadSource: environment Read input from an environment variable
 * GoodSource: Fixed string
 * Sinks: execl
 *    BadSink : execute command with execl
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE78_OS_Command_Injection__char_environment_execl_82.h""

#ifdef _WIN32
#include <process.h>
#define EXECL _execl
#else 
#define EXECL execl
#endif

namespace CWE78_OS_Command_Injection__char_environment_execl_82
{

void CWE78_OS_Command_Injection__char_environment_execl_82_bad::action(char * data)
{
    
    
    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}

}
"
19341,0,CWE134_Uncontrolled_Format_String__char_file_vprintf_10.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(globalTrue)
    {
        {
            
            size_t dataLen = strlen(data);
            FILE * pFile;
            
            if (100-dataLen > 1)
            {
                pFile = fopen(FILENAME, ""r"");
                if (pFile != NULL)
                {
                    
                    if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                    {
                        printLine(""fgets() failed"");
                        
                        data[dataLen] = '\0';
                    }
                    fclose(pFile);
                }
            }
        }
    }
    if(globalTrue)
    {
        badVaSinkB(data, data);
"
19055,0,CWE457_Use_of_Uninitialized_Variable__twointsclass_10.cpp,"    TwoIntsClass data;
    if(globalTrue)
    {
        
        ; 
    }
    if(globalTrue)
    {
        
        printIntLine(data.intOne);
        printIntLine(data.intTwo);
"
17665,0,CWE415_Double_Free__malloc_free_struct_63a.c,"    twoIntsStruct * data;
    
    data = NULL;
    data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
    if (data == NULL) {exit(-1);}
    
    free(data);
"
19252,1,CWE758_Undefined_Behavior__long_malloc_use_07.c,"    if(staticFive!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            long data;
            long * pointer = (long *)malloc(sizeof(long));
            if (pointer == NULL) {exit(-1);}
            data = 5L;
            *pointer = data; 
            {
                long data = *pointer;
                printLongLine(data);
            }
            free(pointer);
        }
"
16466,0,CWE688_Function_Call_With_Incorrect_Variable_or_Reference_as_Argument__basic_10.c,"    if(globalTrue)
    {
        {
            char dest[DEST_SIZE];
            int intFive = 5;
            
            sprintf(dest, ""%s"", intFive);
            printLine(dest);
        }
"
17147,0,CWE415_Double_Free__malloc_free_int_21.c,"    int * data;
    
    data = NULL;
    data = (int *)malloc(100*sizeof(int));
    if (data == NULL) {exit(-1);}
    
    free(data);
    badStatic = 1; 
"
1583,0,CWE252_Unchecked_Return_Value__char_remove_09.c,"    if(GLOBAL_CONST_TRUE)
    {
        
        REMOVE(""removemebad.txt"");
"
6326,0,CWE369_Divide_by_Zero__int_fgets_divide_54a.c,"    int data;
    
    data = -1;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
"
9709,0,CWE590_Free_Memory_Not_on_Heap__delete_long_static_81a.cpp,"    long * data;
    data = NULL; 
    {
        
        static long dataBuffer;
        dataBuffer = 5L;
        data = &dataBuffer;
    }
    const CWE590_Free_Memory_Not_on_Heap__delete_long_static_81_base& baseObject = CWE590_Free_Memory_Not_on_Heap__delete_long_static_81_bad();
"
1909,0,CWE690_NULL_Deref_From_Return__int64_t_calloc_21.c,"    int64_t * data;
    data = NULL; 
    
    data = (int64_t *)calloc(1, sizeof(int64_t));
    badStatic = 1; 
"
16187,0,CWE369_Divide_by_Zero__float_zero_54a.c,"    float data;
    
    data = 0.0F;
    
    data = 0.0F;
"
11276,0,CWE190_Integer_Overflow__int64_t_fscanf_multiply_53a.c,"    int64_t data;
    data = 0LL;
    
    fscanf (stdin, ""%"" SCNd64, &data);
"
16728,0,CWE590_Free_Memory_Not_on_Heap__delete_class_static_67a.cpp,"    TwoIntsClass * data;
    structType myStruct;
    data = NULL; 
    {
        
        static TwoIntsClass dataBuffer;
        dataBuffer.intOne = 1;
        dataBuffer.intTwo = 1;
        data = &dataBuffer;
    }
    myStruct.structFirst = data;
"
1274,0,CWE401_Memory_Leak__twoIntsStruct_malloc_08.c,"    twoIntsStruct * data;
    data = NULL;
    if(staticReturnsTrue())
    {
        
        data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
        if (data == NULL) {exit(-1);}
        
        data[0].intOne = 0;
        data[0].intTwo = 0;
        printStructLine(&data[0]);
    }
    if(staticReturnsTrue())
    {
        
        ; 
"
19526,1,CWE758_Undefined_Behavior__struct_pointer_malloc_use_10.c,"    if(globalFalse)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            twoIntsStruct * data;
            twoIntsStruct * * pointer = (twoIntsStruct * *)malloc(sizeof(twoIntsStruct *));
            if (pointer == NULL) {exit(-1);}
            
            data = (twoIntsStruct *)malloc(sizeof(twoIntsStruct));
            if (data == NULL) {exit(-1);}
            data->intOne = 5;
            data->intTwo = 6;
            *pointer = data; 
            {
                twoIntsStruct * data = *pointer;
                printIntLine(data->intOne);
                printIntLine(data->intTwo);
            }
            free(pointer);
        }
"
13441,0,CWE190_Integer_Overflow__int_fscanf_square_10.c,"    int data;
    
    data = 0;
    if(globalTrue)
    {
        
        fscanf(stdin, ""%d"", &data);
    }
    if(globalTrue)
    {
        {
            
            int result = data * data;
            printIntLine(result);
        }
"
13653,0,CWE197_Numeric_Truncation_Error__short_fgets_31.c,"    short data;
    
    data = -1;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = (short)atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    {
        short dataCopy = data;
        short data = dataCopy;
        {
            
            char charData = (char)data;
            printHexCharLine(charData);
        }
"
15937,0,CWE563_Unused_Variable__unused_uninit_variable_struct_81a.cpp,"    twoIntsStruct data;
    
    ; 
    const CWE563_Unused_Variable__unused_uninit_variable_struct_81_base& baseObject = CWE563_Unused_Variable__unused_uninit_variable_struct_81_bad();
"
2982,0,CWE415_Double_Free__new_delete_array_struct_07.cpp,"    twoIntsStruct * data;
    
    data = NULL;
    if(staticFive==5)
    {
        data = new twoIntsStruct[100];
        
        delete [] data;
    }
    if(staticFive==5)
    {
        
        delete [] data;
"
16216,0,CWE197_Numeric_Truncation_Error__int_listen_socket_to_short_83_bad.cpp,"Label Definition File: CWE197_Numeric_Truncation_Error__int.label.xml
Template File: sources-sink-83_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 197 Numeric Truncation Error
 * BadSource: listen_socket Read data using a listen socket (server side)
 * GoodSource: Less than CHAR_MAX
 * Sinks: to_short
 *    BadSink : Convert data to a short
 * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE197_Numeric_Truncation_Error__int_listen_socket_to_short_83.h""

#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif

#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)

namespace CWE197_Numeric_Truncation_Error__int_listen_socket_to_short_83
{
CWE197_Numeric_Truncation_Error__int_listen_socket_to_short_83_bad::CWE197_Numeric_Truncation_Error__int_listen_socket_to_short_83_bad(int dataCopy)
{
    data = dataCopy;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
}

CWE197_Numeric_Truncation_Error__int_listen_socket_to_short_83_bad::~CWE197_Numeric_Truncation_Error__int_listen_socket_to_short_83_bad()
{
    {
        
        short shortData = (short)data;
        printShortLine(shortData);
    }
}
}
"
12773,1,CWE252_Unchecked_Return_Value__char_fgets_11.c,"    if(globalReturnsTrue())
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            printLine(""Please enter a string: "");
            
            if (fgets(data, 100, stdin) == NULL)
            {
                printLine(""fgets failed!"");
                exit(1);
            }
            printLine(data);
        }
"
1518,0,CWE415_Double_Free__malloc_free_int64_t_83_bad.cpp,"Label Definition File: CWE415_Double_Free__malloc_free.label.xml
Template File: sources-sinks-83_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 415 Double Free
 * BadSource:  Allocate data using malloc() and Deallocate data using free()
 * GoodSource: Allocate data using malloc()
 * Sinks:
 *    GoodSink: do nothing
 *    BadSink : Deallocate data using free()
 * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE415_Double_Free__malloc_free_int64_t_83.h""

namespace CWE415_Double_Free__malloc_free_int64_t_83
{
CWE415_Double_Free__malloc_free_int64_t_83_bad::CWE415_Double_Free__malloc_free_int64_t_83_bad(int64_t * dataCopy)
{
    data = dataCopy;
    data = (int64_t *)malloc(100*sizeof(int64_t));
    if (data == NULL) {exit(-1);}
    
    free(data);
}

CWE415_Double_Free__malloc_free_int64_t_83_bad::~CWE415_Double_Free__malloc_free_int64_t_83_bad()
{
    
    free(data);
}
}
"
4798,0,CWE401_Memory_Leak__int_malloc_31.c,"    int * data;
    data = NULL;
    
    data = (int *)malloc(100*sizeof(int));
    if (data == NULL) {exit(-1);}
    
    data[0] = 5;
    printIntLine(data[0]);
    {
        int * dataCopy = data;
        int * data = dataCopy;
        
        ; 
"
9385,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_04.c,"    size_t data;
    
    data = 0;
    if(STATIC_CONST_TRUE)
    {
        
        fscanf(stdin, ""%zu"", &data);
    }
    if(STATIC_CONST_TRUE)
    {
        {
            char * myString;
            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
             * for the strcpy() function to not cause a buffer overflow */
            
            if (data > strlen(HELLO_STRING))
            {
                myString = (char *)malloc(data*sizeof(char));
                if (myString == NULL) {exit(-1);}
                
                strcpy(myString, HELLO_STRING);
                printLine(myString);
                free(myString);
            }
            else
            {
                printLine(""Input is less than the length of the source string"");
            }
        }
"
18349,0,CWE190_Integer_Overflow__int_fscanf_multiply_34.c,"    int data;
    CWE190_Integer_Overflow__int_fscanf_multiply_34_unionType myUnion;
    
    data = 0;
    
    fscanf(stdin, ""%d"", &data);
    myUnion.unionFirst = data;
    {
        int data = myUnion.unionSecond;
        if(data > 0) 
        {
            
            int result = data * 2;
            printIntLine(result);
        }
"
18594,0,CWE190_Integer_Overflow__char_rand_multiply_44.c,"    char data;
    
    void (*funcPtr) (char) = badSink;
    data = ' ';
    
    data = (char)RAND32();
    
"
6448,0,CWE190_Integer_Overflow__unsigned_int_rand_square_54a.c,"    unsigned int data;
    data = 0;
    
    data = (unsigned int)RAND32();
"
6974,0,CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_09.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(GLOBAL_CONST_TRUE)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET connectSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                
                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                data[dataLen + recvResult / sizeof(char)] = '\0';
                
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(GLOBAL_CONST_TRUE)
    {
        badVaSinkB(data, data);
"
15035,0,CWE78_OS_Command_Injection__char_connect_socket_system_52a.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
6230,0,CWE690_NULL_Deref_From_Return__struct_malloc_64a.c,"    twoIntsStruct * data;
    data = NULL; 
    
    data = (twoIntsStruct *)malloc(1*sizeof(twoIntsStruct));
"
11514,0,CWE416_Use_After_Free__malloc_free_long_06.c,"    long * data;
    
    data = NULL;
    if(STATIC_CONST_FIVE==5)
    {
        data = (long *)malloc(100*sizeof(long));
        if (data == NULL) {exit(-1);}
        {
            size_t i;
            for(i = 0; i < 100; i++)
            {
                data[i] = 5L;
            }
        }
        
        free(data);
    }
    if(STATIC_CONST_FIVE==5)
    {
        
        printLongLine(data[0]);
        
"
18653,0,CWE590_Free_Memory_Not_on_Heap__delete_array_int_alloca_44.cpp,"    int * data;
    
    void (*funcPtr) (int *) = badSink;
    data = NULL; 
    {
        
        int * dataBuffer = (int *)ALLOCA(100*sizeof(int));
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5;
            }
        }
        data = dataBuffer;
    }
    
"
11782,0,CWE590_Free_Memory_Not_on_Heap__delete_array_long_declare_51a.cpp,"    long * data;
    data = NULL; 
    {
        
        long dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5L;
            }
        }
        data = dataBuffer;
    }
"
18482,0,CWE190_Integer_Overflow__char_max_add_07.c,"    char data;
    data = ' ';
    if(staticFive==5)
    {
        
        data = CHAR_MAX;
    }
    if(staticFive==5)
    {
        {
            
            char result = data + 1;
            printHexCharLine(result);
        }
"
4248,0,CWE789_Uncontrolled_Mem_Alloc__new_char_rand_32.cpp,"    size_t data;
    size_t *dataPtr1 = &data;
    size_t *dataPtr2 = &data;
    
    data = 0;
    {
        size_t data = *dataPtr1;
        
        data = rand();
        *dataPtr1 = data;
    }
    {
        size_t data = *dataPtr2;
        {
            char * myString;
            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
             * for the strcpy() function to not cause a buffer overflow */
            
            if (data > strlen(HELLO_STRING))
            {
                myString = new char[data];
                
                strcpy(myString, HELLO_STRING);
                printLine(myString);
                delete [] myString;
            }
            else
            {
                printLine(""Input is less than the length of the source string"");
            }
        }
"
484,0,CWE78_OS_Command_Injection__char_connect_socket_execl_32.c,"    char * data;
    char * *dataPtr1 = &data;
    char * *dataPtr2 = &data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        char * data = *dataPtr1;
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET connectSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
"
7349,0,CWE563_Unused_Variable__unused_init_variable_char_33.cpp,"    char data;
    char &dataRef = data;
    
    data = 'C';
    {
        char data = dataRef;
        
        
        ; 
"
666,1,CWE475_Undefined_Behavior_for_Input_to_API__char_08.c,"    if(staticReturnsTrue())
    {
        {
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            strcpy(data, ""abcdefghijklmnopqrstuvwxyz"");
            
            memmove(data + 6, data + 4, 10*sizeof(char));
            printLine(data);
        }
"
17580,0,CWE190_Integer_Overflow__int64_t_fscanf_preinc_09.c,"    int64_t data;
    data = 0LL;
    if(GLOBAL_CONST_TRUE)
    {
        
        fscanf (stdin, ""%"" SCNd64, &data);
    }
    if(GLOBAL_CONST_TRUE)
    {
        {
            
            ++data;
            int64_t result = data;
            printLongLongLine(result);
        }
"
13256,0,CWE134_Uncontrolled_Format_String__char_connect_socket_printf_51a.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
7904,0,CWE590_Free_Memory_Not_on_Heap__delete_struct_static_81a.cpp,"    twoIntsStruct * data;
    data = NULL; 
    {
        
        static twoIntsStruct dataBuffer;
        dataBuffer.intOne = 1;
        dataBuffer.intTwo = 1;
        data = &dataBuffer;
    }
    const CWE590_Free_Memory_Not_on_Heap__delete_struct_static_81_base& baseObject = CWE590_Free_Memory_Not_on_Heap__delete_struct_static_81_bad();
"
11585,1,CWE758_Undefined_Behavior__int_pointer_malloc_use_07.c,"    if(staticFive!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            int * data;
            int * * pointer = (int * *)malloc(sizeof(int *));
            if (pointer == NULL) {exit(-1);}
            
            data = (int *)malloc(sizeof(int));
            if (data == NULL) {exit(-1);}
            *data = 5;
            *pointer = data; 
            {
                int * data = *pointer;
                printIntLine(*data);
            }
            free(pointer);
        }
"
4339,0,CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_81_bad.cpp,"Label Definition File: CWE190_Integer_Overflow.label.xml
Template File: sources-sinks-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 190 Integer Overflow
 * BadSource: fscanf Read data from the console using fscanf()
 * GoodSource: Set data to a small, non-zero number (two)
 * Sinks: multiply
 *    GoodSink: Ensure there will not be an overflow before multiplying data by 2
 *    BadSink : If data is positive, multiply by 2, which can cause an overflow
 * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_81.h""

namespace CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_81
{

void CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_81_bad::action(unsigned int data) const
{
    if(data > 0) 
    {
        
        unsigned int result = data * 2;
        printUnsignedLine(result);
    }
}

}
"
1608,0,CWE190_Integer_Overflow__unsigned_int_max_multiply_44.c,"    unsigned int data;
    
    void (*funcPtr) (unsigned int) = badSink;
    data = 0;
    
    data = UINT_MAX;
    
"
11868,0,CWE401_Memory_Leak__int_malloc_04.c,"    int * data;
    data = NULL;
    if(STATIC_CONST_TRUE)
    {
        
        data = (int *)malloc(100*sizeof(int));
        if (data == NULL) {exit(-1);}
        
        data[0] = 5;
        printIntLine(data[0]);
    }
    if(STATIC_CONST_TRUE)
    {
        
        ; 
"
13437,0,CWE369_Divide_by_Zero__int_rand_divide_17.c,"    int i,j;
    int data;
    
    data = -1;
    for(i = 0; i < 1; i++)
    {
        
        data = RAND32();
    }
    for(j = 0; j < 1; j++)
    {
        
        printIntLine(100 / data);
"
9913,0,CWE252_Unchecked_Return_Value__char_fputs_06.c,"    if(STATIC_CONST_FIVE==5)
    {
        
        fputs(""string"", stdout);
"
10210,0,CWE416_Use_After_Free__malloc_free_int_01.c,"    int * data;
    
    data = NULL;
    data = (int *)malloc(100*sizeof(int));
    if (data == NULL) {exit(-1);}
    {
        size_t i;
        for(i = 0; i < 100; i++)
        {
            data[i] = 5;
        }
    }
    
    free(data);
    
    printIntLine(data[0]);
"
4207,0,CWE789_Uncontrolled_Mem_Alloc__new_char_connect_socket_54a.cpp,"    size_t data;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = strtoul(inputBuffer, NULL, 0);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
9972,1,CWE401_Memory_Leak__malloc_realloc_int_02.c,"    if(1)
    {
        {
            int * data = (int *)malloc(100*sizeof(int));
            if (data == NULL) {exit(-1);}
            int * tmpData;
            
            data[0] = 5;
            printIntLine(data[0]);
            tmpData = (int *)realloc(data, (130000)*sizeof(int));
            /* FIX: Ensure realloc() was successful before assigning data to the memory block
            * allocated with realloc() */
            if (tmpData != NULL)
            {
                data = tmpData;
                
                data[0] = 10;
                printIntLine(data[0]);
            }
            free(data);
        }
"
7910,0,CWE590_Free_Memory_Not_on_Heap__delete_array_long_alloca_04.cpp,"    long * data;
    data = NULL; 
    if(STATIC_CONST_TRUE)
    {
        {
            
            long * dataBuffer = (long *)ALLOCA(100*sizeof(long));
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5L;
                }
            }
            data = dataBuffer;
        }
    }
    printLongLine(data[0]);
    
"
17944,0,CWE590_Free_Memory_Not_on_Heap__free_int_declare_32.c,"    int * data;
    int * *dataPtr1 = &data;
    int * *dataPtr2 = &data;
    data = NULL; 
    {
        int * data = *dataPtr1;
        {
            
            int dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5;
                }
            }
            data = dataBuffer;
        }
        *dataPtr1 = data;
    }
    {
        int * data = *dataPtr2;
        printIntLine(data[0]);
        
        free(data);
"
14459,1,CWE467_Use_of_sizeof_on_Pointer_Type__char_10.c,"    if(globalTrue)
    {
        {
            char * goodChar = NULL;
            
            goodChar = (char *)malloc(sizeof(*goodChar));
            if (goodChar == NULL) {exit(-1);}
            *goodChar = 'G';
            printHexCharLine(*goodChar);
            free(goodChar);
        }
"
5031,0,CWE401_Memory_Leak__int64_t_realloc_83a.cpp,"    int64_t * data;
    data = NULL;
"
3882,0,CWE134_Uncontrolled_Format_String__char_environment_printf_44.c,"    char * data;
    
    void (*funcPtr) (char *) = badSink;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        
        if (environment != NULL)
        {
            
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    
"
15064,0,CWE690_NULL_Deref_From_Return__int_malloc_12.c,"    int * data;
    data = NULL; 
    
    data = (int *)malloc(1*sizeof(int));
    if(globalReturnsTrueOrFalse())
    {
        
        data[0] = 5;
        printIntLine(data[0]);
        free(data);
    }
    else
    {
        
        if (data != NULL)
        {
            data[0] = 5;
            printIntLine(data[0]);
            free(data);
        }
"
2316,0,CWE401_Memory_Leak__twoIntsStruct_malloc_83_bad.cpp,"Label Definition File: CWE401_Memory_Leak.c.label.xml
Template File: sources-sinks-83_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 401 Memory Leak
 * BadSource: malloc Allocate data using malloc()
 * GoodSource: Allocate data on the stack
 * Sinks:
 *    GoodSink: call free() on data
 *    BadSink : no deallocation of data
 * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE401_Memory_Leak__twoIntsStruct_malloc_83.h""

namespace CWE401_Memory_Leak__twoIntsStruct_malloc_83
{
CWE401_Memory_Leak__twoIntsStruct_malloc_83_bad::CWE401_Memory_Leak__twoIntsStruct_malloc_83_bad(twoIntsStruct * dataCopy)
{
    data = dataCopy;
    
    data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
    if (data == NULL) {exit(-1);}
    
    data[0].intOne = 0;
    data[0].intTwo = 0;
    printStructLine(&data[0]);
}

CWE401_Memory_Leak__twoIntsStruct_malloc_83_bad::~CWE401_Memory_Leak__twoIntsStruct_malloc_83_bad()
{
    
    ; 
}
}
"
16683,1,CWE467_Use_of_sizeof_on_Pointer_Type__int_16.c,"    while(1)
    {
        {
            int * goodInt = NULL;
            
            goodInt = (int *)malloc(sizeof(*goodInt));
            if (goodInt == NULL) {exit(-1);}
            *goodInt = 6;
            printIntLine(*goodInt);
            free(goodInt);
        }
        break;
"
14669,0,CWE197_Numeric_Truncation_Error__short_listen_socket_17.c,"    int i;
    short data;
    
    data = -1;
    for(i = 0; i < 1; i++)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = (short)atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
15461,0,CWE190_Integer_Overflow__unsigned_int_rand_multiply_11.c,"    unsigned int data;
    data = 0;
    if(globalReturnsTrue())
    {
        
        data = (unsigned int)RAND32();
    }
    if(globalReturnsTrue())
    {
        if(data > 0) 
        {
            
            unsigned int result = data * 2;
            printUnsignedLine(result);
        }
"
12315,0,CWE590_Free_Memory_Not_on_Heap__delete_struct_static_41.cpp,"    twoIntsStruct * data;
    data = NULL; 
    {
        
        static twoIntsStruct dataBuffer;
        dataBuffer.intOne = 1;
        dataBuffer.intTwo = 1;
        data = &dataBuffer;
    }
"
17599,0,CWE78_OS_Command_Injection__char_listen_socket_execl_65a.c,"    char * data;
    
    void (*funcPtr) (char *) = CWE78_OS_Command_Injection__char_listen_socket_execl_65b_badSink;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
"
160,1,CWE252_Unchecked_Return_Value__char_fwrite_09.c,"    if(GLOBAL_CONST_TRUE)
    {
        
        if (fwrite((char *)""string"", sizeof(char), strlen(""string""), stdout) != strlen(""string""))
        {
            printLine(""fwrite failed!"");
        }
"
1571,0,CWE590_Free_Memory_Not_on_Heap__free_char_declare_52a.c,"    char * data;
    data = NULL; 
    {
        
        char dataBuffer[100];
        memset(dataBuffer, 'A', 100-1); 
        dataBuffer[100-1] = '\0'; 
        data = dataBuffer;
    }
"
18667,0,CWE457_Use_of_Uninitialized_Variable__double_16.c,"    double data;
    while(1)
    {
        
        ; 
        break;
    }
    while(1)
    {
        
        printDoubleLine(data);
        break;
"
1016,0,CWE78_OS_Command_Injection__char_file_system_03.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(5==5)
    {
        {
            
            size_t dataLen = strlen(data);
            FILE * pFile;
            
            if (100-dataLen > 1)
            {
                pFile = fopen(FILENAME, ""r"");
                if (pFile != NULL)
                {
                    
                    if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                    {
                        printLine(""fgets() failed"");
                        
                        data[dataLen] = '\0';
                    }
                    fclose(pFile);
                }
            }
        }
    }
    
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
"
7449,0,CWE78_OS_Command_Injection__char_connect_socket_popen_05.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(staticTrue)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET connectSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
"
10689,0,CWE252_Unchecked_Return_Value__char_putc_16.c,"    while(1)
    {
        
        putc((int)'A', stdout);
        break;
"
18508,0,CWE401_Memory_Leak__char_realloc_33.cpp,"    char * data;
    char * &dataRef = data;
    data = NULL;
    
    data = (char *)realloc(data, 100*sizeof(char));
    if (data == NULL) {exit(-1);}
    
    strcpy(data, ""A String"");
    printLine(data);
    {
        char * data = dataRef;
        
        ; 
"
712,0,CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_41.c,"    unsigned int data;
    data = 0;
    
    fscanf (stdin, ""%u"", &data);
"
14553,0,CWE190_Integer_Overflow__int_listen_socket_add_66a.c,"    int data;
    int dataArray[5];
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
    dataArray[2] = data;
"
12770,0,CWE758_Undefined_Behavior__class_new_use_05.cpp,"    if(staticTrue)
    {
        {
            TwoIntsClass * pointer = new TwoIntsClass;
            TwoIntsClass data = *pointer; 
            delete pointer;
            printIntLine(data.intOne);
            printIntLine(data.intTwo);
        }
"
18887,0,CWE690_NULL_Deref_From_Return__int_calloc_16.c,"    int * data;
    data = NULL; 
    
    data = (int *)calloc(1, sizeof(int));
    while(1)
    {
        
        data[0] = 5;
        printIntLine(data[0]);
        free(data);
        break;
"
12390,0,CWE78_OS_Command_Injection__char_console_execl_10.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(globalTrue)
    {
        {
            
            size_t dataLen = strlen(data);
            
            if (100-dataLen > 1)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
                {
                    /* The next few lines remove the carriage return from the string that is
                     * inserted by fgets() */
                    dataLen = strlen(data);
                    if (dataLen > 0 && data[dataLen-1] == '\n')
                    {
                        data[dataLen-1] = '\0';
                    }
                }
                else
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
            }
        }
    }
    
    
"
3646,0,CWE457_Use_of_Uninitialized_Variable__twointsclass_15.cpp,"    TwoIntsClass data;
    switch(6)
    {
    case 6:
        
        ; 
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
        
        printIntLine(data.intOne);
        printIntLine(data.intTwo);
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
4356,0,CWE190_Integer_Overflow__char_max_preinc_63a.c,"    char data;
    data = ' ';
    
    data = CHAR_MAX;
"
1309,0,CWE563_Unused_Variable__unused_uninit_variable_char_11.c,"    char data;
    
    ; 
    if(globalReturnsTrue())
    {
        
        
        ; 
"
6397,0,CWE134_Uncontrolled_Format_String__char_listen_socket_printf_34.c,"    char * data;
    CWE134_Uncontrolled_Format_String__char_listen_socket_printf_34_unionType myUnion;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    myUnion.unionFirst = data;
    {
        char * data = myUnion.unionSecond;
        
        printf(data);
"
12949,0,CWE401_Memory_Leak__new_array_char_01.cpp,"    char * data;
    data = NULL;
    
    data = new char[100];
    
    strcpy(data, ""A String"");
    printLine(data);
    
"
8696,1,CWE401_Memory_Leak__malloc_realloc_struct_twoIntsStruct_13.c,"    if(GLOBAL_CONST_FIVE!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            struct _twoIntsStruct * data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));
            if (data == NULL) {exit(-1);}
            struct _twoIntsStruct * tmpData;
            
            data[0].intOne = 0;
            data[0].intTwo = 0;
            printStructLine((twoIntsStruct *)&data[0]);
            tmpData = (struct _twoIntsStruct *)realloc(data, (130000)*sizeof(struct _twoIntsStruct));
            /* FIX: Ensure realloc() was successful before assigning data to the memory block
            * allocated with realloc() */
            if (tmpData != NULL)
            {
                data = tmpData;
                
                data[0].intOne = 1;
                data[0].intTwo = 1;
                printStructLine((twoIntsStruct *)&data[0]);
            }
            free(data);
        }
"
10918,0,CWE190_Integer_Overflow__char_fscanf_multiply_65a.c,"    char data;
    
    void (*funcPtr) (char) = CWE190_Integer_Overflow__char_fscanf_multiply_65b_badSink;
    data = ' ';
    
    fscanf (stdin, ""%c"", &data);
    
"
895,0,CWE190_Integer_Overflow__char_rand_add_32.c,"    char data;
    char *dataPtr1 = &data;
    char *dataPtr2 = &data;
    data = ' ';
    {
        char data = *dataPtr1;
        
        data = (char)RAND32();
        *dataPtr1 = data;
    }
    {
        char data = *dataPtr2;
        {
            
            char result = data + 1;
            printHexCharLine(result);
        }
"
11143,0,CWE590_Free_Memory_Not_on_Heap__delete_array_long_declare_81_bad.cpp,"Label Definition File: CWE590_Free_Memory_Not_on_Heap__delete_array.label.xml
Template File: sources-sink-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 590 Free Memory Not on Heap
 * BadSource: declare Data buffer is declared on the stack
 * GoodSource: Allocate memory on the heap
 * Sinks:
 *    BadSink : Print then free data
 * Flow Variant: 81 Data flow: data passed in a parameter to a virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE590_Free_Memory_Not_on_Heap__delete_array_long_declare_81.h""

namespace CWE590_Free_Memory_Not_on_Heap__delete_array_long_declare_81
{

void CWE590_Free_Memory_Not_on_Heap__delete_array_long_declare_81_bad::action(long * data) const
{
    printLongLine(data[0]);
    
    delete [] data;
}

}
"
13174,0,CWE758_Undefined_Behavior__char_alloca_use_03.c,"    if(5==5)
    {
        {
            char * pointer = (char *)ALLOCA(sizeof(char));
            char data = *pointer; 
            printHexCharLine(data);
        }
"
14229,1,CWE758_Undefined_Behavior__long_malloc_use_09.c,"    if(GLOBAL_CONST_TRUE)
    {
        {
            long data;
            long * pointer = (long *)malloc(sizeof(long));
            if (pointer == NULL) {exit(-1);}
            data = 5L;
            *pointer = data; 
            {
                long data = *pointer;
                printLongLine(data);
            }
            free(pointer);
        }
"
10429,0,CWE190_Integer_Overflow__int64_t_rand_postinc_65a.c,"    int64_t data;
    
    void (*funcPtr) (int64_t) = CWE190_Integer_Overflow__int64_t_rand_postinc_65b_badSink;
    data = 0LL;
    
    data = (int64_t)RAND64();
    
"
4995,0,CWE401_Memory_Leak__struct_twoIntsStruct_realloc_52a.c,"    struct _twoIntsStruct * data;
    data = NULL;
    
    data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));
    if (data == NULL) {exit(-1);}
    
    data[0].intOne = 0;
    data[0].intTwo = 0;
    printStructLine((twoIntsStruct *)&data[0]);
"
11785,0,CWE197_Numeric_Truncation_Error__short_connect_socket_04.c,"    short data;
    
    data = -1;
    if(STATIC_CONST_TRUE)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = (short)atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
18775,0,CWE590_Free_Memory_Not_on_Heap__delete_array_class_alloca_52a.cpp,"    TwoIntsClass * data;
    data = NULL; 
    {
        
        TwoIntsClass * dataBuffer = (TwoIntsClass *)ALLOCA(100*sizeof(TwoIntsClass));
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i].intOne = 1;
                dataBuffer[i].intTwo = 1;
            }
        }
        data = dataBuffer;
    }
"
5069,0,CWE415_Double_Free__malloc_free_char_84a.cpp,"    char * data;
    
    data = NULL;
    CWE415_Double_Free__malloc_free_char_84_bad * badObject = new CWE415_Double_Free__malloc_free_char_84_bad(data);
"
5912,1,CWE401_Memory_Leak__malloc_realloc_int64_t_04.c,"    if(STATIC_CONST_TRUE)
    {
        {
            int64_t * data = (int64_t *)malloc(100*sizeof(int64_t));
            if (data == NULL) {exit(-1);}
            int64_t * tmpData;
            
            data[0] = 5LL;
            printLongLongLine(data[0]);
            tmpData = (int64_t *)realloc(data, (130000)*sizeof(int64_t));
            /* FIX: Ensure realloc() was successful before assigning data to the memory block
            * allocated with realloc() */
            if (tmpData != NULL)
            {
                data = tmpData;
                
                data[0] = 10LL;
                printLongLongLine(data[0]);
            }
            free(data);
        }
"
13383,0,CWE190_Integer_Overflow__int_fscanf_preinc_41.c,"    int data;
    
    data = 0;
    
    fscanf(stdin, ""%d"", &data);
"
389,0,CWE190_Integer_Overflow__int_fgets_postinc_63a.c,"    int data;
    
    data = 0;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
"
3250,0,CWE190_Integer_Overflow__int_listen_socket_add_45.c,"    int data;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    CWE190_Integer_Overflow__int_listen_socket_add_45_badData = data;
"
7180,1,CWE758_Undefined_Behavior__struct_pointer_alloca_use_15.c,"    switch(6)
    {
    case 6:
    {
        twoIntsStruct * data;
        twoIntsStruct * * pointer = (twoIntsStruct * *)ALLOCA(sizeof(twoIntsStruct *));
        
        data = (twoIntsStruct *)malloc(sizeof(twoIntsStruct));
        if (data == NULL) {exit(-1);}
        data->intOne = 5;
        data->intTwo = 6;
        *pointer = data; 
        {
            twoIntsStruct * data = *pointer;
            printIntLine(data->intOne);
            printIntLine(data->intTwo);
        }
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
1349,1,CWE252_Unchecked_Return_Value__char_fputs_15.c,"    switch(5)
    {
    case 6:
        
        printLine(""Benign, fixed string"");
        break;
    default:
        
        if (fputs(""string"", stdout) == EOF)
        {
            printLine(""fputs failed!"");
        }
        break;
"
8484,0,CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_01.c,"    unsigned int data;
    data = 0;
    
    fscanf (stdin, ""%u"", &data);
    if(data > 0) 
    {
        
        unsigned int result = data * 2;
        printUnsignedLine(result);
"
703,0,CWE190_Integer_Overflow__int64_t_rand_postinc_12.c,"    int64_t data;
    data = 0LL;
    if(globalReturnsTrueOrFalse())
    {
        
        data = (int64_t)RAND64();
    }
    else
    {
        
        data = 2;
    }
    if(globalReturnsTrueOrFalse())
    {
        {
            
            data++;
            int64_t result = data;
            printLongLongLine(result);
        }
    }
    else
    {
        
        if (data < LLONG_MAX)
        {
            data++;
            int64_t result = data;
            printLongLongLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
"
11504,1,CWE758_Undefined_Behavior__long_alloca_use_07.c,"    if(staticFive!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            long data;
            long * pointer = (long *)ALLOCA(sizeof(long));
            data = 5L;
            *pointer = data; 
            {
                long data = *pointer;
                printLongLine(data);
            }
        }
"
6954,0,CWE78_OS_Command_Injection__char_environment_popen_08.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(staticReturnsTrue())
    {
        {
            
            size_t dataLen = strlen(data);
            char * environment = GETENV(ENV_VARIABLE);
            
            if (environment != NULL)
            {
                
                strncat(data+dataLen, environment, 100-dataLen-1);
            }
        }
    }
    {
        FILE *pipe;
        
        pipe = POPEN(data, ""w"");
        if (pipe != NULL)
        {
            PCLOSE(pipe);
        }
"
1862,0,CWE415_Double_Free__new_delete_array_long_52a.cpp,"    long * data;
    
    data = NULL;
    data = new long[100];
    
    delete [] data;
"
12316,1,CWE469_Use_of_Pointer_Subtraction_to_Determine_Size__char_01.c,"    {
        char string1[] = SOURCE_STRING;
        char * slashInString1;
        size_t indexOfSlashInString1;
        slashInString1 = strchr(string1, '/');
        if (slashInString1 == NULL)
        {
            exit(1);
        }
        
        indexOfSlashInString1 = (size_t)(slashInString1 - string1);
        
        printUnsignedLine(indexOfSlashInString1);
"
6886,0,CWE190_Integer_Overflow__short_max_multiply_22a.c,"    short data;
    data = 0;
    
    data = SHRT_MAX;
    CWE190_Integer_Overflow__short_max_multiply_22_badGlobal = 1; 
"
10777,0,CWE758_Undefined_Behavior__char_alloca_use_02.c,"    if(1)
    {
        {
            char * pointer = (char *)ALLOCA(sizeof(char));
            char data = *pointer; 
            printHexCharLine(data);
        }
"
2084,0,CWE78_OS_Command_Injection__char_listen_socket_popen_45.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    CWE78_OS_Command_Injection__char_listen_socket_popen_45_badData = data;
"
14434,0,CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_14.cpp,"    size_t data;
    
    data = 0;
    if(globalFive==5)
    {
        
        fscanf(stdin, ""%zu"", &data);
    }
    if(globalFive==5)
    {
        {
            char * myString;
            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
             * for the strcpy() function to not cause a buffer overflow */
            
            if (data > strlen(HELLO_STRING))
            {
                myString = new char[data];
                
                strcpy(myString, HELLO_STRING);
                printLine(myString);
                delete [] myString;
            }
            else
            {
                printLine(""Input is less than the length of the source string"");
            }
        }
"
6148,0,CWE190_Integer_Overflow__short_fscanf_preinc_11.c,"    short data;
    data = 0;
    if(globalReturnsTrue())
    {
        
        fscanf (stdin, ""%hd"", &data);
    }
    if(globalReturnsTrue())
    {
        {
            
            ++data;
            short result = data;
            printIntLine(result);
        }
"
1215,0,CWE190_Integer_Overflow__char_rand_add_01.c,"    char data;
    data = ' ';
    
    data = (char)RAND32();
    {
        
        char result = data + 1;
        printHexCharLine(result);
"
1607,0,CWE401_Memory_Leak__new_int_11.cpp,"    int * data;
    data = NULL;
    if(globalReturnsTrue())
    {
        
        data = new int;
        
        *data = 5;
        printIntLine(*data);
    }
    if(globalReturnsTrue())
    {
        
        ; 
"
1348,0,CWE190_Integer_Overflow__short_fscanf_square_83a.cpp,"    short data;
    data = 0;
"
13257,0,CWE78_OS_Command_Injection__char_console_execlp_07.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(staticFive==5)
    {
        {
            
            size_t dataLen = strlen(data);
            
            if (100-dataLen > 1)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
                {
                    /* The next few lines remove the carriage return from the string that is
                     * inserted by fgets() */
                    dataLen = strlen(data);
"
7926,0,CWE476_NULL_Pointer_Dereference__binary_if_09.c,"    if(GLOBAL_CONST_TRUE)
    {
        {
            twoIntsStruct *twoIntsStructPointer = NULL;
            /* FLAW: Using a single & in the if statement will cause both sides of the expression to be evaluated
             * thus causing a NPD */
            if ((twoIntsStructPointer != NULL) & (twoIntsStructPointer->intOne == 5))
            {
                printLine(""intOne == 5"");
            }
        }
"
15413,0,CWE190_Integer_Overflow__char_max_preinc_31.c,"    char data;
    data = ' ';
    
    data = CHAR_MAX;
    {
        char dataCopy = data;
        char data = dataCopy;
        {
            
            ++data;
            char result = data;
            printHexCharLine(result);
        }
"
14169,0,CWE78_OS_Command_Injection__char_console_execlp_13.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            
            size_t dataLen = strlen(data);
            
            if (100-dataLen > 1)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
                {
                    /* The next few lines remove the carriage return from the string that is
                     * inserted by fgets() */
                    dataLen = strlen(data);
"
10007,0,CWE563_Unused_Variable__unused_value_long_43.cpp,"    long data;
    badSource(data);
    
    data = 10L;
"
16098,0,CWE690_NULL_Deref_From_Return__char_realloc_13.c,"    char * data;
    data = NULL; 
    
    data = (char *)realloc(data, 20*sizeof(char));
    if(GLOBAL_CONST_FIVE==5)
    {
        
        strcpy(data, ""Initialize"");
        printLine(data);
        free(data);
"
6081,0,CWE590_Free_Memory_Not_on_Heap__delete_long_placement_new_15.cpp,"    long * data;
    data = NULL; 
    switch(6)
    {
    case 6:
    {
        
        char buffer[sizeof(long)];
        long * dataBuffer = new(buffer) long;
        *dataBuffer = 5L;
        data = dataBuffer;
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    printLongLine(*data);
    
"
17435,0,CWE190_Integer_Overflow__int_rand_add_53a.c,"    int data;
    
    data = 0;
    
    data = RAND32();
"
6109,0,CWE590_Free_Memory_Not_on_Heap__delete_long_placement_new_68a.cpp,"    long * data;
    data = NULL; 
    {
        
        char buffer[sizeof(long)];
        long * dataBuffer = new(buffer) long;
        *dataBuffer = 5L;
        data = dataBuffer;
    }
    CWE590_Free_Memory_Not_on_Heap__delete_long_placement_new_68_badData = data;
"
98,0,CWE190_Integer_Overflow__short_fscanf_multiply_02.c,"    short data;
    data = 0;
    if(1)
    {
        
        fscanf (stdin, ""%hd"", &data);
    }
    if(1)
    {
        if(data > 0) 
        {
            
            short result = data * 2;
            printIntLine(result);
        }
"
6615,0,CWE467_Use_of_sizeof_on_Pointer_Type__int_05.c,"    if(staticTrue)
    {
        {
            int * badInt = NULL;
            
            badInt = (int *)malloc(sizeof(badInt));
            if (badInt == NULL) {exit(-1);}
            *badInt = 5;
            printIntLine(*badInt);
            free(badInt);
        }
"
16254,0,CWE78_OS_Command_Injection__char_console_system_67a.c,"    char * data;
    CWE78_OS_Command_Injection__char_console_system_67_structType myStruct;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
        
        size_t dataLen = strlen(data);
        
        if (100-dataLen > 1)
        {
            
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgets() */
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
                    data[dataLen-1] = '\0';
                }
            }
            else
            {
                printLine(""fgets() failed"");
                
                data[dataLen] = '\0';
            }
        }
    }
    myStruct.structFirst = data;
"
9832,0,CWE190_Integer_Overflow__unsigned_int_rand_add_82_bad.cpp,"Label Definition File: CWE190_Integer_Overflow.label.xml
Template File: sources-sinks-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 190 Integer Overflow
 * BadSource: rand Set data to result of rand()
 * GoodSource: Set data to a small, non-zero number (two)
 * Sinks: add
 *    GoodSink: Ensure there will not be an overflow before adding 1 to data
 *    BadSink : Add 1 to data, which can cause an overflow
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE190_Integer_Overflow__unsigned_int_rand_add_82.h""

namespace CWE190_Integer_Overflow__unsigned_int_rand_add_82
{

void CWE190_Integer_Overflow__unsigned_int_rand_add_82_bad::action(unsigned int data)
{
    {
        
        unsigned int result = data + 1;
        printUnsignedLine(result);
    }
}

}
"
17853,0,CWE197_Numeric_Truncation_Error__int_large_to_short_72a.cpp,"    int data;
    vector<int> dataVector;
    
    data = -1;
    
    data = SHRT_MAX + 5;
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
17479,0,CWE134_Uncontrolled_Format_String__char_environment_vprintf_82_bad.cpp,"Label Definition File: CWE134_Uncontrolled_Format_String.vasinks.label.xml
Template File: sources-vasinks-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 134 Uncontrolled Format String
 * BadSource: environment Read input from an environment variable
 * GoodSource: Copy a fixed string into data
 * Sinks: vprintf
 *    GoodSink: vprintf with a format string
 *    BadSink : vprintf without a format string
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include <stdarg.h>
#include ""std_testcase.h""
#include ""CWE134_Uncontrolled_Format_String__char_environment_vprintf_82.h""

namespace CWE134_Uncontrolled_Format_String__char_environment_vprintf_82
{

static void badVaSink(char * data, ...)
{
    {
        va_list args;
        va_start(args, data);
        
        vprintf(data, args);
        va_end(args);
    }
}

void CWE134_Uncontrolled_Format_String__char_environment_vprintf_82_bad::action(char * data)
{
    badVaSink(data, data);
}

}
"
10512,0,CWE190_Integer_Overflow__short_fscanf_multiply_62a.cpp,"    short data;
    data = 0;
    badSource(data);
    if(data > 0) 
    {
        
        short result = data * 2;
        printIntLine(result);
"
10843,0,CWE190_Integer_Overflow__int_max_preinc_06.c,"    int data;
    
    data = 0;
    if(STATIC_CONST_FIVE==5)
    {
        
        data = INT_MAX;
    }
    if(STATIC_CONST_FIVE==5)
    {
        {
            
            ++data;
            int result = data;
            printIntLine(result);
        }
"
8659,0,CWE789_Uncontrolled_Mem_Alloc__new_char_connect_socket_68a.cpp,"    size_t data;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = strtoul(inputBuffer, NULL, 0);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    badData = data;
"
12829,0,CWE590_Free_Memory_Not_on_Heap__delete_array_int_static_45.cpp,"    int * data;
    data = NULL; 
    {
        
        static int dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5;
            }
        }
        data = dataBuffer;
    }
    badData = data;
"
19304,0,CWE190_Integer_Overflow__int_fgets_square_09.c,"    int data;
    
    data = 0;
    if(GLOBAL_CONST_TRUE)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    if(GLOBAL_CONST_TRUE)
    {
        {
            
            int result = data * data;
            printIntLine(result);
        }
"
1468,0,CWE563_Unused_Variable__unused_init_variable_long_43.cpp,"    long data;
    badSource(data);
    
    
"
17995,0,CWE690_NULL_Deref_From_Return__struct_calloc_73a.cpp,"    twoIntsStruct * data;
    list<twoIntsStruct *> dataList;
    data = NULL; 
    
    data = (twoIntsStruct *)calloc(1, sizeof(twoIntsStruct));
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
6935,0,CWE197_Numeric_Truncation_Error__int_fgets_to_short_05.c,"    int data;
    
    data = -1;
    if(staticTrue)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    {
        
        short shortData = (short)data;
        printShortLine(shortData);
"
7009,0,CWE78_OS_Command_Injection__char_connect_socket_system_61a.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    data = CWE78_OS_Command_Injection__char_connect_socket_system_61b_badSource(data);
    
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
    }
}

#endif 

#ifndef OMITGOOD


"
13802,0,CWE134_Uncontrolled_Format_String__char_file_fprintf_06.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(STATIC_CONST_FIVE==5)
    {
        {
            
            size_t dataLen = strlen(data);
            FILE * pFile;
            
            if (100-dataLen > 1)
            {
                pFile = fopen(FILENAME, ""r"");
                if (pFile != NULL)
                {
                    
                    if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                    {
                        printLine(""fgets() failed"");
                        
                        data[dataLen] = '\0';
                    }
                    fclose(pFile);
                }
            }
        }
    }
    if(STATIC_CONST_FIVE==5)
    {
        
        fprintf(stdout, data);
"
4892,0,CWE690_NULL_Deref_From_Return__int64_t_realloc_73a.cpp,"    int64_t * data;
    list<int64_t *> dataList;
    data = NULL; 
    
    data = (int64_t *)realloc(data, 1*sizeof(int64_t));
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
16643,1,CWE758_Undefined_Behavior__int64_t_new_use_10.cpp,"    if(globalTrue)
    {
        {
            int64_t data;
            data = 5LL;
            int64_t * pointer = new int64_t;
            *pointer = data; 
            {
                int64_t data = *pointer;
                printLongLongLine(data);
            }
            delete pointer;
        }
"
8653,0,CWE401_Memory_Leak__twoIntsStruct_malloc_33.cpp,"    twoIntsStruct * data;
    twoIntsStruct * &dataRef = data;
    data = NULL;
    
    data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
    if (data == NULL) {exit(-1);}
    
    data[0].intOne = 0;
    data[0].intTwo = 0;
    printStructLine(&data[0]);
    {
        twoIntsStruct * data = dataRef;
        
        ; 
"
5846,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_15.c,"    size_t data;
    
    data = 0;
    switch(6)
    {
    case 6:
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = strtoul(inputBuffer, NULL, 0);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
    {
        char * myString;
        /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
         * for the strcpy() function to not cause a buffer overflow */
        
        if (data > strlen(HELLO_STRING))
        {
            myString = (char *)malloc(data*sizeof(char));
            if (myString == NULL) {exit(-1);}
            
            strcpy(myString, HELLO_STRING);
            printLine(myString);
            free(myString);
        }
        else
        {
            printLine(""Input is less than the length of the source string"");
        }
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
10884,0,CWE134_Uncontrolled_Format_String__char_environment_snprintf_06.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(STATIC_CONST_FIVE==5)
    {
        {
            
            size_t dataLen = strlen(data);
            char * environment = GETENV(ENV_VARIABLE);
            
            if (environment != NULL)
            {
                
                strncat(data+dataLen, environment, 100-dataLen-1);
            }
        }
    }
    if(STATIC_CONST_FIVE==5)
    {
        {
            char dest[100] = """";
            
            SNPRINTF(dest, 100-1, data);
            printLine(dest);
        }
"
16328,0,CWE415_Double_Free__malloc_free_long_66a.c,"    long * data;
    long * dataArray[5];
    
    data = NULL;
    data = (long *)malloc(100*sizeof(long));
    if (data == NULL) {exit(-1);}
    
    free(data);
    
    dataArray[2] = data;
"
10973,0,CWE590_Free_Memory_Not_on_Heap__delete_array_long_declare_32.cpp,"    long * data;
    long * *dataPtr1 = &data;
    long * *dataPtr2 = &data;
    data = NULL; 
    {
        long * data = *dataPtr1;
        {
            
            long dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5L;
                }
            }
            data = dataBuffer;
        }
        *dataPtr1 = data;
    }
    {
        long * data = *dataPtr2;
        printLongLine(data[0]);
        
        delete [] data;
"
10339,0,CWE415_Double_Free__new_delete_char_63a.cpp,"    char * data;
    
    data = NULL;
    data = new char;
    
    delete data;
"
19059,0,CWE190_Integer_Overflow__int_fscanf_preinc_01.c,"    int data;
    
    data = 0;
    
    fscanf(stdin, ""%d"", &data);
    {
        
        ++data;
        int result = data;
        printIntLine(result);
"
539,0,CWE457_Use_of_Uninitialized_Variable__double_09.c,"    double data;
    if(GLOBAL_CONST_TRUE)
    {
        
        ; 
    }
    if(GLOBAL_CONST_TRUE)
    {
        
        printDoubleLine(data);
"
6074,0,CWE590_Free_Memory_Not_on_Heap__delete_int_alloca_18.cpp,"    int * data;
    data = NULL; 
    goto source;
source:
    {
        
        int * dataBuffer = (int *)ALLOCA(sizeof(int));
        *dataBuffer = 5;
        data = dataBuffer;
    }
    printIntLine(*data);
    
"
17161,0,CWE590_Free_Memory_Not_on_Heap__delete_int64_t_placement_new_32.cpp,"    int64_t * data;
    int64_t * *dataPtr1 = &data;
    int64_t * *dataPtr2 = &data;
    data = NULL; 
    {
        int64_t * data = *dataPtr1;
        {
            
            char buffer[sizeof(int64_t)];
            int64_t * dataBuffer = new(buffer) int64_t;
            *dataBuffer = 5LL;
            data = dataBuffer;
        }
        *dataPtr1 = data;
    }
    {
        int64_t * data = *dataPtr2;
        printLongLongLine(*data);
        
        delete data;
"
19407,0,CWE401_Memory_Leak__new_array_TwoIntsClass_52a.cpp,"    TwoIntsClass * data;
    data = NULL;
    
    data = new TwoIntsClass[100];
    
    data[0].intOne = 0;
    data[0].intTwo = 0;
    printIntLine(data[0].intOne);
    printIntLine(data[0].intTwo);
"
2160,1,CWE758_Undefined_Behavior__int64_t_new_use_04.cpp,"    if(STATIC_CONST_TRUE)
    {
        {
            int64_t data;
            data = 5LL;
            int64_t * pointer = new int64_t;
            *pointer = data; 
            {
                int64_t data = *pointer;
                printLongLongLine(data);
            }
            delete pointer;
        }
"
10128,0,CWE457_Use_of_Uninitialized_Variable__twointsclass_array_new_no_init_11.cpp,"    TwoIntsClass * data;
    data = new TwoIntsClass[10];
    if(globalReturnsTrue())
    {
        
        ; 
    }
    if(globalReturnsTrue())
    {
        
        for(int i=0; i<10; i++)
        {
            printIntLine(data[i].intOne);
            printIntLine(data[i].intTwo);
        }
"
5595,0,CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_84a.cpp,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_84_bad * badObject = new CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_84_bad(data);
"
6315,0,CWE134_Uncontrolled_Format_String__char_connect_socket_printf_84_bad.cpp,"Label Definition File: CWE134_Uncontrolled_Format_String.label.xml
Template File: sources-sinks-84_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 134 Uncontrolled Format String
 * BadSource: connect_socket Read data using a connect socket (client side)
 * GoodSource: Copy a fixed string into data
 * Sinks: printf
 *    GoodSink: printf with ""%s"" as the first argument and data as the second
 *    BadSink : printf with only data as an argument
 * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE134_Uncontrolled_Format_String__char_connect_socket_printf_84.h""

#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif

#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""

namespace CWE134_Uncontrolled_Format_String__char_connect_socket_printf_84
{
CWE134_Uncontrolled_Format_String__char_connect_socket_printf_84_bad::CWE134_Uncontrolled_Format_String__char_connect_socket_printf_84_bad(char * dataCopy)
{
    data = dataCopy;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
}

CWE134_Uncontrolled_Format_String__char_connect_socket_printf_84_bad::~CWE134_Uncontrolled_Format_String__char_connect_socket_printf_84_bad()
{
    
    printf(data);
}
}
"
17039,0,CWE190_Integer_Overflow__int_connect_socket_multiply_62a.cpp,"    int data;
    
    data = 0;
    badSource(data);
    if(data > 0) 
    {
        
        int result = data * 2;
        printIntLine(result);
"
9583,0,CWE590_Free_Memory_Not_on_Heap__free_int64_t_declare_72a.cpp,"    int64_t * data;
    vector<int64_t *> dataVector;
    data = NULL; 
    {
        
        int64_t dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5LL;
            }
        }
        data = dataBuffer;
    }
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
5329,0,CWE134_Uncontrolled_Format_String__char_connect_socket_printf_08.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(staticReturnsTrue())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET connectSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                
                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                data[dataLen + recvResult / sizeof(char)] = '\0';
                
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(staticReturnsTrue())
    {
        
        printf(data);
"
6465,0,CWE590_Free_Memory_Not_on_Heap__delete_array_long_static_44.cpp,"    long * data;
    
    void (*funcPtr) (long *) = badSink;
    data = NULL; 
    {
        
        static long dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5L;
            }
        }
        data = dataBuffer;
    }
    
"
8741,0,CWE590_Free_Memory_Not_on_Heap__free_char_declare_13.c,"    char * data;
    data = NULL; 
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            
            char dataBuffer[100];
            memset(dataBuffer, 'A', 100-1); 
            dataBuffer[100-1] = '\0'; 
            data = dataBuffer;
        }
    }
    printLine(data);
    
"
165,0,CWE590_Free_Memory_Not_on_Heap__free_int_static_41.c,"    int * data;
    data = NULL; 
    {
        
        static int dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5;
            }
        }
        data = dataBuffer;
    }
"
4291,0,CWE134_Uncontrolled_Format_String__char_file_snprintf_17.c,"    int i,j;
    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    for(i = 0; i < 1; i++)
    {
        {
            
            size_t dataLen = strlen(data);
            FILE * pFile;
            
            if (100-dataLen > 1)
            {
                pFile = fopen(FILENAME, ""r"");
                if (pFile != NULL)
                {
                    
                    if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                    {
                        printLine(""fgets() failed"");
                        
                        data[dataLen] = '\0';
                    }
                    fclose(pFile);
                }
            }
        }
    }
    for(j = 0; j < 1; j++)
    {
        {
            char dest[100] = """";
            
            SNPRINTF(dest, 100-1, data);
            printLine(dest);
        }
"
15756,0,CWE78_OS_Command_Injection__char_connect_socket_execl_15.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    switch(6)
    {
    case 6:
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
"
4017,0,CWE78_OS_Command_Injection__char_console_system_07.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(staticFive==5)
    {
        {
            
            size_t dataLen = strlen(data);
            
            if (100-dataLen > 1)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
                {
                    /* The next few lines remove the carriage return from the string that is
                     * inserted by fgets() */
                    dataLen = strlen(data);
"
18955,0,CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_52a.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
7453,0,CWE190_Integer_Overflow__int_rand_add_06.c,"    int data;
    
    data = 0;
    if(STATIC_CONST_FIVE==5)
    {
        
        data = RAND32();
    }
    if(STATIC_CONST_FIVE==5)
    {
        {
            
            int result = data + 1;
            printIntLine(result);
        }
"
1247,0,CWE197_Numeric_Truncation_Error__int_fscanf_to_short_64a.c,"    int data;
    
    data = -1;
    
    fscanf(stdin, ""%d"", &data);
"
2653,0,CWE190_Integer_Overflow__int64_t_max_add_13.c,"    int64_t data;
    data = 0LL;
    if(GLOBAL_CONST_FIVE==5)
    {
        
        data = LLONG_MAX;
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            
            int64_t result = data + 1;
            printLongLongLine(result);
        }
"
13691,0,CWE190_Integer_Overflow__short_fscanf_preinc_32.c,"    short data;
    short *dataPtr1 = &data;
    short *dataPtr2 = &data;
    data = 0;
    {
        short data = *dataPtr1;
        
        fscanf (stdin, ""%hd"", &data);
        *dataPtr1 = data;
    }
    {
        short data = *dataPtr2;
        {
            
            ++data;
            short result = data;
            printIntLine(result);
        }
"
7445,0,CWE590_Free_Memory_Not_on_Heap__free_struct_declare_05.c,"    twoIntsStruct * data;
    data = NULL; 
    if(staticTrue)
    {
        {
            
            twoIntsStruct dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i].intOne = 1;
                    dataBuffer[i].intTwo = 1;
                }
            }
            data = dataBuffer;
        }
    }
    printStructLine(&data[0]);
    
"
16367,0,CWE457_Use_of_Uninitialized_Variable__int_array_alloca_partial_init_43.cpp,"    int * data;
    data = (int *)ALLOCA(10*sizeof(int));
    badSource(data);
    
    {
        int i;
        for(i=0; i<10; i++)
        {
            printIntLine(data[i]);
        }
"
3292,0,CWE190_Integer_Overflow__int_max_square_05.c,"    int data;
    
    data = 0;
    if(staticTrue)
    {
        
        data = INT_MAX;
    }
    if(staticTrue)
    {
        {
            
            int result = data * data;
            printIntLine(result);
        }
"
3996,0,CWE690_NULL_Deref_From_Return__struct_realloc_31.c,"    twoIntsStruct * data;
    data = NULL; 
    
    data = (twoIntsStruct *)realloc(data, 1*sizeof(twoIntsStruct));
    {
        twoIntsStruct * dataCopy = data;
        twoIntsStruct * data = dataCopy;
        
        data[0].intOne = 1;
        data[0].intTwo = 1;
        printStructLine(&data[0]);
        free(data);
"
5058,0,CWE190_Integer_Overflow__int_fscanf_postinc_15.c,"    int data;
    
    data = 0;
    switch(6)
    {
    case 6:
        
        fscanf(stdin, ""%d"", &data);
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
    {
        
        data++;
        int result = data;
        printIntLine(result);
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
7933,0,CWE190_Integer_Overflow__int64_t_rand_add_08.c,"    int64_t data;
    data = 0LL;
    if(staticReturnsTrue())
    {
        
        data = (int64_t)RAND64();
    }
    if(staticReturnsTrue())
    {
        {
            
            int64_t result = data + 1;
            printLongLongLine(result);
        }
"
2884,0,CWE190_Integer_Overflow__int64_t_max_preinc_61a.c,"    int64_t data;
    data = 0LL;
    data = CWE190_Integer_Overflow__int64_t_max_preinc_61b_badSource(data);
    {
        
        ++data;
        int64_t result = data;
        printLongLongLine(result);
"
7527,0,CWE563_Unused_Variable__unused_value_int64_t_33.cpp,"    int64_t data;
    int64_t &dataRef = data;
    
    data = 5LL;
    {
        int64_t data = dataRef;
        
        data = 10LL;
        printLongLongLine(data);
"
11615,0,CWE197_Numeric_Truncation_Error__short_fgets_64a.c,"    short data;
    
    data = -1;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = (short)atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
"
8291,0,CWE190_Integer_Overflow__int_connect_socket_postinc_15.c,"    int data;
    
    data = 0;
    switch(6)
    {
    case 6:
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
    {
        
        data++;
        int result = data;
        printIntLine(result);
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
3896,0,CWE190_Integer_Overflow__unsigned_int_max_postinc_06.c,"    unsigned int data;
    data = 0;
    if(STATIC_CONST_FIVE==5)
    {
        
        data = UINT_MAX;
    }
    if(STATIC_CONST_FIVE==5)
    {
        {
            
            data++;
            unsigned int result = data;
            printUnsignedLine(result);
        }
"
2683,0,CWE401_Memory_Leak__char_malloc_83_bad.cpp,"Label Definition File: CWE401_Memory_Leak.c.label.xml
Template File: sources-sinks-83_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 401 Memory Leak
 * BadSource: malloc Allocate data using malloc()
 * GoodSource: Allocate data on the stack
 * Sinks:
 *    GoodSink: call free() on data
 *    BadSink : no deallocation of data
 * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE401_Memory_Leak__char_malloc_83.h""

namespace CWE401_Memory_Leak__char_malloc_83
{
CWE401_Memory_Leak__char_malloc_83_bad::CWE401_Memory_Leak__char_malloc_83_bad(char * dataCopy)
{
    data = dataCopy;
    
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    
    strcpy(data, ""A String"");
    printLine(data);
}

CWE401_Memory_Leak__char_malloc_83_bad::~CWE401_Memory_Leak__char_malloc_83_bad()
{
    
    ; 
}
}
"
7506,0,CWE457_Use_of_Uninitialized_Variable__double_array_malloc_no_init_02.c,"    double * data;
    data = (double *)malloc(10*sizeof(double));
    if (data == NULL) {exit(-1);}
    if(1)
    {
        
        ; 
    }
    if(1)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printDoubleLine(data[i]);
            }
        }
"
17373,0,CWE590_Free_Memory_Not_on_Heap__delete_array_int64_t_declare_09.cpp,"    int64_t * data;
    data = NULL; 
    if(GLOBAL_CONST_TRUE)
    {
        {
            
            int64_t dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5LL;
                }
            }
            data = dataBuffer;
        }
    }
    printLongLongLine(data[0]);
    
"
4845,0,CWE190_Integer_Overflow__char_max_preinc_45.c,"    char data;
    data = ' ';
    
    data = CHAR_MAX;
    CWE190_Integer_Overflow__char_max_preinc_45_badData = data;
"
10898,0,CWE401_Memory_Leak__new_array_twointsStruct_16.cpp,"    twoIntsStruct * data;
    data = NULL;
    while(1)
    {
        
        data = new twoIntsStruct[100];
        
        data[0].intOne = 0;
        data[0].intTwo = 0;
        printStructLine(&data[0]);
        break;
    }
    while(1)
    {
        
        ; 
        break;
"
5598,0,CWE190_Integer_Overflow__short_fscanf_postinc_45.c,"    short data;
    data = 0;
    
    fscanf (stdin, ""%hd"", &data);
    CWE190_Integer_Overflow__short_fscanf_postinc_45_badData = data;
"
16785,0,CWE134_Uncontrolled_Format_String__char_environment_vfprintf_01.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        
        if (environment != NULL)
        {
            
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
"
12148,0,CWE197_Numeric_Truncation_Error__short_listen_socket_05.c,"    short data;
    
    data = -1;
    if(staticTrue)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = (short)atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
13370,0,CWE197_Numeric_Truncation_Error__int_connect_socket_to_short_17.c,"    int i;
    int data;
    
    data = -1;
    for(i = 0; i < 1; i++)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    {
        
        short shortData = (short)data;
        printShortLine(shortData);
"
3507,0,CWE415_Double_Free__new_delete_char_83a.cpp,"    char * data;
    
    data = NULL;
"
9648,0,CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_63a.c,"    unsigned int data;
    data = 0;
    
    fscanf (stdin, ""%u"", &data);
"
3227,0,CWE457_Use_of_Uninitialized_Variable__int_array_declare_no_init_13.c,"    int * data;
    int dataUninitArray[10];
    data = dataUninitArray;
    if(GLOBAL_CONST_FIVE==5)
    {
        
        ; 
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i]);
            }
        }
"
18070,1,CWE401_Memory_Leak__malloc_realloc_int64_t_06.c,"    if(STATIC_CONST_FIVE!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            int64_t * data = (int64_t *)malloc(100*sizeof(int64_t));
            if (data == NULL) {exit(-1);}
            int64_t * tmpData;
            
            data[0] = 5LL;
            printLongLongLine(data[0]);
            tmpData = (int64_t *)realloc(data, (130000)*sizeof(int64_t));
            /* FIX: Ensure realloc() was successful before assigning data to the memory block
            * allocated with realloc() */
            if (tmpData != NULL)
            {
                data = tmpData;
                
                data[0] = 10LL;
                printLongLongLine(data[0]);
            }
            free(data);
        }
"
7492,0,CWE190_Integer_Overflow__int_connect_socket_square_10.c,"    int data;
    
    data = 0;
    if(globalTrue)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(globalTrue)
    {
        {
            
            int result = data * data;
            printIntLine(result);
        }
"
11918,1,CWE416_Use_After_Free__return_freed_ptr_05.c,"    if(staticTrue)
    {
        {
            
            char * reversedString = helperGood(""GoodSink"");
            printLine(reversedString);
            /* free(reversedString);
             * This call to free() was removed because we want the tool to detect the use after free,
             * but we don't want that function to be free(). Essentially we want to avoid a double free
             */
        }
"
4946,0,CWE590_Free_Memory_Not_on_Heap__delete_long_alloca_31.cpp,"    long * data;
    data = NULL; 
    {
        
        long * dataBuffer = (long *)ALLOCA(sizeof(long));
        *dataBuffer = 5L;
        data = dataBuffer;
    }
    {
        long * dataCopy = data;
        long * data = dataCopy;
        printLongLine(*data);
        
        delete data;
"
11606,0,CWE78_OS_Command_Injection__char_file_execlp_72a.cpp,"    char * data;
    vector<char *> dataVector;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        FILE * pFile;
        
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
16024,0,CWE590_Free_Memory_Not_on_Heap__delete_char_placement_new_73a.cpp,"    char * data;
    list<char *> dataList;
    data = NULL; 
    {
        
        char buffer[sizeof(char)];
        char * dataBuffer = new(buffer) char;
        *dataBuffer = 'A';
        data = dataBuffer;
    }
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
2851,0,CWE190_Integer_Overflow__unsigned_int_rand_add_83a.cpp,"    unsigned int data;
    data = 0;
"
17230,0,CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_84a.cpp,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_84_bad * badObject = new CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_84_bad(data);
"
2771,0,CWE590_Free_Memory_Not_on_Heap__delete_char_declare_44.cpp,"    char * data;
    
    void (*funcPtr) (char *) = badSink;
    data = NULL; 
    {
        
        char dataBuffer;
        dataBuffer = 'A';
        data = &dataBuffer;
    }
    
"
7945,0,CWE563_Unused_Variable__unused_value_long_09.c,"    long data;
    if(GLOBAL_CONST_TRUE)
    {
        
        data = 5L;
    }
    if(GLOBAL_CONST_TRUE)
    {
        
        data = 10L;
        printLongLine(data);
"
7989,0,CWE690_NULL_Deref_From_Return__long_calloc_84_bad.cpp,"Label Definition File: CWE690_NULL_Deref_From_Return.free.label.xml
Template File: source-sinks-84_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 690 Unchecked Return Value To NULL Pointer
 * BadSource: calloc Allocate data using calloc()
 * Sinks:
 *    GoodSink: Check to see if the data allocation failed and if not, use data
 *    BadSink : Don't check for NULL and use data
 * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE690_NULL_Deref_From_Return__long_calloc_84.h""

namespace CWE690_NULL_Deref_From_Return__long_calloc_84
{
CWE690_NULL_Deref_From_Return__long_calloc_84_bad::CWE690_NULL_Deref_From_Return__long_calloc_84_bad(long * dataCopy)
{
    data = dataCopy;
    
    data = (long *)calloc(1, sizeof(long));
}

CWE690_NULL_Deref_From_Return__long_calloc_84_bad::~CWE690_NULL_Deref_From_Return__long_calloc_84_bad()
{
    
    data[0] = 5L;
    printLongLine(data[0]);
    free(data);
}
}
"
19445,1,CWE252_Unchecked_Return_Value__char_scanf_01.c,"    {
        /* By initializing dataBuffer, we ensure this will not be the
         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
        char dataBuffer[100] = """";
        char * data = dataBuffer;
        
        if (scanf(""%99s\0"", data) == EOF)
        {
            printLine(""scanf failed!"");
        }
"
16969,1,CWE587_Assignment_of_Fixed_Address_to_Pointer__basic_15.c,"    switch(5)
    {
    case 6:
        
        printLine(""Benign, fixed string"");
        break;
    default:
    {
        
        char charStack = 'a';
        char *charPointer = &charStack;
        printHexCharLine(*charPointer);
    }
    break;
"
5802,0,CWE690_NULL_Deref_From_Return__struct_realloc_14.c,"    twoIntsStruct * data;
    data = NULL; 
    
    data = (twoIntsStruct *)realloc(data, 1*sizeof(twoIntsStruct));
    if(globalFive==5)
    {
        
        data[0].intOne = 1;
        data[0].intTwo = 1;
        printStructLine(&data[0]);
        free(data);
"
7731,0,CWE190_Integer_Overflow__int_rand_square_15.c,"    int data;
    
    data = 0;
    switch(6)
    {
    case 6:
        
        data = RAND32();
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
    {
        
        int result = data * data;
        printIntLine(result);
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
18216,1,CWE401_Memory_Leak__malloc_realloc_char_13.c,"    if(GLOBAL_CONST_FIVE==5)
    {
        {
            char * data = (char *)malloc(100*sizeof(char));
            if (data == NULL) {exit(-1);}
            char * tmpData;
            
            strcpy(data, ""A String"");
            printLine(data);
            tmpData = (char *)realloc(data, (130000)*sizeof(char));
            /* FIX: Ensure realloc() was successful before assigning data to the memory block
            * allocated with realloc() */
            if (tmpData != NULL)
            {
                data = tmpData;
                
                strcpy(data, ""New String"");
                printLine(data);
            }
            free(data);
        }
"
4204,0,CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_18.c,"    int data;
    
    data = -1;
    goto source;
source:
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
11057,0,CWE590_Free_Memory_Not_on_Heap__delete_long_declare_03.cpp,"    long * data;
    data = NULL; 
    if(5==5)
    {
        {
            
            long dataBuffer;
            dataBuffer = 5L;
            data = &dataBuffer;
        }
    }
    printLongLine(*data);
    
"
13554,0,CWE457_Use_of_Uninitialized_Variable__new_double_array_partial_init_01.cpp,"    double * data;
    data = new double[10];
    
    {
        int i;
        for(i=0; i<(10/2); i++)
        {
            data[i] = (double)i;
        }
    }
    
    {
        int i;
        for(i=0; i<10; i++)
        {
            printDoubleLine(data[i]);
        }
    }
    
"
19362,0,CWE190_Integer_Overflow__int64_t_max_add_31.c,"    int64_t data;
    data = 0LL;
    
    data = LLONG_MAX;
    {
        int64_t dataCopy = data;
        int64_t data = dataCopy;
        {
            
            int64_t result = data + 1;
            printLongLongLine(result);
        }
"
7064,0,CWE401_Memory_Leak__char_calloc_07.c,"    char * data;
    data = NULL;
    if(staticFive==5)
    {
        
        data = (char *)calloc(100, sizeof(char));
        if (data == NULL) {exit(-1);}
        
        strcpy(data, ""A String"");
        printLine(data);
    }
    if(staticFive==5)
    {
        
        ; 
"
14436,1,CWE252_Unchecked_Return_Value__char_fscanf_17.c,"    int k;
    for(k = 0; k < 1; k++)
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            
            if (fscanf(stdin, ""%99s\0"", data) == EOF)
            {
                printLine(""fscanf failed!"");
            }
        }
"
14679,0,CWE476_NULL_Pointer_Dereference__char_81a.cpp,"    char * data;
    
    data = NULL;
    const CWE476_NULL_Pointer_Dereference__char_81_base& baseObject = CWE476_NULL_Pointer_Dereference__char_81_bad();
"
13167,0,CWE252_Unchecked_Return_Value__char_rename_15.c,"    switch(6)
    {
    case 6:
        
        RENAME(OLD_BAD_FILE_NAME, ""newbadfilename.txt"");
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
3215,0,CWE78_OS_Command_Injection__char_file_execl_04.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(STATIC_CONST_TRUE)
    {
        {
            
            size_t dataLen = strlen(data);
            FILE * pFile;
            
            if (100-dataLen > 1)
            {
                pFile = fopen(FILENAME, ""r"");
                if (pFile != NULL)
                {
                    
                    if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                    {
                        printLine(""fgets() failed"");
                        
                        data[dataLen] = '\0';
                    }
                    fclose(pFile);
                }
            }
        }
    }
    
    
"
563,0,CWE590_Free_Memory_Not_on_Heap__delete_array_class_alloca_33.cpp,"    TwoIntsClass * data;
    TwoIntsClass * &dataRef = data;
    data = NULL; 
    {
        
        TwoIntsClass * dataBuffer = (TwoIntsClass *)ALLOCA(100*sizeof(TwoIntsClass));
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i].intOne = 1;
                dataBuffer[i].intTwo = 1;
            }
        }
        data = dataBuffer;
    }
    {
        TwoIntsClass * data = dataRef;
        printIntLine(data[0].intOne);
        
        delete [] data;
"
8910,0,CWE476_NULL_Pointer_Dereference__char_31.c,"    char * data;
    
    data = NULL;
    {
        char * dataCopy = data;
        char * data = dataCopy;
        
        
        printHexCharLine(data[0]);
"
13720,0,CWE676_Use_of_Potentially_Dangerous_Function__basic_08.cpp,"    if(staticReturnsTrue())
    {
        {
            char charBuffer[CHAR_BUFFER_SIZE];
            
            
            cin >> charBuffer;
            charBuffer[CHAR_BUFFER_SIZE-1] = '\0';
            printLine(charBuffer);
        }
"
10654,0,CWE190_Integer_Overflow__int_fscanf_square_14.c,"    int data;
    
    data = 0;
    if(globalFive==5)
    {
        
        fscanf(stdin, ""%d"", &data);
    }
    if(globalFive==5)
    {
        {
            
            int result = data * data;
            printIntLine(result);
        }
"
5876,0,CWE758_Undefined_Behavior__int64_t_malloc_use_12.c,"    if(globalReturnsTrueOrFalse())
    {
        {
            int64_t * pointer = (int64_t *)malloc(sizeof(int64_t));
            if (pointer == NULL) {exit(-1);}
            int64_t data = *pointer; 
            free(pointer);
            printLongLongLine(data);
        }
    }
    else
    {
        {
            int64_t data;
            int64_t * pointer = (int64_t *)malloc(sizeof(int64_t));
            if (pointer == NULL) {exit(-1);}
            data = 5LL;
            *pointer = data; 
            {
                int64_t data = *pointer;
                printLongLongLine(data);
            }
            free(pointer);
        }
"
15506,0,CWE415_Double_Free__malloc_free_int_67a.c,"    int * data;
    CWE415_Double_Free__malloc_free_int_67_structType myStruct;
    
    data = NULL;
    data = (int *)malloc(100*sizeof(int));
    if (data == NULL) {exit(-1);}
    
    free(data);
    myStruct.structFirst = data;
"
14185,0,CWE457_Use_of_Uninitialized_Variable__double_array_alloca_no_init_17.c,"    int i,j;
    double * data;
    data = (double *)ALLOCA(10*sizeof(double));
    for(i = 0; i < 1; i++)
    {
        
        ; 
    }
    for(j = 0; j < 1; j++)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printDoubleLine(data[i]);
            }
        }
"
14696,1,CWE758_Undefined_Behavior__struct_new_use_03.cpp,"    if(5==5)
    {
        {
            twoIntsStruct data;
            data.intOne = 1;
            data.intTwo = 2;
            twoIntsStruct * pointer = new twoIntsStruct;
            *pointer = data; 
            {
                twoIntsStruct data = *pointer;
                printIntLine(data.intOne);
                printIntLine(data.intTwo);
            }
            delete pointer;
        }
"
273,0,CWE590_Free_Memory_Not_on_Heap__delete_array_struct_declare_09.cpp,"    twoIntsStruct * data;
    data = NULL; 
    if(GLOBAL_CONST_TRUE)
    {
        {
            
            twoIntsStruct dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i].intOne = 1;
                    dataBuffer[i].intTwo = 1;
                }
            }
            data = dataBuffer;
        }
    }
    printStructLine(&data[0]);
    
"
9276,0,CWE416_Use_After_Free__new_delete_array_struct_64a.cpp,"    twoIntsStruct * data;
    
    data = NULL;
    data = new twoIntsStruct[100];
    {
        size_t i;
        for(i = 0; i < 100; i++)
        {
            data[i].intOne = 1;
            data[i].intTwo = 2;
        }
    }
    
    delete [] data;
"
16748,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_82_bad.cpp,"Label Definition File: CWE789_Uncontrolled_Mem_Alloc__malloc.label.xml
Template File: sources-sinks-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: fgets Read data from the console using fgets()
 * GoodSource: Small number greater than zero
 * Sinks:
 *    GoodSink: Allocate memory with malloc() and check the size of the memory to be allocated
 *    BadSink : Allocate memory with malloc(), but incorrectly check the size of the memory to be allocated
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_82.h""

#define HELLO_STRING ""hello""

namespace CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_82
{

void CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_82_bad::action(size_t data)
{
    {
        char * myString;
        /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
         * for the strcpy() function to not cause a buffer overflow */
        
        if (data > strlen(HELLO_STRING))
        {
            myString = (char *)malloc(data*sizeof(char));
            if (myString == NULL) {exit(-1);}
            
            strcpy(myString, HELLO_STRING);
            printLine(myString);
            free(myString);
        }
        else
        {
            printLine(""Input is less than the length of the source string"");
        }
    }
}

}
"
10084,0,CWE78_OS_Command_Injection__char_file_execl_64a.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        FILE * pFile;
        
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
"
15425,1,CWE758_Undefined_Behavior__int_alloca_use_05.c,"    if(staticFalse)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            int data;
            int * pointer = (int *)ALLOCA(sizeof(int));
            data = 5;
            *pointer = data; 
            {
                int data = *pointer;
                printIntLine(data);
            }
        }
"
7118,0,CWE476_NULL_Pointer_Dereference__deref_after_check_04.c,"    if(STATIC_CONST_TRUE)
    {
        {
            
            int *intPointer = NULL;
            if (intPointer == NULL)
            {
                printIntLine(*intPointer);
            }
        }
"
12382,1,CWE758_Undefined_Behavior__int_pointer_new_use_07.cpp,"    if(staticFive==5)
    {
        {
            int * data;
            
            data = new int;
            *data = 5;
            int * * pointer = new int *;
            *pointer = data; 
            {
                int * data = *pointer;
                printIntLine(*data);
            }
            delete pointer;
        }
"
12973,0,CWE457_Use_of_Uninitialized_Variable__double_array_malloc_partial_init_09.c,"    double * data;
    data = (double *)malloc(10*sizeof(double));
    if (data == NULL) {exit(-1);}
    if(GLOBAL_CONST_TRUE)
    {
        
        {
            int i;
            for(i=0; i<(10/2); i++)
            {
                data[i] = (double)i;
            }
        }
    }
    if(GLOBAL_CONST_TRUE)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printDoubleLine(data[i]);
            }
        }
"
12643,0,CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_43.cpp,"    int data;
    
    data = -1;
    badSource(data);
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
17231,0,CWE476_NULL_Pointer_Dereference__long_81a.cpp,"    long * data;
    
    data = NULL;
    const CWE476_NULL_Pointer_Dereference__long_81_base& baseObject = CWE476_NULL_Pointer_Dereference__long_81_bad();
"
3623,0,CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_10.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(globalTrue)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                data[dataLen + recvResult / sizeof(char)] = '\0';
                
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(globalTrue)
    {
        
        fprintf(stdout, data);
"
11482,0,CWE134_Uncontrolled_Format_String__char_console_vprintf_16.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    while(1)
    {
        {
            
            size_t dataLen = strlen(data);
            
            if (100-dataLen > 1)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
                {
                    /* The next few lines remove the carriage return from the string that is
                     * inserted by fgets() */
                    dataLen = strlen(data);
                    if (dataLen > 0 && data[dataLen-1] == '\n')
                    {
                        data[dataLen-1] = '\0';
                    }
                }
                else
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
            }
        }
        break;
    }
    while(1)
    {
        badVaSinkB(data, data);
        break;
"
15006,1,CWE758_Undefined_Behavior__struct_new_use_15.cpp,"    switch(5)
    {
    case 6:
        
        printLine(""Benign, fixed string"");
        break;
    default:
    {
        twoIntsStruct data;
        data.intOne = 1;
        data.intTwo = 2;
        twoIntsStruct * pointer = new twoIntsStruct;
        *pointer = data; 
        {
            twoIntsStruct data = *pointer;
            printIntLine(data.intOne);
            printIntLine(data.intTwo);
        }
        delete pointer;
    }
    break;
"
10650,0,CWE197_Numeric_Truncation_Error__short_connect_socket_32.c,"    short data;
    short *dataPtr1 = &data;
    short *dataPtr2 = &data;
    
    data = -1;
    {
        short data = *dataPtr1;
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = (short)atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
        *dataPtr1 = data;
    }
    {
        short data = *dataPtr2;
        {
            
            char charData = (char)data;
            printHexCharLine(charData);
        }
"
2804,0,CWE190_Integer_Overflow__int_max_add_32.c,"    int data;
    int *dataPtr1 = &data;
    int *dataPtr2 = &data;
    
    data = 0;
    {
        int data = *dataPtr1;
        
        data = INT_MAX;
        *dataPtr1 = data;
    }
    {
        int data = *dataPtr2;
        {
            
            int result = data + 1;
            printIntLine(result);
        }
"
13528,0,CWE190_Integer_Overflow__short_max_add_51a.c,"    short data;
    data = 0;
    
    data = SHRT_MAX;
"
9918,0,CWE563_Unused_Variable__unused_uninit_variable_int_10.c,"    int data;
    
    ; 
    if(globalTrue)
    {
        
        
        ; 
"
5283,0,CWE789_Uncontrolled_Mem_Alloc__new_char_listen_socket_66a.cpp,"    size_t data;
    size_t dataArray[5];
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = strtoul(inputBuffer, NULL, 0);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
    dataArray[2] = data;
"
5941,0,CWE590_Free_Memory_Not_on_Heap__free_struct_static_81a.cpp,"    twoIntsStruct * data;
    data = NULL; 
    {
        
        static twoIntsStruct dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i].intOne = 1;
                dataBuffer[i].intTwo = 1;
            }
        }
        data = dataBuffer;
    }
    const CWE590_Free_Memory_Not_on_Heap__free_struct_static_81_base& baseObject = CWE590_Free_Memory_Not_on_Heap__free_struct_static_81_bad();
"
3297,0,CWE590_Free_Memory_Not_on_Heap__free_int64_t_alloca_02.c,"    int64_t * data;
    data = NULL; 
    if(1)
    {
        {
            
            int64_t * dataBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5LL;
                }
            }
            data = dataBuffer;
        }
    }
    printLongLongLine(data[0]);
    
"
2444,0,CWE190_Integer_Overflow__int_rand_square_65a.c,"    int data;
    
    void (*funcPtr) (int) = CWE190_Integer_Overflow__int_rand_square_65b_badSink;
    
    data = 0;
    
    data = RAND32();
    
"
7174,0,CWE190_Integer_Overflow__char_max_preinc_06.c,"    char data;
    data = ' ';
    if(STATIC_CONST_FIVE==5)
    {
        
        data = CHAR_MAX;
    }
    if(STATIC_CONST_FIVE==5)
    {
        {
            
            ++data;
            char result = data;
            printHexCharLine(result);
        }
"
16708,1,CWE758_Undefined_Behavior__char_malloc_use_18.c,"    goto sink;
sink:
    {
        char data;
        char * pointer = (char *)malloc(sizeof(char));
        if (pointer == NULL) {exit(-1);}
        data = 5;
        *pointer = data; 
        {
            char data = *pointer;
            printHexCharLine(data);
        }
        free(pointer);
"
13030,0,CWE789_Uncontrolled_Mem_Alloc__new_char_fgets_44.cpp,"    size_t data;
    
    void (*funcPtr) (size_t) = badSink;
    
    data = 0;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = strtoul(inputBuffer, NULL, 0);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    
"
19464,0,CWE590_Free_Memory_Not_on_Heap__delete_array_int_alloca_15.cpp,"    int * data;
    data = NULL; 
    switch(6)
    {
    case 6:
    {
        
        int * dataBuffer = (int *)ALLOCA(100*sizeof(int));
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5;
            }
        }
        data = dataBuffer;
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    printIntLine(data[0]);
    
"
10239,0,CWE476_NULL_Pointer_Dereference__char_81_bad.cpp,"Label Definition File: CWE476_NULL_Pointer_Dereference.label.xml
Template File: sources-sinks-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 476 NULL Pointer Dereference
 * BadSource:  Set data to NULL
 * GoodSource: Initialize data
 * Sinks:
 *    GoodSink: Check for NULL before attempting to print data
 *    BadSink : Print data
 * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE476_NULL_Pointer_Dereference__char_81.h""

namespace CWE476_NULL_Pointer_Dereference__char_81
{

void CWE476_NULL_Pointer_Dereference__char_81_bad::action(char * data) const
{
    
    
    printHexCharLine(data[0]);
}

}
"
10399,1,CWE758_Undefined_Behavior__int_new_use_03.cpp,"    if(5!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            int data;
            data = 5;
            int * pointer = new int;
            *pointer = data; 
            {
                int data = *pointer;
                printIntLine(data);
            }
            delete pointer;
        }
"
4829,0,CWE590_Free_Memory_Not_on_Heap__free_int_static_65a.c,"    int * data;
    
    void (*funcPtr) (int *) = CWE590_Free_Memory_Not_on_Heap__free_int_static_65b_badSink;
    data = NULL; 
    {
        
        static int dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5;
            }
        }
        data = dataBuffer;
    }
    
"
8140,0,CWE789_Uncontrolled_Mem_Alloc__new_char_listen_socket_18.cpp,"    size_t data;
    
    data = 0;
    goto source;
source:
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = strtoul(inputBuffer, NULL, 0);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    goto sink;
sink:
    {
        char * myString;
        /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
         * for the strcpy() function to not cause a buffer overflow */
        
        if (data > strlen(HELLO_STRING))
        {
            myString = new char[data];
            
            strcpy(myString, HELLO_STRING);
            printLine(myString);
            delete [] myString;
        }
        else
        {
            printLine(""Input is less than the length of the source string"");
        }
"
5601,0,CWE690_NULL_Deref_From_Return__char_calloc_03.c,"    char * data;
    data = NULL; 
    
    data = (char *)calloc(20, sizeof(char));
    if(5==5)
    {
        
        strcpy(data, ""Initialize"");
        printLine(data);
        free(data);
"
18459,1,CWE758_Undefined_Behavior__int_new_use_15.cpp,"    switch(6)
    {
    case 6:
    {
        int data;
        data = 5;
        int * pointer = new int;
        *pointer = data; 
        {
            int data = *pointer;
            printIntLine(data);
        }
        delete pointer;
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
15166,0,CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_66a.c,"    char * data;
    char * dataArray[5];
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
    dataArray[2] = data;
"
10962,0,CWE190_Integer_Overflow__short_fscanf_square_64a.c,"    short data;
    data = 0;
    
    fscanf (stdin, ""%hd"", &data);
"
15472,0,CWE134_Uncontrolled_Format_String__char_listen_socket_printf_72a.cpp,"    char * data;
    vector<char *> dataVector;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
15139,1,CWE467_Use_of_sizeof_on_Pointer_Type__short_08.c,"    if(staticReturnsTrue())
    {
        {
            short * goodShort = NULL;
            
            goodShort = (short *)malloc(sizeof(*goodShort));
            if (goodShort == NULL) {exit(-1);}
            *goodShort = 6;
            printShortLine(*goodShort);
            free(goodShort);
        }
"
8534,0,CWE78_OS_Command_Injection__char_listen_socket_popen_42.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    data = badSource(data);
    {
        FILE *pipe;
        
        pipe = POPEN(data, ""w"");
        if (pipe != NULL)
        {
            PCLOSE(pipe);
        }
"
6459,0,CWE476_NULL_Pointer_Dereference__class_08.cpp,"    TwoIntsClass * data;
    if(staticReturnsTrue())
    {
        
        data = NULL;
    }
    if(staticReturnsTrue())
    {
        
        printIntLine(data->intOne);
        
        delete data;
"
203,0,CWE190_Integer_Overflow__char_max_preinc_16.c,"    char data;
    data = ' ';
    while(1)
    {
        
        data = CHAR_MAX;
        break;
    }
    while(1)
    {
        {
            
            ++data;
            char result = data;
            printHexCharLine(result);
        }
        break;
"
15932,0,CWE590_Free_Memory_Not_on_Heap__delete_array_struct_alloca_13.cpp,"    twoIntsStruct * data;
    data = NULL; 
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            
            twoIntsStruct * dataBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i].intOne = 1;
                    dataBuffer[i].intTwo = 1;
                }
            }
            data = dataBuffer;
        }
    }
    printStructLine(&data[0]);
    
"
4732,0,CWE401_Memory_Leak__twoIntsStruct_malloc_81_bad.cpp,"Label Definition File: CWE401_Memory_Leak.c.label.xml
Template File: sources-sinks-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 401 Memory Leak
 * BadSource: malloc Allocate data using malloc()
 * GoodSource: Allocate data on the stack
 * Sinks:
 *    GoodSink: call free() on data
 *    BadSink : no deallocation of data
 * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE401_Memory_Leak__twoIntsStruct_malloc_81.h""

namespace CWE401_Memory_Leak__twoIntsStruct_malloc_81
{

void CWE401_Memory_Leak__twoIntsStruct_malloc_81_bad::action(twoIntsStruct * data) const
{
    
    ; 
}

}
"
10825,0,CWE415_Double_Free__malloc_free_int_14.c,"    int * data;
    
    data = NULL;
    if(globalFive==5)
    {
        data = (int *)malloc(100*sizeof(int));
        if (data == NULL) {exit(-1);}
        
        free(data);
    }
    if(globalFive==5)
    {
        
        free(data);
"
16842,1,CWE401_Memory_Leak__malloc_realloc_int64_t_09.c,"    if(GLOBAL_CONST_TRUE)
    {
        {
            int64_t * data = (int64_t *)malloc(100*sizeof(int64_t));
            if (data == NULL) {exit(-1);}
            int64_t * tmpData;
            
            data[0] = 5LL;
            printLongLongLine(data[0]);
            tmpData = (int64_t *)realloc(data, (130000)*sizeof(int64_t));
            /* FIX: Ensure realloc() was successful before assigning data to the memory block
            * allocated with realloc() */
            if (tmpData != NULL)
            {
                data = tmpData;
                
                data[0] = 10LL;
                printLongLongLine(data[0]);
            }
            free(data);
        }
"
16465,0,CWE190_Integer_Overflow__int_fscanf_square_32.c,"    int data;
    int *dataPtr1 = &data;
    int *dataPtr2 = &data;
    
    data = 0;
    {
        int data = *dataPtr1;
        
        fscanf(stdin, ""%d"", &data);
        *dataPtr1 = data;
    }
    {
        int data = *dataPtr2;
        {
            
            int result = data * data;
            printIntLine(result);
        }
"
3085,0,CWE690_NULL_Deref_From_Return__struct_malloc_13.c,"    twoIntsStruct * data;
    data = NULL; 
    
    data = (twoIntsStruct *)malloc(1*sizeof(twoIntsStruct));
    if(GLOBAL_CONST_FIVE==5)
    {
        
        data[0].intOne = 1;
        data[0].intTwo = 1;
        printStructLine(&data[0]);
        free(data);
"
13535,1,CWE758_Undefined_Behavior__char_pointer_new_use_14.cpp,"    if(globalFive==5)
    {
        {
            char * data;
            data = ""string"";
            char * * pointer = new char *;
            *pointer = data; 
            {
                char * data = *pointer;
                printLine(data);
            }
            delete pointer;
        }
"
14000,0,CWE415_Double_Free__new_delete_array_struct_51a.cpp,"    twoIntsStruct * data;
    
    data = NULL;
    data = new twoIntsStruct[100];
    
    delete [] data;
"
447,0,CWE401_Memory_Leak__twoIntsStruct_malloc_62a.cpp,"    twoIntsStruct * data;
    data = NULL;
    badSource(data);
    
"
13877,0,CWE401_Memory_Leak__int_calloc_61a.c,"    int * data;
    data = NULL;
    data = CWE401_Memory_Leak__int_calloc_61b_badSource(data);
    
"
3848,0,CWE197_Numeric_Truncation_Error__short_fscanf_32.c,"    short data;
    short *dataPtr1 = &data;
    short *dataPtr2 = &data;
    
    data = -1;
    {
        short data = *dataPtr1;
        
        fscanf (stdin, ""%hd"", &data);
        *dataPtr1 = data;
    }
    {
        short data = *dataPtr2;
        {
            
            char charData = (char)data;
            printHexCharLine(charData);
        }
"
5693,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_02.c,"    size_t data;
    
    data = 0;
    if(1)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = strtoul(inputBuffer, NULL, 0);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(1)
    {
        {
            char * myString;
            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
             * for the strcpy() function to not cause a buffer overflow */
            
            if (data > strlen(HELLO_STRING))
            {
                myString = (char *)malloc(data*sizeof(char));
                if (myString == NULL) {exit(-1);}
                
                strcpy(myString, HELLO_STRING);
                printLine(myString);
                free(myString);
            }
            else
            {
                printLine(""Input is less than the length of the source string"");
            }
        }
"
7537,0,CWE369_Divide_by_Zero__int_fgets_modulo_68a.c,"    int data;
    
    data = -1;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    CWE369_Divide_by_Zero__int_fgets_modulo_68_badData = data;
"
18371,0,CWE134_Uncontrolled_Format_String__char_listen_socket_printf_22a.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    CWE134_Uncontrolled_Format_String__char_listen_socket_printf_22_badGlobal = 1; 
"
6899,1,CWE758_Undefined_Behavior__char_pointer_alloca_use_01.c,"    {
        char * data;
        char * * pointer = (char * *)ALLOCA(sizeof(char *));
        data = ""string"";
        *pointer = data; 
        {
            char * data = *pointer;
            printLine(data);
        }
"
3880,0,CWE197_Numeric_Truncation_Error__int_fgets_to_char_83a.cpp,"    int data;
    
    data = -1;
"
13184,0,CWE590_Free_Memory_Not_on_Heap__free_int_static_81a.cpp,"    int * data;
    data = NULL; 
    {
        
        static int dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5;
            }
        }
        data = dataBuffer;
    }
    const CWE590_Free_Memory_Not_on_Heap__free_int_static_81_base& baseObject = CWE590_Free_Memory_Not_on_Heap__free_int_static_81_bad();
"
11163,0,CWE789_Uncontrolled_Mem_Alloc__new_char_rand_83_bad.cpp,"Label Definition File: CWE789_Uncontrolled_Mem_Alloc__new.label.xml
Template File: sources-sinks-83_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: rand Set data to result of rand(), which may be zero
 * GoodSource: Small number greater than zero
 * Sinks:
 *    GoodSink: Allocate memory with new [] and check the size of the memory to be allocated
 *    BadSink : Allocate memory with new [], but incorrectly check the size of the memory to be allocated
 * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE789_Uncontrolled_Mem_Alloc__new_char_rand_83.h""

#define HELLO_STRING ""hello""

namespace CWE789_Uncontrolled_Mem_Alloc__new_char_rand_83
{
CWE789_Uncontrolled_Mem_Alloc__new_char_rand_83_bad::CWE789_Uncontrolled_Mem_Alloc__new_char_rand_83_bad(size_t dataCopy)
{
    data = dataCopy;
    
    data = rand();
}

CWE789_Uncontrolled_Mem_Alloc__new_char_rand_83_bad::~CWE789_Uncontrolled_Mem_Alloc__new_char_rand_83_bad()
{
    {
        char * myString;
        /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
         * for the strcpy() function to not cause a buffer overflow */
        
        if (data > strlen(HELLO_STRING))
        {
            myString = new char[data];
            
            strcpy(myString, HELLO_STRING);
            printLine(myString);
            delete [] myString;
        }
        else
        {
            printLine(""Input is less than the length of the source string"");
        }
    }
}
}
"
2295,0,CWE415_Double_Free__new_delete_array_struct_42.cpp,"    twoIntsStruct * data;
    
    data = NULL;
    data = badSource(data);
    
"
17303,0,CWE590_Free_Memory_Not_on_Heap__delete_array_char_alloca_74a.cpp,"    char * data;
    map<int, char *> dataMap;
    data = NULL; 
    {
        
        char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
        memset(dataBuffer, 'A', 100-1); 
        dataBuffer[100-1] = '\0'; 
        data = dataBuffer;
    }
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
6434,0,CWE590_Free_Memory_Not_on_Heap__delete_char_static_82_bad.cpp,"Label Definition File: CWE590_Free_Memory_Not_on_Heap__delete.nonpointer.label.xml
Template File: sources-sink-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 590 Free Memory Not on Heap
 * BadSource: static Data buffer is declared static on the stack
 * GoodSource: Allocate memory on the heap
 * Sinks:
 *    BadSink : Print then free data
 * Flow Variant: 82 Data flow: data passed in a parameter to a virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE590_Free_Memory_Not_on_Heap__delete_char_static_82.h""

namespace CWE590_Free_Memory_Not_on_Heap__delete_char_static_82
{

void CWE590_Free_Memory_Not_on_Heap__delete_char_static_82_bad::action(char * data)
{
    printHexCharLine(*data);
    
    delete data;
}

}
"
702,0,CWE563_Unused_Variable__unused_uninit_variable_int_22a.c,"    int data;
    
    ; 
    CWE563_Unused_Variable__unused_uninit_variable_int_22_badGlobal = 1; 
"
5903,0,CWE401_Memory_Leak__new_struct_twoIntsStruct_21.cpp,"    struct _twoIntsStruct * data;
    data = NULL;
    
    data = new struct _twoIntsStruct;
    
    data->intOne = 0;
    data->intTwo = 0;
    printStructLine((twoIntsStruct *)data);
    badStatic = 1; 
"
4317,0,CWE190_Integer_Overflow__int_fgets_multiply_14.c,"    int data;
    
    data = 0;
    if(globalFive==5)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    if(globalFive==5)
    {
        if(data > 0) 
        {
            
            int result = data * 2;
            printIntLine(result);
        }
"
3941,0,CWE590_Free_Memory_Not_on_Heap__delete_int_alloca_66a.cpp,"    int * data;
    int * dataArray[5];
    data = NULL; 
    {
        
        int * dataBuffer = (int *)ALLOCA(sizeof(int));
        *dataBuffer = 5;
        data = dataBuffer;
    }
    
    dataArray[2] = data;
"
538,0,CWE134_Uncontrolled_Format_String__char_file_printf_53a.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        FILE * pFile;
        
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
"
7356,0,CWE78_OS_Command_Injection__char_connect_socket_execlp_42.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    data = badSource(data);
    /* execlp - searches for the location of the command among
     * the directories specified by the PATH environment variable */
    
    EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}

#endif 

#ifndef OMITGOOD

static char * goodG2BSource(char * data)
{
    
"
5077,0,CWE690_NULL_Deref_From_Return__int64_t_realloc_65a.c,"    int64_t * data;
    
    void (*funcPtr) (int64_t *) = CWE690_NULL_Deref_From_Return__int64_t_realloc_65b_badSink;
    data = NULL; 
    
    data = (int64_t *)realloc(data, 1*sizeof(int64_t));
    
"
14642,0,CWE563_Unused_Variable__unused_class_member_value_01_bad.cpp," * 
 * */

#include ""std_testcase.h""

namespace CWE563_Unused_Variable__unused_class_member_value_01
{

#ifndef OMITBAD

class BadClass
{
    public:
        BadClass()
        {
            id = 22;
        }
        
        void printMembers() 
        {
            id = 11; 
            printIntLine(id);
        }
        
    private:
        int id; 
};

void bad()
{
    BadClass badClassObject;
    badClassObject.printMembers();
}

#endif 

} 

/* Below is the main(). It is only used when building this testcase on 
 * its own for testing or for building a binary to use in testing binary 
 * analysis tools. It is not used when compiling all the testcases as one 
 * application, which is how source code analysis tools are tested. 
 */
   
#ifdef INCLUDEMAIN

using namespace CWE563_Unused_Variable__unused_class_member_value_01; 

int main(int argc, char * argv[])
{
    
    srand( (unsigned)time(NULL) );
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}

"
623,0,CWE758_Undefined_Behavior__int_pointer_new_use_02.cpp,"    if(1)
    {
        {
            int * * pointer = new int *;
            int * data = *pointer; 
            delete pointer;
            printIntLine(*data);
        }
"
6020,0,CWE190_Integer_Overflow__int_rand_square_01.c,"    int data;
    
    data = 0;
    
    data = RAND32();
    {
        
        int result = data * data;
        printIntLine(result);
"
2746,0,CWE190_Integer_Overflow__short_rand_postinc_11.c,"    short data;
    data = 0;
    if(globalReturnsTrue())
    {
        
        data = (short)RAND32();
    }
    if(globalReturnsTrue())
    {
        {
            
            data++;
            short result = data;
            printIntLine(result);
        }
"
15267,0,CWE401_Memory_Leak__twoIntsStruct_realloc_45.c,"    twoIntsStruct * data;
    data = NULL;
    
    data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));
    if (data == NULL) {exit(-1);}
    
    data[0].intOne = 0;
    data[0].intTwo = 0;
    printStructLine(&data[0]);
    CWE401_Memory_Leak__twoIntsStruct_realloc_45_badData = data;
"
14691,0,CWE134_Uncontrolled_Format_String__char_environment_vfprintf_84_bad.cpp,"Label Definition File: CWE134_Uncontrolled_Format_String.vasinks.label.xml
Template File: sources-vasinks-84_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 134 Uncontrolled Format String
 * BadSource: environment Read input from an environment variable
 * GoodSource: Copy a fixed string into data
 * Sinks: vfprintf
 *    GoodSink: vfprintf with a format string
 *    BadSink : vfprintf without a format string
 * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use
 *
 * */
#ifndef OMITBAD

#include <stdarg.h>
#include ""std_testcase.h""
#include ""CWE134_Uncontrolled_Format_String__char_environment_vfprintf_84.h""

#define ENV_VARIABLE ""ADD""

#ifdef _WIN32
#define GETENV getenv
#else
#define GETENV getenv
#endif

namespace CWE134_Uncontrolled_Format_String__char_environment_vfprintf_84
{
CWE134_Uncontrolled_Format_String__char_environment_vfprintf_84_bad::CWE134_Uncontrolled_Format_String__char_environment_vfprintf_84_bad(char * dataCopy)
{
    data = dataCopy;
    {
        
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        
        if (environment != NULL)
        {
            
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
}

static void badVaSink(char * data, ...)
{
    {
        va_list args;
        va_start(args, data);
        
        vfprintf(stdout, data, args);
        va_end(args);
    }
}

CWE134_Uncontrolled_Format_String__char_environment_vfprintf_84_bad::~CWE134_Uncontrolled_Format_String__char_environment_vfprintf_84_bad()
{
    badVaSink(data, data);
}
}
"
7914,0,CWE190_Integer_Overflow__char_rand_preinc_42.c,"    char data;
    data = ' ';
    data = badSource(data);
    {
        
        ++data;
        char result = data;
        printHexCharLine(result);
"
18192,0,CWE369_Divide_by_Zero__float_fscanf_03.c,"    float data;
    
    data = 0.0F;
    if(5==5)
    {
        
        fscanf (stdin, ""%f"", &data);
    }
    if(5==5)
    {
        {
            
            int result = (int)(100.0 / data);
            printIntLine(result);
        }
"
18495,0,CWE590_Free_Memory_Not_on_Heap__delete_array_long_static_12.cpp,"    long * data;
    data = NULL; 
    if(globalReturnsTrueOrFalse())
    {
        {
            
            static long dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5L;
                }
            }
            data = dataBuffer;
        }
    }
    else
    {
        {
            
            long * dataBuffer = new long[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5L;
                }
            }
            data = dataBuffer;
        }
    }
    printLongLine(data[0]);
    
"
18124,0,CWE190_Integer_Overflow__char_fscanf_postinc_03.c,"    char data;
    data = ' ';
    if(5==5)
    {
        
        fscanf (stdin, ""%c"", &data);
    }
    if(5==5)
    {
        {
            
            data++;
            char result = data;
            printHexCharLine(result);
        }
"
10667,0,CWE590_Free_Memory_Not_on_Heap__delete_array_int64_t_static_03.cpp,"    int64_t * data;
    data = NULL; 
    if(5==5)
    {
        {
            
            static int64_t dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5LL;
                }
            }
            data = dataBuffer;
        }
    }
    printLongLongLine(data[0]);
    
"
11922,0,CWE476_NULL_Pointer_Dereference__int64_t_08.c,"    int64_t * data;
    if(staticReturnsTrue())
    {
        
        data = NULL;
    }
    if(staticReturnsTrue())
    {
        
        printLongLongLine(*data);
"
15773,0,CWE190_Integer_Overflow__char_fscanf_multiply_51a.c,"    char data;
    data = ' ';
    
    fscanf (stdin, ""%c"", &data);
"
13903,0,CWE415_Double_Free__new_delete_class_12.cpp,"    TwoIntsClass * data;
    
    data = NULL;
    if(globalReturnsTrueOrFalse())
    {
        data = new TwoIntsClass;
        
        delete data;
    }
    else
    {
        data = new TwoIntsClass;
        
    }
    if(globalReturnsTrueOrFalse())
    {
        
        delete data;
    }
    else
    {
        
        
        ; 
"
7662,0,CWE369_Divide_by_Zero__int_fscanf_divide_73a.cpp,"    int data;
    list<int> dataList;
    
    data = -1;
    
    fscanf(stdin, ""%d"", &data);
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
7220,0,CWE415_Double_Free__malloc_free_struct_44.c,"    twoIntsStruct * data;
    
    void (*funcPtr) (twoIntsStruct *) = badSink;
    
    data = NULL;
    data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
    if (data == NULL) {exit(-1);}
    
    free(data);
    
"
3671,0,CWE78_OS_Command_Injection__char_environment_execlp_06.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(STATIC_CONST_FIVE==5)
    {
        {
            
            size_t dataLen = strlen(data);
            char * environment = GETENV(ENV_VARIABLE);
            
            if (environment != NULL)
            {
                
                strncat(data+dataLen, environment, 100-dataLen-1);
            }
        }
    }
    /* execlp - searches for the location of the command among
     * the directories specified by the PATH environment variable */
    
"
12570,0,CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_01.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
"
17873,0,CWE590_Free_Memory_Not_on_Heap__free_struct_static_13.c,"    twoIntsStruct * data;
    data = NULL; 
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            
            static twoIntsStruct dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i].intOne = 1;
                    dataBuffer[i].intTwo = 1;
                }
            }
            data = dataBuffer;
        }
    }
    printStructLine(&data[0]);
    
"
16385,0,CWE590_Free_Memory_Not_on_Heap__delete_long_placement_new_32.cpp,"    long * data;
    long * *dataPtr1 = &data;
    long * *dataPtr2 = &data;
    data = NULL; 
    {
        long * data = *dataPtr1;
        {
            
            char buffer[sizeof(long)];
            long * dataBuffer = new(buffer) long;
            *dataBuffer = 5L;
            data = dataBuffer;
        }
        *dataPtr1 = data;
    }
    {
        long * data = *dataPtr2;
        printLongLine(*data);
        
        delete data;
"
19189,0,CWE197_Numeric_Truncation_Error__short_rand_17.c,"    int i;
    short data;
    
    data = -1;
    for(i = 0; i < 1; i++)
    {
        
        data = (short)RAND32();
    }
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
16767,0,CWE590_Free_Memory_Not_on_Heap__delete_array_struct_declare_03.cpp,"    twoIntsStruct * data;
    data = NULL; 
    if(5==5)
    {
        {
            
            twoIntsStruct dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i].intOne = 1;
                    dataBuffer[i].intTwo = 1;
                }
            }
            data = dataBuffer;
        }
    }
    printStructLine(&data[0]);
    
"
14603,0,CWE590_Free_Memory_Not_on_Heap__delete_array_int_alloca_52a.cpp,"    int * data;
    data = NULL; 
    {
        
        int * dataBuffer = (int *)ALLOCA(100*sizeof(int));
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5;
            }
        }
        data = dataBuffer;
    }
"
7600,0,CWE190_Integer_Overflow__int_fgets_postinc_14.c,"    int data;
    
    data = 0;
    if(globalFive==5)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    if(globalFive==5)
    {
        {
            
            data++;
            int result = data;
            printIntLine(result);
        }
"
11576,0,CWE190_Integer_Overflow__int_fscanf_postinc_61a.c,"    int data;
    
    data = 0;
    data = CWE190_Integer_Overflow__int_fscanf_postinc_61b_badSource(data);
    {
        
        data++;
        int result = data;
        printIntLine(result);
"
4089,0,CWE590_Free_Memory_Not_on_Heap__delete_array_int_static_67a.cpp,"    int * data;
    structType myStruct;
    data = NULL; 
    {
        
        static int dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5;
            }
        }
        data = dataBuffer;
    }
    myStruct.structFirst = data;
"
8746,0,CWE475_Undefined_Behavior_for_Input_to_API__char_16.c,"    while(1)
    {
        {
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            strcpy(data, ""abcdefghijklmnopqrstuvwxyz"");
            
            memcpy(data + 6, data + 4, 10*sizeof(char));
            printLine(data);
        }
        break;
"
7772,0,CWE416_Use_After_Free__malloc_free_long_63a.c,"    long * data;
    
    data = NULL;
    data = (long *)malloc(100*sizeof(long));
    if (data == NULL) {exit(-1);}
    {
        size_t i;
        for(i = 0; i < 100; i++)
        {
            data[i] = 5L;
        }
    }
    
    free(data);
"
12676,0,CWE457_Use_of_Uninitialized_Variable__int_array_malloc_no_init_10.c,"    int * data;
    data = (int *)malloc(10*sizeof(int));
    if (data == NULL) {exit(-1);}
    if(globalTrue)
    {
        
        ; 
    }
    if(globalTrue)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i]);
            }
        }
"
12786,0,CWE563_Unused_Variable__unused_value_int64_t_83_bad.cpp,"Label Definition File: CWE563_Unused_Variable__unused_value.label.xml
Template File: sources-sinks-83_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 563 Unused Variable
 * BadSource:  Initialize data
 * GoodSource: Initialize and use data
 * Sinks:
 *    GoodSink: Use data
 *    BadSink : Initialize and use data
 * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE563_Unused_Variable__unused_value_int64_t_83.h""

namespace CWE563_Unused_Variable__unused_value_int64_t_83
{
CWE563_Unused_Variable__unused_value_int64_t_83_bad::CWE563_Unused_Variable__unused_value_int64_t_83_bad(int64_t dataCopy)
{
    data = dataCopy;
    
    data = 5LL;
}

CWE563_Unused_Variable__unused_value_int64_t_83_bad::~CWE563_Unused_Variable__unused_value_int64_t_83_bad()
{
    
    data = 10LL;
    printLongLongLine(data);
}
}
"
9094,0,CWE590_Free_Memory_Not_on_Heap__free_int_static_33.cpp,"    int * data;
    int * &dataRef = data;
    data = NULL; 
    {
        
        static int dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5;
            }
        }
        data = dataBuffer;
    }
    {
        int * data = dataRef;
        printIntLine(data[0]);
        
        free(data);
"
11858,1,CWE676_Use_of_Potentially_Dangerous_Function__basic_10.cpp,"    if(globalFalse)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            char charBuffer[CHAR_BUFFER_SIZE];
            
            cin.width(CHAR_BUFFER_SIZE);
            cin >> charBuffer;
            charBuffer[CHAR_BUFFER_SIZE-1] = '\0';
            printLine(charBuffer);
        }
"
12545,0,CWE190_Integer_Overflow__int_listen_socket_multiply_74a.cpp,"    int data;
    map<int, int> dataMap;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
19048,0,CWE369_Divide_by_Zero__int_fscanf_divide_32.c,"    int data;
    int *dataPtr1 = &data;
    int *dataPtr2 = &data;
    
    data = -1;
    {
        int data = *dataPtr1;
        
        fscanf(stdin, ""%d"", &data);
        *dataPtr1 = data;
    }
    {
        int data = *dataPtr2;
        
        printIntLine(100 / data);
"
5282,0,CWE197_Numeric_Truncation_Error__short_rand_10.c,"    short data;
    
    data = -1;
    if(globalTrue)
    {
        
        data = (short)RAND32();
    }
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
17918,1,CWE475_Undefined_Behavior_for_Input_to_API__char_12.c,"    if(globalReturnsTrueOrFalse())
    {
        {
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            strcpy(data, ""abcdefghijklmnopqrstuvwxyz"");
            
            memmove(data + 6, data + 4, 10*sizeof(char));
            printLine(data);
        }
    }
    else
    {
        {
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            strcpy(data, ""abcdefghijklmnopqrstuvwxyz"");
            
            memmove(data + 6, data + 4, 10*sizeof(char));
            printLine(data);
        }
"
8276,0,CWE190_Integer_Overflow__unsigned_int_max_postinc_63a.c,"    unsigned int data;
    data = 0;
    
    data = UINT_MAX;
"
3185,0,CWE190_Integer_Overflow__int_fscanf_multiply_82_bad.cpp,"Label Definition File: CWE190_Integer_Overflow__int.label.xml
Template File: sources-sinks-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 190 Integer Overflow
 * BadSource: fscanf Read data from the console using fscanf()
 * GoodSource: Set data to a small, non-zero number (two)
 * Sinks: multiply
 *    GoodSink: Ensure there will not be an overflow before multiplying data by 2
 *    BadSink : If data is positive, multiply by 2, which can cause an overflow
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE190_Integer_Overflow__int_fscanf_multiply_82.h""

namespace CWE190_Integer_Overflow__int_fscanf_multiply_82
{

void CWE190_Integer_Overflow__int_fscanf_multiply_82_bad::action(int data)
{
    if(data > 0) 
    {
        
        int result = data * 2;
        printIntLine(result);
    }
}

}
"
17673,0,CWE590_Free_Memory_Not_on_Heap__free_int64_t_declare_17.c,"    int i;
    int64_t * data;
    data = NULL; 
    for(i = 0; i < 1; i++)
    {
        {
            
            int64_t dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5LL;
                }
            }
            data = dataBuffer;
        }
    }
    printLongLongLine(data[0]);
    
"
2504,0,CWE190_Integer_Overflow__unsigned_int_max_postinc_18.c,"    unsigned int data;
    data = 0;
    goto source;
source:
    
    data = UINT_MAX;
    goto sink;
sink:
    {
        
        data++;
        unsigned int result = data;
        printUnsignedLine(result);
"
14598,0,CWE197_Numeric_Truncation_Error__int_listen_socket_to_short_84_bad.cpp,"Label Definition File: CWE197_Numeric_Truncation_Error__int.label.xml
Template File: sources-sink-84_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 197 Numeric Truncation Error
 * BadSource: listen_socket Read data using a listen socket (server side)
 * GoodSource: Less than CHAR_MAX
 * Sinks: to_short
 *    BadSink : Convert data to a short
 * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE197_Numeric_Truncation_Error__int_listen_socket_to_short_84.h""

#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif

#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)

namespace CWE197_Numeric_Truncation_Error__int_listen_socket_to_short_84
{
CWE197_Numeric_Truncation_Error__int_listen_socket_to_short_84_bad::CWE197_Numeric_Truncation_Error__int_listen_socket_to_short_84_bad(int dataCopy)
{
    data = dataCopy;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
}

CWE197_Numeric_Truncation_Error__int_listen_socket_to_short_84_bad::~CWE197_Numeric_Truncation_Error__int_listen_socket_to_short_84_bad()
{
    {
        
        short shortData = (short)data;
        printShortLine(shortData);
    }
}
}
"
18831,1,CWE252_Unchecked_Return_Value__char_sscanf_12.c,"    if(globalReturnsTrueOrFalse())
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            
            if (sscanf(SRC, ""%99s\0"", data) == EOF)
            {
                printLine(""sscanf failed!"");
            }
        }
    }
    else
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            
            if (sscanf(SRC, ""%99s\0"", data) == EOF)
            {
                printLine(""sscanf failed!"");
            }
        }
"
4832,0,CWE590_Free_Memory_Not_on_Heap__delete_char_static_45.cpp,"    char * data;
    data = NULL; 
    {
        
        static char dataBuffer;
        dataBuffer = 'A';
        data = &dataBuffer;
    }
    badData = data;
"
19345,0,CWE590_Free_Memory_Not_on_Heap__free_struct_declare_81_bad.cpp,"Label Definition File: CWE590_Free_Memory_Not_on_Heap__free.label.xml
Template File: sources-sink-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 590 Free Memory Not on Heap
 * BadSource: declare Data buffer is declared on the stack
 * GoodSource: Allocate memory on the heap
 * Sinks:
 *    BadSink : Print then free data
 * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE590_Free_Memory_Not_on_Heap__free_struct_declare_81.h""

namespace CWE590_Free_Memory_Not_on_Heap__free_struct_declare_81
{

void CWE590_Free_Memory_Not_on_Heap__free_struct_declare_81_bad::action(twoIntsStruct * data) const
{
    printStructLine(&data[0]);
    
    free(data);
}

}
"
6878,0,CWE369_Divide_by_Zero__float_listenSocket_03.c,"    float data;
    
    data = 0.0F;
    if(5==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = (float)atof(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(5==5)
    {
        {
            
            int result = (int)(100.0 / data);
            printIntLine(result);
        }
"
6738,0,CWE197_Numeric_Truncation_Error__short_large_52a.c,"    short data;
    
    data = -1;
    
    data = CHAR_MAX + 1;
"
1577,0,CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_03.c,"    unsigned int data;
    data = 0;
    if(5==5)
    {
        
        fscanf (stdin, ""%u"", &data);
    }
    if(5==5)
    {
        {
            
            ++data;
            unsigned int result = data;
            printUnsignedLine(result);
        }
"
1329,0,CWE401_Memory_Leak__char_malloc_08.c,"    char * data;
    data = NULL;
    if(staticReturnsTrue())
    {
        
        data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        
        strcpy(data, ""A String"");
        printLine(data);
    }
    if(staticReturnsTrue())
    {
        
        ; 
"
8589,0,CWE590_Free_Memory_Not_on_Heap__delete_class_placement_new_67a.cpp,"    TwoIntsClass * data;
    structType myStruct;
    data = NULL; 
    {
        
        char buffer[sizeof(TwoIntsClass)];
        TwoIntsClass * dataBuffer = new(buffer) TwoIntsClass;
        dataBuffer->intOne = 2;
        dataBuffer->intTwo = 2;
        data = dataBuffer;
    }
    myStruct.structFirst = data;
"
7529,0,CWE457_Use_of_Uninitialized_Variable__double_array_declare_no_init_13.c,"    double * data;
    double dataUninitArray[10];
    data = dataUninitArray;
    if(GLOBAL_CONST_FIVE==5)
    {
        
        ; 
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printDoubleLine(data[i]);
            }
        }
"
99,0,CWE401_Memory_Leak__int_malloc_65a.c,"    int * data;
    
    void (*funcPtr) (int *) = CWE401_Memory_Leak__int_malloc_65b_badSink;
    data = NULL;
    
    data = (int *)malloc(100*sizeof(int));
    if (data == NULL) {exit(-1);}
    
    data[0] = 5;
    printIntLine(data[0]);
    
"
1083,0,CWE590_Free_Memory_Not_on_Heap__free_char_static_67a.c,"    char * data;
    CWE590_Free_Memory_Not_on_Heap__free_char_static_67_structType myStruct;
    data = NULL; 
    {
        
        static char dataBuffer[100];
        memset(dataBuffer, 'A', 100-1); 
        dataBuffer[100-1] = '\0'; 
        data = dataBuffer;
    }
    myStruct.structFirst = data;
"
11336,0,CWE590_Free_Memory_Not_on_Heap__free_int64_t_declare_44.c,"    int64_t * data;
    
    void (*funcPtr) (int64_t *) = badSink;
    data = NULL; 
    {
        
        int64_t dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5LL;
            }
        }
        data = dataBuffer;
    }
    
"
17355,0,CWE190_Integer_Overflow__int_max_square_12.c,"    int data;
    
    data = 0;
    if(globalReturnsTrueOrFalse())
    {
        
        data = INT_MAX;
    }
    else
    {
        
        data = 2;
    }
    if(globalReturnsTrueOrFalse())
    {
        {
            
            int result = data * data;
            printIntLine(result);
        }
    }
    else
    {
        
        if (data > INT_MIN && abs(data) < (long)sqrt((double)INT_MAX))
        {
            int result = data * data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
"
11086,0,CWE134_Uncontrolled_Format_String__char_file_vprintf_32.c,"    char * data;
    char * *dataPtr1 = &data;
    char * *dataPtr2 = &data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        char * data = *dataPtr1;
        {
            
            size_t dataLen = strlen(data);
            FILE * pFile;
            
            if (100-dataLen > 1)
            {
                pFile = fopen(FILENAME, ""r"");
                if (pFile != NULL)
                {
                    
                    if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                    {
                        printLine(""fgets() failed"");
                        
                        data[dataLen] = '\0';
                    }
                    fclose(pFile);
                }
            }
        }
        *dataPtr1 = data;
    }
    {
        char * data = *dataPtr2;
        badVaSink(data, data);
"
1779,0,CWE457_Use_of_Uninitialized_Variable__int_pointer_15.c,"    int * data;
    switch(6)
    {
    case 6:
        
        ; 
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
        
        printIntLine(*data);
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
15901,0,CWE690_NULL_Deref_From_Return__struct_realloc_67a.c,"    twoIntsStruct * data;
    CWE690_NULL_Deref_From_Return__struct_realloc_67_structType myStruct;
    data = NULL; 
    
    data = (twoIntsStruct *)realloc(data, 1*sizeof(twoIntsStruct));
    myStruct.structFirst = data;
"
8859,0,CWE467_Use_of_sizeof_on_Pointer_Type__short_05.c,"    if(staticTrue)
    {
        {
            short * badShort = NULL;
            
            badShort = (short *)malloc(sizeof(badShort));
            if (badShort == NULL) {exit(-1);}
            *badShort = 5;
            printShortLine(*badShort);
            free(badShort);
        }
"
15041,1,CWE252_Unchecked_Return_Value__char_remove_14.c,"    if(globalFive!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        
        if (REMOVE(""removemegood.txt"") != 0)
        {
            printLine(""remove failed!"");
        }
"
3401,0,CWE590_Free_Memory_Not_on_Heap__delete_array_struct_static_01.cpp,"    twoIntsStruct * data;
    data = NULL; 
    {
        
        static twoIntsStruct dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i].intOne = 1;
                dataBuffer[i].intTwo = 1;
            }
        }
        data = dataBuffer;
    }
    printStructLine(&data[0]);
    
"
6334,0,CWE197_Numeric_Truncation_Error__int_rand_to_short_11.c,"    int data;
    
    data = -1;
    if(globalReturnsTrue())
    {
        
        data = RAND32();
    }
    {
        
        short shortData = (short)data;
        printShortLine(shortData);
"
19206,0,CWE416_Use_After_Free__new_delete_array_char_10.cpp,"    char * data;
    
    data = NULL;
    if(globalTrue)
    {
        data = new char[100];
        memset(data, 'A', 100-1);
        data[100-1] = '\0';
        
        delete [] data;
    }
    if(globalTrue)
    {
        
        printLine(data);
        
"
4716,0,CWE78_OS_Command_Injection__char_environment_system_04.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(STATIC_CONST_TRUE)
    {
        {
            
            size_t dataLen = strlen(data);
            char * environment = GETENV(ENV_VARIABLE);
            
            if (environment != NULL)
            {
                
                strncat(data+dataLen, environment, 100-dataLen-1);
            }
        }
    }
    
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
"
14103,1,CWE401_Memory_Leak__malloc_realloc_char_17.c,"    int k;
    for(k = 0; k < 1; k++)
    {
        {
            char * data = (char *)malloc(100*sizeof(char));
            if (data == NULL) {exit(-1);}
            char * tmpData;
            
            strcpy(data, ""A String"");
            printLine(data);
            tmpData = (char *)realloc(data, (130000)*sizeof(char));
            /* FIX: Ensure realloc() was successful before assigning data to the memory block
            * allocated with realloc() */
            if (tmpData != NULL)
            {
                data = tmpData;
                
                strcpy(data, ""New String"");
                printLine(data);
            }
            free(data);
        }
"
12270,0,CWE190_Integer_Overflow__int64_t_max_square_34.c,"    int64_t data;
    CWE190_Integer_Overflow__int64_t_max_square_34_unionType myUnion;
    data = 0LL;
    
    data = LLONG_MAX;
    myUnion.unionFirst = data;
    {
        int64_t data = myUnion.unionSecond;
        {
            
            int64_t result = data * data;
            printLongLongLine(result);
        }
"
18728,0,CWE590_Free_Memory_Not_on_Heap__delete_array_long_static_41.cpp,"    long * data;
    data = NULL; 
    {
        
        static long dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5L;
            }
        }
        data = dataBuffer;
    }
"
1392,0,CWE665_Improper_Initialization__char_cat_66a.c,"    char * data;
    char * dataArray[5];
    char dataBuffer[100];
    data = dataBuffer;
    
    ; 
    
    dataArray[2] = data;
"
2168,0,CWE401_Memory_Leak__new_TwoIntsClass_67a.cpp,"    TwoIntsClass * data;
    structType myStruct;
    data = NULL;
    
    data = new TwoIntsClass;
    
    data->intOne = 0;
    data->intTwo = 0;
    printIntLine(data->intOne);
    printIntLine(data->intTwo);
    myStruct.structFirst = data;
"
5046,0,CWE789_Uncontrolled_Mem_Alloc__new_char_rand_81_bad.cpp,"Label Definition File: CWE789_Uncontrolled_Mem_Alloc__new.label.xml
Template File: sources-sinks-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: rand Set data to result of rand(), which may be zero
 * GoodSource: Small number greater than zero
 * Sinks:
 *    GoodSink: Allocate memory with new [] and check the size of the memory to be allocated
 *    BadSink : Allocate memory with new [], but incorrectly check the size of the memory to be allocated
 * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE789_Uncontrolled_Mem_Alloc__new_char_rand_81.h""

#define HELLO_STRING ""hello""

namespace CWE789_Uncontrolled_Mem_Alloc__new_char_rand_81
{

void CWE789_Uncontrolled_Mem_Alloc__new_char_rand_81_bad::action(size_t data) const
{
    {
        char * myString;
        /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
         * for the strcpy() function to not cause a buffer overflow */
        
        if (data > strlen(HELLO_STRING))
        {
            myString = new char[data];
            
            strcpy(myString, HELLO_STRING);
            printLine(myString);
            delete [] myString;
        }
        else
        {
            printLine(""Input is less than the length of the source string"");
        }
    }
}

}
"
27,0,CWE758_Undefined_Behavior__int_malloc_use_02.c,"    if(1)
    {
        {
            int * pointer = (int *)malloc(sizeof(int));
            if (pointer == NULL) {exit(-1);}
            int data = *pointer; 
            free(pointer);
            printIntLine(data);
        }
"
3325,0,CWE78_OS_Command_Injection__char_environment_execl_83_bad.cpp,"Label Definition File: CWE78_OS_Command_Injection.strings.label.xml
Template File: sources-sink-83_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 78 OS Command Injection
 * BadSource: environment Read input from an environment variable
 * GoodSource: Fixed string
 * Sinks: execl
 *    BadSink : execute command with execl
 * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE78_OS_Command_Injection__char_environment_execl_83.h""

#define ENV_VARIABLE ""ADD""

#ifdef _WIN32
#define GETENV getenv
#else
#define GETENV getenv
#endif

#ifdef _WIN32
#include <process.h>
#define EXECL _execl
#else 
#define EXECL execl
#endif

namespace CWE78_OS_Command_Injection__char_environment_execl_83
{
CWE78_OS_Command_Injection__char_environment_execl_83_bad::CWE78_OS_Command_Injection__char_environment_execl_83_bad(char * dataCopy)
{
    data = dataCopy;
    {
        
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        
        if (environment != NULL)
        {
            
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
}

CWE78_OS_Command_Injection__char_environment_execl_83_bad::~CWE78_OS_Command_Injection__char_environment_execl_83_bad()
{
    
    
    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
}
"
16395,0,CWE369_Divide_by_Zero__float_zero_33.cpp,"    float data;
    float &dataRef = data;
    
    data = 0.0F;
    
    data = 0.0F;
    {
        float data = dataRef;
        {
            
            int result = (int)(100.0 / data);
            printIntLine(result);
        }
"
5724,0,CWE590_Free_Memory_Not_on_Heap__delete_class_placement_new_65a.cpp,"    TwoIntsClass * data;
    
    void (*funcPtr) (TwoIntsClass *) = badSink;
    data = NULL; 
    {
        
        char buffer[sizeof(TwoIntsClass)];
        TwoIntsClass * dataBuffer = new(buffer) TwoIntsClass;
        dataBuffer->intOne = 2;
        dataBuffer->intTwo = 2;
        data = dataBuffer;
    }
    
"
18314,0,CWE134_Uncontrolled_Format_String__char_file_snprintf_13.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            
            size_t dataLen = strlen(data);
            FILE * pFile;
            
            if (100-dataLen > 1)
            {
                pFile = fopen(FILENAME, ""r"");
                if (pFile != NULL)
                {
                    
                    if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                    {
                        printLine(""fgets() failed"");
                        
                        data[dataLen] = '\0';
                    }
                    fclose(pFile);
                }
            }
        }
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            char dest[100] = """";
            
            SNPRINTF(dest, 100-1, data);
            printLine(dest);
        }
"
18798,0,CWE590_Free_Memory_Not_on_Heap__delete_class_declare_10.cpp,"    TwoIntsClass * data;
    data = NULL; 
    if(globalTrue)
    {
        {
            
            TwoIntsClass dataBuffer;
            dataBuffer.intOne = 1;
            dataBuffer.intTwo = 1;
            data = &dataBuffer;
        }
    }
    printIntLine(data->intOne);
    
"
2461,0,CWE190_Integer_Overflow__char_fscanf_postinc_14.c,"    char data;
    data = ' ';
    if(globalFive==5)
    {
        
        fscanf (stdin, ""%c"", &data);
    }
    if(globalFive==5)
    {
        {
            
            data++;
            char result = data;
            printHexCharLine(result);
        }
"
4372,0,CWE78_OS_Command_Injection__char_console_execl_84a.cpp,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    CWE78_OS_Command_Injection__char_console_execl_84_bad * badObject = new CWE78_OS_Command_Injection__char_console_execl_84_bad(data);
"
7764,0,CWE190_Integer_Overflow__int_max_square_84_bad.cpp,"Label Definition File: CWE190_Integer_Overflow__int.label.xml
Template File: sources-sinks-84_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 190 Integer Overflow
 * BadSource: max Set data to the max value for int
 * GoodSource: Set data to a small, non-zero number (two)
 * Sinks: square
 *    GoodSink: Ensure there will not be an overflow before squaring data
 *    BadSink : Square data, which can lead to overflow
 * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE190_Integer_Overflow__int_max_square_84.h""

#include <math.h>

namespace CWE190_Integer_Overflow__int_max_square_84
{
CWE190_Integer_Overflow__int_max_square_84_bad::CWE190_Integer_Overflow__int_max_square_84_bad(int dataCopy)
{
    data = dataCopy;
    
    data = INT_MAX;
}

CWE190_Integer_Overflow__int_max_square_84_bad::~CWE190_Integer_Overflow__int_max_square_84_bad()
{
    {
        
        int result = data * data;
        printIntLine(result);
    }
}
}
"
19485,0,CWE415_Double_Free__malloc_free_long_10.c,"    long * data;
    
    data = NULL;
    if(globalTrue)
    {
        data = (long *)malloc(100*sizeof(long));
        if (data == NULL) {exit(-1);}
        
        free(data);
    }
    if(globalTrue)
    {
        
        free(data);
"
9669,0,CWE590_Free_Memory_Not_on_Heap__free_char_alloca_33.cpp,"    char * data;
    char * &dataRef = data;
    data = NULL; 
    {
        
        char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
        memset(dataBuffer, 'A', 100-1); 
        dataBuffer[100-1] = '\0'; 
        data = dataBuffer;
    }
    {
        char * data = dataRef;
        printLine(data);
        
        free(data);
"
16617,0,CWE190_Integer_Overflow__char_rand_multiply_81a.cpp,"    char data;
    data = ' ';
    
    data = (char)RAND32();
    const CWE190_Integer_Overflow__char_rand_multiply_81_base& baseObject = CWE190_Integer_Overflow__char_rand_multiply_81_bad();
"
14452,0,CWE190_Integer_Overflow__int_rand_square_07.c,"    int data;
    
    data = 0;
    if(staticFive==5)
    {
        
        data = RAND32();
    }
    if(staticFive==5)
    {
        {
            
            int result = data * data;
            printIntLine(result);
        }
"
2335,0,CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_62a.cpp,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    badSource(data);
    {
        char dest[100] = """";
        
        SNPRINTF(dest, 100-1, data);
        printLine(dest);
"
2625,0,CWE401_Memory_Leak__twoIntsStruct_malloc_14.c,"    twoIntsStruct * data;
    data = NULL;
    if(globalFive==5)
    {
        
        data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
        if (data == NULL) {exit(-1);}
        
        data[0].intOne = 0;
        data[0].intTwo = 0;
        printStructLine(&data[0]);
    }
    if(globalFive==5)
    {
        
        ; 
"
9894,0,CWE252_Unchecked_Return_Value__char_fputs_02.c,"    if(1)
    {
        
        fputs(""string"", stdout);
"
8975,0,CWE78_OS_Command_Injection__char_connect_socket_execlp_61a.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    data = CWE78_OS_Command_Injection__char_connect_socket_execlp_61b_badSource(data);
    /* execlp - searches for the location of the command among
     * the directories specified by the PATH environment variable */
    
    EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}

#endif 

#ifndef OMITGOOD


char * CWE78_OS_Command_Injection__char_connect_socket_execlp_61b_goodG2BSource(char * data);

"
9301,0,CWE590_Free_Memory_Not_on_Heap__free_char_declare_41.c,"    char * data;
    data = NULL; 
    {
        
        char dataBuffer[100];
        memset(dataBuffer, 'A', 100-1); 
        dataBuffer[100-1] = '\0'; 
        data = dataBuffer;
    }
"
11821,0,CWE590_Free_Memory_Not_on_Heap__delete_struct_declare_02.cpp,"    twoIntsStruct * data;
    data = NULL; 
    if(1)
    {
        {
            
            twoIntsStruct dataBuffer;
            dataBuffer.intOne = 1;
            dataBuffer.intTwo = 1;
            data = &dataBuffer;
        }
    }
    printStructLine(data);
    
"
15070,0,CWE590_Free_Memory_Not_on_Heap__delete_int64_t_alloca_73a.cpp,"    int64_t * data;
    list<int64_t *> dataList;
    data = NULL; 
    {
        
        int64_t * dataBuffer = (int64_t *)ALLOCA(sizeof(int64_t));
        *dataBuffer = 5LL;
        data = dataBuffer;
    }
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
11850,0,CWE190_Integer_Overflow__short_rand_square_31.c,"    short data;
    data = 0;
    
    data = (short)RAND32();
    {
        short dataCopy = data;
        short data = dataCopy;
        {
            
            short result = data * data;
            printIntLine(result);
        }
"
8205,0,CWE416_Use_After_Free__new_delete_int64_t_16.cpp,"    int64_t * data;
    
    data = NULL;
    while(1)
    {
        data = new int64_t;
        *data = 5LL;
        
        delete data;
        break;
    }
    while(1)
    {
        
        printLongLongLine(*data);
        
        break;
"
15145,0,CWE190_Integer_Overflow__int64_t_max_multiply_04.c,"    int64_t data;
    data = 0LL;
    if(STATIC_CONST_TRUE)
    {
        
        data = LLONG_MAX;
    }
    if(STATIC_CONST_TRUE)
    {
        if(data > 0) 
        {
            
            int64_t result = data * 2;
            printLongLongLine(result);
        }
"
2684,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_07.c,"    size_t data;
    
    data = 0;
    if(staticFive==5)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                
                data = strtoul(inputBuffer, NULL, 0);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    if(staticFive==5)
    {
        {
            char * myString;
            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
             * for the strcpy() function to not cause a buffer overflow */
            
            if (data > strlen(HELLO_STRING))
            {
                myString = (char *)malloc(data*sizeof(char));
                if (myString == NULL) {exit(-1);}
                
                strcpy(myString, HELLO_STRING);
                printLine(myString);
                free(myString);
            }
            else
            {
                printLine(""Input is less than the length of the source string"");
            }
        }
"
8926,0,CWE401_Memory_Leak__char_calloc_64a.c,"    char * data;
    data = NULL;
    
    data = (char *)calloc(100, sizeof(char));
    if (data == NULL) {exit(-1);}
    
    strcpy(data, ""A String"");
    printLine(data);
"
6469,0,CWE369_Divide_by_Zero__int_fscanf_modulo_67a.c,"    int data;
    CWE369_Divide_by_Zero__int_fscanf_modulo_67_structType myStruct;
    
    data = -1;
    
    fscanf(stdin, ""%d"", &data);
    myStruct.structFirst = data;
"
620,0,CWE190_Integer_Overflow__int_max_postinc_51a.c,"    int data;
    
    data = 0;
    
    data = INT_MAX;
"
4702,0,CWE401_Memory_Leak__new_array_int64_t_18.cpp,"    int64_t * data;
    data = NULL;
    goto source;
source:
    
    data = new int64_t[100];
    
    data[0] = 5LL;
    printLongLongLine(data[0]);
    goto sink;
sink:
    
"
7834,0,CWE401_Memory_Leak__new_int64_t_09.cpp,"    int64_t * data;
    data = NULL;
    if(GLOBAL_CONST_TRUE)
    {
        
        data = new int64_t;
        
        *data = 5LL;
        printLongLongLine(*data);
    }
    if(GLOBAL_CONST_TRUE)
    {
        
        ; 
"
15759,0,CWE401_Memory_Leak__new_twoIntsStruct_51a.cpp,"    twoIntsStruct * data;
    data = NULL;
    
    data = new twoIntsStruct;
    
    data->intOne = 0;
    data->intTwo = 0;
    printStructLine(data);
"
18788,0,CWE190_Integer_Overflow__int_fscanf_postinc_11.c,"    int data;
    
    data = 0;
    if(globalReturnsTrue())
    {
        
        fscanf(stdin, ""%d"", &data);
    }
    if(globalReturnsTrue())
    {
        {
            
            data++;
            int result = data;
            printIntLine(result);
        }
"
9034,0,CWE415_Double_Free__new_delete_array_long_09.cpp,"    long * data;
    
    data = NULL;
    if(GLOBAL_CONST_TRUE)
    {
        data = new long[100];
        
        delete [] data;
    }
    if(GLOBAL_CONST_TRUE)
    {
        
        delete [] data;
"
11333,0,CWE690_NULL_Deref_From_Return__int_realloc_65a.c,"    int * data;
    
    void (*funcPtr) (int *) = CWE690_NULL_Deref_From_Return__int_realloc_65b_badSink;
    data = NULL; 
    
    data = (int *)realloc(data, 1*sizeof(int));
    
"
10029,1,CWE758_Undefined_Behavior__int_pointer_malloc_use_13.c,"    if(GLOBAL_CONST_FIVE==5)
    {
        {
            int * data;
            int * * pointer = (int * *)malloc(sizeof(int *));
            if (pointer == NULL) {exit(-1);}
            
            data = (int *)malloc(sizeof(int));
            if (data == NULL) {exit(-1);}
            *data = 5;
            *pointer = data; 
            {
                int * data = *pointer;
                printIntLine(*data);
            }
            free(pointer);
        }
"
4676,0,CWE252_Unchecked_Return_Value__char_fprintf_18.c,"    goto sink;
sink:
    
"
4446,0,CWE134_Uncontrolled_Format_String__char_console_snprintf_83_bad.cpp,"Label Definition File: CWE134_Uncontrolled_Format_String.label.xml
Template File: sources-sinks-83_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 134 Uncontrolled Format String
 * BadSource: console Read input from the console
 * GoodSource: Copy a fixed string into data
 * Sinks: snprintf
 *    GoodSink: snprintf with ""%s"" as the third argument and data as the fourth
 *    BadSink : snprintf with data as the third argument
 * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE134_Uncontrolled_Format_String__char_console_snprintf_83.h""

#ifdef _WIN32
#define SNPRINTF _snprintf
#else
#define SNPRINTF snprintf
#endif

namespace CWE134_Uncontrolled_Format_String__char_console_snprintf_83
{
CWE134_Uncontrolled_Format_String__char_console_snprintf_83_bad::CWE134_Uncontrolled_Format_String__char_console_snprintf_83_bad(char * dataCopy)
{
    data = dataCopy;
    {
        
        size_t dataLen = strlen(data);
        
        if (100-dataLen > 1)
        {
            
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgets() */
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
                    data[dataLen-1] = '\0';
                }
            }
            else
            {
                printLine(""fgets() failed"");
                
                data[dataLen] = '\0';
            }
        }
    }
}

CWE134_Uncontrolled_Format_String__char_console_snprintf_83_bad::~CWE134_Uncontrolled_Format_String__char_console_snprintf_83_bad()
{
    {
        char dest[100] = """";
        
        SNPRINTF(dest, 100-1, data);
        printLine(dest);
    }
}
}
"
4433,1,CWE252_Unchecked_Return_Value__char_fprintf_09.c,"    if(GLOBAL_CONST_TRUE)
    {
        
        if (fprintf(stdout, ""%s\n"", ""string"") < 0)
        {
            printLine(""fprintf failed!"");
        }
"
2913,0,CWE457_Use_of_Uninitialized_Variable__struct_04.c,"    twoIntsStruct data;
    if(STATIC_CONST_TRUE)
    {
        
        ; 
    }
    if(STATIC_CONST_TRUE)
    {
        
        printIntLine(data.intOne);
        printIntLine(data.intTwo);
"
1387,0,CWE401_Memory_Leak__new_twoIntsStruct_54a.cpp,"    twoIntsStruct * data;
    data = NULL;
    
    data = new twoIntsStruct;
    
    data->intOne = 0;
    data->intTwo = 0;
    printStructLine(data);
"
18605,0,CWE197_Numeric_Truncation_Error__int_rand_to_char_32.c,"    int data;
    int *dataPtr1 = &data;
    int *dataPtr2 = &data;
    
    data = -1;
    {
        int data = *dataPtr1;
        
        data = RAND32();
        *dataPtr1 = data;
    }
    {
        int data = *dataPtr2;
        {
            
            char charData = (char)data;
            printHexCharLine(charData);
        }
"
14914,0,CWE190_Integer_Overflow__short_fscanf_add_84a.cpp,"    short data;
    data = 0;
    CWE190_Integer_Overflow__short_fscanf_add_84_bad * badObject = new CWE190_Integer_Overflow__short_fscanf_add_84_bad(data);
"
4954,0,CWE369_Divide_by_Zero__int_connect_socket_divide_68a.c,"    int data;
    
    data = -1;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    CWE369_Divide_by_Zero__int_connect_socket_divide_68_badData = data;
"
9950,0,CWE476_NULL_Pointer_Dereference__class_01.cpp,"    TwoIntsClass * data;
    
    data = NULL;
    
    printIntLine(data->intOne);
    
"
2958,0,CWE401_Memory_Leak__twoIntsStruct_calloc_84_bad.cpp,"Label Definition File: CWE401_Memory_Leak.c.label.xml
Template File: sources-sinks-84_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 401 Memory Leak
 * BadSource: calloc Allocate data using calloc()
 * GoodSource: Allocate data on the stack
 * Sinks:
 *    GoodSink: call free() on data
 *    BadSink : no deallocation of data
 * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE401_Memory_Leak__twoIntsStruct_calloc_84.h""

namespace CWE401_Memory_Leak__twoIntsStruct_calloc_84
{
CWE401_Memory_Leak__twoIntsStruct_calloc_84_bad::CWE401_Memory_Leak__twoIntsStruct_calloc_84_bad(twoIntsStruct * dataCopy)
{
    data = dataCopy;
    
    data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));
    if (data == NULL) {exit(-1);}
    
    data[0].intOne = 0;
    data[0].intTwo = 0;
    printStructLine(&data[0]);
}

CWE401_Memory_Leak__twoIntsStruct_calloc_84_bad::~CWE401_Memory_Leak__twoIntsStruct_calloc_84_bad()
{
    
    ; 
}
}
"
422,0,CWE190_Integer_Overflow__short_rand_multiply_21.c,"    short data;
    data = 0;
    
    data = (short)RAND32();
    badStatic = 1; 
"
2121,0,CWE134_Uncontrolled_Format_String__char_environment_snprintf_51a.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        
        if (environment != NULL)
        {
            
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
"
2742,0,CWE134_Uncontrolled_Format_String__char_environment_printf_09.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(GLOBAL_CONST_TRUE)
    {
        {
            
            size_t dataLen = strlen(data);
            char * environment = GETENV(ENV_VARIABLE);
            
            if (environment != NULL)
            {
                
                strncat(data+dataLen, environment, 100-dataLen-1);
            }
        }
    }
    if(GLOBAL_CONST_TRUE)
    {
        
        printf(data);
"
14747,0,CWE590_Free_Memory_Not_on_Heap__delete_array_struct_alloca_66a.cpp,"    twoIntsStruct * data;
    twoIntsStruct * dataArray[5];
    data = NULL; 
    {
        
        twoIntsStruct * dataBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i].intOne = 1;
                dataBuffer[i].intTwo = 1;
            }
        }
        data = dataBuffer;
    }
    
    dataArray[2] = data;
"
4508,0,CWE369_Divide_by_Zero__int_fscanf_divide_41.c,"    int data;
    
    data = -1;
    
    fscanf(stdin, ""%d"", &data);
"
566,1,CWE467_Use_of_sizeof_on_Pointer_Type__int_02.c,"    if(0)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            int * goodInt = NULL;
            
            goodInt = (int *)malloc(sizeof(*goodInt));
            if (goodInt == NULL) {exit(-1);}
            *goodInt = 6;
            printIntLine(*goodInt);
            free(goodInt);
        }
"
3972,0,CWE563_Unused_Variable__unused_uninit_variable_int_83_bad.cpp,"Label Definition File: CWE563_Unused_Variable__unused_uninit_variable.label.xml
Template File: source-sinks-83_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 563 Unused Variable
 * BadSource:  Initialize data
 * Sinks:
 *    GoodSink: Initialize, then use data
 *    BadSink : Do nothing
 * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE563_Unused_Variable__unused_uninit_variable_int_83.h""

namespace CWE563_Unused_Variable__unused_uninit_variable_int_83
{
CWE563_Unused_Variable__unused_uninit_variable_int_83_bad::CWE563_Unused_Variable__unused_uninit_variable_int_83_bad(int dataCopy)
{
    data = dataCopy;
    
    ; 
}

CWE563_Unused_Variable__unused_uninit_variable_int_83_bad::~CWE563_Unused_Variable__unused_uninit_variable_int_83_bad()
{
    
    
    ; 
}
}
"
7788,0,CWE457_Use_of_Uninitialized_Variable__int_01.c,"    int data;
    
    ; 
    
"
7158,0,CWE401_Memory_Leak__malloc_realloc_struct_twoIntsStruct_18.c,"    goto sink;
sink:
    {
        struct _twoIntsStruct * data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));
        if (data == NULL) {exit(-1);}
        
        data[0].intOne = 0;
        data[0].intTwo = 0;
        printStructLine((twoIntsStruct *)&data[0]);
        
        data = (struct _twoIntsStruct *)realloc(data, (130000)*sizeof(struct _twoIntsStruct));
        if (data != NULL)
        {
            
            data[0].intOne = 1;
            data[0].intTwo = 1;
            printStructLine((twoIntsStruct *)&data[0]);
            free(data);
        }
"
4961,0,CWE190_Integer_Overflow__int_max_multiply_22a.c,"    int data;
    
    data = 0;
    
    data = INT_MAX;
    CWE190_Integer_Overflow__int_max_multiply_22_badGlobal = 1; 
"
2400,0,CWE590_Free_Memory_Not_on_Heap__delete_array_struct_declare_08.cpp,"    twoIntsStruct * data;
    data = NULL; 
    if(staticReturnsTrue())
    {
        {
            
            twoIntsStruct dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i].intOne = 1;
                    dataBuffer[i].intTwo = 1;
                }
            }
            data = dataBuffer;
        }
    }
    printStructLine(&data[0]);
    
"
17645,0,CWE401_Memory_Leak__char_malloc_52a.c,"    char * data;
    data = NULL;
    
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    
    strcpy(data, ""A String"");
    printLine(data);
"
1443,0,CWE190_Integer_Overflow__unsigned_int_rand_preinc_44.c,"    unsigned int data;
    
    void (*funcPtr) (unsigned int) = badSink;
    data = 0;
    
    data = (unsigned int)RAND32();
    
"
8864,0,CWE590_Free_Memory_Not_on_Heap__delete_array_struct_declare_13.cpp,"    twoIntsStruct * data;
    data = NULL; 
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            
            twoIntsStruct dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i].intOne = 1;
                    dataBuffer[i].intTwo = 1;
                }
            }
            data = dataBuffer;
        }
    }
    printStructLine(&data[0]);
    
"
2017,1,CWE467_Use_of_sizeof_on_Pointer_Type__char_04.c,"    if(STATIC_CONST_FALSE)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            char * goodChar = NULL;
            
            goodChar = (char *)malloc(sizeof(*goodChar));
            if (goodChar == NULL) {exit(-1);}
            *goodChar = 'G';
            printHexCharLine(*goodChar);
            free(goodChar);
        }
"
77,0,CWE590_Free_Memory_Not_on_Heap__delete_array_class_alloca_66a.cpp,"    TwoIntsClass * data;
    TwoIntsClass * dataArray[5];
    data = NULL; 
    {
        
        TwoIntsClass * dataBuffer = (TwoIntsClass *)ALLOCA(100*sizeof(TwoIntsClass));
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i].intOne = 1;
                dataBuffer[i].intTwo = 1;
            }
        }
        data = dataBuffer;
    }
    
    dataArray[2] = data;
"
15875,0,CWE590_Free_Memory_Not_on_Heap__free_char_declare_82a.cpp,"    char * data;
    data = NULL; 
    {
        
        char dataBuffer[100];
        memset(dataBuffer, 'A', 100-1); 
        dataBuffer[100-1] = '\0'; 
        data = dataBuffer;
    }
    CWE590_Free_Memory_Not_on_Heap__free_char_declare_82_base* baseObject = new CWE590_Free_Memory_Not_on_Heap__free_char_declare_82_bad;
    baseObject->action(data);
"
1883,0,CWE590_Free_Memory_Not_on_Heap__free_struct_static_53a.c,"    twoIntsStruct * data;
    data = NULL; 
    {
        
        static twoIntsStruct dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i].intOne = 1;
                dataBuffer[i].intTwo = 1;
            }
        }
        data = dataBuffer;
    }
"
2200,0,CWE190_Integer_Overflow__int_listen_socket_square_81_bad.cpp,"Label Definition File: CWE190_Integer_Overflow__int.label.xml
Template File: sources-sinks-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 190 Integer Overflow
 * BadSource: listen_socket Read data using a listen socket (server side)
 * GoodSource: Set data to a small, non-zero number (two)
 * Sinks: square
 *    GoodSink: Ensure there will not be an overflow before squaring data
 *    BadSink : Square data, which can lead to overflow
 * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE190_Integer_Overflow__int_listen_socket_square_81.h""

#include <math.h>

namespace CWE190_Integer_Overflow__int_listen_socket_square_81
{

void CWE190_Integer_Overflow__int_listen_socket_square_81_bad::action(int data) const
{
    {
        
        int result = data * data;
        printIntLine(result);
    }
}

}
"
10707,0,CWE190_Integer_Overflow__int_max_postinc_67a.c,"    int data;
    CWE190_Integer_Overflow__int_max_postinc_67_structType myStruct;
    
    data = 0;
    
    data = INT_MAX;
    myStruct.structFirst = data;
"
2609,0,CWE590_Free_Memory_Not_on_Heap__delete_array_long_declare_54a.cpp,"    long * data;
    data = NULL; 
    {
        
        long dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5L;
            }
        }
        data = dataBuffer;
    }
"
3420,0,CWE563_Unused_Variable__unused_init_variable_int_06.c,"    int data;
    
    data = 5;
    if(STATIC_CONST_FIVE==5)
    {
        
        
        ; 
"
13767,0,CWE190_Integer_Overflow__char_max_multiply_21.c,"    char data;
    data = ' ';
    
    data = CHAR_MAX;
    badStatic = 1; 
"
10153,0,CWE190_Integer_Overflow__char_fscanf_square_12.c,"    char data;
    data = ' ';
    if(globalReturnsTrueOrFalse())
    {
        
        fscanf (stdin, ""%c"", &data);
    }
    else
    {
        
        data = 2;
    }
    if(globalReturnsTrueOrFalse())
    {
        {
            
            char result = data * data;
            printHexCharLine(result);
        }
    }
    else
    {
        
        if (abs((long)data) <= (long)sqrt((double)CHAR_MAX))
        {
            char result = data * data;
            printHexCharLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
"
4557,0,CWE190_Integer_Overflow__short_fscanf_square_52a.c,"    short data;
    data = 0;
    
    fscanf (stdin, ""%hd"", &data);
"
19210,0,CWE457_Use_of_Uninitialized_Variable__double_array_declare_partial_init_05.c,"    double * data;
    double dataUninitArray[10];
    data = dataUninitArray;
    if(staticTrue)
    {
        
        {
            int i;
            for(i=0; i<(10/2); i++)
            {
                data[i] = (double)i;
            }
        }
    }
    if(staticTrue)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printDoubleLine(data[i]);
            }
        }
"
7341,0,CWE78_OS_Command_Injection__char_environment_popen_44.c,"    char * data;
    
    void (*funcPtr) (char *) = badSink;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
        
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        
        if (environment != NULL)
        {
            
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    
"
9302,0,CWE563_Unused_Variable__unused_uninit_variable_long_14.c,"    long data;
    
    ; 
    if(globalFive==5)
    {
        
        
        ; 
"
12768,0,CWE197_Numeric_Truncation_Error__short_connect_socket_63a.c,"    short data;
    
    data = -1;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = (short)atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
2651,0,CWE690_NULL_Deref_From_Return__int_calloc_61a.c,"    int * data;
    data = NULL; 
    data = CWE690_NULL_Deref_From_Return__int_calloc_61b_badSource(data);
    
    data[0] = 5;
    printIntLine(data[0]);
"
7687,0,CWE190_Integer_Overflow__char_max_multiply_17.c,"    int i,j;
    char data;
    data = ' ';
    for(i = 0; i < 1; i++)
    {
        
        data = CHAR_MAX;
    }
    for(j = 0; j < 1; j++)
    {
        if(data > 0) 
        {
            
            char result = data * 2;
            printHexCharLine(result);
        }
"
7972,0,CWE190_Integer_Overflow__int64_t_rand_square_14.c,"    int64_t data;
    data = 0LL;
    if(globalFive==5)
    {
        
        data = (int64_t)RAND64();
    }
    if(globalFive==5)
    {
        {
            
            int64_t result = data * data;
            printLongLongLine(result);
        }
"
8791,0,CWE134_Uncontrolled_Format_String__char_connect_socket_printf_52a.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
10382,0,CWE197_Numeric_Truncation_Error__short_fscanf_15.c,"    short data;
    
    data = -1;
    switch(6)
    {
    case 6:
        
        fscanf (stdin, ""%hd"", &data);
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
13988,1,CWE758_Undefined_Behavior__int_alloca_use_14.c,"    if(globalFive!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            int data;
            int * pointer = (int *)ALLOCA(sizeof(int));
            data = 5;
            *pointer = data; 
            {
                int data = *pointer;
                printIntLine(data);
            }
        }
"
17516,0,CWE190_Integer_Overflow__int64_t_fscanf_square_01.c,"    int64_t data;
    data = 0LL;
    
    fscanf (stdin, ""%"" SCNd64, &data);
    {
        
        int64_t result = data * data;
        printLongLongLine(result);
"
4191,0,CWE401_Memory_Leak__new_char_54a.cpp,"    char * data;
    data = NULL;
    
    data = new char;
    
    *data = 'A';
    printHexCharLine(*data);
"
12656,0,CWE415_Double_Free__new_delete_array_long_10.cpp,"    long * data;
    
    data = NULL;
    if(globalTrue)
    {
        data = new long[100];
        
        delete [] data;
    }
    if(globalTrue)
    {
        
        delete [] data;
"
2204,1,CWE758_Undefined_Behavior__struct_malloc_use_08.c,"    if(staticReturnsTrue())
    {
        {
            twoIntsStruct data;
            twoIntsStruct * pointer = (twoIntsStruct *)malloc(sizeof(twoIntsStruct));
            if (pointer == NULL) {exit(-1);}
            data.intOne = 1;
            data.intTwo = 2;
            *pointer = data; 
            {
                twoIntsStruct data = *pointer;
                printIntLine(data.intOne);
                printIntLine(data.intTwo);
            }
            free(pointer);
        }
"
10932,0,CWE190_Integer_Overflow__char_max_preinc_08.c,"    char data;
    data = ' ';
    if(staticReturnsTrue())
    {
        
        data = CHAR_MAX;
    }
    if(staticReturnsTrue())
    {
        {
            
            ++data;
            char result = data;
            printHexCharLine(result);
        }
"
19374,0,CWE758_Undefined_Behavior__int_alloca_use_12.c,"    if(globalReturnsTrueOrFalse())
    {
        {
            int * pointer = (int *)ALLOCA(sizeof(int));
            int data = *pointer; 
            printIntLine(data);
        }
    }
    else
    {
        {
            int data;
            int * pointer = (int *)ALLOCA(sizeof(int));
            data = 5;
            *pointer = data; 
            {
                int data = *pointer;
                printIntLine(data);
            }
        }
"
8439,1,CWE758_Undefined_Behavior__double_pointer_new_use_08.cpp,"    if(staticReturnsFalse())
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            double * data;
            
            data = new double;
            *data = 5.0;
            double * * pointer = new double *;
            *pointer = data; 
            {
                double * data = *pointer;
                printDoubleLine(*data);
            }
            delete pointer;
        }
"
18190,0,CWE401_Memory_Leak__new_array_int64_t_03.cpp,"    int64_t * data;
    data = NULL;
    if(5==5)
    {
        
        data = new int64_t[100];
        
        data[0] = 5LL;
        printLongLongLine(data[0]);
    }
    if(5==5)
    {
        
        ; 
"
14967,0,CWE190_Integer_Overflow__int64_t_fscanf_add_21.c,"    int64_t data;
    data = 0LL;
    
    fscanf (stdin, ""%"" SCNd64, &data);
    badStatic = 1; 
"
3584,0,CWE190_Integer_Overflow__int_connect_socket_add_21.c,"    int data;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    badStatic = 1; 
"
7898,0,CWE190_Integer_Overflow__int_rand_square_22a.c,"    int data;
    
    data = 0;
    
    data = RAND32();
    CWE190_Integer_Overflow__int_rand_square_22_badGlobal = 1; 
"
12457,0,CWE197_Numeric_Truncation_Error__int_large_to_char_73a.cpp,"    int data;
    list<int> dataList;
    
    data = -1;
    
    data = SHRT_MAX + 5;
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
16305,0,CWE190_Integer_Overflow__unsigned_int_fscanf_add_11.c,"    unsigned int data;
    data = 0;
    if(globalReturnsTrue())
    {
        
        fscanf (stdin, ""%u"", &data);
    }
    if(globalReturnsTrue())
    {
        {
            
            unsigned int result = data + 1;
            printUnsignedLine(result);
        }
"
758,0,CWE190_Integer_Overflow__int64_t_rand_square_01.c,"    int64_t data;
    data = 0LL;
    
    data = (int64_t)RAND64();
    {
        
        int64_t result = data * data;
        printLongLongLine(result);
"
18322,0,CWE590_Free_Memory_Not_on_Heap__delete_char_static_72a.cpp,"    char * data;
    vector<char *> dataVector;
    data = NULL; 
    {
        
        static char dataBuffer;
        dataBuffer = 'A';
        data = &dataBuffer;
    }
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
3084,0,CWE190_Integer_Overflow__int_connect_socket_preinc_03.c,"    int data;
    
    data = 0;
    if(5==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(5==5)
    {
        {
            
            ++data;
            int result = data;
            printIntLine(result);
        }
"
8636,0,CWE197_Numeric_Truncation_Error__short_connect_socket_13.c,"    short data;
    
    data = -1;
    if(GLOBAL_CONST_FIVE==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = (short)atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
13285,0,CWE690_NULL_Deref_From_Return__long_realloc_04.c,"    long * data;
    data = NULL; 
    
    data = (long *)realloc(data, 1*sizeof(long));
    if(STATIC_CONST_TRUE)
    {
        
        data[0] = 5L;
        printLongLine(data[0]);
        free(data);
"
10669,0,CWE590_Free_Memory_Not_on_Heap__delete_array_struct_declare_32.cpp,"    twoIntsStruct * data;
    twoIntsStruct * *dataPtr1 = &data;
    twoIntsStruct * *dataPtr2 = &data;
    data = NULL; 
    {
        twoIntsStruct * data = *dataPtr1;
        {
            
            twoIntsStruct dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i].intOne = 1;
                    dataBuffer[i].intTwo = 1;
                }
            }
            data = dataBuffer;
        }
        *dataPtr1 = data;
    }
    {
        twoIntsStruct * data = *dataPtr2;
        printStructLine(&data[0]);
        
        delete [] data;
"
1524,0,CWE590_Free_Memory_Not_on_Heap__delete_array_long_alloca_68a.cpp,"    long * data;
    data = NULL; 
    {
        
        long * dataBuffer = (long *)ALLOCA(100*sizeof(long));
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5L;
            }
        }
        data = dataBuffer;
    }
    CWE590_Free_Memory_Not_on_Heap__delete_array_long_alloca_68_badData = data;
"
17400,0,CWE590_Free_Memory_Not_on_Heap__delete_array_char_alloca_51a.cpp,"    char * data;
    data = NULL; 
    {
        
        char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
        memset(dataBuffer, 'A', 100-1); 
        dataBuffer[100-1] = '\0'; 
        data = dataBuffer;
    }
"
7855,0,CWE369_Divide_by_Zero__int_zero_divide_11.c,"    int data;
    
    data = -1;
    if(globalReturnsTrue())
    {
        
        data = 0;
    }
    if(globalReturnsTrue())
    {
        
        printIntLine(100 / data);
"
1365,1,CWE252_Unchecked_Return_Value__char_rename_10.c,"    if(globalTrue)
    {
        
        if (RENAME(OLD_GOOD_FILE_NAME, ""newgoodfilename.txt"") != 0)
        {
            printLine(""rename failed!"");
        }
"
9735,0,CWE190_Integer_Overflow__int_rand_preinc_42.c,"    int data;
    
    data = 0;
    data = badSource(data);
    {
        
        ++data;
        int result = data;
        printIntLine(result);
"
1584,0,CWE590_Free_Memory_Not_on_Heap__delete_array_char_static_81a.cpp,"    char * data;
    data = NULL; 
    {
        
        static char dataBuffer[100];
        memset(dataBuffer, 'A', 100-1); 
        dataBuffer[100-1] = '\0'; 
        data = dataBuffer;
    }
    const CWE590_Free_Memory_Not_on_Heap__delete_array_char_static_81_base& baseObject = CWE590_Free_Memory_Not_on_Heap__delete_array_char_static_81_bad();
"
5715,0,CWE590_Free_Memory_Not_on_Heap__free_long_declare_04.c,"    long * data;
    data = NULL; 
    if(STATIC_CONST_TRUE)
    {
        {
            
            long dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5L;
                }
            }
            data = dataBuffer;
        }
    }
    printLongLine(data[0]);
    
"
4085,0,CWE401_Memory_Leak__strdup_char_81_bad.cpp,"Label Definition File: CWE401_Memory_Leak__strdup.label.xml
Template File: sources-sinks-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 401 Memory Leak
 * BadSource:  Allocate data using strdup()
 * GoodSource: Allocate data on the stack
 * Sinks:
 *    GoodSink: call free() on data
 *    BadSink : no deallocation of data
 * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE401_Memory_Leak__strdup_char_81.h""

namespace CWE401_Memory_Leak__strdup_char_81
{

void CWE401_Memory_Leak__strdup_char_81_bad::action(char * data) const
{
    
    
    ; 
}

}
"
14646,0,CWE789_Uncontrolled_Mem_Alloc__new_char_connect_socket_31.cpp,"    size_t data;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = strtoul(inputBuffer, NULL, 0);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    {
        size_t dataCopy = data;
        size_t data = dataCopy;
        {
            char * myString;
            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
             * for the strcpy() function to not cause a buffer overflow */
            
            if (data > strlen(HELLO_STRING))
            {
                myString = new char[data];
                
                strcpy(myString, HELLO_STRING);
                printLine(myString);
                delete [] myString;
            }
            else
            {
                printLine(""Input is less than the length of the source string"");
            }
        }
"
10095,0,CWE415_Double_Free__new_delete_class_08.cpp,"    TwoIntsClass * data;
    
    data = NULL;
    if(staticReturnsTrue())
    {
        data = new TwoIntsClass;
        
        delete data;
    }
    if(staticReturnsTrue())
    {
        
        delete data;
"
8495,1,CWE587_Assignment_of_Fixed_Address_to_Pointer__basic_04.c,"    if(STATIC_CONST_TRUE)
    {
        {
            
            char charStack = 'a';
            char *charPointer = &charStack;
            printHexCharLine(*charPointer);
        }
"
9774,1,CWE676_Use_of_Potentially_Dangerous_Function__basic_02.cpp,"    if(0)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            char charBuffer[CHAR_BUFFER_SIZE];
            
            cin.width(CHAR_BUFFER_SIZE);
            cin >> charBuffer;
            charBuffer[CHAR_BUFFER_SIZE-1] = '\0';
            printLine(charBuffer);
        }
"
13116,0,CWE690_NULL_Deref_From_Return__long_calloc_82a.cpp,"    long * data;
    data = NULL; 
    
    data = (long *)calloc(1, sizeof(long));
    CWE690_NULL_Deref_From_Return__long_calloc_82_base* baseObject = new CWE690_NULL_Deref_From_Return__long_calloc_82_bad;
    baseObject->action(data);
"
19430,1,CWE758_Undefined_Behavior__int64_t_malloc_use_10.c,"    if(globalFalse)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            int64_t data;
            int64_t * pointer = (int64_t *)malloc(sizeof(int64_t));
            if (pointer == NULL) {exit(-1);}
            data = 5LL;
            *pointer = data; 
            {
                int64_t data = *pointer;
                printLongLongLine(data);
            }
            free(pointer);
        }
"
1252,0,CWE590_Free_Memory_Not_on_Heap__delete_int_declare_65a.cpp,"    int * data;
    
    void (*funcPtr) (int *) = badSink;
    data = NULL; 
    {
        
        int dataBuffer;
        dataBuffer = 5;
        data = &dataBuffer;
    }
    
"
3870,0,CWE590_Free_Memory_Not_on_Heap__free_long_declare_82a.cpp,"    long * data;
    data = NULL; 
    {
        
        long dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5L;
            }
        }
        data = dataBuffer;
    }
    CWE590_Free_Memory_Not_on_Heap__free_long_declare_82_base* baseObject = new CWE590_Free_Memory_Not_on_Heap__free_long_declare_82_bad;
    baseObject->action(data);
"
5003,0,CWE78_OS_Command_Injection__char_environment_popen_43.cpp,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    badSource(data);
    {
        FILE *pipe;
        
        pipe = POPEN(data, ""w"");
        if (pipe != NULL)
        {
            PCLOSE(pipe);
        }
"
5682,0,CWE369_Divide_by_Zero__float_listenSocket_18.c,"    float data;
    
    data = 0.0F;
    goto source;
source:
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = (float)atof(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    goto sink;
sink:
    {
        
        int result = (int)(100.0 / data);
        printIntLine(result);
"
13799,0,CWE690_NULL_Deref_From_Return__int_calloc_01.c,"    int * data;
    data = NULL; 
    
    data = (int *)calloc(1, sizeof(int));
    
    data[0] = 5;
    printIntLine(data[0]);
"
15016,0,CWE190_Integer_Overflow__char_max_add_64a.c,"    char data;
    data = ' ';
    
    data = CHAR_MAX;
"
659,0,CWE563_Unused_Variable__unused_uninit_variable_int_73a.cpp,"    int data;
    list<int> dataList;
    
    ; 
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
755,0,CWE415_Double_Free__malloc_free_int_66a.c,"    int * data;
    int * dataArray[5];
    
    data = NULL;
    data = (int *)malloc(100*sizeof(int));
    if (data == NULL) {exit(-1);}
    
    free(data);
    
    dataArray[2] = data;
"
17103,0,CWE457_Use_of_Uninitialized_Variable__twointsclass_array_malloc_no_init_15.cpp,"    TwoIntsClass * data;
    data = reinterpret_cast<TwoIntsClass *>(malloc(10*sizeof(TwoIntsClass)));
    if (data == NULL) {exit(-1);}
    switch(6)
    {
    case 6:
        
        ; 
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
        
        for(int i=0; i<10; i++)
        {
            printIntLine(data[i].intOne);
            printIntLine(data[i].intTwo);
        }
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
10178,0,CWE590_Free_Memory_Not_on_Heap__delete_array_int64_t_alloca_14.cpp,"    int64_t * data;
    data = NULL; 
    if(globalFive==5)
    {
        {
            
            int64_t * dataBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5LL;
                }
            }
            data = dataBuffer;
        }
    }
    printLongLongLine(data[0]);
    
"
15171,0,CWE401_Memory_Leak__malloc_realloc_twoIntsStruct_07.c,"    if(staticFive==5)
    {
        {
            twoIntsStruct * data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
            if (data == NULL) {exit(-1);}
            
            data[0].intOne = 0;
            data[0].intTwo = 0;
            printStructLine(&data[0]);
            
            data = (twoIntsStruct *)realloc(data, (130000)*sizeof(twoIntsStruct));
            if (data != NULL)
            {
                
                data[0].intOne = 1;
                data[0].intTwo = 1;
                printStructLine(&data[0]);
                free(data);
            }
        }
"
71,0,CWE401_Memory_Leak__int_malloc_16.c,"    int * data;
    data = NULL;
    while(1)
    {
        
        data = (int *)malloc(100*sizeof(int));
        if (data == NULL) {exit(-1);}
        
        data[0] = 5;
        printIntLine(data[0]);
        break;
    }
    while(1)
    {
        
        ; 
        break;
"
4677,0,CWE134_Uncontrolled_Format_String__char_file_vfprintf_42.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    data = badSource(data);
"
15320,1,CWE476_NULL_Pointer_Dereference__deref_after_check_13.c,"    if(GLOBAL_CONST_FIVE==5)
    {
        {
            
            int *intPointer = NULL;
            if (intPointer == NULL)
            {
                printLine(""pointer is NULL"");
            }
        }
"
6023,0,CWE190_Integer_Overflow__int64_t_fscanf_multiply_02.c,"    int64_t data;
    data = 0LL;
    if(1)
    {
        
        fscanf (stdin, ""%"" SCNd64, &data);
    }
    if(1)
    {
        if(data > 0) 
        {
            
            int64_t result = data * 2;
            printLongLongLine(result);
        }
"
19507,0,CWE78_OS_Command_Injection__char_connect_socket_execlp_02.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(1)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET connectSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
"
16015,0,CWE190_Integer_Overflow__int_rand_multiply_44.c,"    int data;
    
    void (*funcPtr) (int) = badSink;
    
    data = 0;
    
    data = RAND32();
    
"
14847,0,CWE416_Use_After_Free__new_delete_long_07.cpp,"    long * data;
    
    data = NULL;
    if(staticFive==5)
    {
        data = new long;
        *data = 5L;
        
        delete data;
    }
    if(staticFive==5)
    {
        
        printLongLine(*data);
        
"
19534,0,CWE590_Free_Memory_Not_on_Heap__delete_array_class_declare_53a.cpp,"    TwoIntsClass * data;
    data = NULL; 
    {
        
        TwoIntsClass dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i].intOne = 1;
                dataBuffer[i].intTwo = 1;
            }
        }
        data = dataBuffer;
    }
"
11175,0,CWE789_Uncontrolled_Mem_Alloc__new_char_rand_64a.cpp,"    size_t data;
    
    data = 0;
    
    data = rand();
"
1985,0,CWE369_Divide_by_Zero__int_rand_divide_41.c,"    int data;
    
    data = -1;
    
    data = RAND32();
"
11466,0,CWE134_Uncontrolled_Format_String__char_environment_fprintf_02.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(1)
    {
        {
            
            size_t dataLen = strlen(data);
            char * environment = GETENV(ENV_VARIABLE);
            
            if (environment != NULL)
            {
                
                strncat(data+dataLen, environment, 100-dataLen-1);
            }
        }
    }
    if(1)
    {
        
        fprintf(stdout, data);
"
6392,0,CWE690_NULL_Deref_From_Return__long_realloc_81a.cpp,"    long * data;
    data = NULL; 
    
    data = (long *)realloc(data, 1*sizeof(long));
    const CWE690_NULL_Deref_From_Return__long_realloc_81_base& baseObject = CWE690_NULL_Deref_From_Return__long_realloc_81_bad();
"
11293,1,CWE758_Undefined_Behavior__long_new_use_10.cpp,"    if(globalFalse)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            long data;
            data = 5L;
            long * pointer = new long;
            *pointer = data; 
            {
                long data = *pointer;
                printLongLine(data);
            }
            delete pointer;
        }
"
13142,0,CWE415_Double_Free__malloc_free_int64_t_84a.cpp,"    int64_t * data;
    
    data = NULL;
    CWE415_Double_Free__malloc_free_int64_t_84_bad * badObject = new CWE415_Double_Free__malloc_free_int64_t_84_bad(data);
"
8623,0,CWE590_Free_Memory_Not_on_Heap__delete_int_alloca_82a.cpp,"    int * data;
    data = NULL; 
    {
        
        int * dataBuffer = (int *)ALLOCA(sizeof(int));
        *dataBuffer = 5;
        data = dataBuffer;
    }
    CWE590_Free_Memory_Not_on_Heap__delete_int_alloca_82_base* baseObject = new CWE590_Free_Memory_Not_on_Heap__delete_int_alloca_82_bad;
    baseObject->action(data);
"
11179,0,CWE197_Numeric_Truncation_Error__short_rand_11.c,"    short data;
    
    data = -1;
    if(globalReturnsTrue())
    {
        
        data = (short)RAND32();
    }
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
3054,0,CWE134_Uncontrolled_Format_String__char_console_snprintf_10.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(globalTrue)
    {
        {
            
            size_t dataLen = strlen(data);
            
            if (100-dataLen > 1)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
                {
                    /* The next few lines remove the carriage return from the string that is
                     * inserted by fgets() */
                    dataLen = strlen(data);
                    if (dataLen > 0 && data[dataLen-1] == '\n')
                    {
                        data[dataLen-1] = '\0';
                    }
                }
                else
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
            }
        }
    }
    if(globalTrue)
    {
        {
            char dest[100] = """";
            
            SNPRINTF(dest, 100-1, data);
            printLine(dest);
        }
"
9727,0,CWE190_Integer_Overflow__unsigned_int_max_add_18.c,"    unsigned int data;
    data = 0;
    goto source;
source:
    
    data = UINT_MAX;
    goto sink;
sink:
    {
        
        unsigned int result = data + 1;
        printUnsignedLine(result);
"
5704,0,CWE197_Numeric_Truncation_Error__short_large_17.c,"    int i;
    short data;
    
    data = -1;
    for(i = 0; i < 1; i++)
    {
        
        data = CHAR_MAX + 1;
    }
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
3147,0,CWE78_OS_Command_Injection__char_listen_socket_execl_64a.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
9616,0,CWE252_Unchecked_Return_Value__char_fscanf_08.c,"    if(staticReturnsTrue())
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            
            fscanf(stdin, ""%99s\0"", data);
        }
"
16146,0,CWE590_Free_Memory_Not_on_Heap__delete_array_long_declare_02.cpp,"    long * data;
    data = NULL; 
    if(1)
    {
        {
            
            long dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5L;
                }
            }
            data = dataBuffer;
        }
    }
    printLongLine(data[0]);
    
"
7113,0,CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_74a.cpp,"    char * data;
    map<int, char *> dataMap;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
10510,0,CWE416_Use_After_Free__new_delete_long_05.cpp,"    long * data;
    
    data = NULL;
    if(staticTrue)
    {
        data = new long;
        *data = 5L;
        
        delete data;
    }
    if(staticTrue)
    {
        
        printLongLine(*data);
        
"
7653,0,CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_63a.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
10641,0,CWE415_Double_Free__new_delete_int_07.cpp,"    int * data;
    
    data = NULL;
    if(staticFive==5)
    {
        data = new int;
        
        delete data;
    }
    if(staticFive==5)
    {
        
        delete data;
"
15309,0,CWE690_NULL_Deref_From_Return__char_realloc_52a.c,"    char * data;
    data = NULL; 
    
    data = (char *)realloc(data, 20*sizeof(char));
"
5922,0,CWE369_Divide_by_Zero__int_fscanf_divide_84_bad.cpp,"Label Definition File: CWE369_Divide_by_Zero__int.label.xml
Template File: sources-sinks-84_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 369 Divide by Zero
 * BadSource: fscanf Read data from the console using fscanf()
 * GoodSource: Non-zero
 * Sinks: divide
 *    GoodSink: Check for zero before dividing
 *    BadSink : Divide a constant by data
 * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE369_Divide_by_Zero__int_fscanf_divide_84.h""

namespace CWE369_Divide_by_Zero__int_fscanf_divide_84
{
CWE369_Divide_by_Zero__int_fscanf_divide_84_bad::CWE369_Divide_by_Zero__int_fscanf_divide_84_bad(int dataCopy)
{
    data = dataCopy;
    
    fscanf(stdin, ""%d"", &data);
}

CWE369_Divide_by_Zero__int_fscanf_divide_84_bad::~CWE369_Divide_by_Zero__int_fscanf_divide_84_bad()
{
    
    printIntLine(100 / data);
}
}
"
10102,1,CWE587_Assignment_of_Fixed_Address_to_Pointer__basic_06.c,"    if(STATIC_CONST_FIVE==5)
    {
        {
            
            char charStack = 'a';
            char *charPointer = &charStack;
            printHexCharLine(*charPointer);
        }
"
8057,0,CWE401_Memory_Leak__twoIntsStruct_calloc_05.c,"    twoIntsStruct * data;
    data = NULL;
    if(staticTrue)
    {
        
        data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));
        if (data == NULL) {exit(-1);}
        
        data[0].intOne = 0;
        data[0].intTwo = 0;
        printStructLine(&data[0]);
    }
    if(staticTrue)
    {
        
        ; 
"
15084,0,CWE190_Integer_Overflow__short_fscanf_postinc_13.c,"    short data;
    data = 0;
    if(GLOBAL_CONST_FIVE==5)
    {
        
        fscanf (stdin, ""%hd"", &data);
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            
            data++;
            short result = data;
            printIntLine(result);
        }
"
14131,0,CWE190_Integer_Overflow__int64_t_fscanf_preinc_08.c,"    int64_t data;
    data = 0LL;
    if(staticReturnsTrue())
    {
        
        fscanf (stdin, ""%"" SCNd64, &data);
    }
    if(staticReturnsTrue())
    {
        {
            
            ++data;
            int64_t result = data;
            printLongLongLine(result);
        }
"
6383,0,CWE665_Improper_Initialization__char_ncat_04.c,"    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    if(STATIC_CONST_TRUE)
    {
        
        ; 
    }
    {
        size_t sourceLen;
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        sourceLen = strlen(source);
        
        strncat(data, source, sourceLen);
        printLine(data);
"
16682,0,CWE369_Divide_by_Zero__int_rand_divide_61a.c,"    int data;
    
    data = -1;
    data = CWE369_Divide_by_Zero__int_rand_divide_61b_badSource(data);
    
"
6199,0,CWE134_Uncontrolled_Format_String__char_file_vprintf_31.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        FILE * pFile;
        
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
    {
        char * dataCopy = data;
        char * data = dataCopy;
        badVaSink(data, data);
"
4489,0,CWE457_Use_of_Uninitialized_Variable__long_62a.cpp,"    long data;
    badSource(data);
    
"
12843,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_52a.c,"    size_t data;
    
    data = 0;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = strtoul(inputBuffer, NULL, 0);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
"
12212,0,CWE134_Uncontrolled_Format_String__char_console_fprintf_18.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    goto source;
source:
    {
        
        size_t dataLen = strlen(data);
        
        if (100-dataLen > 1)
        {
            
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgets() */
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
                    data[dataLen-1] = '\0';
                }
            }
            else
            {
                printLine(""fgets() failed"");
                
                data[dataLen] = '\0';
            }
        }
    }
    goto sink;
sink:
    
"
7689,0,CWE457_Use_of_Uninitialized_Variable__int_09.c,"    int data;
    if(GLOBAL_CONST_TRUE)
    {
        
        ; 
    }
    if(GLOBAL_CONST_TRUE)
    {
        
        printIntLine(data);
"
4275,0,CWE197_Numeric_Truncation_Error__int_large_to_short_04.c,"    int data;
    
    data = -1;
    if(STATIC_CONST_TRUE)
    {
        
        data = SHRT_MAX + 5;
    }
    {
        
        short shortData = (short)data;
        printShortLine(shortData);
"
12983,0,CWE690_NULL_Deref_From_Return__fopen_41.c,"    FILE * data;
    
    data = NULL;
    
    data = fopen(""file.txt"", ""w+"");
"
12835,0,CWE190_Integer_Overflow__int_rand_add_15.c,"    int data;
    
    data = 0;
    switch(6)
    {
    case 6:
        
        data = RAND32();
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
    {
        
        int result = data + 1;
        printIntLine(result);
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
13434,0,CWE134_Uncontrolled_Format_String__char_connect_socket_printf_01.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
"
1232,0,CWE401_Memory_Leak__int64_t_realloc_01.c,"    int64_t * data;
    data = NULL;
    
    data = (int64_t *)realloc(data, 100*sizeof(int64_t));
    if (data == NULL) {exit(-1);}
    
    data[0] = 5LL;
    printLongLongLine(data[0]);
    
"
1959,0,CWE590_Free_Memory_Not_on_Heap__delete_class_placement_new_33.cpp,"    TwoIntsClass * data;
    TwoIntsClass * &dataRef = data;
    data = NULL; 
    {
        
        char buffer[sizeof(TwoIntsClass)];
        TwoIntsClass * dataBuffer = new(buffer) TwoIntsClass;
        dataBuffer->intOne = 2;
        dataBuffer->intTwo = 2;
        data = dataBuffer;
    }
    {
        TwoIntsClass * data = dataRef;
        printIntLine(data->intOne);
        
        delete data;
"
9491,0,CWE190_Integer_Overflow__short_max_preinc_04.c,"    short data;
    data = 0;
    if(STATIC_CONST_TRUE)
    {
        
        data = SHRT_MAX;
    }
    if(STATIC_CONST_TRUE)
    {
        {
            
            ++data;
            short result = data;
            printIntLine(result);
        }
"
18173,0,CWE252_Unchecked_Return_Value__char_fputs_08.c,"    if(staticReturnsTrue())
    {
        
        fputs(""string"", stdout);
"
1114,0,CWE789_Uncontrolled_Mem_Alloc__new_char_rand_62a.cpp,"    size_t data;
    
    data = 0;
    badSource(data);
    {
        char * myString;
        /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
         * for the strcpy() function to not cause a buffer overflow */
        
        if (data > strlen(HELLO_STRING))
        {
            myString = new char[data];
            
            strcpy(myString, HELLO_STRING);
            printLine(myString);
            delete [] myString;
        }
        else
        {
            printLine(""Input is less than the length of the source string"");
        }
"
12644,0,CWE401_Memory_Leak__char_malloc_84_bad.cpp,"Label Definition File: CWE401_Memory_Leak.c.label.xml
Template File: sources-sinks-84_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 401 Memory Leak
 * BadSource: malloc Allocate data using malloc()
 * GoodSource: Allocate data on the stack
 * Sinks:
 *    GoodSink: call free() on data
 *    BadSink : no deallocation of data
 * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE401_Memory_Leak__char_malloc_84.h""

namespace CWE401_Memory_Leak__char_malloc_84
{
CWE401_Memory_Leak__char_malloc_84_bad::CWE401_Memory_Leak__char_malloc_84_bad(char * dataCopy)
{
    data = dataCopy;
    
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    
    strcpy(data, ""A String"");
    printLine(data);
}

CWE401_Memory_Leak__char_malloc_84_bad::~CWE401_Memory_Leak__char_malloc_84_bad()
{
    
    ; 
}
}
"
7736,1,CWE401_Memory_Leak__malloc_realloc_struct_twoIntsStruct_09.c,"    if(GLOBAL_CONST_TRUE)
    {
        {
            struct _twoIntsStruct * data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));
            if (data == NULL) {exit(-1);}
            struct _twoIntsStruct * tmpData;
            
            data[0].intOne = 0;
            data[0].intTwo = 0;
            printStructLine((twoIntsStruct *)&data[0]);
            tmpData = (struct _twoIntsStruct *)realloc(data, (130000)*sizeof(struct _twoIntsStruct));
            /* FIX: Ensure realloc() was successful before assigning data to the memory block
            * allocated with realloc() */
            if (tmpData != NULL)
            {
                data = tmpData;
                
                data[0].intOne = 1;
                data[0].intTwo = 1;
                printStructLine((twoIntsStruct *)&data[0]);
            }
            free(data);
        }
"
6344,0,CWE134_Uncontrolled_Format_String__char_environment_vprintf_17.c,"    int i,j;
    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    for(i = 0; i < 1; i++)
    {
        {
            
            size_t dataLen = strlen(data);
            char * environment = GETENV(ENV_VARIABLE);
            
            if (environment != NULL)
            {
                
                strncat(data+dataLen, environment, 100-dataLen-1);
            }
        }
    }
    for(j = 0; j < 1; j++)
    {
        badVaSinkB(data, data);
"
5899,0,CWE197_Numeric_Truncation_Error__short_connect_socket_09.c,"    short data;
    
    data = -1;
    if(GLOBAL_CONST_TRUE)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = (short)atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
10001,0,CWE590_Free_Memory_Not_on_Heap__delete_class_alloca_82_bad.cpp,"Label Definition File: CWE590_Free_Memory_Not_on_Heap__delete.pointer.label.xml
Template File: sources-sink-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 590 Free Memory Not on Heap
 * BadSource: alloca Data buffer is allocated on the stack with alloca()
 * GoodSource: Allocate memory on the heap
 * Sinks:
 *    BadSink : Print then free data
 * Flow Variant: 82 Data flow: data passed in a parameter to a virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE590_Free_Memory_Not_on_Heap__delete_class_alloca_82.h""

namespace CWE590_Free_Memory_Not_on_Heap__delete_class_alloca_82
{

void CWE590_Free_Memory_Not_on_Heap__delete_class_alloca_82_bad::action(TwoIntsClass * data)
{
    printIntLine(data->intOne);
    
    delete data;
}

}
"
11483,0,CWE457_Use_of_Uninitialized_Variable__new_double_array_partial_init_08.cpp,"    double * data;
    data = new double[10];
    if(staticReturnsTrue())
    {
        
        {
            int i;
            for(i=0; i<(10/2); i++)
            {
                data[i] = (double)i;
            }
        }
    }
    if(staticReturnsTrue())
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printDoubleLine(data[i]);
            }
        }
        
        delete [] data;
"
7230,0,CWE401_Memory_Leak__new_int64_t_22a.cpp,"    int64_t * data;
    data = NULL;
    
    data = new int64_t;
    
    *data = 5LL;
    printLongLongLine(*data);
    badGlobal = 1; 
"
12097,1,CWE758_Undefined_Behavior__char_alloca_use_01.c,"    {
        char data;
        char * pointer = (char *)ALLOCA(sizeof(char));
        data = 5;
        *pointer = data; 
        {
            char data = *pointer;
            printHexCharLine(data);
        }
"
12733,0,CWE590_Free_Memory_Not_on_Heap__free_int_static_51a.c,"    int * data;
    data = NULL; 
    {
        
        static int dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5;
            }
        }
        data = dataBuffer;
    }
"
549,1,CWE252_Unchecked_Return_Value__char_fgets_03.c,"    if(5!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            printLine(""Please enter a string: "");
            
            if (fgets(data, 100, stdin) == NULL)
            {
                printLine(""fgets failed!"");
                exit(1);
            }
            printLine(data);
        }
"
10622,0,CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_66a.c,"    int data;
    int dataArray[5];
    
    data = -1;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
    dataArray[2] = data;
"
5606,0,CWE401_Memory_Leak__new_int_72a.cpp,"    int * data;
    vector<int *> dataVector;
    data = NULL;
    
    data = new int;
    
    *data = 5;
    printIntLine(*data);
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
6464,0,CWE190_Integer_Overflow__int_fgets_square_52a.c,"    int data;
    
    data = 0;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
"
12823,0,CWE190_Integer_Overflow__int_listen_socket_multiply_84_bad.cpp,"Label Definition File: CWE190_Integer_Overflow__int.label.xml
Template File: sources-sinks-84_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 190 Integer Overflow
 * BadSource: listen_socket Read data using a listen socket (server side)
 * GoodSource: Set data to a small, non-zero number (two)
 * Sinks: multiply
 *    GoodSink: Ensure there will not be an overflow before multiplying data by 2
 *    BadSink : If data is positive, multiply by 2, which can cause an overflow
 * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE190_Integer_Overflow__int_listen_socket_multiply_84.h""

#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif

#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)

namespace CWE190_Integer_Overflow__int_listen_socket_multiply_84
{
CWE190_Integer_Overflow__int_listen_socket_multiply_84_bad::CWE190_Integer_Overflow__int_listen_socket_multiply_84_bad(int dataCopy)
{
    data = dataCopy;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
}

CWE190_Integer_Overflow__int_listen_socket_multiply_84_bad::~CWE190_Integer_Overflow__int_listen_socket_multiply_84_bad()
{
    if(data > 0) 
    {
        
        int result = data * 2;
        printIntLine(result);
    }
}
}
"
12131,0,CWE590_Free_Memory_Not_on_Heap__delete_array_int64_t_static_13.cpp,"    int64_t * data;
    data = NULL; 
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            
            static int64_t dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5LL;
                }
            }
            data = dataBuffer;
        }
    }
    printLongLongLine(data[0]);
    
"
12554,0,CWE190_Integer_Overflow__int_fscanf_add_81_bad.cpp,"Label Definition File: CWE190_Integer_Overflow__int.label.xml
Template File: sources-sinks-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 190 Integer Overflow
 * BadSource: fscanf Read data from the console using fscanf()
 * GoodSource: Set data to a small, non-zero number (two)
 * Sinks: add
 *    GoodSink: Ensure there will not be an overflow before adding 1 to data
 *    BadSink : Add 1 to data, which can cause an overflow
 * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE190_Integer_Overflow__int_fscanf_add_81.h""

namespace CWE190_Integer_Overflow__int_fscanf_add_81
{

void CWE190_Integer_Overflow__int_fscanf_add_81_bad::action(int data) const
{
    {
        
        int result = data + 1;
        printIntLine(result);
    }
}

}
"
2452,1,CWE758_Undefined_Behavior__int_pointer_alloca_use_05.c,"    if(staticFalse)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            int * data;
            int * * pointer = (int * *)ALLOCA(sizeof(int *));
            
            data = (int *)malloc(sizeof(int));
            if (data == NULL) {exit(-1);}
            *data = 5;
            *pointer = data; 
            {
                int * data = *pointer;
                printIntLine(*data);
            }
        }
"
12844,1,CWE758_Undefined_Behavior__int64_t_alloca_use_12.c,"    if(globalReturnsTrueOrFalse())
    {
        {
            int64_t data;
            int64_t * pointer = (int64_t *)ALLOCA(sizeof(int64_t));
            data = 5LL;
            *pointer = data; 
            {
                int64_t data = *pointer;
                printLongLongLine(data);
            }
        }
    }
    else
    {
        {
            int64_t data;
            int64_t * pointer = (int64_t *)ALLOCA(sizeof(int64_t));
            data = 5LL;
            *pointer = data; 
            {
                int64_t data = *pointer;
                printLongLongLine(data);
            }
        }
"
11763,0,CWE190_Integer_Overflow__int64_t_fscanf_square_72a.cpp,"    int64_t data;
    vector<int64_t> dataVector;
    data = 0LL;
    
    fscanf (stdin, ""%"" SCNd64, &data);
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
6197,1,CWE252_Unchecked_Return_Value__char_fgets_15.c,"    switch(5)
    {
    case 6:
        
        printLine(""Benign, fixed string"");
        break;
    default:
    {
        /* By initializing dataBuffer, we ensure this will not be the
         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
        char dataBuffer[100] = """";
        char * data = dataBuffer;
        printLine(""Please enter a string: "");
        
        if (fgets(data, 100, stdin) == NULL)
        {
            printLine(""fgets failed!"");
            exit(1);
        }
        printLine(data);
    }
    break;
"
1803,0,CWE190_Integer_Overflow__int64_t_max_add_81_bad.cpp,"Label Definition File: CWE190_Integer_Overflow.label.xml
Template File: sources-sinks-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 190 Integer Overflow
 * BadSource: max Set data to the max value for int64_t
 * GoodSource: Set data to a small, non-zero number (two)
 * Sinks: add
 *    GoodSink: Ensure there will not be an overflow before adding 1 to data
 *    BadSink : Add 1 to data, which can cause an overflow
 * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE190_Integer_Overflow__int64_t_max_add_81.h""

namespace CWE190_Integer_Overflow__int64_t_max_add_81
{

void CWE190_Integer_Overflow__int64_t_max_add_81_bad::action(int64_t data) const
{
    {
        
        int64_t result = data + 1;
        printLongLongLine(result);
    }
}

}
"
319,0,CWE690_NULL_Deref_From_Return__char_malloc_64a.c,"    char * data;
    data = NULL; 
    
    data = (char *)malloc(20*sizeof(char));
"
5758,0,CWE590_Free_Memory_Not_on_Heap__free_struct_alloca_17.c,"    int i;
    twoIntsStruct * data;
    data = NULL; 
    for(i = 0; i < 1; i++)
    {
        {
            
            twoIntsStruct * dataBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i].intOne = 1;
                    dataBuffer[i].intTwo = 1;
                }
            }
            data = dataBuffer;
        }
    }
    printStructLine(&data[0]);
    
"
17089,0,CWE590_Free_Memory_Not_on_Heap__free_long_alloca_65a.c,"    long * data;
    
    void (*funcPtr) (long *) = CWE590_Free_Memory_Not_on_Heap__free_long_alloca_65b_badSink;
    data = NULL; 
    {
        
        long * dataBuffer = (long *)ALLOCA(100*sizeof(long));
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5L;
            }
        }
        data = dataBuffer;
    }
    
"
3254,0,CWE190_Integer_Overflow__int_connect_socket_postinc_12.c,"    int data;
    
    data = 0;
    if(globalReturnsTrueOrFalse())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    else
    {
        
        data = 2;
    }
    if(globalReturnsTrueOrFalse())
    {
        {
            
            data++;
            int result = data;
            printIntLine(result);
        }
    }
    else
    {
        
        if (data < INT_MAX)
        {
            data++;
            int result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
"
955,0,CWE415_Double_Free__new_delete_array_struct_74a.cpp,"    twoIntsStruct * data;
    map<int, twoIntsStruct *> dataMap;
    
    data = NULL;
    data = new twoIntsStruct[100];
    
    delete [] data;
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
9745,0,CWE190_Integer_Overflow__int64_t_max_square_10.c,"    int64_t data;
    data = 0LL;
    if(globalTrue)
    {
        
        data = LLONG_MAX;
    }
    if(globalTrue)
    {
        {
            
            int64_t result = data * data;
            printLongLongLine(result);
        }
"
5001,0,CWE190_Integer_Overflow__int_listen_socket_preinc_03.c,"    int data;
    
    data = 0;
    if(5==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(5==5)
    {
        {
            
            ++data;
            int result = data;
            printIntLine(result);
        }
"
3487,0,CWE190_Integer_Overflow__short_fscanf_preinc_52a.c,"    short data;
    data = 0;
    
    fscanf (stdin, ""%hd"", &data);
"
14978,0,CWE590_Free_Memory_Not_on_Heap__delete_array_long_declare_07.cpp,"    long * data;
    data = NULL; 
    if(staticFive==5)
    {
        {
            
            long dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5L;
                }
            }
            data = dataBuffer;
        }
    }
    printLongLine(data[0]);
    
"
4368,0,CWE416_Use_After_Free__new_delete_struct_03.cpp,"    twoIntsStruct * data;
    
    data = NULL;
    if(5==5)
    {
        data = new twoIntsStruct;
        data->intOne = 1;
        data->intTwo = 2;
        
        delete data;
    }
    if(5==5)
    {
        
        printStructLine(data);
        
"
17592,0,CWE590_Free_Memory_Not_on_Heap__free_long_declare_31.c,"    long * data;
    data = NULL; 
    {
        
        long dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5L;
            }
        }
        data = dataBuffer;
    }
    {
        long * dataCopy = data;
        long * data = dataCopy;
        printLongLine(data[0]);
        
        free(data);
"
10024,0,CWE590_Free_Memory_Not_on_Heap__free_char_static_73a.cpp,"    char * data;
    list<char *> dataList;
    data = NULL; 
    {
        
        static char dataBuffer[100];
        memset(dataBuffer, 'A', 100-1); 
        dataBuffer[100-1] = '\0'; 
        data = dataBuffer;
    }
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
1199,0,CWE476_NULL_Pointer_Dereference__long_12.c,"    long * data;
    long tmpData = 5L;
    if(globalReturnsTrueOrFalse())
    {
        
        data = NULL;
    }
    else
    {
        
        {
            data = &tmpData;
        }
    }
    if(globalReturnsTrueOrFalse())
    {
        
        printLongLine(*data);
    }
    else
    {
        
        if (data != NULL)
        {
            printLongLine(*data);
        }
        else
        {
            printLine(""data is NULL"");
        }
"
8424,0,CWE197_Numeric_Truncation_Error__short_listen_socket_03.c,"    short data;
    
    data = -1;
    if(5==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = (short)atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
18923,0,CWE369_Divide_by_Zero__int_listen_socket_divide_32.c,"    int data;
    int *dataPtr1 = &data;
    int *dataPtr2 = &data;
    
    data = -1;
    {
        int data = *dataPtr1;
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
        *dataPtr1 = data;
    }
    {
        int data = *dataPtr2;
        
        printIntLine(100 / data);
"
8014,0,CWE789_Uncontrolled_Mem_Alloc__new_char_rand_74a.cpp,"    size_t data;
    map<int, size_t> dataMap;
    
    data = 0;
    
    data = rand();
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
15196,0,CWE190_Integer_Overflow__unsigned_int_fscanf_square_02.c,"    unsigned int data;
    data = 0;
    if(1)
    {
        
        fscanf (stdin, ""%u"", &data);
    }
    if(1)
    {
        {
            
            unsigned int result = data * data;
            printUnsignedLine(result);
        }
"
6420,0,CWE590_Free_Memory_Not_on_Heap__delete_array_int64_t_declare_17.cpp,"    int i;
    int64_t * data;
    data = NULL; 
    for(i = 0; i < 1; i++)
    {
        {
            
            int64_t dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5LL;
                }
            }
            data = dataBuffer;
        }
    }
    printLongLongLine(data[0]);
    
"
9332,0,CWE190_Integer_Overflow__int_listen_socket_add_81a.cpp,"    int data;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    const CWE190_Integer_Overflow__int_listen_socket_add_81_base& baseObject = CWE190_Integer_Overflow__int_listen_socket_add_81_bad();
"
4531,0,CWE476_NULL_Pointer_Dereference__char_12.c,"    char * data;
    if(globalReturnsTrueOrFalse())
    {
        
        data = NULL;
    }
    else
    {
        
        data = ""Good"";
    }
    if(globalReturnsTrueOrFalse())
    {
        
        
        printHexCharLine(data[0]);
    }
    else
    {
        
        if (data != NULL)
        {
            
            printHexCharLine(data[0]);
        }
        else
        {
            printLine(""data is NULL"");
        }
"
1291,0,CWE563_Unused_Variable__unused_init_variable_int64_t_11.c,"    int64_t data;
    
    data = 5LL;
    if(globalReturnsTrue())
    {
        
        
        ; 
"
4032,0,CWE665_Improper_Initialization__char_ncat_08.c,"    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    if(staticReturnsTrue())
    {
        
        ; 
    }
    {
        size_t sourceLen;
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        sourceLen = strlen(source);
        
        strncat(data, source, sourceLen);
        printLine(data);
"
14245,0,CWE197_Numeric_Truncation_Error__short_connect_socket_17.c,"    int i;
    short data;
    
    data = -1;
    for(i = 0; i < 1; i++)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = (short)atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
3399,0,CWE690_NULL_Deref_From_Return__int_calloc_42.c,"    int * data;
    data = NULL; 
    data = badSource(data);
    
    data[0] = 5;
    printIntLine(data[0]);
"
4394,0,CWE190_Integer_Overflow__int_fscanf_square_63a.c,"    int data;
    
    data = 0;
    
    fscanf(stdin, ""%d"", &data);
"
11500,0,CWE197_Numeric_Truncation_Error__short_connect_socket_83a.cpp,"    short data;
    
    data = -1;
"
10427,0,CWE457_Use_of_Uninitialized_Variable__struct_array_malloc_partial_init_64a.c,"    twoIntsStruct * data;
    data = (twoIntsStruct *)malloc(10*sizeof(twoIntsStruct));
    if (data == NULL) {exit(-1);}
    
    {
        int i;
        for(i=0; i<(10/2); i++)
        {
            data[i].intOne = i;
            data[i].intTwo = i;
        }
    }
"
3282,0,CWE190_Integer_Overflow__int_fgets_square_83a.cpp,"    int data;
    
    data = 0;
"
3594,0,CWE415_Double_Free__malloc_free_char_32.c,"    char * data;
    char * *dataPtr1 = &data;
    char * *dataPtr2 = &data;
    
    data = NULL;
    {
        char * data = *dataPtr1;
        data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        
        free(data);
        *dataPtr1 = data;
    }
    {
        char * data = *dataPtr2;
        
        free(data);
"
10502,1,CWE758_Undefined_Behavior__struct_pointer_alloca_use_11.c,"    if(globalReturnsTrue())
    {
        {
            twoIntsStruct * data;
            twoIntsStruct * * pointer = (twoIntsStruct * *)ALLOCA(sizeof(twoIntsStruct *));
            
            data = (twoIntsStruct *)malloc(sizeof(twoIntsStruct));
            if (data == NULL) {exit(-1);}
            data->intOne = 5;
            data->intTwo = 6;
            *pointer = data; 
            {
                twoIntsStruct * data = *pointer;
                printIntLine(data->intOne);
                printIntLine(data->intTwo);
            }
        }
"
3738,0,CWE134_Uncontrolled_Format_String__char_console_vfprintf_17.c,"    int i,j;
    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    for(i = 0; i < 1; i++)
    {
        {
            
            size_t dataLen = strlen(data);
            
            if (100-dataLen > 1)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
                {
                    /* The next few lines remove the carriage return from the string that is
                     * inserted by fgets() */
                    dataLen = strlen(data);
                    if (dataLen > 0 && data[dataLen-1] == '\n')
                    {
                        data[dataLen-1] = '\0';
                    }
                }
                else
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
            }
        }
    }
    for(j = 0; j < 1; j++)
    {
        badVaSinkB(data, data);
"
11601,0,CWE190_Integer_Overflow__int_max_postinc_53a.c,"    int data;
    
    data = 0;
    
    data = INT_MAX;
"
1893,0,CWE369_Divide_by_Zero__int_connect_socket_divide_34.c,"    int data;
    CWE369_Divide_by_Zero__int_connect_socket_divide_34_unionType myUnion;
    
    data = -1;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    myUnion.unionFirst = data;
    {
        int data = myUnion.unionSecond;
        
        printIntLine(100 / data);
"
10080,0,CWE401_Memory_Leak__new_struct_twoIntsStruct_01.cpp,"    struct _twoIntsStruct * data;
    data = NULL;
    
    data = new struct _twoIntsStruct;
    
    data->intOne = 0;
    data->intTwo = 0;
    printStructLine((twoIntsStruct *)data);
    
"
12599,0,CWE134_Uncontrolled_Format_String__char_console_fprintf_22a.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        
        if (100-dataLen > 1)
        {
            
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgets() */
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
                    data[dataLen-1] = '\0';
                }
            }
            else
            {
                printLine(""fgets() failed"");
                
                data[dataLen] = '\0';
            }
        }
    }
    CWE134_Uncontrolled_Format_String__char_console_fprintf_22_badGlobal = 1; 
"
16250,0,CWE369_Divide_by_Zero__int_fscanf_divide_65a.c,"    int data;
    
    void (*funcPtr) (int) = CWE369_Divide_by_Zero__int_fscanf_divide_65b_badSink;
    
    data = -1;
    
    fscanf(stdin, ""%d"", &data);
    
"
17205,0,CWE758_Undefined_Behavior__char_new_use_07.cpp,"    if(staticFive==5)
    {
        {
            char * pointer = new char;
            char data = *pointer; 
            delete pointer;
            printHexCharLine(data);
        }
"
4419,0,CWE252_Unchecked_Return_Value__char_sscanf_17.c,"    int j;
    for(j = 0; j < 1; j++)
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            
            sscanf(SRC, ""%99s\0"", data);
        }
"
11665,0,CWE190_Integer_Overflow__char_rand_square_64a.c,"    char data;
    data = ' ';
    
    data = (char)RAND32();
"
11462,0,CWE190_Integer_Overflow__int64_t_fscanf_preinc_16.c,"    int64_t data;
    data = 0LL;
    while(1)
    {
        
        fscanf (stdin, ""%"" SCNd64, &data);
        break;
    }
    while(1)
    {
        {
            
            ++data;
            int64_t result = data;
            printLongLongLine(result);
        }
        break;
"
14531,0,CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_32.c,"    char * data;
    char * *dataPtr1 = &data;
    char * *dataPtr2 = &data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        char * data = *dataPtr1;
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET connectSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                
                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                data[dataLen + recvResult / sizeof(char)] = '\0';
                
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
        *dataPtr1 = data;
    }
    {
        char * data = *dataPtr2;
        badVaSink(data, data);
"
14462,0,CWE676_Use_of_Potentially_Dangerous_Function__basic_09.cpp,"    if(GLOBAL_CONST_TRUE)
    {
        {
            char charBuffer[CHAR_BUFFER_SIZE];
            
            
            cin >> charBuffer;
            charBuffer[CHAR_BUFFER_SIZE-1] = '\0';
            printLine(charBuffer);
        }
"
18970,0,CWE190_Integer_Overflow__short_max_square_63a.c,"    short data;
    data = 0;
    
    data = SHRT_MAX;
"
17127,0,CWE78_OS_Command_Injection__char_connect_socket_popen_13.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(GLOBAL_CONST_FIVE==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET connectSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
"
16077,0,CWE78_OS_Command_Injection__char_environment_execlp_51a.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        
        if (environment != NULL)
        {
            
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
"
5319,1,CWE467_Use_of_sizeof_on_Pointer_Type__short_17.c,"    int k;
    for(k = 0; k < 1; k++)
    {
        {
            short * goodShort = NULL;
            
            goodShort = (short *)malloc(sizeof(*goodShort));
            if (goodShort == NULL) {exit(-1);}
            *goodShort = 6;
            printShortLine(*goodShort);
            free(goodShort);
        }
"
4230,0,CWE690_NULL_Deref_From_Return__char_malloc_84a.cpp,"    char * data;
    data = NULL; 
    CWE690_NULL_Deref_From_Return__char_malloc_84_bad * badObject = new CWE690_NULL_Deref_From_Return__char_malloc_84_bad(data);
"
4972,0,CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_65a.c,"    int data;
    
    void (*funcPtr) (int) = CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_65b_badSink;
    
    data = -1;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
"
15626,0,CWE590_Free_Memory_Not_on_Heap__free_int_declare_54a.c,"    int * data;
    data = NULL; 
    {
        
        int dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5;
            }
        }
        data = dataBuffer;
    }
"
11085,0,CWE190_Integer_Overflow__short_fscanf_square_21.c,"    short data;
    data = 0;
    
    fscanf (stdin, ""%hd"", &data);
    badStatic = 1; 
"
7568,0,CWE665_Improper_Initialization__char_ncat_31.c,"    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    
    ; 
    {
        char * dataCopy = data;
        char * data = dataCopy;
        {
            size_t sourceLen;
            char source[100];
            memset(source, 'C', 100-1); 
            source[100-1] = '\0'; 
            sourceLen = strlen(source);
            
            strncat(data, source, sourceLen);
            printLine(data);
        }
"
12932,0,CWE590_Free_Memory_Not_on_Heap__delete_struct_alloca_07.cpp,"    twoIntsStruct * data;
    data = NULL; 
    if(staticFive==5)
    {
        {
            
            twoIntsStruct * dataBuffer = (twoIntsStruct *)ALLOCA(sizeof(twoIntsStruct));
            dataBuffer->intOne = 1;
            dataBuffer->intTwo = 1;
            data = dataBuffer;
        }
    }
    printStructLine(data);
    
"
1841,0,CWE457_Use_of_Uninitialized_Variable__twointsclass_array_declare_partial_init_10.cpp,"    TwoIntsClass * data;
    TwoIntsClass dataUninitArray[10];
    data = dataUninitArray;
    if(globalTrue)
    {
        
        for(int i=0; i<(10/2); i++)
        {
            data[i].intOne = i;
            data[i].intTwo = i;
        }
    }
    if(globalTrue)
    {
        
        for(int i=0; i<10; i++)
        {
            printIntLine(data[i].intOne);
            printIntLine(data[i].intTwo);
        }
"
14530,0,CWE401_Memory_Leak__strdup_char_09.c,"    char * data;
    data = NULL;
    if(GLOBAL_CONST_TRUE)
    {
        {
            char myString[] = ""myString"";
            
            data = strdup(myString);
            
            printLine(data);
        }
    }
    if(GLOBAL_CONST_TRUE)
    {
        
        
        ; 
"
16174,0,CWE401_Memory_Leak__struct_twoIntsStruct_malloc_51a.c,"    struct _twoIntsStruct * data;
    data = NULL;
    
    data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));
    if (data == NULL) {exit(-1);}
    
    data[0].intOne = 0;
    data[0].intTwo = 0;
    printStructLine((twoIntsStruct *)&data[0]);
"
2063,0,CWE78_OS_Command_Injection__char_file_execlp_44.c,"    char * data;
    
    void (*funcPtr) (char *) = badSink;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        FILE * pFile;
        
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
    
"
15787,0,CWE415_Double_Free__new_delete_int64_t_84a.cpp,"    int64_t * data;
    
    data = NULL;
    CWE415_Double_Free__new_delete_int64_t_84_bad * badObject = new CWE415_Double_Free__new_delete_int64_t_84_bad(data);
"
18164,0,CWE78_OS_Command_Injection__char_console_execl_01.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        
        if (100-dataLen > 1)
        {
            
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgets() */
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
"
19503,0,CWE590_Free_Memory_Not_on_Heap__delete_array_char_declare_45.cpp,"    char * data;
    data = NULL; 
    {
        
        char dataBuffer[100];
        memset(dataBuffer, 'A', 100-1); 
        dataBuffer[100-1] = '\0'; 
        data = dataBuffer;
    }
    badData = data;
"
6041,1,CWE758_Undefined_Behavior__int64_t_alloca_use_14.c,"    if(globalFive!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            int64_t data;
            int64_t * pointer = (int64_t *)ALLOCA(sizeof(int64_t));
            data = 5LL;
            *pointer = data; 
            {
                int64_t data = *pointer;
                printLongLongLine(data);
            }
        }
"
3968,0,CWE78_OS_Command_Injection__char_connect_socket_popen_68a.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    CWE78_OS_Command_Injection__char_connect_socket_popen_68_badData = data;
"
19073,0,CWE369_Divide_by_Zero__int_fscanf_divide_15.c,"    int data;
    
    data = -1;
    switch(6)
    {
    case 6:
        
        fscanf(stdin, ""%d"", &data);
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
        
        printIntLine(100 / data);
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
11287,0,CWE401_Memory_Leak__strdup_char_14.c,"    char * data;
    data = NULL;
    if(globalFive==5)
    {
        {
            char myString[] = ""myString"";
            
            data = strdup(myString);
            
            printLine(data);
        }
    }
    if(globalFive==5)
    {
        
        
        ; 
"
11334,0,CWE197_Numeric_Truncation_Error__short_fscanf_16.c,"    short data;
    
    data = -1;
    while(1)
    {
        
        fscanf (stdin, ""%hd"", &data);
        break;
    }
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
19057,0,CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_83a.cpp,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
"
16550,0,CWE457_Use_of_Uninitialized_Variable__double_array_malloc_partial_init_05.c,"    double * data;
    data = (double *)malloc(10*sizeof(double));
    if (data == NULL) {exit(-1);}
    if(staticTrue)
    {
        
        {
            int i;
            for(i=0; i<(10/2); i++)
            {
                data[i] = (double)i;
            }
        }
    }
    if(staticTrue)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printDoubleLine(data[i]);
            }
        }
"
4791,1,CWE758_Undefined_Behavior__class_pointer_new_use_05.cpp,"    if(staticTrue)
    {
        {
            TwoIntsClass * data;
            
            data = new TwoIntsClass;
            data->intOne = 5;
            data->intTwo = 6;
            TwoIntsClass * * pointer = new TwoIntsClass *;
            *pointer = data; 
            {
                TwoIntsClass * data = *pointer;
                printIntLine(data->intOne);
                printIntLine(data->intTwo);
            }
            delete pointer;
        }
"
10849,0,CWE401_Memory_Leak__malloc_realloc_twoIntsStruct_02.c,"    if(1)
    {
        {
            twoIntsStruct * data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
            if (data == NULL) {exit(-1);}
            
            data[0].intOne = 0;
            data[0].intTwo = 0;
            printStructLine(&data[0]);
            
            data = (twoIntsStruct *)realloc(data, (130000)*sizeof(twoIntsStruct));
            if (data != NULL)
            {
                
                data[0].intOne = 1;
                data[0].intTwo = 1;
                printStructLine(&data[0]);
                free(data);
            }
        }
"
746,0,CWE690_NULL_Deref_From_Return__int64_t_malloc_41.c,"    int64_t * data;
    data = NULL; 
    
    data = (int64_t *)malloc(1*sizeof(int64_t));
"
16740,0,CWE789_Uncontrolled_Mem_Alloc__new_char_fgets_73a.cpp,"    size_t data;
    list<size_t> dataList;
    
    data = 0;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = strtoul(inputBuffer, NULL, 0);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
8933,0,CWE190_Integer_Overflow__short_fscanf_postinc_21.c,"    short data;
    data = 0;
    
    fscanf (stdin, ""%hd"", &data);
    badStatic = 1; 
"
15330,0,CWE369_Divide_by_Zero__int_connect_socket_divide_67a.c,"    int data;
    CWE369_Divide_by_Zero__int_connect_socket_divide_67_structType myStruct;
    
    data = -1;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    myStruct.structFirst = data;
"
18167,1,CWE758_Undefined_Behavior__double_pointer_alloca_use_13.c,"    if(GLOBAL_CONST_FIVE!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            double * data;
            double * * pointer = (double * *)ALLOCA(sizeof(double *));
            
            data = (double *)malloc(sizeof(double));
            if (data == NULL) {exit(-1);}
            *data = 5.0;
            *pointer = data; 
            {
                double * data = *pointer;
                printDoubleLine(*data);
            }
        }
"
13540,0,CWE789_Uncontrolled_Mem_Alloc__new_char_listen_socket_74a.cpp,"    size_t data;
    map<int, size_t> dataMap;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = strtoul(inputBuffer, NULL, 0);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
17682,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_15.c,"    size_t data;
    
    data = 0;
    switch(6)
    {
    case 6:
        
        fscanf(stdin, ""%zu"", &data);
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
    {
        char * myString;
        /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
         * for the strcpy() function to not cause a buffer overflow */
        
        if (data > strlen(HELLO_STRING))
        {
            myString = (char *)malloc(data*sizeof(char));
            if (myString == NULL) {exit(-1);}
            
            strcpy(myString, HELLO_STRING);
            printLine(myString);
            free(myString);
        }
        else
        {
            printLine(""Input is less than the length of the source string"");
        }
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
5506,0,CWE190_Integer_Overflow__int_fgets_preinc_06.c,"    int data;
    
    data = 0;
    if(STATIC_CONST_FIVE==5)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    if(STATIC_CONST_FIVE==5)
    {
        {
            
            ++data;
            int result = data;
            printIntLine(result);
        }
"
14108,1,CWE758_Undefined_Behavior__char_pointer_alloca_use_03.c,"    if(5!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            char * data;
            char * * pointer = (char * *)ALLOCA(sizeof(char *));
            data = ""string"";
            *pointer = data; 
            {
                char * data = *pointer;
                printLine(data);
            }
        }
"
8455,0,CWE590_Free_Memory_Not_on_Heap__delete_class_placement_new_07.cpp,"    TwoIntsClass * data;
    data = NULL; 
    if(staticFive==5)
    {
        {
            
            char buffer[sizeof(TwoIntsClass)];
            TwoIntsClass * dataBuffer = new(buffer) TwoIntsClass;
            dataBuffer->intOne = 2;
            dataBuffer->intTwo = 2;
            data = dataBuffer;
        }
    }
    printIntLine(data->intOne);
    
"
1969,0,CWE758_Undefined_Behavior__int64_t_alloca_use_03.c,"    if(5==5)
    {
        {
            int64_t * pointer = (int64_t *)ALLOCA(sizeof(int64_t));
            int64_t data = *pointer; 
            printLongLongLine(data);
        }
"
9421,0,CWE190_Integer_Overflow__unsigned_int_max_preinc_67a.c,"    unsigned int data;
    CWE190_Integer_Overflow__unsigned_int_max_preinc_67_structType myStruct;
    data = 0;
    
    data = UINT_MAX;
    myStruct.structFirst = data;
"
17528,1,CWE758_Undefined_Behavior__class_new_use_04.cpp,"    if(STATIC_CONST_TRUE)
    {
        {
            TwoIntsClass data;
            data.intOne = 1;
            data.intTwo = 2;
            TwoIntsClass * pointer = new TwoIntsClass;
            *pointer = data; 
            {
                TwoIntsClass data = *pointer;
                printIntLine(data.intOne);
                printIntLine(data.intTwo);
            }
            delete pointer;
        }
"
10446,0,CWE190_Integer_Overflow__int64_t_rand_add_66a.c,"    int64_t data;
    int64_t dataArray[5];
    data = 0LL;
    
    data = (int64_t)RAND64();
    
    dataArray[2] = data;
"
5963,0,CWE190_Integer_Overflow__int_fgets_multiply_66a.c,"    int data;
    int dataArray[5];
    
    data = 0;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    
    dataArray[2] = data;
"
1415,0,CWE587_Assignment_of_Fixed_Address_to_Pointer__basic_13.c,"    if(GLOBAL_CONST_FIVE==5)
    {
        {
            
            char *charPointer = (char*)0x400000;
            printHexCharLine(*charPointer);
        }
"
6024,0,CWE78_OS_Command_Injection__char_file_system_06.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(STATIC_CONST_FIVE==5)
    {
        {
            
            size_t dataLen = strlen(data);
            FILE * pFile;
            
            if (100-dataLen > 1)
            {
                pFile = fopen(FILENAME, ""r"");
                if (pFile != NULL)
                {
                    
                    if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                    {
                        printLine(""fgets() failed"");
                        
                        data[dataLen] = '\0';
                    }
                    fclose(pFile);
                }
            }
        }
    }
    
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
"
3607,0,CWE401_Memory_Leak__new_int64_t_07.cpp,"    int64_t * data;
    data = NULL;
    if(staticFive==5)
    {
        
        data = new int64_t;
        
        *data = 5LL;
        printLongLongLine(*data);
    }
    if(staticFive==5)
    {
        
        ; 
"
17216,0,CWE563_Unused_Variable__unused_value_int64_t_13.c,"    int64_t data;
    if(GLOBAL_CONST_FIVE==5)
    {
        
        data = 5LL;
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        
        data = 10LL;
        printLongLongLine(data);
"
14984,0,CWE690_NULL_Deref_From_Return__int_calloc_09.c,"    int * data;
    data = NULL; 
    
    data = (int *)calloc(1, sizeof(int));
    if(GLOBAL_CONST_TRUE)
    {
        
        data[0] = 5;
        printIntLine(data[0]);
        free(data);
"
7186,0,CWE590_Free_Memory_Not_on_Heap__delete_char_alloca_13.cpp,"    char * data;
    data = NULL; 
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            
            char * dataBuffer = (char *)ALLOCA(sizeof(char));
            *dataBuffer = 'A';
            data = dataBuffer;
        }
    }
    printHexCharLine(*data);
    
"
7998,0,CWE401_Memory_Leak__struct_twoIntsStruct_realloc_54a.c,"    struct _twoIntsStruct * data;
    data = NULL;
    
    data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));
    if (data == NULL) {exit(-1);}
    
    data[0].intOne = 0;
    data[0].intTwo = 0;
    printStructLine((twoIntsStruct *)&data[0]);
"
12326,0,CWE197_Numeric_Truncation_Error__int_rand_to_short_62a.cpp,"    int data;
    
    data = -1;
    badSource(data);
    {
        
        short shortData = (short)data;
        printShortLine(shortData);
"
19257,0,CWE78_OS_Command_Injection__char_console_popen_41.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
        
        size_t dataLen = strlen(data);
        
        if (100-dataLen > 1)
        {
            
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgets() */
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
"
12145,0,CWE78_OS_Command_Injection__char_file_popen_15.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    switch(6)
    {
    case 6:
    {
        
        size_t dataLen = strlen(data);
        FILE * pFile;
        
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    {
        FILE *pipe;
        
        pipe = POPEN(data, ""w"");
        if (pipe != NULL)
        {
            PCLOSE(pipe);
        }
"
950,0,CWE252_Unchecked_Return_Value__char_puts_16.c,"    while(1)
    {
        
        PUTS(""string"");
        break;
"
15182,0,CWE590_Free_Memory_Not_on_Heap__delete_int_declare_12.cpp,"    int * data;
    data = NULL; 
    if(globalReturnsTrueOrFalse())
    {
        {
            
            int dataBuffer;
            dataBuffer = 5;
            data = &dataBuffer;
        }
    }
    else
    {
        {
            
            int * dataBuffer = new int;
            *dataBuffer = 5;
            data = dataBuffer;
        }
    }
    printIntLine(*data);
    
"
10731,0,CWE197_Numeric_Truncation_Error__int_connect_socket_to_short_82_bad.cpp,"Label Definition File: CWE197_Numeric_Truncation_Error__int.label.xml
Template File: sources-sink-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 197 Numeric Truncation Error
 * BadSource: connect_socket Read data using a connect socket (client side)
 * GoodSource: Less than CHAR_MAX
 * Sinks: to_short
 *    BadSink : Convert data to a short
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE197_Numeric_Truncation_Error__int_connect_socket_to_short_82.h""

namespace CWE197_Numeric_Truncation_Error__int_connect_socket_to_short_82
{

void CWE197_Numeric_Truncation_Error__int_connect_socket_to_short_82_bad::action(int data)
{
    {
        
        short shortData = (short)data;
        printShortLine(shortData);
    }
}

}
"
7797,0,CWE190_Integer_Overflow__int_fscanf_square_83a.cpp,"    int data;
    
    data = 0;
"
18380,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_16.c,"    size_t data;
    
    data = 0;
    while(1)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                
                data = strtoul(inputBuffer, NULL, 0);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
        break;
    }
    while(1)
    {
        {
            char * myString;
            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
             * for the strcpy() function to not cause a buffer overflow */
            
            if (data > strlen(HELLO_STRING))
            {
                myString = (char *)malloc(data*sizeof(char));
                if (myString == NULL) {exit(-1);}
                
                strcpy(myString, HELLO_STRING);
                printLine(myString);
                free(myString);
            }
            else
            {
                printLine(""Input is less than the length of the source string"");
            }
        }
        break;
"
7044,0,CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_42.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    data = badSource(data);
    {
        char dest[100] = """";
        
        SNPRINTF(dest, 100-1, data);
        printLine(dest);
"
10661,1,CWE252_Unchecked_Return_Value__char_sscanf_15.c,"    switch(5)
    {
    case 6:
        
        printLine(""Benign, fixed string"");
        break;
    default:
    {
        /* By initializing dataBuffer, we ensure this will not be the
         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
        char dataBuffer[100] = """";
        char * data = dataBuffer;
        
        if (sscanf(SRC, ""%99s\0"", data) == EOF)
        {
            printLine(""sscanf failed!"");
        }
    }
    break;
"
8371,0,CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_52a.c,"    int data;
    
    data = -1;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
15686,0,CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_54a.c,"    unsigned int data;
    data = 0;
    
    fscanf (stdin, ""%u"", &data);
"
19121,0,CWE190_Integer_Overflow__unsigned_int_rand_square_17.c,"    int i,j;
    unsigned int data;
    data = 0;
    for(i = 0; i < 1; i++)
    {
        
        data = (unsigned int)RAND32();
    }
    for(j = 0; j < 1; j++)
    {
        {
            
            unsigned int result = data * data;
            printUnsignedLine(result);
        }
"
14510,0,CWE401_Memory_Leak__char_realloc_42.c,"    char * data;
    data = NULL;
    data = badSource(data);
    
"
10486,0,CWE134_Uncontrolled_Format_String__char_listen_socket_printf_13.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(GLOBAL_CONST_FIVE==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                data[dataLen + recvResult / sizeof(char)] = '\0';
                
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        
        printf(data);
"
2183,0,CWE401_Memory_Leak__struct_twoIntsStruct_calloc_44.c,"    struct _twoIntsStruct * data;
    
    void (*funcPtr) (struct _twoIntsStruct *) = badSink;
    data = NULL;
    
    data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));
    if (data == NULL) {exit(-1);}
    
    data[0].intOne = 0;
    data[0].intTwo = 0;
    printStructLine((twoIntsStruct *)&data[0]);
    
"
9118,0,CWE197_Numeric_Truncation_Error__int_listen_socket_to_char_14.c,"    int data;
    
    data = -1;
    if(globalFive==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
16229,0,CWE190_Integer_Overflow__int_rand_preinc_54a.c,"    int data;
    
    data = 0;
    
    data = RAND32();
"
5862,0,CWE590_Free_Memory_Not_on_Heap__delete_int64_t_placement_new_54a.cpp,"    int64_t * data;
    data = NULL; 
    {
        
        char buffer[sizeof(int64_t)];
        int64_t * dataBuffer = new(buffer) int64_t;
        *dataBuffer = 5LL;
        data = dataBuffer;
    }
"
11254,0,CWE190_Integer_Overflow__int_listen_socket_add_03.c,"    int data;
    
    data = 0;
    if(5==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(5==5)
    {
        {
            
            int result = data + 1;
            printIntLine(result);
        }
"
2567,0,CWE415_Double_Free__new_delete_int_14.cpp,"    int * data;
    
    data = NULL;
    if(globalFive==5)
    {
        data = new int;
        
        delete data;
    }
    if(globalFive==5)
    {
        
        delete data;
"
16997,0,CWE690_NULL_Deref_From_Return__struct_malloc_84a.cpp,"    twoIntsStruct * data;
    data = NULL; 
    CWE690_NULL_Deref_From_Return__struct_malloc_84_bad * badObject = new CWE690_NULL_Deref_From_Return__struct_malloc_84_bad(data);
"
11260,0,CWE590_Free_Memory_Not_on_Heap__free_long_alloca_14.c,"    long * data;
    data = NULL; 
    if(globalFive==5)
    {
        {
            
            long * dataBuffer = (long *)ALLOCA(100*sizeof(long));
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5L;
                }
            }
            data = dataBuffer;
        }
    }
    printLongLine(data[0]);
    
"
15271,0,CWE401_Memory_Leak__int64_t_malloc_82a.cpp,"    int64_t * data;
    data = NULL;
    
    data = (int64_t *)malloc(100*sizeof(int64_t));
    if (data == NULL) {exit(-1);}
    
    data[0] = 5LL;
    printLongLongLine(data[0]);
    CWE401_Memory_Leak__int64_t_malloc_82_base* baseObject = new CWE401_Memory_Leak__int64_t_malloc_82_bad;
    baseObject->action(data);
"
144,0,CWE134_Uncontrolled_Format_String__char_environment_snprintf_01.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        
        if (environment != NULL)
        {
            
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    {
        char dest[100] = """";
        
        SNPRINTF(dest, 100-1, data);
        printLine(dest);
"
8542,0,CWE690_NULL_Deref_From_Return__int64_t_realloc_09.c,"    int64_t * data;
    data = NULL; 
    
    data = (int64_t *)realloc(data, 1*sizeof(int64_t));
    if(GLOBAL_CONST_TRUE)
    {
        
        data[0] = 5LL;
        printLongLongLine(data[0]);
        free(data);
"
14413,0,CWE78_OS_Command_Injection__char_listen_socket_execlp_82_bad.cpp,"Label Definition File: CWE78_OS_Command_Injection.strings.label.xml
Template File: sources-sink-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 78 OS Command Injection
 * BadSource: listen_socket Read data using a listen socket (server side)
 * GoodSource: Fixed string
 * Sinks: execlp
 *    BadSink : execute command with execlp
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE78_OS_Command_Injection__char_listen_socket_execlp_82.h""

#ifdef _WIN32
#include <process.h>
#define EXECLP _execlp
#else 
#define EXECLP execlp
#endif

namespace CWE78_OS_Command_Injection__char_listen_socket_execlp_82
{

void CWE78_OS_Command_Injection__char_listen_socket_execlp_82_bad::action(char * data)
{
    /* execlp - searches for the location of the command among
     * the directories specified by the PATH environment variable */
    
    EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}

}
"
2723,1,CWE758_Undefined_Behavior__double_pointer_malloc_use_13.c,"    if(GLOBAL_CONST_FIVE!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            double * data;
            double * * pointer = (double * *)malloc(sizeof(double *));
            if (pointer == NULL) {exit(-1);}
            
            data = (double *)malloc(sizeof(double));
            if (data == NULL) {exit(-1);}
            *data = 5.0;
            *pointer = data; 
            {
                double * data = *pointer;
                printDoubleLine(*data);
            }
            free(pointer);
        }
"
11150,0,CWE190_Integer_Overflow__char_max_add_66a.c,"    char data;
    char dataArray[5];
    data = ' ';
    
    data = CHAR_MAX;
    
    dataArray[2] = data;
"
8748,0,CWE590_Free_Memory_Not_on_Heap__free_struct_declare_72a.cpp,"    twoIntsStruct * data;
    vector<twoIntsStruct *> dataVector;
    data = NULL; 
    {
        
        twoIntsStruct dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i].intOne = 1;
                dataBuffer[i].intTwo = 1;
            }
        }
        data = dataBuffer;
    }
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
17256,0,CWE252_Unchecked_Return_Value__char_puts_18.c,"    goto sink;
sink:
    
"
16799,0,CWE415_Double_Free__new_delete_array_int_51a.cpp,"    int * data;
    
    data = NULL;
    data = new int[100];
    
    delete [] data;
"
10586,0,CWE190_Integer_Overflow__int_listen_socket_multiply_41.c,"    int data;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
19227,0,CWE563_Unused_Variable__unused_value_long_05.c,"    long data;
    if(staticTrue)
    {
        
        data = 5L;
    }
    if(staticTrue)
    {
        
        data = 10L;
        printLongLine(data);
"
15996,0,CWE415_Double_Free__new_delete_long_63a.cpp,"    long * data;
    
    data = NULL;
    data = new long;
    
    delete data;
"
13447,0,CWE590_Free_Memory_Not_on_Heap__delete_array_class_alloca_81_bad.cpp,"Label Definition File: CWE590_Free_Memory_Not_on_Heap__delete_array.label.xml
Template File: sources-sink-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 590 Free Memory Not on Heap
 * BadSource: alloca Data buffer is allocated on the stack with alloca()
 * GoodSource: Allocate memory on the heap
 * Sinks:
 *    BadSink : Print then free data
 * Flow Variant: 81 Data flow: data passed in a parameter to a virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE590_Free_Memory_Not_on_Heap__delete_array_class_alloca_81.h""

namespace CWE590_Free_Memory_Not_on_Heap__delete_array_class_alloca_81
{

void CWE590_Free_Memory_Not_on_Heap__delete_array_class_alloca_81_bad::action(TwoIntsClass * data) const
{
    printIntLine(data[0].intOne);
    
    delete [] data;
}

}
"
18563,0,CWE590_Free_Memory_Not_on_Heap__free_struct_declare_06.c,"    twoIntsStruct * data;
    data = NULL; 
    if(STATIC_CONST_FIVE==5)
    {
        {
            
            twoIntsStruct dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i].intOne = 1;
                    dataBuffer[i].intTwo = 1;
                }
            }
            data = dataBuffer;
        }
    }
    printStructLine(&data[0]);
    
"
13100,0,CWE690_NULL_Deref_From_Return__fopen_82_bad.cpp,"Label Definition File: CWE690_NULL_Deref_From_Return.fclose.label.xml
Template File: source-sinks-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 690 Unchecked Return Value To NULL Pointer
 * BadSource: fopen Open data with fopen()
 * Sinks: 0
 *    GoodSink: Check data for NULL
 *    BadSink : Do not check data for NULL
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE690_NULL_Deref_From_Return__fopen_82.h""

namespace CWE690_NULL_Deref_From_Return__fopen_82
{

void CWE690_NULL_Deref_From_Return__fopen_82_bad::action(FILE * data)
{
    
    fclose(data);
}

}
"
2422,0,CWE197_Numeric_Truncation_Error__int_fscanf_to_char_42.c,"    int data;
    
    data = -1;
    data = badSource(data);
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
8807,0,CWE401_Memory_Leak__new_array_struct_twoIntsStruct_53a.cpp,"    struct _twoIntsStruct * data;
    data = NULL;
    
    data = new struct _twoIntsStruct[100];
    
    data[0].intOne = 0;
    data[0].intTwo = 0;
    printStructLine((twoIntsStruct *)&data[0]);
"
275,0,CWE134_Uncontrolled_Format_String__char_file_snprintf_07.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(staticFive==5)
    {
        {
            
            size_t dataLen = strlen(data);
            FILE * pFile;
            
            if (100-dataLen > 1)
            {
                pFile = fopen(FILENAME, ""r"");
                if (pFile != NULL)
                {
                    
                    if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                    {
                        printLine(""fgets() failed"");
                        
                        data[dataLen] = '\0';
                    }
                    fclose(pFile);
                }
            }
        }
    }
    if(staticFive==5)
    {
        {
            char dest[100] = """";
            
            SNPRINTF(dest, 100-1, data);
            printLine(dest);
        }
"
5145,0,CWE415_Double_Free__new_delete_array_class_82_bad.cpp,"Label Definition File: CWE415_Double_Free__new_delete_array.label.xml
Template File: sources-sinks-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 415 Double Free
 * BadSource:  Allocate data using new and Deallocae data using delete
 * GoodSource: Allocate data using new
 * Sinks:
 *    GoodSink: do nothing
 *    BadSink : Deallocate data using delete
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE415_Double_Free__new_delete_array_class_82.h""

namespace CWE415_Double_Free__new_delete_array_class_82
{

void CWE415_Double_Free__new_delete_array_class_82_bad::action(TwoIntsClass * data)
{
    
    delete [] data;
}

}
"
5883,0,CWE190_Integer_Overflow__unsigned_int_max_postinc_05.c,"    unsigned int data;
    data = 0;
    if(staticTrue)
    {
        
        data = UINT_MAX;
    }
    if(staticTrue)
    {
        {
            
            data++;
            unsigned int result = data;
            printUnsignedLine(result);
        }
"
7988,0,CWE190_Integer_Overflow__unsigned_int_rand_add_73a.cpp,"    unsigned int data;
    list<unsigned int> dataList;
    data = 0;
    
    data = (unsigned int)RAND32();
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
11958,0,CWE190_Integer_Overflow__short_rand_square_33.cpp,"    short data;
    short &dataRef = data;
    data = 0;
    
    data = (short)RAND32();
    {
        short data = dataRef;
        {
            
            short result = data * data;
            printIntLine(result);
        }
"
5355,0,CWE78_OS_Command_Injection__char_listen_socket_execlp_21.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    badStatic = 1; 
    data = badSource(data);
    /* execlp - searches for the location of the command among
     * the directories specified by the PATH environment variable */
    
"
6166,0,CWE416_Use_After_Free__malloc_free_struct_13.c,"    twoIntsStruct * data;
    
    data = NULL;
    if(GLOBAL_CONST_FIVE==5)
    {
        data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
        if (data == NULL) {exit(-1);}
        {
            size_t i;
            for(i = 0; i < 100; i++)
            {
                data[i].intOne = 1;
                data[i].intTwo = 2;
            }
        }
        
        free(data);
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        
        printStructLine(&data[0]);
        
"
365,1,CWE758_Undefined_Behavior__char_pointer_new_use_09.cpp,"    if(GLOBAL_CONST_TRUE)
    {
        {
            char * data;
            data = ""string"";
            char * * pointer = new char *;
            *pointer = data; 
            {
                char * data = *pointer;
                printLine(data);
            }
            delete pointer;
        }
"
10779,0,CWE590_Free_Memory_Not_on_Heap__delete_long_alloca_66a.cpp,"    long * data;
    long * dataArray[5];
    data = NULL; 
    {
        
        long * dataBuffer = (long *)ALLOCA(sizeof(long));
        *dataBuffer = 5L;
        data = dataBuffer;
    }
    
    dataArray[2] = data;
"
14806,0,CWE197_Numeric_Truncation_Error__int_listen_socket_to_short_08.c,"    int data;
    
    data = -1;
    if(staticReturnsTrue())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    {
        
        short shortData = (short)data;
        printShortLine(shortData);
"
10958,1,CWE758_Undefined_Behavior__char_new_use_13.cpp,"    if(GLOBAL_CONST_FIVE==5)
    {
        {
            char data;
            data = 5;
            char * pointer = new char;
            *pointer = data; 
            {
                char data = *pointer;
                printHexCharLine(data);
            }
            delete pointer;
        }
"
4834,0,CWE78_OS_Command_Injection__char_environment_execlp_31.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        
        if (environment != NULL)
        {
            
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    {
        char * dataCopy = data;
        char * data = dataCopy;
        /* execlp - searches for the location of the command among
         * the directories specified by the PATH environment variable */
        
        EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
"
3183,1,CWE758_Undefined_Behavior__long_new_use_02.cpp,"    if(1)
    {
        {
            long data;
            data = 5L;
            long * pointer = new long;
            *pointer = data; 
            {
                long data = *pointer;
                printLongLine(data);
            }
            delete pointer;
        }
"
7031,0,CWE190_Integer_Overflow__short_max_add_82a.cpp,"    short data;
    data = 0;
    
    data = SHRT_MAX;
    CWE190_Integer_Overflow__short_max_add_82_base* baseObject = new CWE190_Integer_Overflow__short_max_add_82_bad;
    baseObject->action(data);
"
960,0,CWE134_Uncontrolled_Format_String__char_environment_vfprintf_13.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            
            size_t dataLen = strlen(data);
            char * environment = GETENV(ENV_VARIABLE);
            
            if (environment != NULL)
            {
                
                strncat(data+dataLen, environment, 100-dataLen-1);
            }
        }
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        badVaSinkB(data, data);
"
9071,0,CWE789_Uncontrolled_Mem_Alloc__new_char_fgets_63a.cpp,"    size_t data;
    
    data = 0;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = strtoul(inputBuffer, NULL, 0);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
"
15159,0,CWE415_Double_Free__malloc_free_int_03.c,"    int * data;
    
    data = NULL;
    if(5==5)
    {
        data = (int *)malloc(100*sizeof(int));
        if (data == NULL) {exit(-1);}
        
        free(data);
    }
    if(5==5)
    {
        
        free(data);
"
7069,0,CWE190_Integer_Overflow__char_fscanf_add_09.c,"    char data;
    data = ' ';
    if(GLOBAL_CONST_TRUE)
    {
        
        fscanf (stdin, ""%c"", &data);
    }
    if(GLOBAL_CONST_TRUE)
    {
        {
            
            char result = data + 1;
            printHexCharLine(result);
        }
"
6241,0,CWE197_Numeric_Truncation_Error__short_listen_socket_61a.c,"    short data;
    
    data = -1;
    data = CWE197_Numeric_Truncation_Error__short_listen_socket_61b_badSource(data);
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
17229,0,CWE476_NULL_Pointer_Dereference__class_10.cpp,"    TwoIntsClass * data;
    if(globalTrue)
    {
        
        data = NULL;
    }
    if(globalTrue)
    {
        
        printIntLine(data->intOne);
        
        delete data;
"
19156,0,CWE476_NULL_Pointer_Dereference__null_check_after_deref_08.c,"    if(staticReturnsTrue())
    {
        {
            int *intPointer = NULL;
            intPointer = (int *)malloc(sizeof(int));
            *intPointer = 5;
            printIntLine(*intPointer);
            
            if (intPointer != NULL)
            {
                *intPointer = 10;
            }
            printIntLine(*intPointer);
        }
"
3892,0,CWE190_Integer_Overflow__unsigned_int_max_preinc_51a.c,"    unsigned int data;
    data = 0;
    
    data = UINT_MAX;
"
4846,1,CWE758_Undefined_Behavior__struct_new_use_08.cpp,"    if(staticReturnsFalse())
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            twoIntsStruct data;
            data.intOne = 1;
            data.intTwo = 2;
            twoIntsStruct * pointer = new twoIntsStruct;
            *pointer = data; 
            {
                twoIntsStruct data = *pointer;
                printIntLine(data.intOne);
                printIntLine(data.intTwo);
            }
            delete pointer;
        }
"
16319,0,CWE78_OS_Command_Injection__char_listen_socket_execlp_53a.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
5943,0,CWE590_Free_Memory_Not_on_Heap__free_int_alloca_52a.c,"    int * data;
    data = NULL; 
    {
        
        int * dataBuffer = (int *)ALLOCA(100*sizeof(int));
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5;
            }
        }
        data = dataBuffer;
    }
"
140,0,CWE690_NULL_Deref_From_Return__int_realloc_44.c,"    int * data;
    
    void (*funcPtr) (int *) = badSink;
    data = NULL; 
    
    data = (int *)realloc(data, 1*sizeof(int));
    
"
17761,0,CWE758_Undefined_Behavior__char_pointer_malloc_use_10.c,"    if(globalTrue)
    {
        {
            char * * pointer = (char * *)malloc(sizeof(char *));
            if (pointer == NULL) {exit(-1);}
            char * data = *pointer; 
            free(pointer);
            printLine(data);
        }
"
8306,0,CWE416_Use_After_Free__new_delete_struct_63a.cpp,"    twoIntsStruct * data;
    
    data = NULL;
    data = new twoIntsStruct;
    data->intOne = 1;
    data->intTwo = 2;
    
    delete data;
"
10268,0,CWE590_Free_Memory_Not_on_Heap__delete_int64_t_alloca_10.cpp,"    int64_t * data;
    data = NULL; 
    if(globalTrue)
    {
        {
            
            int64_t * dataBuffer = (int64_t *)ALLOCA(sizeof(int64_t));
            *dataBuffer = 5LL;
            data = dataBuffer;
        }
    }
    printLongLongLine(*data);
    
"
18063,0,CWE590_Free_Memory_Not_on_Heap__delete_int_declare_18.cpp,"    int * data;
    data = NULL; 
    goto source;
source:
    {
        
        int dataBuffer;
        dataBuffer = 5;
        data = &dataBuffer;
    }
    printIntLine(*data);
    
"
6423,0,CWE78_OS_Command_Injection__char_connect_socket_execlp_64a.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
5900,0,CWE590_Free_Memory_Not_on_Heap__free_int64_t_declare_14.c,"    int64_t * data;
    data = NULL; 
    if(globalFive==5)
    {
        {
            
            int64_t dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5LL;
                }
            }
            data = dataBuffer;
        }
    }
    printLongLongLine(data[0]);
    
"
5783,0,CWE563_Unused_Variable__unused_uninit_variable_struct_43.cpp,"    twoIntsStruct data;
    badSource(data);
    
    
"
1023,0,CWE369_Divide_by_Zero__float_connect_socket_18.c,"    float data;
    
    data = 0.0F;
    goto source;
source:
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = (float)atof(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    goto sink;
sink:
    {
        
        int result = (int)(100.0 / data);
        printIntLine(result);
"
18859,1,CWE758_Undefined_Behavior__struct_pointer_alloca_use_01.c,"    {
        twoIntsStruct * data;
        twoIntsStruct * * pointer = (twoIntsStruct * *)ALLOCA(sizeof(twoIntsStruct *));
        
        data = (twoIntsStruct *)malloc(sizeof(twoIntsStruct));
        if (data == NULL) {exit(-1);}
        data->intOne = 5;
        data->intTwo = 6;
        *pointer = data; 
        {
            twoIntsStruct * data = *pointer;
            printIntLine(data->intOne);
            printIntLine(data->intTwo);
        }
"
12839,0,CWE457_Use_of_Uninitialized_Variable__double_array_declare_no_init_43.cpp,"    double * data;
    double dataUninitArray[10];
    data = dataUninitArray;
    badSource(data);
    
    {
        int i;
        for(i=0; i<10; i++)
        {
            printDoubleLine(data[i]);
        }
"
11949,0,CWE369_Divide_by_Zero__int_fscanf_divide_63a.c,"    int data;
    
    data = -1;
    
    fscanf(stdin, ""%d"", &data);
"
17061,0,CWE134_Uncontrolled_Format_String__char_environment_vfprintf_08.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(staticReturnsTrue())
    {
        {
            
            size_t dataLen = strlen(data);
            char * environment = GETENV(ENV_VARIABLE);
            
            if (environment != NULL)
            {
                
                strncat(data+dataLen, environment, 100-dataLen-1);
            }
        }
    }
    if(staticReturnsTrue())
    {
        badVaSinkB(data, data);
"
6922,0,CWE415_Double_Free__new_delete_int64_t_32.cpp,"    int64_t * data;
    int64_t * *dataPtr1 = &data;
    int64_t * *dataPtr2 = &data;
    
    data = NULL;
    {
        int64_t * data = *dataPtr1;
        data = new int64_t;
        
        delete data;
        *dataPtr1 = data;
    }
    {
        int64_t * data = *dataPtr2;
        
        delete data;
"
1679,1,CWE758_Undefined_Behavior__struct_new_use_14.cpp,"    if(globalFive!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            twoIntsStruct data;
            data.intOne = 1;
            data.intTwo = 2;
            twoIntsStruct * pointer = new twoIntsStruct;
            *pointer = data; 
            {
                twoIntsStruct data = *pointer;
                printIntLine(data.intOne);
                printIntLine(data.intTwo);
            }
            delete pointer;
        }
"
7315,0,CWE190_Integer_Overflow__int64_t_fscanf_square_67a.c,"    int64_t data;
    CWE190_Integer_Overflow__int64_t_fscanf_square_67_structType myStruct;
    data = 0LL;
    
    fscanf (stdin, ""%"" SCNd64, &data);
    myStruct.structFirst = data;
"
17789,0,CWE590_Free_Memory_Not_on_Heap__free_long_static_64a.c,"    long * data;
    data = NULL; 
    {
        
        static long dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5L;
            }
        }
        data = dataBuffer;
    }
"
3379,0,CWE590_Free_Memory_Not_on_Heap__delete_class_declare_01.cpp,"    TwoIntsClass * data;
    data = NULL; 
    {
        
        TwoIntsClass dataBuffer;
        dataBuffer.intOne = 1;
        dataBuffer.intTwo = 1;
        data = &dataBuffer;
    }
    printIntLine(data->intOne);
    
"
7740,0,CWE789_Uncontrolled_Mem_Alloc__new_char_rand_34.cpp,"    size_t data;
    unionType myUnion;
    
    data = 0;
    
    data = rand();
    myUnion.unionFirst = data;
    {
        size_t data = myUnion.unionSecond;
        {
            char * myString;
            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
             * for the strcpy() function to not cause a buffer overflow */
            
            if (data > strlen(HELLO_STRING))
            {
                myString = new char[data];
                
                strcpy(myString, HELLO_STRING);
                printLine(myString);
                delete [] myString;
            }
            else
            {
                printLine(""Input is less than the length of the source string"");
            }
        }
"
12019,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_18.c,"    size_t data;
    
    data = 0;
    goto source;
source:
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = strtoul(inputBuffer, NULL, 0);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    goto sink;
sink:
    {
        char * myString;
        /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
         * for the strcpy() function to not cause a buffer overflow */
        
        if (data > strlen(HELLO_STRING))
        {
            myString = (char *)malloc(data*sizeof(char));
            if (myString == NULL) {exit(-1);}
            
            strcpy(myString, HELLO_STRING);
            printLine(myString);
            free(myString);
        }
        else
        {
            printLine(""Input is less than the length of the source string"");
        }
"
15906,0,CWE590_Free_Memory_Not_on_Heap__delete_long_declare_45.cpp,"    long * data;
    data = NULL; 
    {
        
        long dataBuffer;
        dataBuffer = 5L;
        data = &dataBuffer;
    }
    badData = data;
"
12685,0,CWE457_Use_of_Uninitialized_Variable__struct_array_declare_partial_init_10.c,"    twoIntsStruct * data;
    twoIntsStruct dataUninitArray[10];
    data = dataUninitArray;
    if(globalTrue)
    {
        
        {
            int i;
            for(i=0; i<(10/2); i++)
            {
                data[i].intOne = i;
                data[i].intTwo = i;
            }
        }
    }
    if(globalTrue)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i].intOne);
                printIntLine(data[i].intTwo);
            }
        }
"
4452,0,CWE457_Use_of_Uninitialized_Variable__int_07.c,"    int data;
    if(staticFive==5)
    {
        
        ; 
    }
    if(staticFive==5)
    {
        
        printIntLine(data);
"
4357,1,CWE758_Undefined_Behavior__int_alloca_use_06.c,"    if(STATIC_CONST_FIVE!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            int data;
            int * pointer = (int *)ALLOCA(sizeof(int));
            data = 5;
            *pointer = data; 
            {
                int data = *pointer;
                printIntLine(data);
            }
        }
"
4569,0,CWE415_Double_Free__new_delete_int_51a.cpp,"    int * data;
    
    data = NULL;
    data = new int;
    
    delete data;
"
1734,1,CWE758_Undefined_Behavior__class_pointer_new_use_02.cpp,"    if(1)
    {
        {
            TwoIntsClass * data;
            
            data = new TwoIntsClass;
            data->intOne = 5;
            data->intTwo = 6;
            TwoIntsClass * * pointer = new TwoIntsClass *;
            *pointer = data; 
            {
                TwoIntsClass * data = *pointer;
                printIntLine(data->intOne);
                printIntLine(data->intTwo);
            }
            delete pointer;
        }
"
4354,1,CWE467_Use_of_sizeof_on_Pointer_Type__short_10.c,"    if(globalFalse)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            short * goodShort = NULL;
            
            goodShort = (short *)malloc(sizeof(*goodShort));
            if (goodShort == NULL) {exit(-1);}
            *goodShort = 6;
            printShortLine(*goodShort);
            free(goodShort);
        }
"
11825,0,CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_01.cpp,"    size_t data;
    
    data = 0;
    
    fscanf(stdin, ""%zu"", &data);
    {
        char * myString;
        /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
         * for the strcpy() function to not cause a buffer overflow */
        
        if (data > strlen(HELLO_STRING))
        {
            myString = new char[data];
            
            strcpy(myString, HELLO_STRING);
            printLine(myString);
            delete [] myString;
        }
        else
        {
            printLine(""Input is less than the length of the source string"");
        }
"
6647,0,CWE134_Uncontrolled_Format_String__char_file_vprintf_13.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            
            size_t dataLen = strlen(data);
            FILE * pFile;
            
            if (100-dataLen > 1)
            {
                pFile = fopen(FILENAME, ""r"");
                if (pFile != NULL)
                {
                    
                    if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                    {
                        printLine(""fgets() failed"");
                        
                        data[dataLen] = '\0';
                    }
                    fclose(pFile);
                }
            }
        }
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        badVaSinkB(data, data);
"
15042,0,CWE415_Double_Free__malloc_free_int64_t_72a.cpp,"    int64_t * data;
    vector<int64_t *> dataVector;
    
    data = NULL;
    data = (int64_t *)malloc(100*sizeof(int64_t));
    if (data == NULL) {exit(-1);}
    
    free(data);
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
687,0,CWE197_Numeric_Truncation_Error__int_fscanf_to_char_08.c,"    int data;
    
    data = -1;
    if(staticReturnsTrue())
    {
        
        fscanf(stdin, ""%d"", &data);
    }
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
8873,0,CWE190_Integer_Overflow__int_rand_square_09.c,"    int data;
    
    data = 0;
    if(GLOBAL_CONST_TRUE)
    {
        
        data = RAND32();
    }
    if(GLOBAL_CONST_TRUE)
    {
        {
            
            int result = data * data;
            printIntLine(result);
        }
"
9798,0,CWE758_Undefined_Behavior__char_malloc_use_12.c,"    if(globalReturnsTrueOrFalse())
    {
        {
            char * pointer = (char *)malloc(sizeof(char));
            if (pointer == NULL) {exit(-1);}
            char data = *pointer; 
            free(pointer);
            printHexCharLine(data);
        }
    }
    else
    {
        {
            char data;
            char * pointer = (char *)malloc(sizeof(char));
            if (pointer == NULL) {exit(-1);}
            data = 5;
            *pointer = data; 
            {
                char data = *pointer;
                printHexCharLine(data);
            }
            free(pointer);
        }
"
19395,1,CWE476_NULL_Pointer_Dereference__binary_if_17.c,"    int k;
    for(k = 0; k < 1; k++)
    {
        {
            twoIntsStruct *twoIntsStructPointer = NULL;
            /* FIX: Use && in the if statement so that if the left side of the expression fails then
             * the right side will not be evaluated */
            if ((twoIntsStructPointer != NULL) && (twoIntsStructPointer->intOne == 5))
            {
                printLine(""intOne == 5"");
            }
        }
"
7979,0,CWE190_Integer_Overflow__int_fscanf_add_01.c,"    int data;
    
    data = 0;
    
    fscanf(stdin, ""%d"", &data);
    {
        
        int result = data + 1;
        printIntLine(result);
"
17441,0,CWE415_Double_Free__new_delete_int_08.cpp,"    int * data;
    
    data = NULL;
    if(staticReturnsTrue())
    {
        data = new int;
        
        delete data;
    }
    if(staticReturnsTrue())
    {
        
        delete data;
"
15803,0,CWE563_Unused_Variable__unused_uninit_variable_char_84a.cpp,"    char data;
    CWE563_Unused_Variable__unused_uninit_variable_char_84_bad * badObject = new CWE563_Unused_Variable__unused_uninit_variable_char_84_bad(data);
"
10950,0,CWE590_Free_Memory_Not_on_Heap__delete_int64_t_declare_09.cpp,"    int64_t * data;
    data = NULL; 
    if(GLOBAL_CONST_TRUE)
    {
        {
            
            int64_t dataBuffer;
            dataBuffer = 5LL;
            data = &dataBuffer;
        }
    }
    printLongLongLine(*data);
    
"
3653,0,CWE190_Integer_Overflow__unsigned_int_max_square_64a.c,"    unsigned int data;
    data = 0;
    
    data = UINT_MAX;
"
3068,1,CWE676_Use_of_Potentially_Dangerous_Function__basic_12.cpp,"    if(globalReturnsTrueOrFalse())
    {
        {
            char charBuffer[CHAR_BUFFER_SIZE];
            
            cin.width(CHAR_BUFFER_SIZE);
            cin >> charBuffer;
            charBuffer[CHAR_BUFFER_SIZE-1] = '\0';
            printLine(charBuffer);
        }
    }
    else
    {
        {
            char charBuffer[CHAR_BUFFER_SIZE];
            
            cin.width(CHAR_BUFFER_SIZE);
            cin >> charBuffer;
            charBuffer[CHAR_BUFFER_SIZE-1] = '\0';
            printLine(charBuffer);
        }
"
16698,0,CWE190_Integer_Overflow__short_rand_add_72a.cpp,"    short data;
    vector<short> dataVector;
    data = 0;
    
    data = (short)RAND32();
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
8290,0,CWE415_Double_Free__malloc_free_char_02.c,"    char * data;
    
    data = NULL;
    if(1)
    {
        data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        
        free(data);
    }
    if(1)
    {
        
        free(data);
"
17252,0,CWE563_Unused_Variable__unused_value_char_82a.cpp,"    char data;
    
    data = 'C';
    CWE563_Unused_Variable__unused_value_char_82_base* baseObject = new CWE563_Unused_Variable__unused_value_char_82_bad;
    baseObject->action(data);
"
3381,0,CWE590_Free_Memory_Not_on_Heap__free_int_static_52a.c,"    int * data;
    data = NULL; 
    {
        
        static int dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5;
            }
        }
        data = dataBuffer;
    }
"
16397,0,CWE415_Double_Free__new_delete_array_char_52a.cpp,"    char * data;
    
    data = NULL;
    data = new char[100];
    
    delete [] data;
"
19125,0,CWE190_Integer_Overflow__short_rand_postinc_31.c,"    short data;
    data = 0;
    
    data = (short)RAND32();
    {
        short dataCopy = data;
        short data = dataCopy;
        {
            
            data++;
            short result = data;
            printIntLine(result);
        }
"
5220,0,CWE401_Memory_Leak__struct_twoIntsStruct_malloc_31.c,"    struct _twoIntsStruct * data;
    data = NULL;
    
    data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));
    if (data == NULL) {exit(-1);}
    
    data[0].intOne = 0;
    data[0].intTwo = 0;
    printStructLine((twoIntsStruct *)&data[0]);
    {
        struct _twoIntsStruct * dataCopy = data;
        struct _twoIntsStruct * data = dataCopy;
        
        ; 
"
1563,0,CWE401_Memory_Leak__int_realloc_81_bad.cpp,"Label Definition File: CWE401_Memory_Leak.c.label.xml
Template File: sources-sinks-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 401 Memory Leak
 * BadSource: realloc Allocate data using realloc()
 * GoodSource: Allocate data on the stack
 * Sinks:
 *    GoodSink: call free() on data
 *    BadSink : no deallocation of data
 * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE401_Memory_Leak__int_realloc_81.h""

namespace CWE401_Memory_Leak__int_realloc_81
{

void CWE401_Memory_Leak__int_realloc_81_bad::action(int * data) const
{
    
    ; 
}

}
"
7460,0,CWE415_Double_Free__malloc_free_long_68a.c,"    long * data;
    
    data = NULL;
    data = (long *)malloc(100*sizeof(long));
    if (data == NULL) {exit(-1);}
    
    free(data);
    CWE415_Double_Free__malloc_free_long_68_badData = data;
"
16835,0,CWE134_Uncontrolled_Format_String__char_console_vfprintf_16.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    while(1)
    {
        {
            
            size_t dataLen = strlen(data);
            
            if (100-dataLen > 1)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
                {
                    /* The next few lines remove the carriage return from the string that is
                     * inserted by fgets() */
                    dataLen = strlen(data);
                    if (dataLen > 0 && data[dataLen-1] == '\n')
                    {
                        data[dataLen-1] = '\0';
                    }
                }
                else
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
            }
        }
        break;
    }
    while(1)
    {
        badVaSinkB(data, data);
        break;
"
7065,0,CWE190_Integer_Overflow__char_rand_square_16.c,"    char data;
    data = ' ';
    while(1)
    {
        
        data = (char)RAND32();
        break;
    }
    while(1)
    {
        {
            
            char result = data * data;
            printHexCharLine(result);
        }
        break;
"
17543,0,CWE690_NULL_Deref_From_Return__int_malloc_62a.cpp,"    int * data;
    data = NULL; 
    badSource(data);
    
    data[0] = 5;
    printIntLine(data[0]);
"
1298,1,CWE676_Use_of_Potentially_Dangerous_Function__basic_17.cpp,"    int k;
    for(k = 0; k < 1; k++)
    {
        {
            char charBuffer[CHAR_BUFFER_SIZE];
            
            cin.width(CHAR_BUFFER_SIZE);
            cin >> charBuffer;
            charBuffer[CHAR_BUFFER_SIZE-1] = '\0';
            printLine(charBuffer);
        }
"
2302,0,CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_16.cpp,"    size_t data;
    
    data = 0;
    while(1)
    {
        
        fscanf(stdin, ""%zu"", &data);
        break;
    }
    while(1)
    {
        {
            char * myString;
            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
             * for the strcpy() function to not cause a buffer overflow */
            
            if (data > strlen(HELLO_STRING))
            {
                myString = new char[data];
                
                strcpy(myString, HELLO_STRING);
                printLine(myString);
                delete [] myString;
            }
            else
            {
                printLine(""Input is less than the length of the source string"");
            }
        }
        break;
"
12054,0,CWE401_Memory_Leak__struct_twoIntsStruct_malloc_04.c,"    struct _twoIntsStruct * data;
    data = NULL;
    if(STATIC_CONST_TRUE)
    {
        
        data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));
        if (data == NULL) {exit(-1);}
        
        data[0].intOne = 0;
        data[0].intTwo = 0;
        printStructLine((twoIntsStruct *)&data[0]);
    }
    if(STATIC_CONST_TRUE)
    {
        
        ; 
"
19274,0,CWE190_Integer_Overflow__int_connect_socket_add_17.c,"    int i,j;
    int data;
    
    data = 0;
    for(i = 0; i < 1; i++)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    for(j = 0; j < 1; j++)
    {
        {
            
            int result = data + 1;
            printIntLine(result);
        }
"
17954,0,CWE190_Integer_Overflow__unsigned_int_rand_add_54a.c,"    unsigned int data;
    data = 0;
    
    data = (unsigned int)RAND32();
"
2394,0,CWE415_Double_Free__malloc_free_char_21.c,"    char * data;
    
    data = NULL;
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    
    free(data);
    badStatic = 1; 
"
15266,0,CWE590_Free_Memory_Not_on_Heap__delete_array_long_alloca_03.cpp,"    long * data;
    data = NULL; 
    if(5==5)
    {
        {
            
            long * dataBuffer = (long *)ALLOCA(100*sizeof(long));
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5L;
                }
            }
            data = dataBuffer;
        }
    }
    printLongLine(data[0]);
    
"
18592,0,CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_14.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(globalFive==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                data[dataLen + recvResult / sizeof(char)] = '\0';
                
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(globalFive==5)
    {
        {
            char dest[100] = """";
            
            SNPRINTF(dest, 100-1, data);
            printLine(dest);
        }
"
6558,0,CWE416_Use_After_Free__malloc_free_struct_16.c,"    twoIntsStruct * data;
    
    data = NULL;
    while(1)
    {
        data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
        if (data == NULL) {exit(-1);}
        {
            size_t i;
            for(i = 0; i < 100; i++)
            {
                data[i].intOne = 1;
                data[i].intTwo = 2;
            }
        }
        
        free(data);
        break;
    }
    while(1)
    {
        
        printStructLine(&data[0]);
        
        break;
"
280,0,CWE190_Integer_Overflow__int64_t_rand_preinc_64a.c,"    int64_t data;
    data = 0LL;
    
    data = (int64_t)RAND64();
"
849,0,CWE415_Double_Free__new_delete_array_long_68a.cpp,"    long * data;
    
    data = NULL;
    data = new long[100];
    
    delete [] data;
    badData = data;
"
5137,0,CWE190_Integer_Overflow__int_fgets_add_73a.cpp,"    int data;
    list<int> dataList;
    
    data = 0;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
12534,0,CWE415_Double_Free__new_delete_array_class_51a.cpp,"    TwoIntsClass * data;
    
    data = NULL;
    data = new TwoIntsClass[100];
    
    delete [] data;
"
15974,1,CWE401_Memory_Leak__malloc_realloc_char_13.c,"    if(GLOBAL_CONST_FIVE!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            char * data = (char *)malloc(100*sizeof(char));
            if (data == NULL) {exit(-1);}
            char * tmpData;
            
            strcpy(data, ""A String"");
            printLine(data);
            tmpData = (char *)realloc(data, (130000)*sizeof(char));
            /* FIX: Ensure realloc() was successful before assigning data to the memory block
            * allocated with realloc() */
            if (tmpData != NULL)
            {
                data = tmpData;
                
                strcpy(data, ""New String"");
                printLine(data);
            }
            free(data);
        }
"
16050,0,CWE369_Divide_by_Zero__float_listenSocket_53a.c,"    float data;
    
    data = 0.0F;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = (float)atof(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
7607,0,CWE197_Numeric_Truncation_Error__short_rand_22a.c,"    short data;
    
    data = -1;
    CWE197_Numeric_Truncation_Error__short_rand_22_badGlobal = 1; 
    data = CWE197_Numeric_Truncation_Error__short_rand_22_badSource(data);
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
16754,0,CWE190_Integer_Overflow__int_rand_multiply_74a.cpp,"    int data;
    map<int, int> dataMap;
    
    data = 0;
    
    data = RAND32();
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
15589,0,CWE758_Undefined_Behavior__int64_t_malloc_use_15.c,"    switch(6)
    {
    case 6:
    {
        int64_t * pointer = (int64_t *)malloc(sizeof(int64_t));
        if (pointer == NULL) {exit(-1);}
        int64_t data = *pointer; 
        free(pointer);
        printLongLongLine(data);
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
12222,1,CWE252_Unchecked_Return_Value__char_rename_06.c,"    if(STATIC_CONST_FIVE==5)
    {
        
        if (RENAME(OLD_GOOD_FILE_NAME, ""newgoodfilename.txt"") != 0)
        {
            printLine(""rename failed!"");
        }
"
8630,0,CWE457_Use_of_Uninitialized_Variable__double_64a.c,"    double data;
    
    ; 
"
1749,0,CWE690_NULL_Deref_From_Return__struct_calloc_51a.c,"    twoIntsStruct * data;
    data = NULL; 
    
    data = (twoIntsStruct *)calloc(1, sizeof(twoIntsStruct));
"
6994,0,CWE415_Double_Free__new_delete_array_long_62a.cpp,"    long * data;
    
    data = NULL;
    badSource(data);
    
"
18362,0,CWE369_Divide_by_Zero__int_zero_divide_12.c,"    int data;
    
    data = -1;
    if(globalReturnsTrueOrFalse())
    {
        
        data = 0;
    }
    else
    {
        
        data = 7;
    }
    if(globalReturnsTrueOrFalse())
    {
        
        printIntLine(100 / data);
    }
    else
    {
        
        if( data != 0 )
        {
            printIntLine(100 / data);
        }
        else
        {
            printLine(""This would result in a divide by zero"");
        }
"
2658,1,CWE475_Undefined_Behavior_for_Input_to_API__char_03.c,"    if(5!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            strcpy(data, ""abcdefghijklmnopqrstuvwxyz"");
            
            memmove(data + 6, data + 4, 10*sizeof(char));
            printLine(data);
        }
"
16113,0,CWE457_Use_of_Uninitialized_Variable__twointsclass_array_malloc_partial_init_17.cpp,"    int i,j;
    TwoIntsClass * data;
    data = reinterpret_cast<TwoIntsClass *>(malloc(10*sizeof(TwoIntsClass)));
    if (data == NULL) {exit(-1);}
    for(i = 0; i < 1; i++)
    {
        
        for(int i=0; i<(10/2); i++)
        {
            data[i].intOne = i;
            data[i].intTwo = i;
        }
    }
    for(j = 0; j < 1; j++)
    {
        
        for(int i=0; i<10; i++)
        {
            printIntLine(data[i].intOne);
            printIntLine(data[i].intTwo);
        }
"
17440,0,CWE369_Divide_by_Zero__int_fscanf_divide_01.c,"    int data;
    
    data = -1;
    
    fscanf(stdin, ""%d"", &data);
    
"
59,0,CWE197_Numeric_Truncation_Error__short_large_43.cpp,"    short data;
    
    data = -1;
    badSource(data);
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
6312,0,CWE415_Double_Free__malloc_free_long_41.c,"    long * data;
    
    data = NULL;
    data = (long *)malloc(100*sizeof(long));
    if (data == NULL) {exit(-1);}
    
    free(data);
"
10112,0,CWE690_NULL_Deref_From_Return__struct_realloc_51a.c,"    twoIntsStruct * data;
    data = NULL; 
    
    data = (twoIntsStruct *)realloc(data, 1*sizeof(twoIntsStruct));
"
15559,0,CWE590_Free_Memory_Not_on_Heap__delete_char_placement_new_82_bad.cpp,"Label Definition File: CWE590_Free_Memory_Not_on_Heap__delete.pointer.label.xml
Template File: sources-sink-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 590 Free Memory Not on Heap
 * BadSource: placement_new Data buffer is declared on the stack
 * GoodSource: Allocate memory on the heap
 * Sinks:
 *    BadSink : Print then free data
 * Flow Variant: 82 Data flow: data passed in a parameter to a virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE590_Free_Memory_Not_on_Heap__delete_char_placement_new_82.h""

namespace CWE590_Free_Memory_Not_on_Heap__delete_char_placement_new_82
{

void CWE590_Free_Memory_Not_on_Heap__delete_char_placement_new_82_bad::action(char * data)
{
    printHexCharLine(*data);
    
    delete data;
}

}
"
4835,0,CWE476_NULL_Pointer_Dereference__int64_t_12.c,"    int64_t * data;
    int64_t tmpData = 5LL;
    if(globalReturnsTrueOrFalse())
    {
        
        data = NULL;
    }
    else
    {
        
        {
            data = &tmpData;
        }
    }
    if(globalReturnsTrueOrFalse())
    {
        
        printLongLongLine(*data);
    }
    else
    {
        
        if (data != NULL)
        {
            printLongLongLine(*data);
        }
        else
        {
            printLine(""data is NULL"");
        }
"
17055,1,CWE758_Undefined_Behavior__int_malloc_use_04.c,"    if(STATIC_CONST_TRUE)
    {
        {
            int data;
            int * pointer = (int *)malloc(sizeof(int));
            if (pointer == NULL) {exit(-1);}
            data = 5;
            *pointer = data; 
            {
                int data = *pointer;
                printIntLine(data);
            }
            free(pointer);
        }
"
16271,0,CWE415_Double_Free__malloc_free_long_05.c,"    long * data;
    
    data = NULL;
    if(staticTrue)
    {
        data = (long *)malloc(100*sizeof(long));
        if (data == NULL) {exit(-1);}
        
        free(data);
    }
    if(staticTrue)
    {
        
        free(data);
"
13718,0,CWE401_Memory_Leak__int64_t_calloc_66a.c,"    int64_t * data;
    int64_t * dataArray[5];
    data = NULL;
    
    data = (int64_t *)calloc(100, sizeof(int64_t));
    if (data == NULL) {exit(-1);}
    
    data[0] = 5LL;
    printLongLongLine(data[0]);
    
    dataArray[2] = data;
"
17694,0,CWE190_Integer_Overflow__int64_t_max_add_65a.c,"    int64_t data;
    
    void (*funcPtr) (int64_t) = CWE190_Integer_Overflow__int64_t_max_add_65b_badSink;
    data = 0LL;
    
    data = LLONG_MAX;
    
"
8147,0,CWE134_Uncontrolled_Format_String__char_file_printf_84_bad.cpp,"Label Definition File: CWE134_Uncontrolled_Format_String.label.xml
Template File: sources-sinks-84_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 134 Uncontrolled Format String
 * BadSource: file Read input from a file
 * GoodSource: Copy a fixed string into data
 * Sinks: printf
 *    GoodSink: printf with ""%s"" as the first argument and data as the second
 *    BadSink : printf with only data as an argument
 * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE134_Uncontrolled_Format_String__char_file_printf_84.h""

#ifdef _WIN32
#define FILENAME ""C:\\temp\\file.txt""
#else
#define FILENAME ""/tmp/file.txt""
#endif

namespace CWE134_Uncontrolled_Format_String__char_file_printf_84
{
CWE134_Uncontrolled_Format_String__char_file_printf_84_bad::CWE134_Uncontrolled_Format_String__char_file_printf_84_bad(char * dataCopy)
{
    data = dataCopy;
    {
        
        size_t dataLen = strlen(data);
        FILE * pFile;
        
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
}

CWE134_Uncontrolled_Format_String__char_file_printf_84_bad::~CWE134_Uncontrolled_Format_String__char_file_printf_84_bad()
{
    
    printf(data);
}
}
"
11587,0,CWE190_Integer_Overflow__unsigned_int_max_preinc_18.c,"    unsigned int data;
    data = 0;
    goto source;
source:
    
    data = UINT_MAX;
    goto sink;
sink:
    {
        
        ++data;
        unsigned int result = data;
        printUnsignedLine(result);
"
12966,0,CWE190_Integer_Overflow__int_connect_socket_postinc_01.c,"    int data;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    {
        
        data++;
        int result = data;
        printIntLine(result);
"
19065,0,CWE590_Free_Memory_Not_on_Heap__delete_array_class_declare_34.cpp,"    TwoIntsClass * data;
    unionType myUnion;
    data = NULL; 
    {
        
        TwoIntsClass dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i].intOne = 1;
                dataBuffer[i].intTwo = 1;
            }
        }
        data = dataBuffer;
    }
    myUnion.unionFirst = data;
    {
        TwoIntsClass * data = myUnion.unionSecond;
        printIntLine(data[0].intOne);
        
        delete [] data;
"
17469,0,CWE563_Unused_Variable__unused_uninit_variable_struct_13.c,"    twoIntsStruct data;
    
    ; 
    if(GLOBAL_CONST_FIVE==5)
    {
        
        
        ; 
"
5910,0,CWE78_OS_Command_Injection__char_environment_execl_15.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    switch(6)
    {
    case 6:
    {
        
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        
        if (environment != NULL)
        {
            
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    
    
"
18589,0,CWE134_Uncontrolled_Format_String__char_environment_printf_11.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(globalReturnsTrue())
    {
        {
            
            size_t dataLen = strlen(data);
            char * environment = GETENV(ENV_VARIABLE);
            
            if (environment != NULL)
            {
                
                strncat(data+dataLen, environment, 100-dataLen-1);
            }
        }
    }
    if(globalReturnsTrue())
    {
        
        printf(data);
"
11744,0,CWE190_Integer_Overflow__char_rand_preinc_51a.c,"    char data;
    data = ' ';
    
    data = (char)RAND32();
"
1945,0,CWE190_Integer_Overflow__short_rand_add_68a.c,"    short data;
    data = 0;
    
    data = (short)RAND32();
    CWE190_Integer_Overflow__short_rand_add_68_badData = data;
"
7790,0,CWE401_Memory_Leak__new_struct_twoIntsStruct_68a.cpp,"    struct _twoIntsStruct * data;
    data = NULL;
    
    data = new struct _twoIntsStruct;
    
    data->intOne = 0;
    data->intTwo = 0;
    printStructLine((twoIntsStruct *)data);
    badData = data;
"
5818,0,CWE476_NULL_Pointer_Dereference__char_33.cpp,"    char * data;
    char * &dataRef = data;
    
    data = NULL;
    {
        char * data = dataRef;
        
        
        printHexCharLine(data[0]);
"
6582,0,CWE190_Integer_Overflow__short_fscanf_square_62a.cpp,"    short data;
    data = 0;
    badSource(data);
    {
        
        short result = data * data;
        printIntLine(result);
"
5087,0,CWE690_NULL_Deref_From_Return__long_malloc_42.c,"    long * data;
    data = NULL; 
    data = badSource(data);
    
    data[0] = 5L;
    printLongLine(data[0]);
"
2930,0,CWE401_Memory_Leak__malloc_realloc_int_08.c,"    if(staticReturnsTrue())
    {
        {
            int * data = (int *)malloc(100*sizeof(int));
            if (data == NULL) {exit(-1);}
            
            data[0] = 5;
            printIntLine(data[0]);
            
            data = (int *)realloc(data, (130000)*sizeof(int));
            if (data != NULL)
            {
                
                data[0] = 10;
                printIntLine(data[0]);
                free(data);
            }
        }
"
4533,0,CWE476_NULL_Pointer_Dereference__struct_18.c,"    twoIntsStruct * data;
    goto source;
source:
    
    data = NULL;
    goto sink;
sink:
    
"
1775,1,CWE758_Undefined_Behavior__int_pointer_new_use_15.cpp,"    switch(5)
    {
    case 6:
        
        printLine(""Benign, fixed string"");
        break;
    default:
    {
        int * data;
        
        data = new int;
        *data = 5;
        int * * pointer = new int *;
        *pointer = data; 
        {
            int * data = *pointer;
            printIntLine(*data);
        }
        delete pointer;
    }
    break;
"
1859,0,CWE197_Numeric_Truncation_Error__short_large_84a.cpp,"    short data;
    
    data = -1;
    CWE197_Numeric_Truncation_Error__short_large_84_bad * badObject = new CWE197_Numeric_Truncation_Error__short_large_84_bad(data);
"
6981,0,CWE252_Unchecked_Return_Value__char_snprintf_12.c,"    if(globalReturnsTrueOrFalse())
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            
            SNPRINTF(data,100-strlen(SRC)-1, ""%s\n"", SRC);
        }
    }
    else
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            
            if (SNPRINTF(data,100-strlen(SRC)-1, ""%s\n"", SRC) < 0)
            {
                printLine(""snprintf failed!"");
            }
        }
"
14511,0,CWE690_NULL_Deref_From_Return__int64_t_realloc_18.c,"    int64_t * data;
    data = NULL; 
    
    data = (int64_t *)realloc(data, 1*sizeof(int64_t));
    goto sink;
sink:
    
    data[0] = 5LL;
    printLongLongLine(data[0]);
"
14353,0,CWE190_Integer_Overflow__int_rand_square_41.c,"    int data;
    
    data = 0;
    
    data = RAND32();
"
9160,0,CWE190_Integer_Overflow__short_max_preinc_42.c,"    short data;
    data = 0;
    data = badSource(data);
    {
        
        ++data;
        short result = data;
        printIntLine(result);
"
18657,0,CWE590_Free_Memory_Not_on_Heap__free_int64_t_alloca_68a.c,"    int64_t * data;
    data = NULL; 
    {
        
        int64_t * dataBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5LL;
            }
        }
        data = dataBuffer;
    }
    CWE590_Free_Memory_Not_on_Heap__free_int64_t_alloca_68_badData = data;
"
17308,0,CWE369_Divide_by_Zero__int_connect_socket_divide_18.c,"    int data;
    
    data = -1;
    goto source;
source:
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    goto sink;
sink:
    
"
9075,0,CWE690_NULL_Deref_From_Return__long_malloc_22a.c,"    long * data;
    data = NULL; 
    
    data = (long *)malloc(1*sizeof(long));
    CWE690_NULL_Deref_From_Return__long_malloc_22_badGlobal = 1; 
"
9489,0,CWE190_Integer_Overflow__int_listen_socket_square_34.c,"    int data;
    CWE190_Integer_Overflow__int_listen_socket_square_34_unionType myUnion;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    myUnion.unionFirst = data;
    {
        int data = myUnion.unionSecond;
        {
            
            int result = data * data;
            printIntLine(result);
        }
"
7319,1,CWE252_Unchecked_Return_Value__char_putchar_11.c,"    if(globalReturnsFalse())
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        
        if (putchar((int)'A') == EOF)
        {
            printLine(""putchar failed!"");
        }
"
9782,0,CWE190_Integer_Overflow__int_rand_multiply_42.c,"    int data;
    
    data = 0;
    data = badSource(data);
    if(data > 0) 
    {
        
        int result = data * 2;
        printIntLine(result);
"
17976,0,CWE590_Free_Memory_Not_on_Heap__delete_long_static_09.cpp,"    long * data;
    data = NULL; 
    if(GLOBAL_CONST_TRUE)
    {
        {
            
            static long dataBuffer;
            dataBuffer = 5L;
            data = &dataBuffer;
        }
    }
    printLongLine(*data);
    
"
4976,1,CWE758_Undefined_Behavior__long_alloca_use_02.c,"    if(1)
    {
        {
            long data;
            long * pointer = (long *)ALLOCA(sizeof(long));
            data = 5L;
            *pointer = data; 
            {
                long data = *pointer;
                printLongLine(data);
            }
        }
"
10461,0,CWE190_Integer_Overflow__unsigned_int_max_multiply_15.c,"    unsigned int data;
    data = 0;
    switch(6)
    {
    case 6:
        
        data = UINT_MAX;
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
        if(data > 0) 
        {
            
            unsigned int result = data * 2;
            printUnsignedLine(result);
        }
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
18762,0,CWE197_Numeric_Truncation_Error__int_fgets_to_short_10.c,"    int data;
    
    data = -1;
    if(globalTrue)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    {
        
        short shortData = (short)data;
        printShortLine(shortData);
"
