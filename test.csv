,file,code,label
6630,0,CWE134_Uncontrolled_Format_String__char_console_fprintf_12.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(globalReturnsTrueOrFalse())
    {
        {
            
            size_t dataLen = strlen(data);
            
            if (100-dataLen > 1)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
                {
                    /* The next few lines remove the carriage return from the string that is
                     * inserted by fgets() */
                    dataLen = strlen(data);
                    if (dataLen > 0 && data[dataLen-1] == '\n')
                    {
                        data[dataLen-1] = '\0';
                    }
                }
                else
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
            }
        }
    }
    else
    {
        
        strcpy(data, ""fixedstringtest"");
    }
    if(globalReturnsTrueOrFalse())
    {
        
        fprintf(stdout, data);
    }
    else
    {
        
        fprintf(stdout, ""%s\n"", data);
"
5414,0,CWE563_Unused_Variable__unused_value_struct_16.c,"    twoIntsStruct data;
    while(1)
    {
        
        data.intOne = 0;
        data.intTwo = 0;
        break;
    }
    while(1)
    {
        
        data.intOne = 1;
        data.intTwo = 1;
        printStructLine(&data);
        break;
"
6604,1,CWE758_Undefined_Behavior__char_malloc_use_05.c,"    if(staticTrue)
    {
        {
            char data;
            char * pointer = (char *)malloc(sizeof(char));
            if (pointer == NULL) {exit(-1);}
            data = 5;
            *pointer = data; 
            {
                char data = *pointer;
                printHexCharLine(data);
            }
            free(pointer);
        }
"
17180,0,CWE190_Integer_Overflow__short_fscanf_multiply_22a.c,"    short data;
    data = 0;
    
    fscanf (stdin, ""%hd"", &data);
    CWE190_Integer_Overflow__short_fscanf_multiply_22_badGlobal = 1; 
"
16312,0,CWE416_Use_After_Free__malloc_free_struct_17.c,"    int i,j;
    twoIntsStruct * data;
    
    data = NULL;
    for(i = 0; i < 1; i++)
    {
        data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
        if (data == NULL) {exit(-1);}
        {
            size_t i;
            for(i = 0; i < 100; i++)
            {
                data[i].intOne = 1;
                data[i].intTwo = 2;
            }
        }
        
        free(data);
    }
    for(j = 0; j < 1; j++)
    {
        
        printStructLine(&data[0]);
        
"
764,0,CWE190_Integer_Overflow__unsigned_int_rand_preinc_54a.c,"    unsigned int data;
    data = 0;
    
    data = (unsigned int)RAND32();
"
14574,0,CWE190_Integer_Overflow__int_rand_postinc_02.c,"    int data;
    
    data = 0;
    if(1)
    {
        
        data = RAND32();
    }
    if(1)
    {
        {
            
            data++;
            int result = data;
            printIntLine(result);
        }
"
14323,0,CWE476_NULL_Pointer_Dereference__long_65a.c,"    long * data;
    
    void (*funcPtr) (long *) = CWE476_NULL_Pointer_Dereference__long_65b_badSink;
    
    data = NULL;
    
"
7223,0,CWE78_OS_Command_Injection__char_environment_execlp_53a.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        
        if (environment != NULL)
        {
            
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
"
13228,0,CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_14.c,"    unsigned int data;
    data = 0;
    if(globalFive==5)
    {
        
        fscanf (stdin, ""%u"", &data);
    }
    if(globalFive==5)
    {
        {
            
            data++;
            unsigned int result = data;
            printUnsignedLine(result);
        }
"
19416,0,CWE590_Free_Memory_Not_on_Heap__delete_long_placement_new_33.cpp,"    long * data;
    long * &dataRef = data;
    data = NULL; 
    {
        
        char buffer[sizeof(long)];
        long * dataBuffer = new(buffer) long;
        *dataBuffer = 5L;
        data = dataBuffer;
    }
    {
        long * data = dataRef;
        printLongLine(*data);
        
        delete data;
"
18023,0,CWE252_Unchecked_Return_Value__char_fgets_09.c,"    if(GLOBAL_CONST_TRUE)
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            printLine(""Please enter a string: "");
            
            fgets(data, 100, stdin);
            printLine(data);
        }
"
1097,0,CWE467_Use_of_sizeof_on_Pointer_Type__char_07.c,"    if(staticFive==5)
    {
        {
            char * badChar = NULL;
            
            badChar = (char *)malloc(sizeof(badChar));
            if (badChar == NULL) {exit(-1);}
            *badChar = 'B';
            printHexCharLine(*badChar);
            free(badChar);
        }
"
16323,0,CWE457_Use_of_Uninitialized_Variable__int_pointer_01.c,"    int * data;
    
    ; 
    
"
8408,0,CWE190_Integer_Overflow__short_rand_postinc_03.c,"    short data;
    data = 0;
    if(5==5)
    {
        
        data = (short)RAND32();
    }
    if(5==5)
    {
        {
            
            data++;
            short result = data;
            printIntLine(result);
        }
"
12819,0,CWE590_Free_Memory_Not_on_Heap__delete_class_static_64a.cpp,"    TwoIntsClass * data;
    data = NULL; 
    {
        
        static TwoIntsClass dataBuffer;
        dataBuffer.intOne = 1;
        dataBuffer.intTwo = 1;
        data = &dataBuffer;
    }
"
12067,1,CWE587_Assignment_of_Fixed_Address_to_Pointer__basic_17.c,"    int k;
    for(k = 0; k < 1; k++)
    {
        {
            
            char charStack = 'a';
            char *charPointer = &charStack;
            printHexCharLine(*charPointer);
        }
"
8676,0,CWE369_Divide_by_Zero__float_rand_41.c,"    float data;
    
    data = 0.0F;
    
    data = (float)RAND32();
"
12169,0,CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_68a.cpp,"    size_t data;
    
    data = 0;
    
    fscanf(stdin, ""%zu"", &data);
    badData = data;
"
17982,0,CWE197_Numeric_Truncation_Error__short_rand_33.cpp,"    short data;
    short &dataRef = data;
    
    data = -1;
    
    data = (short)RAND32();
    {
        short data = dataRef;
        {
            
            char charData = (char)data;
            printHexCharLine(charData);
        }
"
15242,0,CWE457_Use_of_Uninitialized_Variable__new_struct_array_no_init_18.cpp,"    twoIntsStruct * data;
    data = new twoIntsStruct[10];
    goto source;
source:
    
    ; 
    goto sink;
sink:
    
    {
        int i;
        for(i=0; i<10; i++)
        {
            printIntLine(data[i].intOne);
            printIntLine(data[i].intTwo);
        }
    }
    
"
14861,0,CWE415_Double_Free__new_delete_array_int_84a.cpp,"    int * data;
    
    data = NULL;
    CWE415_Double_Free__new_delete_array_int_84_bad * badObject = new CWE415_Double_Free__new_delete_array_int_84_bad(data);
"
9431,0,CWE457_Use_of_Uninitialized_Variable__int_array_declare_no_init_05.c,"    int * data;
    int dataUninitArray[10];
    data = dataUninitArray;
    if(staticTrue)
    {
        
        ; 
    }
    if(staticTrue)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i]);
            }
        }
"
10670,1,CWE758_Undefined_Behavior__int_pointer_malloc_use_08.c,"    if(staticReturnsTrue())
    {
        {
            int * data;
            int * * pointer = (int * *)malloc(sizeof(int *));
            if (pointer == NULL) {exit(-1);}
            
            data = (int *)malloc(sizeof(int));
            if (data == NULL) {exit(-1);}
            *data = 5;
            *pointer = data; 
            {
                int * data = *pointer;
                printIntLine(*data);
            }
            free(pointer);
        }
"
4915,0,CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_66a.c,"    char * data;
    char * dataArray[5];
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
    dataArray[2] = data;
"
18016,0,CWE563_Unused_Variable__unused_uninit_variable_struct_01.c,"    twoIntsStruct data;
    
    ; 
    
    
"
1265,0,CWE401_Memory_Leak__struct_twoIntsStruct_calloc_73a.cpp,"    struct _twoIntsStruct * data;
    list<struct _twoIntsStruct *> dataList;
    data = NULL;
    
    data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));
    if (data == NULL) {exit(-1);}
    
    data[0].intOne = 0;
    data[0].intTwo = 0;
    printStructLine((twoIntsStruct *)&data[0]);
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
15346,0,CWE197_Numeric_Truncation_Error__int_fgets_to_short_42.c,"    int data;
    
    data = -1;
    data = badSource(data);
    {
        
        short shortData = (short)data;
        printShortLine(shortData);
"
14711,0,CWE590_Free_Memory_Not_on_Heap__delete_array_int_static_08.cpp,"    int * data;
    data = NULL; 
    if(staticReturnsTrue())
    {
        {
            
            static int dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5;
                }
            }
            data = dataBuffer;
        }
    }
    printIntLine(data[0]);
    
"
17004,1,CWE758_Undefined_Behavior__long_new_use_06.cpp,"    if(STATIC_CONST_FIVE!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            long data;
            data = 5L;
            long * pointer = new long;
            *pointer = data; 
            {
                long data = *pointer;
                printLongLine(data);
            }
            delete pointer;
        }
"
1816,0,CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_54a.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
4040,0,CWE369_Divide_by_Zero__float_fgets_12.c,"    float data;
    
    data = 0.0F;
    if(globalReturnsTrueOrFalse())
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE];
            
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                
                data = (float)atof(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    else
    {
        
        data = 2.0F;
    }
    if(globalReturnsTrueOrFalse())
    {
        {
            
            int result = (int)(100.0 / data);
            printIntLine(result);
        }
    }
    else
    {
        
        if(fabs(data) > 0.000001)
        {
            int result = (int)(100.0 / data);
            printIntLine(result);
        }
        else
        {
            printLine(""This would result in a divide by zero"");
        }
"
5017,0,CWE190_Integer_Overflow__char_max_preinc_66a.c,"    char data;
    char dataArray[5];
    data = ' ';
    
    data = CHAR_MAX;
    
    dataArray[2] = data;
"
11305,0,CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_16.c,"    unsigned int data;
    data = 0;
    while(1)
    {
        
        fscanf (stdin, ""%u"", &data);
        break;
    }
    while(1)
    {
        {
            
            data++;
            unsigned int result = data;
            printUnsignedLine(result);
        }
        break;
"
2557,0,CWE369_Divide_by_Zero__int_zero_divide_02.c,"    int data;
    
    data = -1;
    if(1)
    {
        
        data = 0;
    }
    if(1)
    {
        
        printIntLine(100 / data);
"
16744,0,CWE190_Integer_Overflow__int64_t_fscanf_postinc_68a.c,"    int64_t data;
    data = 0LL;
    
    fscanf (stdin, ""%"" SCNd64, &data);
    CWE190_Integer_Overflow__int64_t_fscanf_postinc_68_badData = data;
"
18661,0,CWE134_Uncontrolled_Format_String__char_file_snprintf_16.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    while(1)
    {
        {
            
            size_t dataLen = strlen(data);
            FILE * pFile;
            
            if (100-dataLen > 1)
            {
                pFile = fopen(FILENAME, ""r"");
                if (pFile != NULL)
                {
                    
                    if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                    {
                        printLine(""fgets() failed"");
                        
                        data[dataLen] = '\0';
                    }
                    fclose(pFile);
                }
            }
        }
        break;
    }
    while(1)
    {
        {
            char dest[100] = """";
            
            SNPRINTF(dest, 100-1, data);
            printLine(dest);
        }
        break;
"
263,0,CWE197_Numeric_Truncation_Error__int_rand_to_short_73a.cpp,"    int data;
    list<int> dataList;
    
    data = -1;
    
    data = RAND32();
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
18009,0,CWE401_Memory_Leak__malloc_realloc_char_13.c,"    if(GLOBAL_CONST_FIVE==5)
    {
        {
            char * data = (char *)malloc(100*sizeof(char));
            if (data == NULL) {exit(-1);}
            
            strcpy(data, ""A String"");
            printLine(data);
            
            data = (char *)realloc(data, (130000)*sizeof(char));
            if (data != NULL)
            {
                
                strcpy(data, ""New String"");
                printLine(data);
                free(data);
            }
        }
"
469,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_53a.c,"    size_t data;
    
    data = 0;
    
    data = rand();
"
14741,0,CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_72a.cpp,"    char * data;
    vector<char *> dataVector;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
16792,0,CWE476_NULL_Pointer_Dereference__class_22a.cpp,"    TwoIntsClass * data;
    
    data = NULL;
    badGlobal = 1; 
"
17518,0,CWE190_Integer_Overflow__int_max_square_82_bad.cpp,"Label Definition File: CWE190_Integer_Overflow__int.label.xml
Template File: sources-sinks-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 190 Integer Overflow
 * BadSource: max Set data to the max value for int
 * GoodSource: Set data to a small, non-zero number (two)
 * Sinks: square
 *    GoodSink: Ensure there will not be an overflow before squaring data
 *    BadSink : Square data, which can lead to overflow
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE190_Integer_Overflow__int_max_square_82.h""

#include <math.h>

namespace CWE190_Integer_Overflow__int_max_square_82
{

void CWE190_Integer_Overflow__int_max_square_82_bad::action(int data)
{
    {
        
        int result = data * data;
        printIntLine(result);
    }
}

}
"
10925,0,CWE197_Numeric_Truncation_Error__short_large_02.c,"    short data;
    
    data = -1;
    if(1)
    {
        
        data = CHAR_MAX + 1;
    }
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
4039,0,CWE590_Free_Memory_Not_on_Heap__delete_struct_placement_new_34.cpp,"    twoIntsStruct * data;
    unionType myUnion;
    data = NULL; 
    {
        
        char buffer[sizeof(twoIntsStruct)];
        twoIntsStruct * dataBuffer = new(buffer) twoIntsStruct;
        dataBuffer->intOne = 1;
        dataBuffer->intTwo = 1;
        data = dataBuffer;
    }
    myUnion.unionFirst = data;
    {
        twoIntsStruct * data = myUnion.unionSecond;
        printStructLine(data);
        
        delete data;
"
14710,0,CWE457_Use_of_Uninitialized_Variable__twointsclass_array_alloca_partial_init_07.cpp,"    TwoIntsClass * data;
    data = reinterpret_cast<TwoIntsClass *>(ALLOCA(10*sizeof(TwoIntsClass)));
    if(staticFive==5)
    {
        
        for(int i=0; i<(10/2); i++)
        {
            data[i].intOne = i;
            data[i].intTwo = i;
        }
    }
    if(staticFive==5)
    {
        
        for(int i=0; i<10; i++)
        {
            printIntLine(data[i].intOne);
            printIntLine(data[i].intTwo);
        }
"
8235,0,CWE590_Free_Memory_Not_on_Heap__delete_char_static_12.cpp,"    char * data;
    data = NULL; 
    if(globalReturnsTrueOrFalse())
    {
        {
            
            static char dataBuffer;
            dataBuffer = 'A';
            data = &dataBuffer;
        }
    }
    else
    {
        {
            
            char * dataBuffer = new char;
            *dataBuffer = 'A';
            data = dataBuffer;
        }
    }
    printHexCharLine(*data);
    
"
8989,0,CWE415_Double_Free__new_delete_struct_51a.cpp,"    twoIntsStruct * data;
    
    data = NULL;
    data = new twoIntsStruct;
    
    delete data;
"
9264,0,CWE190_Integer_Overflow__short_fscanf_add_45.c,"    short data;
    data = 0;
    
    fscanf (stdin, ""%hd"", &data);
    CWE190_Integer_Overflow__short_fscanf_add_45_badData = data;
"
14200,0,CWE563_Unused_Variable__unused_uninit_variable_struct_21.c,"    twoIntsStruct data;
    
    ; 
    badStatic = 1; 
"
6040,1,CWE252_Unchecked_Return_Value__char_puts_12.c,"    if(globalReturnsTrueOrFalse())
    {
        
        if (PUTS(""string"") == EOF)
        {
            printLine(""puts failed!"");
        }
    }
    else
    {
        
        if (PUTS(""string"") == EOF)
        {
            printLine(""puts failed!"");
        }
"
2513,0,CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_16.c,"    int data;
    
    data = -1;
    while(1)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
        break;
    }
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
1852,0,CWE78_OS_Command_Injection__char_listen_socket_execlp_32.c,"    char * data;
    char * *dataPtr1 = &data;
    char * *dataPtr2 = &data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        char * data = *dataPtr1;
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                data[dataLen + recvResult / sizeof(char)] = '\0';
                
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
        *dataPtr1 = data;
    }
    {
        char * data = *dataPtr2;
        /* execlp - searches for the location of the command among
         * the directories specified by the PATH environment variable */
        
        EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
"
3618,0,CWE134_Uncontrolled_Format_String__char_environment_printf_14.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(globalFive==5)
    {
        {
            
            size_t dataLen = strlen(data);
            char * environment = GETENV(ENV_VARIABLE);
            
            if (environment != NULL)
            {
                
                strncat(data+dataLen, environment, 100-dataLen-1);
            }
        }
    }
    if(globalFive==5)
    {
        
        printf(data);
"
18195,0,CWE190_Integer_Overflow__unsigned_int_rand_multiply_18.c,"    unsigned int data;
    data = 0;
    goto source;
source:
    
    data = (unsigned int)RAND32();
    goto sink;
sink:
    if(data > 0) 
    {
        
        unsigned int result = data * 2;
        printUnsignedLine(result);
"
3784,1,CWE676_Use_of_Potentially_Dangerous_Function__basic_03.cpp,"    if(5==5)
    {
        {
            char charBuffer[CHAR_BUFFER_SIZE];
            
            cin.width(CHAR_BUFFER_SIZE);
            cin >> charBuffer;
            charBuffer[CHAR_BUFFER_SIZE-1] = '\0';
            printLine(charBuffer);
        }
"
9677,0,CWE197_Numeric_Truncation_Error__int_large_to_char_81_bad.cpp,"Label Definition File: CWE197_Numeric_Truncation_Error__int.label.xml
Template File: sources-sink-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 197 Numeric Truncation Error
 * BadSource: large Set data to a number larger than SHRT_MAX
 * GoodSource: Less than CHAR_MAX
 * Sinks: to_char
 *    BadSink : Convert data to a char
 * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE197_Numeric_Truncation_Error__int_large_to_char_81.h""

namespace CWE197_Numeric_Truncation_Error__int_large_to_char_81
{

void CWE197_Numeric_Truncation_Error__int_large_to_char_81_bad::action(int data) const
{
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
    }
}

}
"
4584,1,CWE401_Memory_Leak__malloc_realloc_int_12.c,"    if(globalReturnsTrueOrFalse())
    {
        {
            int * data = (int *)malloc(100*sizeof(int));
            if (data == NULL) {exit(-1);}
            int * tmpData;
            
            data[0] = 5;
            printIntLine(data[0]);
            tmpData = (int *)realloc(data, (130000)*sizeof(int));
            /* FIX: Ensure realloc() was successful before assigning data to the memory block
            * allocated with realloc() */
            if (tmpData != NULL)
            {
                data = tmpData;
                
                data[0] = 10;
                printIntLine(data[0]);
            }
            free(data);
        }
    }
    else
    {
        {
            int * data = (int *)malloc(100*sizeof(int));
            if (data == NULL) {exit(-1);}
            int * tmpData;
            
            data[0] = 5;
            printIntLine(data[0]);
            tmpData = (int *)realloc(data, (130000)*sizeof(int));
            /* FIX: Ensure realloc() was successful before assigning data to the memory block
            * allocated with realloc() */
            if (tmpData != NULL)
            {
                data = tmpData;
                
                data[0] = 10;
                printIntLine(data[0]);
            }
            free(data);
        }
"
17798,0,CWE401_Memory_Leak__struct_twoIntsStruct_malloc_81a.cpp,"    struct _twoIntsStruct * data;
    data = NULL;
    
    data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));
    if (data == NULL) {exit(-1);}
    
    data[0].intOne = 0;
    data[0].intTwo = 0;
    printStructLine((twoIntsStruct *)&data[0]);
    const CWE401_Memory_Leak__struct_twoIntsStruct_malloc_81_base& baseObject = CWE401_Memory_Leak__struct_twoIntsStruct_malloc_81_bad();
"
7954,0,CWE590_Free_Memory_Not_on_Heap__delete_long_alloca_82_bad.cpp,"Label Definition File: CWE590_Free_Memory_Not_on_Heap__delete.pointer.label.xml
Template File: sources-sink-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 590 Free Memory Not on Heap
 * BadSource: alloca Data buffer is allocated on the stack with alloca()
 * GoodSource: Allocate memory on the heap
 * Sinks:
 *    BadSink : Print then free data
 * Flow Variant: 82 Data flow: data passed in a parameter to a virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE590_Free_Memory_Not_on_Heap__delete_long_alloca_82.h""

namespace CWE590_Free_Memory_Not_on_Heap__delete_long_alloca_82
{

void CWE590_Free_Memory_Not_on_Heap__delete_long_alloca_82_bad::action(long * data)
{
    printLongLine(*data);
    
    delete data;
}

}
"
16212,0,CWE690_NULL_Deref_From_Return__int_malloc_45.c,"    int * data;
    data = NULL; 
    
    data = (int *)malloc(1*sizeof(int));
    CWE690_NULL_Deref_From_Return__int_malloc_45_badData = data;
"
3192,0,CWE590_Free_Memory_Not_on_Heap__delete_long_alloca_11.cpp,"    long * data;
    data = NULL; 
    if(globalReturnsTrue())
    {
        {
            
            long * dataBuffer = (long *)ALLOCA(sizeof(long));
            *dataBuffer = 5L;
            data = dataBuffer;
        }
    }
    printLongLine(*data);
    
"
5834,1,CWE252_Unchecked_Return_Value__char_sscanf_11.c,"    if(globalReturnsFalse())
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            
            if (sscanf(SRC, ""%99s\0"", data) == EOF)
            {
                printLine(""sscanf failed!"");
            }
        }
"
18534,0,CWE590_Free_Memory_Not_on_Heap__delete_struct_alloca_65a.cpp,"    twoIntsStruct * data;
    
    void (*funcPtr) (twoIntsStruct *) = badSink;
    data = NULL; 
    {
        
        twoIntsStruct * dataBuffer = (twoIntsStruct *)ALLOCA(sizeof(twoIntsStruct));
        dataBuffer->intOne = 1;
        dataBuffer->intTwo = 1;
        data = dataBuffer;
    }
    
"
18739,0,CWE134_Uncontrolled_Format_String__char_connect_socket_printf_41.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
15887,0,CWE476_NULL_Pointer_Dereference__int_05.c,"    int * data;
    if(staticTrue)
    {
        
        data = NULL;
    }
    if(staticTrue)
    {
        
        printIntLine(*data);
"
15679,0,CWE467_Use_of_sizeof_on_Pointer_Type__short_14.c,"    if(globalFive==5)
    {
        {
            short * badShort = NULL;
            
            badShort = (short *)malloc(sizeof(badShort));
            if (badShort == NULL) {exit(-1);}
            *badShort = 5;
            printShortLine(*badShort);
            free(badShort);
        }
"
12864,0,CWE190_Integer_Overflow__int_fscanf_postinc_16.c,"    int data;
    
    data = 0;
    while(1)
    {
        
        fscanf(stdin, ""%d"", &data);
        break;
    }
    while(1)
    {
        {
            
            data++;
            int result = data;
            printIntLine(result);
        }
        break;
"
14262,0,CWE590_Free_Memory_Not_on_Heap__delete_array_long_declare_53a.cpp,"    long * data;
    data = NULL; 
    {
        
        long dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5L;
            }
        }
        data = dataBuffer;
    }
"
4815,0,CWE563_Unused_Variable__unused_value_long_18.c,"    long data;
    goto source;
source:
    
    data = 5L;
    goto sink;
sink:
    
    data = 10L;
"
13630,0,CWE590_Free_Memory_Not_on_Heap__delete_array_char_declare_53a.cpp,"    char * data;
    data = NULL; 
    {
        
        char dataBuffer[100];
        memset(dataBuffer, 'A', 100-1); 
        dataBuffer[100-1] = '\0'; 
        data = dataBuffer;
    }
"
4725,0,CWE369_Divide_by_Zero__int_zero_modulo_41.c,"    int data;
    
    data = -1;
    
    data = 0;
"
11053,0,CWE457_Use_of_Uninitialized_Variable__int_array_declare_no_init_12.c,"    int * data;
    int dataUninitArray[10];
    data = dataUninitArray;
    if(globalReturnsTrueOrFalse())
    {
        
        ; 
    }
    else
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                data[i] = i;
            }
        }
    }
    if(globalReturnsTrueOrFalse())
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i]);
            }
        }
    }
    else
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                data[i] = i;
            }
        }
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i]);
            }
        }
"
7695,0,CWE190_Integer_Overflow__short_fscanf_multiply_66a.c,"    short data;
    short dataArray[5];
    data = 0;
    
    fscanf (stdin, ""%hd"", &data);
    
    dataArray[2] = data;
"
1431,0,CWE590_Free_Memory_Not_on_Heap__delete_long_placement_new_16.cpp,"    long * data;
    data = NULL; 
    while(1)
    {
        {
            
            char buffer[sizeof(long)];
            long * dataBuffer = new(buffer) long;
            *dataBuffer = 5L;
            data = dataBuffer;
        }
        break;
    }
    printLongLine(*data);
    
"
7394,0,CWE190_Integer_Overflow__char_max_multiply_08.c,"    char data;
    data = ' ';
    if(staticReturnsTrue())
    {
        
        data = CHAR_MAX;
    }
    if(staticReturnsTrue())
    {
        if(data > 0) 
        {
            
            char result = data * 2;
            printHexCharLine(result);
        }
"
15891,0,CWE415_Double_Free__new_delete_array_char_02.cpp,"    char * data;
    
    data = NULL;
    if(1)
    {
        data = new char[100];
        
        delete [] data;
    }
    if(1)
    {
        
        delete [] data;
"
10697,0,CWE758_Undefined_Behavior__int64_t_new_use_05.cpp,"    if(staticTrue)
    {
        {
            int64_t * pointer = new int64_t;
            int64_t data = *pointer; 
            delete pointer;
            printLongLongLine(data);
        }
"
7278,0,CWE134_Uncontrolled_Format_String__char_file_printf_44.c,"    char * data;
    
    void (*funcPtr) (char *) = badSink;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        FILE * pFile;
        
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
    
"
9865,0,CWE197_Numeric_Truncation_Error__int_listen_socket_to_char_52a.c,"    int data;
    
    data = -1;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
4486,0,CWE78_OS_Command_Injection__char_connect_socket_execlp_18.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    goto source;
source:
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
"
7837,0,CWE190_Integer_Overflow__unsigned_int_rand_preinc_51a.c,"    unsigned int data;
    data = 0;
    
    data = (unsigned int)RAND32();
"
9481,0,CWE369_Divide_by_Zero__float_connect_socket_66a.c,"    float data;
    float dataArray[5];
    
    data = 0.0F;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = (float)atof(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
    dataArray[2] = data;
"
5095,1,CWE758_Undefined_Behavior__char_pointer_alloca_use_07.c,"    if(staticFive!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            char * data;
            char * * pointer = (char * *)ALLOCA(sizeof(char *));
            data = ""string"";
            *pointer = data; 
            {
                char * data = *pointer;
                printLine(data);
            }
        }
"
15994,0,CWE590_Free_Memory_Not_on_Heap__free_int_static_05.c,"    int * data;
    data = NULL; 
    if(staticTrue)
    {
        {
            
            static int dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5;
                }
            }
            data = dataBuffer;
        }
    }
    printIntLine(data[0]);
    
"
13218,0,CWE369_Divide_by_Zero__float_fgets_67a.c,"    float data;
    CWE369_Divide_by_Zero__float_fgets_67_structType myStruct;
    
    data = 0.0F;
    {
        char inputBuffer[CHAR_ARRAY_SIZE];
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = (float)atof(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    myStruct.structFirst = data;
"
12143,1,CWE467_Use_of_sizeof_on_Pointer_Type__int_14.c,"    if(globalFive!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            int * goodInt = NULL;
            
            goodInt = (int *)malloc(sizeof(*goodInt));
            if (goodInt == NULL) {exit(-1);}
            *goodInt = 6;
            printIntLine(*goodInt);
            free(goodInt);
        }
"
10531,0,CWE369_Divide_by_Zero__float_listenSocket_83a.cpp,"    float data;
    
    data = 0.0F;
"
15407,1,CWE758_Undefined_Behavior__class_new_use_13.cpp,"    if(GLOBAL_CONST_FIVE!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            TwoIntsClass data;
            data.intOne = 1;
            data.intTwo = 2;
            TwoIntsClass * pointer = new TwoIntsClass;
            *pointer = data; 
            {
                TwoIntsClass data = *pointer;
                printIntLine(data.intOne);
                printIntLine(data.intTwo);
            }
            delete pointer;
        }
"
3954,0,CWE415_Double_Free__malloc_free_int64_t_16.c,"    int64_t * data;
    
    data = NULL;
    while(1)
    {
        data = (int64_t *)malloc(100*sizeof(int64_t));
        if (data == NULL) {exit(-1);}
        
        free(data);
        break;
    }
    while(1)
    {
        
        free(data);
        break;
"
18013,0,CWE134_Uncontrolled_Format_String__char_file_printf_11.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(globalReturnsTrue())
    {
        {
            
            size_t dataLen = strlen(data);
            FILE * pFile;
            
            if (100-dataLen > 1)
            {
                pFile = fopen(FILENAME, ""r"");
                if (pFile != NULL)
                {
                    
                    if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                    {
                        printLine(""fgets() failed"");
                        
                        data[dataLen] = '\0';
                    }
                    fclose(pFile);
                }
            }
        }
    }
    if(globalReturnsTrue())
    {
        
        printf(data);
"
12113,0,CWE78_OS_Command_Injection__char_file_execl_09.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(GLOBAL_CONST_TRUE)
    {
        {
            
            size_t dataLen = strlen(data);
            FILE * pFile;
            
            if (100-dataLen > 1)
            {
                pFile = fopen(FILENAME, ""r"");
                if (pFile != NULL)
                {
                    
                    if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                    {
                        printLine(""fgets() failed"");
                        
                        data[dataLen] = '\0';
                    }
                    fclose(pFile);
                }
            }
        }
    }
    
    
"
19082,0,CWE190_Integer_Overflow__int_fscanf_add_42.c,"    int data;
    
    data = 0;
    data = badSource(data);
    {
        
        int result = data + 1;
        printIntLine(result);
"
5776,0,CWE401_Memory_Leak__malloc_realloc_twoIntsStruct_10.c,"    if(globalTrue)
    {
        {
            twoIntsStruct * data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
            if (data == NULL) {exit(-1);}
            
            data[0].intOne = 0;
            data[0].intTwo = 0;
            printStructLine(&data[0]);
            
            data = (twoIntsStruct *)realloc(data, (130000)*sizeof(twoIntsStruct));
            if (data != NULL)
            {
                
                data[0].intOne = 1;
                data[0].intTwo = 1;
                printStructLine(&data[0]);
                free(data);
            }
        }
"
10122,0,CWE690_NULL_Deref_From_Return__int_realloc_52a.c,"    int * data;
    data = NULL; 
    
    data = (int *)realloc(data, 1*sizeof(int));
"
4638,0,CWE78_OS_Command_Injection__char_console_popen_31.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
        
        size_t dataLen = strlen(data);
        
        if (100-dataLen > 1)
        {
            
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgets() */
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
"
18119,0,CWE590_Free_Memory_Not_on_Heap__delete_long_alloca_68a.cpp,"    long * data;
    data = NULL; 
    {
        
        long * dataBuffer = (long *)ALLOCA(sizeof(long));
        *dataBuffer = 5L;
        data = dataBuffer;
    }
    CWE590_Free_Memory_Not_on_Heap__delete_long_alloca_68_badData = data;
"
11735,0,CWE190_Integer_Overflow__char_rand_multiply_04.c,"    char data;
    data = ' ';
    if(STATIC_CONST_TRUE)
    {
        
        data = (char)RAND32();
    }
    if(STATIC_CONST_TRUE)
    {
        if(data > 0) 
        {
            
            char result = data * 2;
            printHexCharLine(result);
        }
"
16298,0,CWE197_Numeric_Truncation_Error__short_large_62a.cpp,"    short data;
    
    data = -1;
    badSource(data);
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
5725,0,CWE401_Memory_Leak__new_array_int_17.cpp,"    int i,j;
    int * data;
    data = NULL;
    for(i = 0; i < 1; i++)
    {
        
        data = new int[100];
        
        data[0] = 5;
        printIntLine(data[0]);
    }
    for(j = 0; j < 1; j++)
    {
        
        ; 
"
17387,0,CWE190_Integer_Overflow__int_listen_socket_square_08.c,"    int data;
    
    data = 0;
    if(staticReturnsTrue())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(staticReturnsTrue())
    {
        {
            
            int result = data * data;
            printIntLine(result);
        }
"
134,0,CWE416_Use_After_Free__new_delete_struct_05.cpp,"    twoIntsStruct * data;
    
    data = NULL;
    if(staticTrue)
    {
        data = new twoIntsStruct;
        data->intOne = 1;
        data->intTwo = 2;
        
        delete data;
    }
    if(staticTrue)
    {
        
        printStructLine(data);
        
"
10910,0,CWE590_Free_Memory_Not_on_Heap__free_long_alloca_09.c,"    long * data;
    data = NULL; 
    if(GLOBAL_CONST_TRUE)
    {
        {
            
            long * dataBuffer = (long *)ALLOCA(100*sizeof(long));
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5L;
                }
            }
            data = dataBuffer;
        }
    }
    printLongLine(data[0]);
    
"
8792,0,CWE758_Undefined_Behavior__long_malloc_use_04.c,"    if(STATIC_CONST_TRUE)
    {
        {
            long * pointer = (long *)malloc(sizeof(long));
            if (pointer == NULL) {exit(-1);}
            long data = *pointer; 
            free(pointer);
            printLongLine(data);
        }
"
7063,0,CWE78_OS_Command_Injection__char_listen_socket_execlp_08.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(staticReturnsTrue())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                data[dataLen + recvResult / sizeof(char)] = '\0';
                
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    /* execlp - searches for the location of the command among
     * the directories specified by the PATH environment variable */
    
"
1019,0,CWE78_OS_Command_Injection__char_console_popen_16.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    while(1)
    {
        {
            
            size_t dataLen = strlen(data);
            
            if (100-dataLen > 1)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
                {
                    /* The next few lines remove the carriage return from the string that is
                     * inserted by fgets() */
                    dataLen = strlen(data);
"
11219,0,CWE401_Memory_Leak__struct_twoIntsStruct_malloc_06.c,"    struct _twoIntsStruct * data;
    data = NULL;
    if(STATIC_CONST_FIVE==5)
    {
        
        data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));
        if (data == NULL) {exit(-1);}
        
        data[0].intOne = 0;
        data[0].intTwo = 0;
        printStructLine((twoIntsStruct *)&data[0]);
    }
    if(STATIC_CONST_FIVE==5)
    {
        
        ; 
"
16342,0,CWE457_Use_of_Uninitialized_Variable__double_array_alloca_no_init_64a.c,"    double * data;
    data = (double *)ALLOCA(10*sizeof(double));
    
    ; 
"
244,0,CWE190_Integer_Overflow__short_rand_multiply_04.c,"    short data;
    data = 0;
    if(STATIC_CONST_TRUE)
    {
        
        data = (short)RAND32();
    }
    if(STATIC_CONST_TRUE)
    {
        if(data > 0) 
        {
            
            short result = data * 2;
            printIntLine(result);
        }
"
821,0,CWE190_Integer_Overflow__int_connect_socket_postinc_02.c,"    int data;
    
    data = 0;
    if(1)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(1)
    {
        {
            
            data++;
            int result = data;
            printIntLine(result);
        }
"
7919,0,CWE369_Divide_by_Zero__int_zero_modulo_34.c,"    int data;
    CWE369_Divide_by_Zero__int_zero_modulo_34_unionType myUnion;
    
    data = -1;
    
    data = 0;
    myUnion.unionFirst = data;
    {
        int data = myUnion.unionSecond;
        
        printIntLine(100 % data);
"
12645,0,CWE134_Uncontrolled_Format_String__char_console_fprintf_68a.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        
        if (100-dataLen > 1)
        {
            
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgets() */
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
                    data[dataLen-1] = '\0';
                }
            }
            else
            {
                printLine(""fgets() failed"");
                
                data[dataLen] = '\0';
            }
        }
    }
    CWE134_Uncontrolled_Format_String__char_console_fprintf_68_badData = data;
"
17372,0,CWE190_Integer_Overflow__int64_t_max_add_05.c,"    int64_t data;
    data = 0LL;
    if(staticTrue)
    {
        
        data = LLONG_MAX;
    }
    if(staticTrue)
    {
        {
            
            int64_t result = data + 1;
            printLongLongLine(result);
        }
"
4820,0,CWE190_Integer_Overflow__int_listen_socket_preinc_63a.c,"    int data;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
1039,0,CWE190_Integer_Overflow__unsigned_int_rand_add_67a.c,"    unsigned int data;
    CWE190_Integer_Overflow__unsigned_int_rand_add_67_structType myStruct;
    data = 0;
    
    data = (unsigned int)RAND32();
    myStruct.structFirst = data;
"
16786,0,CWE78_OS_Command_Injection__char_listen_socket_execl_42.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    data = badSource(data);
    
    
"
4903,0,CWE469_Use_of_Pointer_Subtraction_to_Determine_Size__char_01.c,"    {
        char string1[] = SOURCE_STRING;
        char string2[] = SOURCE_STRING;
        char * slashInString1;
        size_t indexOfSlashInString1;
        slashInString1 = strchr(string1, '/');
        if (slashInString1 == NULL)
        {
            exit(1);
        }
        
        indexOfSlashInString1 = (size_t)(slashInString1 - string2);
        
        printUnsignedLine(indexOfSlashInString1);
"
1107,0,CWE190_Integer_Overflow__short_rand_postinc_08.c,"    short data;
    data = 0;
    if(staticReturnsTrue())
    {
        
        data = (short)RAND32();
    }
    if(staticReturnsTrue())
    {
        {
            
            data++;
            short result = data;
            printIntLine(result);
        }
"
4424,0,CWE457_Use_of_Uninitialized_Variable__struct_array_declare_no_init_17.c,"    int i,j;
    twoIntsStruct * data;
    twoIntsStruct dataUninitArray[10];
    data = dataUninitArray;
    for(i = 0; i < 1; i++)
    {
        
        ; 
    }
    for(j = 0; j < 1; j++)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i].intOne);
                printIntLine(data[i].intTwo);
            }
        }
"
10876,0,CWE590_Free_Memory_Not_on_Heap__delete_long_alloca_45.cpp,"    long * data;
    data = NULL; 
    {
        
        long * dataBuffer = (long *)ALLOCA(sizeof(long));
        *dataBuffer = 5L;
        data = dataBuffer;
    }
    badData = data;
"
12042,0,CWE590_Free_Memory_Not_on_Heap__delete_class_static_05.cpp,"    TwoIntsClass * data;
    data = NULL; 
    if(staticTrue)
    {
        {
            
            static TwoIntsClass dataBuffer;
            dataBuffer.intOne = 1;
            dataBuffer.intTwo = 1;
            data = &dataBuffer;
        }
    }
    printIntLine(data->intOne);
    
"
10040,0,CWE590_Free_Memory_Not_on_Heap__delete_char_static_05.cpp,"    char * data;
    data = NULL; 
    if(staticTrue)
    {
        {
            
            static char dataBuffer;
            dataBuffer = 'A';
            data = &dataBuffer;
        }
    }
    printHexCharLine(*data);
    
"
16043,0,CWE190_Integer_Overflow__int64_t_fscanf_square_09.c,"    int64_t data;
    data = 0LL;
    if(GLOBAL_CONST_TRUE)
    {
        
        fscanf (stdin, ""%"" SCNd64, &data);
    }
    if(GLOBAL_CONST_TRUE)
    {
        {
            
            int64_t result = data * data;
            printLongLongLine(result);
        }
"
3958,0,CWE415_Double_Free__new_delete_class_52a.cpp,"    TwoIntsClass * data;
    
    data = NULL;
    data = new TwoIntsClass;
    
    delete data;
"
665,0,CWE758_Undefined_Behavior__long_alloca_use_08.c,"    if(staticReturnsTrue())
    {
        {
            long * pointer = (long *)ALLOCA(sizeof(long));
            long data = *pointer; 
            printLongLine(data);
        }
"
16403,0,CWE690_NULL_Deref_From_Return__long_malloc_09.c,"    long * data;
    data = NULL; 
    
    data = (long *)malloc(1*sizeof(long));
    if(GLOBAL_CONST_TRUE)
    {
        
        data[0] = 5L;
        printLongLine(data[0]);
        free(data);
"
2928,0,CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_67a.cpp,"    size_t data;
    structType myStruct;
    
    data = 0;
    
    fscanf(stdin, ""%zu"", &data);
    myStruct.structFirst = data;
"
11126,0,CWE369_Divide_by_Zero__int_zero_divide_22a.c,"    int data;
    
    data = -1;
    
    data = 0;
    CWE369_Divide_by_Zero__int_zero_divide_22_badGlobal = 1; 
"
2826,0,CWE758_Undefined_Behavior__struct_new_use_17.cpp,"    int j;
    for(j = 0; j < 1; j++)
    {
        {
            twoIntsStruct * pointer = new twoIntsStruct;
            twoIntsStruct data = *pointer; 
            delete pointer;
            printIntLine(data.intOne);
            printIntLine(data.intTwo);
        }
"
3661,0,CWE590_Free_Memory_Not_on_Heap__delete_array_class_alloca_68a.cpp,"    TwoIntsClass * data;
    data = NULL; 
    {
        
        TwoIntsClass * dataBuffer = (TwoIntsClass *)ALLOCA(100*sizeof(TwoIntsClass));
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i].intOne = 1;
                dataBuffer[i].intTwo = 1;
            }
        }
        data = dataBuffer;
    }
    CWE590_Free_Memory_Not_on_Heap__delete_array_class_alloca_68_badData = data;
"
17327,0,CWE590_Free_Memory_Not_on_Heap__free_long_alloca_67a.c,"    long * data;
    CWE590_Free_Memory_Not_on_Heap__free_long_alloca_67_structType myStruct;
    data = NULL; 
    {
        
        long * dataBuffer = (long *)ALLOCA(100*sizeof(long));
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5L;
            }
        }
        data = dataBuffer;
    }
    myStruct.structFirst = data;
"
15494,0,CWE190_Integer_Overflow__int64_t_max_square_17.c,"    int i,j;
    int64_t data;
    data = 0LL;
    for(i = 0; i < 1; i++)
    {
        
        data = LLONG_MAX;
    }
    for(j = 0; j < 1; j++)
    {
        {
            
            int64_t result = data * data;
            printLongLongLine(result);
        }
"
13638,1,CWE252_Unchecked_Return_Value__char_snprintf_10.c,"    if(globalTrue)
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            
            if (SNPRINTF(data,100-strlen(SRC)-1, ""%s\n"", SRC) < 0)
            {
                printLine(""snprintf failed!"");
            }
        }
"
13572,0,CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_21.c,"    unsigned int data;
    data = 0;
    
    fscanf (stdin, ""%u"", &data);
    badStatic = 1; 
"
15567,0,CWE401_Memory_Leak__struct_twoIntsStruct_calloc_22a.c,"    struct _twoIntsStruct * data;
    data = NULL;
    
    data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));
    if (data == NULL) {exit(-1);}
    
    data[0].intOne = 0;
    data[0].intTwo = 0;
    printStructLine((twoIntsStruct *)&data[0]);
    CWE401_Memory_Leak__struct_twoIntsStruct_calloc_22_badGlobal = 1; 
"
15460,0,CWE190_Integer_Overflow__char_rand_add_22a.c,"    char data;
    data = ' ';
    
    data = (char)RAND32();
    CWE190_Integer_Overflow__char_rand_add_22_badGlobal = 1; 
"
13192,0,CWE401_Memory_Leak__int_calloc_41.c,"    int * data;
    data = NULL;
    
    data = (int *)calloc(100, sizeof(int));
    if (data == NULL) {exit(-1);}
    
    data[0] = 5;
    printIntLine(data[0]);
"
14483,0,CWE190_Integer_Overflow__int_max_preinc_18.c,"    int data;
    
    data = 0;
    goto source;
source:
    
    data = INT_MAX;
    goto sink;
sink:
    {
        
        ++data;
        int result = data;
        printIntLine(result);
"
11173,0,CWE758_Undefined_Behavior__class_pointer_new_use_14.cpp,"    if(globalFive==5)
    {
        {
            TwoIntsClass * * pointer = new TwoIntsClass *;
            TwoIntsClass * data = *pointer; 
            delete pointer;
            printIntLine(data->intOne);
            printIntLine(data->intTwo);
        }
"
9704,1,CWE252_Unchecked_Return_Value__char_putchar_11.c,"    if(globalReturnsTrue())
    {
        
        if (putchar((int)'A') == EOF)
        {
            printLine(""putchar failed!"");
        }
"
5549,1,CWE758_Undefined_Behavior__int_pointer_new_use_11.cpp,"    if(globalReturnsFalse())
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            int * data;
            
            data = new int;
            *data = 5;
            int * * pointer = new int *;
            *pointer = data; 
            {
                int * data = *pointer;
                printIntLine(*data);
            }
            delete pointer;
        }
"
13334,0,CWE415_Double_Free__new_delete_char_82_bad.cpp,"Label Definition File: CWE415_Double_Free__new_delete.label.xml
Template File: sources-sinks-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 415 Double Free
 * BadSource:  Allocate data using new and Deallocae data using delete
 * GoodSource: Allocate data using new
 * Sinks:
 *    GoodSink: do nothing
 *    BadSink : Deallocate data using delete
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE415_Double_Free__new_delete_char_82.h""

namespace CWE415_Double_Free__new_delete_char_82
{

void CWE415_Double_Free__new_delete_char_82_bad::action(char * data)
{
    
    delete data;
}

}
"
2218,0,CWE134_Uncontrolled_Format_String__char_environment_fprintf_61a.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    data = CWE134_Uncontrolled_Format_String__char_environment_fprintf_61b_badSource(data);
    
"
8846,0,CWE758_Undefined_Behavior__double_pointer_malloc_use_15.c,"    switch(6)
    {
    case 6:
    {
        double * * pointer = (double * *)malloc(sizeof(double *));
        if (pointer == NULL) {exit(-1);}
        double * data = *pointer; 
        free(pointer);
        printDoubleLine(*data);
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
3219,0,CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_22a.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_22_badGlobal = 1; 
"
19117,0,CWE190_Integer_Overflow__unsigned_int_max_square_45.c,"    unsigned int data;
    data = 0;
    
    data = UINT_MAX;
    CWE190_Integer_Overflow__unsigned_int_max_square_45_badData = data;
"
3120,1,CWE758_Undefined_Behavior__int_pointer_alloca_use_11.c,"    if(globalReturnsTrue())
    {
        {
            int * data;
            int * * pointer = (int * *)ALLOCA(sizeof(int *));
            
            data = (int *)malloc(sizeof(int));
            if (data == NULL) {exit(-1);}
            *data = 5;
            *pointer = data; 
            {
                int * data = *pointer;
                printIntLine(*data);
            }
        }
"
14347,0,CWE197_Numeric_Truncation_Error__int_listen_socket_to_short_41.c,"    int data;
    
    data = -1;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
854,0,CWE469_Use_of_Pointer_Subtraction_to_Determine_Size__char_04.c,"    if(STATIC_CONST_TRUE)
    {
        {
            char string1[] = SOURCE_STRING;
            char string2[] = SOURCE_STRING;
            char * slashInString1;
            size_t indexOfSlashInString1;
            slashInString1 = strchr(string1, '/');
            if (slashInString1 == NULL)
            {
                exit(1);
            }
            
            indexOfSlashInString1 = (size_t)(slashInString1 - string2);
            
            printUnsignedLine(indexOfSlashInString1);
        }
"
2475,0,CWE590_Free_Memory_Not_on_Heap__delete_char_placement_new_52a.cpp,"    char * data;
    data = NULL; 
    {
        
        char buffer[sizeof(char)];
        char * dataBuffer = new(buffer) char;
        *dataBuffer = 'A';
        data = dataBuffer;
    }
"
18544,0,CWE252_Unchecked_Return_Value__char_sscanf_08.c,"    if(staticReturnsTrue())
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            
            sscanf(SRC, ""%99s\0"", data);
        }
"
11257,0,CWE190_Integer_Overflow__int64_t_fscanf_square_81_bad.cpp,"Label Definition File: CWE190_Integer_Overflow.label.xml
Template File: sources-sinks-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 190 Integer Overflow
 * BadSource: fscanf Read data from the console using fscanf()
 * GoodSource: Set data to a small, non-zero number (two)
 * Sinks: square
 *    GoodSink: Ensure there will not be an overflow before squaring data
 *    BadSink : Square data, which can lead to overflow
 * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE190_Integer_Overflow__int64_t_fscanf_square_81.h""

#include <math.h>
#include <inttypes.h>

namespace CWE190_Integer_Overflow__int64_t_fscanf_square_81
{

void CWE190_Integer_Overflow__int64_t_fscanf_square_81_bad::action(int64_t data) const
{
    {
        
        int64_t result = data * data;
        printLongLongLine(result);
    }
}

}
"
12389,0,CWE78_OS_Command_Injection__char_connect_socket_system_12.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(globalReturnsTrueOrFalse())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET connectSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
"
5440,0,CWE134_Uncontrolled_Format_String__char_connect_socket_printf_66a.c,"    char * data;
    char * dataArray[5];
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
    dataArray[2] = data;
"
7361,0,CWE758_Undefined_Behavior__char_malloc_use_15.c,"    switch(6)
    {
    case 6:
    {
        char * pointer = (char *)malloc(sizeof(char));
        if (pointer == NULL) {exit(-1);}
        char data = *pointer; 
        free(pointer);
        printHexCharLine(data);
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
10856,1,CWE469_Use_of_Pointer_Subtraction_to_Determine_Size__char_10.c,"    if(globalTrue)
    {
        {
            char string1[] = SOURCE_STRING;
            char * slashInString1;
            size_t indexOfSlashInString1;
            slashInString1 = strchr(string1, '/');
            if (slashInString1 == NULL)
            {
                exit(1);
            }
            
            indexOfSlashInString1 = (size_t)(slashInString1 - string1);
            
            printUnsignedLine(indexOfSlashInString1);
        }
"
6403,0,CWE590_Free_Memory_Not_on_Heap__delete_array_long_declare_11.cpp,"    long * data;
    data = NULL; 
    if(globalReturnsTrue())
    {
        {
            
            long dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5L;
                }
            }
            data = dataBuffer;
        }
    }
    printLongLine(data[0]);
    
"
2837,0,CWE134_Uncontrolled_Format_String__char_console_snprintf_15.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    switch(6)
    {
    case 6:
    {
        
        size_t dataLen = strlen(data);
        
        if (100-dataLen > 1)
        {
            
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgets() */
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
                    data[dataLen-1] = '\0';
                }
            }
            else
            {
                printLine(""fgets() failed"");
                
                data[dataLen] = '\0';
            }
        }
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
    {
        char dest[100] = """";
        
        SNPRINTF(dest, 100-1, data);
        printLine(dest);
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
1732,1,CWE252_Unchecked_Return_Value__char_fputc_15.c,"    switch(6)
    {
    case 6:
        
        if (fputc((int)'A', stdout) == EOF)
        {
            printLine(""fputc failed!"");
        }
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
7776,0,CWE590_Free_Memory_Not_on_Heap__delete_array_struct_alloca_51a.cpp,"    twoIntsStruct * data;
    data = NULL; 
    {
        
        twoIntsStruct * dataBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i].intOne = 1;
                dataBuffer[i].intTwo = 1;
            }
        }
        data = dataBuffer;
    }
"
6092,0,CWE590_Free_Memory_Not_on_Heap__delete_int_placement_new_17.cpp,"    int i;
    int * data;
    data = NULL; 
    for(i = 0; i < 1; i++)
    {
        {
            
            char buffer[sizeof(int)];
            int * dataBuffer = new(buffer) int;
            *dataBuffer = 5;
            data = dataBuffer;
        }
    }
    printIntLine(*data);
    
"
6612,0,CWE190_Integer_Overflow__char_fscanf_multiply_54a.c,"    char data;
    data = ' ';
    
    fscanf (stdin, ""%c"", &data);
"
7750,0,CWE190_Integer_Overflow__short_rand_postinc_54a.c,"    short data;
    data = 0;
    
    data = (short)RAND32();
"
12878,1,CWE401_Memory_Leak__malloc_realloc_twoIntsStruct_17.c,"    int k;
    for(k = 0; k < 1; k++)
    {
        {
            twoIntsStruct * data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
            if (data == NULL) {exit(-1);}
            twoIntsStruct * tmpData;
            
            data[0].intOne = 0;
            data[0].intTwo = 0;
            printStructLine(&data[0]);
            tmpData = (twoIntsStruct *)realloc(data, (130000)*sizeof(twoIntsStruct));
            /* FIX: Ensure realloc() was successful before assigning data to the memory block
            * allocated with realloc() */
            if (tmpData != NULL)
            {
                data = tmpData;
                
                data[0].intOne = 1;
                data[0].intTwo = 1;
                printStructLine(&data[0]);
            }
            free(data);
        }
"
1696,0,CWE190_Integer_Overflow__int_rand_multiply_65a.c,"    int data;
    
    void (*funcPtr) (int) = CWE190_Integer_Overflow__int_rand_multiply_65b_badSink;
    
    data = 0;
    
    data = RAND32();
    
"
9885,0,CWE197_Numeric_Truncation_Error__int_fscanf_to_char_43.cpp,"    int data;
    
    data = -1;
    badSource(data);
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
13074,0,CWE134_Uncontrolled_Format_String__char_environment_fprintf_84_bad.cpp,"Label Definition File: CWE134_Uncontrolled_Format_String.label.xml
Template File: sources-sinks-84_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 134 Uncontrolled Format String
 * BadSource: environment Read input from an environment variable
 * GoodSource: Copy a fixed string into data
 * Sinks: fprintf
 *    GoodSink: fprintf with ""%s"" as the second argument and data as the third
 *    BadSink : fprintf with data as the second argument
 * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE134_Uncontrolled_Format_String__char_environment_fprintf_84.h""

#define ENV_VARIABLE ""ADD""

#ifdef _WIN32
#define GETENV getenv
#else
#define GETENV getenv
#endif

namespace CWE134_Uncontrolled_Format_String__char_environment_fprintf_84
{
CWE134_Uncontrolled_Format_String__char_environment_fprintf_84_bad::CWE134_Uncontrolled_Format_String__char_environment_fprintf_84_bad(char * dataCopy)
{
    data = dataCopy;
    {
        
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        
        if (environment != NULL)
        {
            
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
}

CWE134_Uncontrolled_Format_String__char_environment_fprintf_84_bad::~CWE134_Uncontrolled_Format_String__char_environment_fprintf_84_bad()
{
    
    fprintf(stdout, data);
}
}
"
7665,0,CWE78_OS_Command_Injection__char_file_system_72a.cpp,"    char * data;
    vector<char *> dataVector;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
        
        size_t dataLen = strlen(data);
        FILE * pFile;
        
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
7749,0,CWE252_Unchecked_Return_Value__char_snprintf_08.c,"    if(staticReturnsTrue())
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            
            SNPRINTF(data,100-strlen(SRC)-1, ""%s\n"", SRC);
        }
"
3490,0,CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_21.cpp,"    size_t data;
    
    data = 0;
    
    fscanf(stdin, ""%zu"", &data);
    badStatic = 1; 
"
5120,0,CWE190_Integer_Overflow__short_max_square_44.c,"    short data;
    
    void (*funcPtr) (short) = badSink;
    data = 0;
    
    data = SHRT_MAX;
    
"
5850,0,CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_08.cpp,"    size_t data;
    
    data = 0;
    if(staticReturnsTrue())
    {
        
        fscanf(stdin, ""%zu"", &data);
    }
    if(staticReturnsTrue())
    {
        {
            char * myString;
            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
             * for the strcpy() function to not cause a buffer overflow */
            
            if (data > strlen(HELLO_STRING))
            {
                myString = new char[data];
                
                strcpy(myString, HELLO_STRING);
                printLine(myString);
                delete [] myString;
            }
            else
            {
                printLine(""Input is less than the length of the source string"");
            }
        }
"
9641,0,CWE78_OS_Command_Injection__char_environment_popen_34.c,"    char * data;
    CWE78_OS_Command_Injection__char_environment_popen_34_unionType myUnion;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
        
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        
        if (environment != NULL)
        {
            
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    myUnion.unionFirst = data;
    {
        char * data = myUnion.unionSecond;
        {
            FILE *pipe;
            
            pipe = POPEN(data, ""w"");
            if (pipe != NULL)
            {
                PCLOSE(pipe);
            }
        }
"
918,1,CWE758_Undefined_Behavior__int_pointer_alloca_use_04.c,"    if(STATIC_CONST_FALSE)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            int * data;
            int * * pointer = (int * *)ALLOCA(sizeof(int *));
            
            data = (int *)malloc(sizeof(int));
            if (data == NULL) {exit(-1);}
            *data = 5;
            *pointer = data; 
            {
                int * data = *pointer;
                printIntLine(*data);
            }
        }
"
3283,0,CWE190_Integer_Overflow__int_connect_socket_postinc_09.c,"    int data;
    
    data = 0;
    if(GLOBAL_CONST_TRUE)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(GLOBAL_CONST_TRUE)
    {
        {
            
            data++;
            int result = data;
            printIntLine(result);
        }
"
6413,0,CWE190_Integer_Overflow__int_listen_socket_preinc_67a.c,"    int data;
    CWE190_Integer_Overflow__int_listen_socket_preinc_67_structType myStruct;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    myStruct.structFirst = data;
"
3581,0,CWE190_Integer_Overflow__short_fscanf_square_08.c,"    short data;
    data = 0;
    if(staticReturnsTrue())
    {
        
        fscanf (stdin, ""%hd"", &data);
    }
    if(staticReturnsTrue())
    {
        {
            
            short result = data * data;
            printIntLine(result);
        }
"
13348,0,CWE415_Double_Free__new_delete_int_65a.cpp,"    int * data;
    
    void (*funcPtr) (int *) = badSink;
    
    data = NULL;
    data = new int;
    
    delete data;
    
"
13457,0,CWE78_OS_Command_Injection__char_connect_socket_system_44.c,"    char * data;
    
    void (*funcPtr) (char *) = badSink;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
"
8919,0,CWE190_Integer_Overflow__int_fscanf_square_45.c,"    int data;
    
    data = 0;
    
    fscanf(stdin, ""%d"", &data);
    CWE190_Integer_Overflow__int_fscanf_square_45_badData = data;
"
2275,0,CWE401_Memory_Leak__char_calloc_68a.c,"    char * data;
    data = NULL;
    
    data = (char *)calloc(100, sizeof(char));
    if (data == NULL) {exit(-1);}
    
    strcpy(data, ""A String"");
    printLine(data);
    CWE401_Memory_Leak__char_calloc_68_badData = data;
"
14423,0,CWE197_Numeric_Truncation_Error__short_connect_socket_41.c,"    short data;
    
    data = -1;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = (short)atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
18223,0,CWE197_Numeric_Truncation_Error__short_rand_73a.cpp,"    short data;
    list<short> dataList;
    
    data = -1;
    
    data = (short)RAND32();
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
9525,0,CWE190_Integer_Overflow__int64_t_fscanf_multiply_08.c,"    int64_t data;
    data = 0LL;
    if(staticReturnsTrue())
    {
        
        fscanf (stdin, ""%"" SCNd64, &data);
    }
    if(staticReturnsTrue())
    {
        if(data > 0) 
        {
            
            int64_t result = data * 2;
            printLongLongLine(result);
        }
"
16379,0,CWE758_Undefined_Behavior__class_new_use_12.cpp,"    if(globalReturnsTrueOrFalse())
    {
        {
            TwoIntsClass * pointer = new TwoIntsClass;
            TwoIntsClass data = *pointer; 
            delete pointer;
            printIntLine(data.intOne);
            printIntLine(data.intTwo);
        }
    }
    else
    {
        {
            TwoIntsClass data;
            data.intOne = 1;
            data.intTwo = 2;
            TwoIntsClass * pointer = new TwoIntsClass;
            *pointer = data; 
            {
                TwoIntsClass data = *pointer;
                printIntLine(data.intOne);
                printIntLine(data.intTwo);
            }
            delete pointer;
        }
"
3697,0,CWE457_Use_of_Uninitialized_Variable__struct_array_alloca_no_init_04.c,"    twoIntsStruct * data;
    data = (twoIntsStruct *)ALLOCA(10*sizeof(twoIntsStruct));
    if(STATIC_CONST_TRUE)
    {
        
        ; 
    }
    if(STATIC_CONST_TRUE)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i].intOne);
                printIntLine(data[i].intTwo);
            }
        }
"
5206,0,CWE563_Unused_Variable__unused_uninit_variable_char_15.c,"    char data;
    
    ; 
    switch(6)
    {
    case 6:
        
        
        ; 
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
12824,0,CWE190_Integer_Overflow__int_listen_socket_square_41.c,"    int data;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
11772,0,CWE134_Uncontrolled_Format_String__char_console_vfprintf_81_bad.cpp,"Label Definition File: CWE134_Uncontrolled_Format_String.vasinks.label.xml
Template File: sources-vasinks-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 134 Uncontrolled Format String
 * BadSource: console Read input from the console
 * GoodSource: Copy a fixed string into data
 * Sinks: vfprintf
 *    GoodSink: vfprintf with a format string
 *    BadSink : vfprintf without a format string
 * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include <stdarg.h>
#include ""std_testcase.h""
#include ""CWE134_Uncontrolled_Format_String__char_console_vfprintf_81.h""

namespace CWE134_Uncontrolled_Format_String__char_console_vfprintf_81
{

static void badVaSink(char * data, ...)
{
    {
        va_list args;
        va_start(args, data);
        
        vfprintf(stdout, data, args);
        va_end(args);
    }
}

void CWE134_Uncontrolled_Format_String__char_console_vfprintf_81_bad::action(char * data) const
{
    badVaSink(data, data);
}

}
"
12933,0,CWE197_Numeric_Truncation_Error__int_large_to_char_45.c,"    int data;
    
    data = -1;
    
    data = SHRT_MAX + 5;
    CWE197_Numeric_Truncation_Error__int_large_to_char_45_badData = data;
"
5253,0,CWE590_Free_Memory_Not_on_Heap__free_long_alloca_45.c,"    long * data;
    data = NULL; 
    {
        
        long * dataBuffer = (long *)ALLOCA(100*sizeof(long));
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5L;
            }
        }
        data = dataBuffer;
    }
    CWE590_Free_Memory_Not_on_Heap__free_long_alloca_45_badData = data;
"
15082,0,CWE190_Integer_Overflow__char_max_preinc_12.c,"    char data;
    data = ' ';
    if(globalReturnsTrueOrFalse())
    {
        
        data = CHAR_MAX;
    }
    else
    {
        
        data = 2;
    }
    if(globalReturnsTrueOrFalse())
    {
        {
            
            ++data;
            char result = data;
            printHexCharLine(result);
        }
    }
    else
    {
        
        if (data < CHAR_MAX)
        {
            ++data;
            char result = data;
            printHexCharLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
"
18004,0,CWE690_NULL_Deref_From_Return__long_malloc_84a.cpp,"    long * data;
    data = NULL; 
    CWE690_NULL_Deref_From_Return__long_malloc_84_bad * badObject = new CWE690_NULL_Deref_From_Return__long_malloc_84_bad(data);
"
15495,0,CWE401_Memory_Leak__int_calloc_81_bad.cpp,"Label Definition File: CWE401_Memory_Leak.c.label.xml
Template File: sources-sinks-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 401 Memory Leak
 * BadSource: calloc Allocate data using calloc()
 * GoodSource: Allocate data on the stack
 * Sinks:
 *    GoodSink: call free() on data
 *    BadSink : no deallocation of data
 * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE401_Memory_Leak__int_calloc_81.h""

namespace CWE401_Memory_Leak__int_calloc_81
{

void CWE401_Memory_Leak__int_calloc_81_bad::action(int * data) const
{
    
    ; 
}

}
"
9700,0,CWE415_Double_Free__new_delete_long_02.cpp,"    long * data;
    
    data = NULL;
    if(1)
    {
        data = new long;
        
        delete data;
    }
    if(1)
    {
        
        delete data;
"
11438,1,CWE758_Undefined_Behavior__char_pointer_new_use_06.cpp,"    if(STATIC_CONST_FIVE==5)
    {
        {
            char * data;
            data = ""string"";
            char * * pointer = new char *;
            *pointer = data; 
            {
                char * data = *pointer;
                printLine(data);
            }
            delete pointer;
        }
"
11833,0,CWE190_Integer_Overflow__int64_t_fscanf_preinc_53a.c,"    int64_t data;
    data = 0LL;
    
    fscanf (stdin, ""%"" SCNd64, &data);
"
8884,0,CWE590_Free_Memory_Not_on_Heap__delete_array_int64_t_alloca_45.cpp,"    int64_t * data;
    data = NULL; 
    {
        
        int64_t * dataBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5LL;
            }
        }
        data = dataBuffer;
    }
    badData = data;
"
9085,0,CWE78_OS_Command_Injection__char_environment_system_83a.cpp,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
"
10485,0,CWE190_Integer_Overflow__int64_t_fscanf_preinc_03.c,"    int64_t data;
    data = 0LL;
    if(5==5)
    {
        
        fscanf (stdin, ""%"" SCNd64, &data);
    }
    if(5==5)
    {
        {
            
            ++data;
            int64_t result = data;
            printLongLongLine(result);
        }
"
228,0,CWE190_Integer_Overflow__char_fscanf_square_31.c,"    char data;
    data = ' ';
    
    fscanf (stdin, ""%c"", &data);
    {
        char dataCopy = data;
        char data = dataCopy;
        {
            
            char result = data * data;
            printHexCharLine(result);
        }
"
6920,0,CWE590_Free_Memory_Not_on_Heap__delete_array_char_static_17.cpp,"    int i;
    char * data;
    data = NULL; 
    for(i = 0; i < 1; i++)
    {
        {
            
            static char dataBuffer[100];
            memset(dataBuffer, 'A', 100-1); 
            dataBuffer[100-1] = '\0'; 
            data = dataBuffer;
        }
    }
    printLine(data);
    
"
7844,0,CWE190_Integer_Overflow__char_fscanf_square_62a.cpp,"    char data;
    data = ' ';
    badSource(data);
    {
        
        char result = data * data;
        printHexCharLine(result);
"
9661,0,CWE401_Memory_Leak__int64_t_malloc_84_bad.cpp,"Label Definition File: CWE401_Memory_Leak.c.label.xml
Template File: sources-sinks-84_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 401 Memory Leak
 * BadSource: malloc Allocate data using malloc()
 * GoodSource: Allocate data on the stack
 * Sinks:
 *    GoodSink: call free() on data
 *    BadSink : no deallocation of data
 * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE401_Memory_Leak__int64_t_malloc_84.h""

namespace CWE401_Memory_Leak__int64_t_malloc_84
{
CWE401_Memory_Leak__int64_t_malloc_84_bad::CWE401_Memory_Leak__int64_t_malloc_84_bad(int64_t * dataCopy)
{
    data = dataCopy;
    
    data = (int64_t *)malloc(100*sizeof(int64_t));
    if (data == NULL) {exit(-1);}
    
    data[0] = 5LL;
    printLongLongLine(data[0]);
}

CWE401_Memory_Leak__int64_t_malloc_84_bad::~CWE401_Memory_Leak__int64_t_malloc_84_bad()
{
    
    ; 
}
}
"
10068,0,CWE690_NULL_Deref_From_Return__struct_calloc_81_bad.cpp,"Label Definition File: CWE690_NULL_Deref_From_Return.free.label.xml
Template File: source-sinks-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 690 Unchecked Return Value To NULL Pointer
 * BadSource: calloc Allocate data using calloc()
 * Sinks:
 *    GoodSink: Check to see if the data allocation failed and if not, use data
 *    BadSink : Don't check for NULL and use data
 * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE690_NULL_Deref_From_Return__struct_calloc_81.h""

namespace CWE690_NULL_Deref_From_Return__struct_calloc_81
{

void CWE690_NULL_Deref_From_Return__struct_calloc_81_bad::action(twoIntsStruct * data) const
{
    
    data[0].intOne = 1;
    data[0].intTwo = 1;
    printStructLine(&data[0]);
    free(data);
}

}
"
3184,0,CWE416_Use_After_Free__new_delete_array_char_15.cpp,"    char * data;
    
    data = NULL;
    switch(6)
    {
    case 6:
        data = new char[100];
        memset(data, 'A', 100-1);
        data[100-1] = '\0';
        
        delete [] data;
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
        
        printLine(data);
        
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
12082,0,CWE369_Divide_by_Zero__int_listen_socket_divide_62a.cpp,"    int data;
    
    data = -1;
    badSource(data);
    
"
5125,0,CWE457_Use_of_Uninitialized_Variable__twointsclass_array_alloca_partial_init_05.cpp,"    TwoIntsClass * data;
    data = reinterpret_cast<TwoIntsClass *>(ALLOCA(10*sizeof(TwoIntsClass)));
    if(staticTrue)
    {
        
        for(int i=0; i<(10/2); i++)
        {
            data[i].intOne = i;
            data[i].intTwo = i;
        }
    }
    if(staticTrue)
    {
        
        for(int i=0; i<10; i++)
        {
            printIntLine(data[i].intOne);
            printIntLine(data[i].intTwo);
        }
"
8362,1,CWE676_Use_of_Potentially_Dangerous_Function__basic_04.cpp,"    if(STATIC_CONST_TRUE)
    {
        {
            char charBuffer[CHAR_BUFFER_SIZE];
            
            cin.width(CHAR_BUFFER_SIZE);
            cin >> charBuffer;
            charBuffer[CHAR_BUFFER_SIZE-1] = '\0';
            printLine(charBuffer);
        }
"
5032,0,CWE415_Double_Free__new_delete_int64_t_73a.cpp,"    int64_t * data;
    list<int64_t *> dataList;
    
    data = NULL;
    data = new int64_t;
    
    delete data;
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
9511,0,CWE190_Integer_Overflow__char_fscanf_preinc_52a.c,"    char data;
    data = ' ';
    
    fscanf (stdin, ""%c"", &data);
"
15809,0,CWE690_NULL_Deref_From_Return__struct_calloc_74a.cpp,"    twoIntsStruct * data;
    map<int, twoIntsStruct *> dataMap;
    data = NULL; 
    
    data = (twoIntsStruct *)calloc(1, sizeof(twoIntsStruct));
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
18320,0,CWE190_Integer_Overflow__int_fgets_square_64a.c,"    int data;
    
    data = 0;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
"
11141,0,CWE416_Use_After_Free__malloc_free_struct_43.cpp,"    twoIntsStruct * data;
    
    data = NULL;
    badSource(data);
    
    printStructLine(&data[0]);
"
128,0,CWE134_Uncontrolled_Format_String__char_listen_socket_printf_08.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(staticReturnsTrue())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                data[dataLen + recvResult / sizeof(char)] = '\0';
                
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(staticReturnsTrue())
    {
        
        printf(data);
"
9636,0,CWE690_NULL_Deref_From_Return__char_malloc_32.c,"    char * data;
    char * *dataPtr1 = &data;
    char * *dataPtr2 = &data;
    data = NULL; 
    {
        char * data = *dataPtr1;
        
        data = (char *)malloc(20*sizeof(char));
        *dataPtr1 = data;
    }
    {
        char * data = *dataPtr2;
        
        strcpy(data, ""Initialize"");
        printLine(data);
        free(data);
"
17033,0,CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_34.c,"    unsigned int data;
    CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_34_unionType myUnion;
    data = 0;
    
    fscanf (stdin, ""%u"", &data);
    myUnion.unionFirst = data;
    {
        unsigned int data = myUnion.unionSecond;
        {
            
            data++;
            unsigned int result = data;
            printUnsignedLine(result);
        }
"
7043,0,CWE789_Uncontrolled_Mem_Alloc__new_char_fgets_18.cpp,"    size_t data;
    
    data = 0;
    goto source;
source:
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = strtoul(inputBuffer, NULL, 0);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    goto sink;
sink:
    {
        char * myString;
        /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
         * for the strcpy() function to not cause a buffer overflow */
        
        if (data > strlen(HELLO_STRING))
        {
            myString = new char[data];
            
            strcpy(myString, HELLO_STRING);
            printLine(myString);
            delete [] myString;
        }
        else
        {
            printLine(""Input is less than the length of the source string"");
        }
"
2109,0,CWE563_Unused_Variable__unused_uninit_variable_int_08.c,"    int data;
    
    ; 
    if(staticReturnsTrue())
    {
        
        
        ; 
"
5481,0,CWE369_Divide_by_Zero__float_zero_82_bad.cpp,"Label Definition File: CWE369_Divide_by_Zero__float.label.xml
Template File: sources-sinks-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 369 Divide by Zero
 * BadSource: zero Fixed value of zero
 * GoodSource: A hardcoded non-zero number (two)
 * Sinks:
 *    GoodSink: Check value of or near zero before dividing
 *    BadSink : Divide a constant by data
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE369_Divide_by_Zero__float_zero_82.h""

namespace CWE369_Divide_by_Zero__float_zero_82
{

void CWE369_Divide_by_Zero__float_zero_82_bad::action(float data)
{
    {
        
        int result = (int)(100.0 / data);
        printIntLine(result);
    }
}

}
"
15240,0,CWE197_Numeric_Truncation_Error__int_listen_socket_to_char_42.c,"    int data;
    
    data = -1;
    data = badSource(data);
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
5789,0,CWE416_Use_After_Free__new_delete_array_long_14.cpp,"    long * data;
    
    data = NULL;
    if(globalFive==5)
    {
        data = new long[100];
        {
            size_t i;
            for(i = 0; i < 100; i++)
            {
                data[i] = 5L;
            }
        }
        
        delete [] data;
    }
    if(globalFive==5)
    {
        
        printLongLine(data[0]);
        
"
7530,0,CWE590_Free_Memory_Not_on_Heap__delete_class_placement_new_11.cpp,"    TwoIntsClass * data;
    data = NULL; 
    if(globalReturnsTrue())
    {
        {
            
            char buffer[sizeof(TwoIntsClass)];
            TwoIntsClass * dataBuffer = new(buffer) TwoIntsClass;
            dataBuffer->intOne = 2;
            dataBuffer->intTwo = 2;
            data = dataBuffer;
        }
    }
    printIntLine(data->intOne);
    
"
13127,0,CWE134_Uncontrolled_Format_String__char_environment_vprintf_42.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    data = badSource(data);
"
15095,0,CWE401_Memory_Leak__int64_t_calloc_13.c,"    int64_t * data;
    data = NULL;
    if(GLOBAL_CONST_FIVE==5)
    {
        
        data = (int64_t *)calloc(100, sizeof(int64_t));
        if (data == NULL) {exit(-1);}
        
        data[0] = 5LL;
        printLongLongLine(data[0]);
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        
        ; 
"
16219,0,CWE190_Integer_Overflow__short_max_preinc_34.c,"    short data;
    CWE190_Integer_Overflow__short_max_preinc_34_unionType myUnion;
    data = 0;
    
    data = SHRT_MAX;
    myUnion.unionFirst = data;
    {
        short data = myUnion.unionSecond;
        {
            
            ++data;
            short result = data;
            printIntLine(result);
        }
"
4341,0,CWE590_Free_Memory_Not_on_Heap__delete_struct_placement_new_03.cpp,"    twoIntsStruct * data;
    data = NULL; 
    if(5==5)
    {
        {
            
            char buffer[sizeof(twoIntsStruct)];
            twoIntsStruct * dataBuffer = new(buffer) twoIntsStruct;
            dataBuffer->intOne = 1;
            dataBuffer->intTwo = 1;
            data = dataBuffer;
        }
    }
    printStructLine(data);
    
"
16223,0,CWE563_Unused_Variable__unused_init_variable_int64_t_82a.cpp,"    int64_t data;
    
    data = 5LL;
    CWE563_Unused_Variable__unused_init_variable_int64_t_82_base* baseObject = new CWE563_Unused_Variable__unused_init_variable_int64_t_82_bad;
    baseObject->action(data);
"
16904,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_31.c,"    size_t data;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = strtoul(inputBuffer, NULL, 0);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    {
        size_t dataCopy = data;
        size_t data = dataCopy;
        {
            char * myString;
            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
             * for the strcpy() function to not cause a buffer overflow */
            
            if (data > strlen(HELLO_STRING))
            {
                myString = (char *)malloc(data*sizeof(char));
                if (myString == NULL) {exit(-1);}
                
                strcpy(myString, HELLO_STRING);
                printLine(myString);
                free(myString);
            }
            else
            {
                printLine(""Input is less than the length of the source string"");
            }
        }
"
9352,0,CWE369_Divide_by_Zero__float_rand_11.c,"    float data;
    
    data = 0.0F;
    if(globalReturnsTrue())
    {
        
        data = (float)RAND32();
    }
    if(globalReturnsTrue())
    {
        {
            
            int result = (int)(100.0 / data);
            printIntLine(result);
        }
"
7211,0,CWE690_NULL_Deref_From_Return__struct_malloc_21.c,"    twoIntsStruct * data;
    data = NULL; 
    
    data = (twoIntsStruct *)malloc(1*sizeof(twoIntsStruct));
    badStatic = 1; 
"
239,0,CWE690_NULL_Deref_From_Return__int64_t_realloc_63a.c,"    int64_t * data;
    data = NULL; 
    
    data = (int64_t *)realloc(data, 1*sizeof(int64_t));
"
5673,0,CWE758_Undefined_Behavior__int_malloc_use_12.c,"    if(globalReturnsTrueOrFalse())
    {
        {
            int * pointer = (int *)malloc(sizeof(int));
            if (pointer == NULL) {exit(-1);}
            int data = *pointer; 
            free(pointer);
            printIntLine(data);
        }
    }
    else
    {
        {
            int data;
            int * pointer = (int *)malloc(sizeof(int));
            if (pointer == NULL) {exit(-1);}
            data = 5;
            *pointer = data; 
            {
                int data = *pointer;
                printIntLine(data);
            }
            free(pointer);
        }
"
4305,0,CWE457_Use_of_Uninitialized_Variable__struct_array_malloc_partial_init_07.c,"    twoIntsStruct * data;
    data = (twoIntsStruct *)malloc(10*sizeof(twoIntsStruct));
    if (data == NULL) {exit(-1);}
    if(staticFive==5)
    {
        
        {
            int i;
            for(i=0; i<(10/2); i++)
            {
                data[i].intOne = i;
                data[i].intTwo = i;
            }
        }
    }
    if(staticFive==5)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i].intOne);
                printIntLine(data[i].intTwo);
            }
        }
"
12464,0,CWE690_NULL_Deref_From_Return__long_realloc_83a.cpp,"    long * data;
    data = NULL; 
"
1943,0,CWE134_Uncontrolled_Format_String__char_connect_socket_printf_12.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(globalReturnsTrueOrFalse())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET connectSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                
                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                data[dataLen + recvResult / sizeof(char)] = '\0';
                
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    else
    {
        
        strcpy(data, ""fixedstringtest"");
    }
    if(globalReturnsTrueOrFalse())
    {
        
        printf(data);
    }
    else
    {
        
        printf(""%s\n"", data);
"
4866,0,CWE190_Integer_Overflow__short_rand_multiply_01.c,"    short data;
    data = 0;
    
    data = (short)RAND32();
    if(data > 0) 
    {
        
        short result = data * 2;
        printIntLine(result);
"
7613,0,CWE190_Integer_Overflow__int_fscanf_square_81a.cpp,"    int data;
    
    data = 0;
    
    fscanf(stdin, ""%d"", &data);
    const CWE190_Integer_Overflow__int_fscanf_square_81_base& baseObject = CWE190_Integer_Overflow__int_fscanf_square_81_bad();
"
9038,0,CWE590_Free_Memory_Not_on_Heap__free_int64_t_static_10.c,"    int64_t * data;
    data = NULL; 
    if(globalTrue)
    {
        {
            
            static int64_t dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5LL;
                }
            }
            data = dataBuffer;
        }
    }
    printLongLongLine(data[0]);
    
"
17894,0,CWE190_Integer_Overflow__char_fscanf_multiply_82_bad.cpp,"Label Definition File: CWE190_Integer_Overflow.label.xml
Template File: sources-sinks-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 190 Integer Overflow
 * BadSource: fscanf Read data from the console using fscanf()
 * GoodSource: Set data to a small, non-zero number (two)
 * Sinks: multiply
 *    GoodSink: Ensure there will not be an overflow before multiplying data by 2
 *    BadSink : If data is positive, multiply by 2, which can cause an overflow
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE190_Integer_Overflow__char_fscanf_multiply_82.h""

namespace CWE190_Integer_Overflow__char_fscanf_multiply_82
{

void CWE190_Integer_Overflow__char_fscanf_multiply_82_bad::action(char data)
{
    if(data > 0) 
    {
        
        char result = data * 2;
        printHexCharLine(result);
    }
}

}
"
6128,0,CWE197_Numeric_Truncation_Error__short_connect_socket_66a.c,"    short data;
    short dataArray[5];
    
    data = -1;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = (short)atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
    dataArray[2] = data;
"
4345,0,CWE78_OS_Command_Injection__char_environment_system_84a.cpp,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    CWE78_OS_Command_Injection__char_environment_system_84_bad * badObject = new CWE78_OS_Command_Injection__char_environment_system_84_bad(data);
"
12146,0,CWE190_Integer_Overflow__unsigned_int_fscanf_add_12.c,"    unsigned int data;
    data = 0;
    if(globalReturnsTrueOrFalse())
    {
        
        fscanf (stdin, ""%u"", &data);
    }
    else
    {
        
        data = 2;
    }
    if(globalReturnsTrueOrFalse())
    {
        {
            
            unsigned int result = data + 1;
            printUnsignedLine(result);
        }
    }
    else
    {
        
        if (data < UINT_MAX)
        {
            unsigned int result = data + 1;
            printUnsignedLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
"
10035,0,CWE758_Undefined_Behavior__char_malloc_use_04.c,"    if(STATIC_CONST_TRUE)
    {
        {
            char * pointer = (char *)malloc(sizeof(char));
            if (pointer == NULL) {exit(-1);}
            char data = *pointer; 
            free(pointer);
            printHexCharLine(data);
        }
"
11026,0,CWE590_Free_Memory_Not_on_Heap__free_int_declare_17.c,"    int i;
    int * data;
    data = NULL; 
    for(i = 0; i < 1; i++)
    {
        {
            
            int dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5;
                }
            }
            data = dataBuffer;
        }
    }
    printIntLine(data[0]);
    
"
5204,0,CWE590_Free_Memory_Not_on_Heap__free_char_alloca_03.c,"    char * data;
    data = NULL; 
    if(5==5)
    {
        {
            
            char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
            memset(dataBuffer, 'A', 100-1); 
            dataBuffer[100-1] = '\0'; 
            data = dataBuffer;
        }
    }
    printLine(data);
    
"
3811,0,CWE690_NULL_Deref_From_Return__int_malloc_53a.c,"    int * data;
    data = NULL; 
    
    data = (int *)malloc(1*sizeof(int));
"
7517,0,CWE665_Improper_Initialization__char_ncat_83a.cpp,"    char * data;
    char dataBuffer[100];
    data = dataBuffer;
"
11546,0,CWE590_Free_Memory_Not_on_Heap__delete_struct_declare_51a.cpp,"    twoIntsStruct * data;
    data = NULL; 
    {
        
        twoIntsStruct dataBuffer;
        dataBuffer.intOne = 1;
        dataBuffer.intTwo = 1;
        data = &dataBuffer;
    }
"
5448,0,CWE190_Integer_Overflow__int_max_multiply_51a.c,"    int data;
    
    data = 0;
    
    data = INT_MAX;
"
12440,0,CWE457_Use_of_Uninitialized_Variable__twointsclass_array_new_no_init_14.cpp,"    TwoIntsClass * data;
    data = new TwoIntsClass[10];
    if(globalFive==5)
    {
        
        ; 
    }
    if(globalFive==5)
    {
        
        for(int i=0; i<10; i++)
        {
            printIntLine(data[i].intOne);
            printIntLine(data[i].intTwo);
        }
"
5346,0,CWE369_Divide_by_Zero__int_connect_socket_modulo_45.c,"    int data;
    
    data = -1;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    CWE369_Divide_by_Zero__int_connect_socket_modulo_45_badData = data;
"
11375,0,CWE197_Numeric_Truncation_Error__int_fgets_to_short_65a.c,"    int data;
    
    void (*funcPtr) (int) = CWE197_Numeric_Truncation_Error__int_fgets_to_short_65b_badSink;
    
    data = -1;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    
"
14634,0,CWE190_Integer_Overflow__int64_t_fscanf_postinc_45.c,"    int64_t data;
    data = 0LL;
    
    fscanf (stdin, ""%"" SCNd64, &data);
    CWE190_Integer_Overflow__int64_t_fscanf_postinc_45_badData = data;
"
2068,0,CWE369_Divide_by_Zero__int_listen_socket_modulo_72a.cpp,"    int data;
    vector<int> dataVector;
    
    data = -1;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
7188,0,CWE369_Divide_by_Zero__int_fscanf_modulo_21.c,"    int data;
    
    data = -1;
    
    fscanf(stdin, ""%d"", &data);
    badStatic = 1; 
"
15456,0,CWE476_NULL_Pointer_Dereference__int64_t_21.c,"    int64_t * data;
    
    data = NULL;
    badStatic = 1; 
"
8621,0,CWE190_Integer_Overflow__int64_t_max_multiply_31.c,"    int64_t data;
    data = 0LL;
    
    data = LLONG_MAX;
    {
        int64_t dataCopy = data;
        int64_t data = dataCopy;
        if(data > 0) 
        {
            
            int64_t result = data * 2;
            printLongLongLine(result);
        }
"
18352,0,CWE190_Integer_Overflow__int_max_add_43.cpp,"    int data;
    
    data = 0;
    badSource(data);
    {
        
        int result = data + 1;
        printIntLine(result);
"
17877,0,CWE190_Integer_Overflow__char_max_postinc_16.c,"    char data;
    data = ' ';
    while(1)
    {
        
        data = CHAR_MAX;
        break;
    }
    while(1)
    {
        {
            
            data++;
            char result = data;
            printHexCharLine(result);
        }
        break;
"
11773,0,CWE690_NULL_Deref_From_Return__fopen_04.c,"    FILE * data;
    
    data = NULL;
    
    data = fopen(""file.txt"", ""w+"");
    if(STATIC_CONST_TRUE)
    {
        
        fclose(data);
"
6466,0,CWE197_Numeric_Truncation_Error__int_listen_socket_to_short_02.c,"    int data;
    
    data = -1;
    if(1)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    {
        
        short shortData = (short)data;
        printShortLine(shortData);
"
11511,0,CWE416_Use_After_Free__new_delete_int64_t_06.cpp,"    int64_t * data;
    
    data = NULL;
    if(STATIC_CONST_FIVE==5)
    {
        data = new int64_t;
        *data = 5LL;
        
        delete data;
    }
    if(STATIC_CONST_FIVE==5)
    {
        
        printLongLongLine(*data);
        
"
3456,1,CWE758_Undefined_Behavior__struct_alloca_use_13.c,"    if(GLOBAL_CONST_FIVE!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            twoIntsStruct data;
            twoIntsStruct * pointer = (twoIntsStruct *)ALLOCA(sizeof(twoIntsStruct));
            data.intOne = 1;
            data.intTwo = 2;
            *pointer = data; 
            {
                twoIntsStruct data = *pointer;
                printIntLine(data.intOne);
                printIntLine(data.intTwo);
            }
        }
"
6587,1,CWE758_Undefined_Behavior__struct_malloc_use_15.c,"    switch(6)
    {
    case 6:
    {
        twoIntsStruct data;
        twoIntsStruct * pointer = (twoIntsStruct *)malloc(sizeof(twoIntsStruct));
        if (pointer == NULL) {exit(-1);}
        data.intOne = 1;
        data.intTwo = 2;
        *pointer = data; 
        {
            twoIntsStruct data = *pointer;
            printIntLine(data.intOne);
            printIntLine(data.intTwo);
        }
        free(pointer);
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
7187,0,CWE369_Divide_by_Zero__int_listen_socket_modulo_81a.cpp,"    int data;
    
    data = -1;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    const CWE369_Divide_by_Zero__int_listen_socket_modulo_81_base& baseObject = CWE369_Divide_by_Zero__int_listen_socket_modulo_81_bad();
"
2863,0,CWE476_NULL_Pointer_Dereference__struct_02.c,"    twoIntsStruct * data;
    if(1)
    {
        
        data = NULL;
    }
    if(1)
    {
        
        printIntLine(data->intOne);
"
248,0,CWE590_Free_Memory_Not_on_Heap__free_int_static_74a.cpp,"    int * data;
    map<int, int *> dataMap;
    data = NULL; 
    {
        
        static int dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5;
            }
        }
        data = dataBuffer;
    }
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
14270,0,CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_08.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(staticReturnsTrue())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                data[dataLen + recvResult / sizeof(char)] = '\0';
                
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(staticReturnsTrue())
    {
        badVaSinkB(data, data);
"
4054,0,CWE476_NULL_Pointer_Dereference__deref_after_check_11.c,"    if(globalReturnsTrue())
    {
        {
            
            int *intPointer = NULL;
            if (intPointer == NULL)
            {
                printIntLine(*intPointer);
            }
        }
"
1967,0,CWE190_Integer_Overflow__int_max_postinc_11.c,"    int data;
    
    data = 0;
    if(globalReturnsTrue())
    {
        
        data = INT_MAX;
    }
    if(globalReturnsTrue())
    {
        {
            
            data++;
            int result = data;
            printIntLine(result);
        }
"
6508,0,CWE590_Free_Memory_Not_on_Heap__delete_long_placement_new_07.cpp,"    long * data;
    data = NULL; 
    if(staticFive==5)
    {
        {
            
            char buffer[sizeof(long)];
            long * dataBuffer = new(buffer) long;
            *dataBuffer = 5L;
            data = dataBuffer;
        }
    }
    printLongLine(*data);
    
"
9439,1,CWE252_Unchecked_Return_Value__char_sscanf_06.c,"    if(STATIC_CONST_FIVE!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            
            if (sscanf(SRC, ""%99s\0"", data) == EOF)
            {
                printLine(""sscanf failed!"");
            }
        }
"
1332,0,CWE401_Memory_Leak__int64_t_calloc_72a.cpp,"    int64_t * data;
    vector<int64_t *> dataVector;
    data = NULL;
    
    data = (int64_t *)calloc(100, sizeof(int64_t));
    if (data == NULL) {exit(-1);}
    
    data[0] = 5LL;
    printLongLongLine(data[0]);
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
12118,0,CWE252_Unchecked_Return_Value__char_fwrite_02.c,"    if(1)
    {
        
        fwrite((char *)""string"", sizeof(char), strlen(""string""), stdout);
"
1720,1,CWE401_Memory_Leak__malloc_realloc_twoIntsStruct_04.c,"    if(STATIC_CONST_FALSE)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            twoIntsStruct * data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
            if (data == NULL) {exit(-1);}
            twoIntsStruct * tmpData;
            
            data[0].intOne = 0;
            data[0].intTwo = 0;
            printStructLine(&data[0]);
            tmpData = (twoIntsStruct *)realloc(data, (130000)*sizeof(twoIntsStruct));
            /* FIX: Ensure realloc() was successful before assigning data to the memory block
            * allocated with realloc() */
            if (tmpData != NULL)
            {
                data = tmpData;
                
                data[0].intOne = 1;
                data[0].intTwo = 1;
                printStructLine(&data[0]);
            }
            free(data);
        }
"
10975,0,CWE190_Integer_Overflow__unsigned_int_max_square_13.c,"    unsigned int data;
    data = 0;
    if(GLOBAL_CONST_FIVE==5)
    {
        
        data = UINT_MAX;
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            
            unsigned int result = data * data;
            printUnsignedLine(result);
        }
"
16310,0,CWE563_Unused_Variable__unused_init_variable_int_18.c,"    int data;
    
    data = 5;
    goto sink;
sink:
    
    
"
6785,0,CWE190_Integer_Overflow__short_rand_preinc_41.c,"    short data;
    data = 0;
    
    data = (short)RAND32();
"
6352,1,CWE401_Memory_Leak__malloc_realloc_twoIntsStruct_01.c,"    {
        twoIntsStruct * data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
        if (data == NULL) {exit(-1);}
        twoIntsStruct * tmpData;
        
        data[0].intOne = 0;
        data[0].intTwo = 0;
        printStructLine(&data[0]);
        tmpData = (twoIntsStruct *)realloc(data, (130000)*sizeof(twoIntsStruct));
        /* FIX: Ensure realloc() was successful before assigning data to the memory block
        * allocated with realloc() */
        if (tmpData != NULL)
        {
            data = tmpData;
            
            data[0].intOne = 1;
            data[0].intTwo = 1;
            printStructLine(&data[0]);
        }
        free(data);
"
2386,0,CWE369_Divide_by_Zero__float_listenSocket_73a.cpp,"    float data;
    list<float> dataList;
    
    data = 0.0F;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = (float)atof(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
16442,0,CWE78_OS_Command_Injection__char_file_popen_12.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(globalReturnsTrueOrFalse())
    {
        {
            
            size_t dataLen = strlen(data);
            FILE * pFile;
            
            if (100-dataLen > 1)
            {
                pFile = fopen(FILENAME, ""r"");
                if (pFile != NULL)
                {
                    
                    if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                    {
                        printLine(""fgets() failed"");
                        
                        data[dataLen] = '\0';
                    }
                    fclose(pFile);
                }
            }
        }
    }
    else
    {
        
        strcat(data, ""*.*"");
    }
    {
        FILE *pipe;
        
        pipe = POPEN(data, ""w"");
        if (pipe != NULL)
        {
            PCLOSE(pipe);
        }
"
1497,0,CWE401_Memory_Leak__strdup_char_53a.c,"    char * data;
    data = NULL;
    {
        char myString[] = ""myString"";
        
        data = strdup(myString);
        
        printLine(data);
    }
"
8619,0,CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_43.cpp,"    unsigned int data;
    data = 0;
    badSource(data);
    if(data > 0) 
    {
        
        unsigned int result = data * 2;
        printUnsignedLine(result);
"
15833,0,CWE415_Double_Free__new_delete_array_long_06.cpp,"    long * data;
    
    data = NULL;
    if(STATIC_CONST_FIVE==5)
    {
        data = new long[100];
        
        delete [] data;
    }
    if(STATIC_CONST_FIVE==5)
    {
        
        delete [] data;
"
10580,0,CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_03.c,"    int data;
    
    data = -1;
    if(5==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
13295,1,CWE252_Unchecked_Return_Value__char_remove_13.c,"    if(GLOBAL_CONST_FIVE==5)
    {
        
        if (REMOVE(""removemegood.txt"") != 0)
        {
            printLine(""remove failed!"");
        }
"
3377,0,CWE563_Unused_Variable__unused_value_char_01.c,"    char data;
    
    data = 'C';
    
    data = 'Z';
"
7921,0,CWE190_Integer_Overflow__short_rand_square_82a.cpp,"    short data;
    data = 0;
    
    data = (short)RAND32();
    CWE190_Integer_Overflow__short_rand_square_82_base* baseObject = new CWE190_Integer_Overflow__short_rand_square_82_bad;
    baseObject->action(data);
"
14895,0,CWE78_OS_Command_Injection__char_console_system_31.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
        
        size_t dataLen = strlen(data);
        
        if (100-dataLen > 1)
        {
            
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgets() */
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
"
16209,0,CWE190_Integer_Overflow__int_max_multiply_61a.c,"    int data;
    
    data = 0;
    data = CWE190_Integer_Overflow__int_max_multiply_61b_badSource(data);
    if(data > 0) 
    {
        
        int result = data * 2;
        printIntLine(result);
"
16516,0,CWE190_Integer_Overflow__int_listen_socket_square_68a.c,"    int data;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    CWE190_Integer_Overflow__int_listen_socket_square_68_badData = data;
"
866,0,CWE190_Integer_Overflow__int_fgets_add_21.c,"    int data;
    
    data = 0;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    badStatic = 1; 
"
19479,0,CWE252_Unchecked_Return_Value__char_putc_17.c,"    int j;
    for(j = 0; j < 1; j++)
    {
        
        putc((int)'A', stdout);
"
393,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_43.cpp,"    size_t data;
    
    data = 0;
    badSource(data);
    {
        char * myString;
        /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
         * for the strcpy() function to not cause a buffer overflow */
        
        if (data > strlen(HELLO_STRING))
        {
            myString = (char *)malloc(data*sizeof(char));
            if (myString == NULL) {exit(-1);}
            
            strcpy(myString, HELLO_STRING);
            printLine(myString);
            free(myString);
        }
        else
        {
            printLine(""Input is less than the length of the source string"");
        }
"
6105,0,CWE134_Uncontrolled_Format_String__char_environment_fprintf_07.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(staticFive==5)
    {
        {
            
            size_t dataLen = strlen(data);
            char * environment = GETENV(ENV_VARIABLE);
            
            if (environment != NULL)
            {
                
                strncat(data+dataLen, environment, 100-dataLen-1);
            }
        }
    }
    if(staticFive==5)
    {
        
        fprintf(stdout, data);
"
12289,0,CWE197_Numeric_Truncation_Error__int_fgets_to_char_74a.cpp,"    int data;
    map<int, int> dataMap;
    
    data = -1;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
13588,0,CWE415_Double_Free__new_delete_array_struct_06.cpp,"    twoIntsStruct * data;
    
    data = NULL;
    if(STATIC_CONST_FIVE==5)
    {
        data = new twoIntsStruct[100];
        
        delete [] data;
    }
    if(STATIC_CONST_FIVE==5)
    {
        
        delete [] data;
"
10549,0,CWE690_NULL_Deref_From_Return__int_malloc_16.c,"    int * data;
    data = NULL; 
    
    data = (int *)malloc(1*sizeof(int));
    while(1)
    {
        
        data[0] = 5;
        printIntLine(data[0]);
        free(data);
        break;
"
2192,0,CWE401_Memory_Leak__new_array_char_03.cpp,"    char * data;
    data = NULL;
    if(5==5)
    {
        
        data = new char[100];
        
        strcpy(data, ""A String"");
        printLine(data);
    }
    if(5==5)
    {
        
        ; 
"
11854,0,CWE190_Integer_Overflow__int_listen_socket_square_65a.c,"    int data;
    
    void (*funcPtr) (int) = CWE190_Integer_Overflow__int_listen_socket_square_65b_badSink;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
"
18942,0,CWE476_NULL_Pointer_Dereference__int_64a.c,"    int * data;
    
    data = NULL;
"
10764,1,CWE758_Undefined_Behavior__long_new_use_01.cpp,"    {
        long data;
        data = 5L;
        long * pointer = new long;
        *pointer = data; 
        {
            long data = *pointer;
            printLongLine(data);
        }
        delete pointer;
"
1811,0,CWE190_Integer_Overflow__int_rand_add_09.c,"    int data;
    
    data = 0;
    if(GLOBAL_CONST_TRUE)
    {
        
        data = RAND32();
    }
    if(GLOBAL_CONST_TRUE)
    {
        {
            
            int result = data + 1;
            printIntLine(result);
        }
"
6339,0,CWE415_Double_Free__new_delete_array_int_72a.cpp,"    int * data;
    vector<int *> dataVector;
    
    data = NULL;
    data = new int[100];
    
    delete [] data;
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
9330,0,CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_08.c,"    unsigned int data;
    data = 0;
    if(staticReturnsTrue())
    {
        
        fscanf (stdin, ""%u"", &data);
    }
    if(staticReturnsTrue())
    {
        if(data > 0) 
        {
            
            unsigned int result = data * 2;
            printUnsignedLine(result);
        }
"
13688,0,CWE369_Divide_by_Zero__int_rand_divide_81_bad.cpp,"Label Definition File: CWE369_Divide_by_Zero__int.label.xml
Template File: sources-sinks-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 369 Divide by Zero
 * BadSource: rand Set data to result of rand(), which may be zero
 * GoodSource: Non-zero
 * Sinks: divide
 *    GoodSink: Check for zero before dividing
 *    BadSink : Divide a constant by data
 * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE369_Divide_by_Zero__int_rand_divide_81.h""

namespace CWE369_Divide_by_Zero__int_rand_divide_81
{

void CWE369_Divide_by_Zero__int_rand_divide_81_bad::action(int data) const
{
    
    printIntLine(100 / data);
}

}
"
18809,0,CWE369_Divide_by_Zero__int_zero_modulo_05.c,"    int data;
    
    data = -1;
    if(staticTrue)
    {
        
        data = 0;
    }
    if(staticTrue)
    {
        
        printIntLine(100 % data);
"
16055,0,CWE590_Free_Memory_Not_on_Heap__delete_long_alloca_05.cpp,"    long * data;
    data = NULL; 
    if(staticTrue)
    {
        {
            
            long * dataBuffer = (long *)ALLOCA(sizeof(long));
            *dataBuffer = 5L;
            data = dataBuffer;
        }
    }
    printLongLine(*data);
    
"
4870,1,CWE758_Undefined_Behavior__char_alloca_use_13.c,"    if(GLOBAL_CONST_FIVE==5)
    {
        {
            char data;
            char * pointer = (char *)ALLOCA(sizeof(char));
            data = 5;
            *pointer = data; 
            {
                char data = *pointer;
                printHexCharLine(data);
            }
        }
"
3985,0,CWE415_Double_Free__new_delete_int64_t_53a.cpp,"    int64_t * data;
    
    data = NULL;
    data = new int64_t;
    
    delete data;
"
3211,0,CWE590_Free_Memory_Not_on_Heap__delete_array_struct_static_72a.cpp,"    twoIntsStruct * data;
    vector<twoIntsStruct *> dataVector;
    data = NULL; 
    {
        
        static twoIntsStruct dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i].intOne = 1;
                dataBuffer[i].intTwo = 1;
            }
        }
        data = dataBuffer;
    }
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
17268,0,CWE190_Integer_Overflow__int_connect_socket_square_34.c,"    int data;
    CWE190_Integer_Overflow__int_connect_socket_square_34_unionType myUnion;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    myUnion.unionFirst = data;
    {
        int data = myUnion.unionSecond;
        {
            
            int result = data * data;
            printIntLine(result);
        }
"
8805,0,CWE563_Unused_Variable__unused_global_value_01.c,"    
    CWE563_Unused_Variable__unused_global_value_01_badGlobal = 10;
"
10978,0,CWE401_Memory_Leak__new_array_twointsStruct_32.cpp,"    twoIntsStruct * data;
    twoIntsStruct * *dataPtr1 = &data;
    twoIntsStruct * *dataPtr2 = &data;
    data = NULL;
    {
        twoIntsStruct * data = *dataPtr1;
        
        data = new twoIntsStruct[100];
        
        data[0].intOne = 0;
        data[0].intTwo = 0;
        printStructLine(&data[0]);
        *dataPtr1 = data;
    }
    {
        twoIntsStruct * data = *dataPtr2;
        
        ; 
"
11488,0,CWE590_Free_Memory_Not_on_Heap__delete_int_alloca_44.cpp,"    int * data;
    
    void (*funcPtr) (int *) = badSink;
    data = NULL; 
    {
        
        int * dataBuffer = (int *)ALLOCA(sizeof(int));
        *dataBuffer = 5;
        data = dataBuffer;
    }
    
"
7751,0,CWE369_Divide_by_Zero__int_fscanf_divide_82a.cpp,"    int data;
    
    data = -1;
    
    fscanf(stdin, ""%d"", &data);
    CWE369_Divide_by_Zero__int_fscanf_divide_82_base* baseObject = new CWE369_Divide_by_Zero__int_fscanf_divide_82_bad;
    baseObject->action(data);
"
14896,1,CWE758_Undefined_Behavior__class_new_use_06.cpp,"    if(STATIC_CONST_FIVE!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            TwoIntsClass data;
            data.intOne = 1;
            data.intTwo = 2;
            TwoIntsClass * pointer = new TwoIntsClass;
            *pointer = data; 
            {
                TwoIntsClass data = *pointer;
                printIntLine(data.intOne);
                printIntLine(data.intTwo);
            }
            delete pointer;
        }
"
13001,0,CWE690_NULL_Deref_From_Return__int64_t_realloc_05.c,"    int64_t * data;
    data = NULL; 
    
    data = (int64_t *)realloc(data, 1*sizeof(int64_t));
    if(staticTrue)
    {
        
        data[0] = 5LL;
        printLongLongLine(data[0]);
        free(data);
"
17057,0,CWE401_Memory_Leak__strdup_char_82_bad.cpp,"Label Definition File: CWE401_Memory_Leak__strdup.label.xml
Template File: sources-sinks-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 401 Memory Leak
 * BadSource:  Allocate data using strdup()
 * GoodSource: Allocate data on the stack
 * Sinks:
 *    GoodSink: call free() on data
 *    BadSink : no deallocation of data
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE401_Memory_Leak__strdup_char_82.h""

namespace CWE401_Memory_Leak__strdup_char_82
{

void CWE401_Memory_Leak__strdup_char_82_bad::action(char * data)
{
    
    
    ; 
}

}
"
14374,0,CWE758_Undefined_Behavior__char_alloca_use_05.c,"    if(staticTrue)
    {
        {
            char * pointer = (char *)ALLOCA(sizeof(char));
            char data = *pointer; 
            printHexCharLine(data);
        }
"
18142,0,CWE197_Numeric_Truncation_Error__int_fgets_to_short_82a.cpp,"    int data;
    
    data = -1;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    CWE197_Numeric_Truncation_Error__int_fgets_to_short_82_base* baseObject = new CWE197_Numeric_Truncation_Error__int_fgets_to_short_82_bad;
    baseObject->action(data);
"
1337,0,CWE190_Integer_Overflow__int_fgets_square_01.c,"    int data;
    
    data = 0;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    {
        
        int result = data * data;
        printIntLine(result);
"
8209,0,CWE190_Integer_Overflow__short_rand_add_21.c,"    short data;
    data = 0;
    
    data = (short)RAND32();
    badStatic = 1; 
"
8293,0,CWE190_Integer_Overflow__int_fscanf_add_82_bad.cpp,"Label Definition File: CWE190_Integer_Overflow__int.label.xml
Template File: sources-sinks-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 190 Integer Overflow
 * BadSource: fscanf Read data from the console using fscanf()
 * GoodSource: Set data to a small, non-zero number (two)
 * Sinks: add
 *    GoodSink: Ensure there will not be an overflow before adding 1 to data
 *    BadSink : Add 1 to data, which can cause an overflow
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE190_Integer_Overflow__int_fscanf_add_82.h""

namespace CWE190_Integer_Overflow__int_fscanf_add_82
{

void CWE190_Integer_Overflow__int_fscanf_add_82_bad::action(int data)
{
    {
        
        int result = data + 1;
        printIntLine(result);
    }
}

}
"
5452,0,CWE665_Improper_Initialization__char_ncat_65a.c,"    char * data;
    
    void (*funcPtr) (char *) = CWE665_Improper_Initialization__char_ncat_65b_badSink;
    char dataBuffer[100];
    data = dataBuffer;
    
    ; 
    
"
13514,0,CWE197_Numeric_Truncation_Error__short_connect_socket_42.c,"    short data;
    
    data = -1;
    data = badSource(data);
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
18720,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_10.c,"    size_t data;
    
    data = 0;
    if(globalTrue)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = strtoul(inputBuffer, NULL, 0);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(globalTrue)
    {
        {
            char * myString;
            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
             * for the strcpy() function to not cause a buffer overflow */
            
            if (data > strlen(HELLO_STRING))
            {
                myString = (char *)malloc(data*sizeof(char));
                if (myString == NULL) {exit(-1);}
                
                strcpy(myString, HELLO_STRING);
                printLine(myString);
                free(myString);
            }
            else
            {
                printLine(""Input is less than the length of the source string"");
            }
        }
"
12945,0,CWE197_Numeric_Truncation_Error__short_fgets_21.c,"    short data;
    
    data = -1;
    badStatic = 1; 
    data = badSource(data);
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
15512,0,CWE587_Assignment_of_Fixed_Address_to_Pointer__basic_15.c,"    switch(6)
    {
    case 6:
    {
        
        char *charPointer = (char*)0x400000;
        printHexCharLine(*charPointer);
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
3291,0,CWE190_Integer_Overflow__int_listen_socket_multiply_54a.c,"    int data;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
19400,0,CWE190_Integer_Overflow__int64_t_fscanf_postinc_08.c,"    int64_t data;
    data = 0LL;
    if(staticReturnsTrue())
    {
        
        fscanf (stdin, ""%"" SCNd64, &data);
    }
    if(staticReturnsTrue())
    {
        {
            
            data++;
            int64_t result = data;
            printLongLongLine(result);
        }
"
11104,0,CWE190_Integer_Overflow__int_connect_socket_add_82_bad.cpp,"Label Definition File: CWE190_Integer_Overflow__int.label.xml
Template File: sources-sinks-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 190 Integer Overflow
 * BadSource: connect_socket Read data using a connect socket (client side)
 * GoodSource: Set data to a small, non-zero number (two)
 * Sinks: add
 *    GoodSink: Ensure there will not be an overflow before adding 1 to data
 *    BadSink : Add 1 to data, which can cause an overflow
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE190_Integer_Overflow__int_connect_socket_add_82.h""

namespace CWE190_Integer_Overflow__int_connect_socket_add_82
{

void CWE190_Integer_Overflow__int_connect_socket_add_82_bad::action(int data)
{
    {
        
        int result = data + 1;
        printIntLine(result);
    }
}

}
"
4683,0,CWE789_Uncontrolled_Mem_Alloc__new_char_fgets_02.cpp,"    size_t data;
    
    data = 0;
    if(1)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                
                data = strtoul(inputBuffer, NULL, 0);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    if(1)
    {
        {
            char * myString;
            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
             * for the strcpy() function to not cause a buffer overflow */
            
            if (data > strlen(HELLO_STRING))
            {
                myString = new char[data];
                
                strcpy(myString, HELLO_STRING);
                printLine(myString);
                delete [] myString;
            }
            else
            {
                printLine(""Input is less than the length of the source string"");
            }
        }
"
13409,0,CWE190_Integer_Overflow__unsigned_int_max_add_08.c,"    unsigned int data;
    data = 0;
    if(staticReturnsTrue())
    {
        
        data = UINT_MAX;
    }
    if(staticReturnsTrue())
    {
        {
            
            unsigned int result = data + 1;
            printUnsignedLine(result);
        }
"
16487,0,CWE190_Integer_Overflow__int64_t_max_square_83_bad.cpp,"Label Definition File: CWE190_Integer_Overflow.label.xml
Template File: sources-sinks-83_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 190 Integer Overflow
 * BadSource: max Set data to the max value for int64_t
 * GoodSource: Set data to a small, non-zero number (two)
 * Sinks: square
 *    GoodSink: Ensure there will not be an overflow before squaring data
 *    BadSink : Square data, which can lead to overflow
 * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE190_Integer_Overflow__int64_t_max_square_83.h""

#include <math.h>

namespace CWE190_Integer_Overflow__int64_t_max_square_83
{
CWE190_Integer_Overflow__int64_t_max_square_83_bad::CWE190_Integer_Overflow__int64_t_max_square_83_bad(int64_t dataCopy)
{
    data = dataCopy;
    
    data = LLONG_MAX;
}

CWE190_Integer_Overflow__int64_t_max_square_83_bad::~CWE190_Integer_Overflow__int64_t_max_square_83_bad()
{
    {
        
        int64_t result = data * data;
        printLongLongLine(result);
    }
}
}
"
17198,0,CWE401_Memory_Leak__int64_t_realloc_06.c,"    int64_t * data;
    data = NULL;
    if(STATIC_CONST_FIVE==5)
    {
        
        data = (int64_t *)realloc(data, 100*sizeof(int64_t));
        if (data == NULL) {exit(-1);}
        
        data[0] = 5LL;
        printLongLongLine(data[0]);
    }
    if(STATIC_CONST_FIVE==5)
    {
        
        ; 
"
18800,0,CWE590_Free_Memory_Not_on_Heap__delete_array_struct_static_54a.cpp,"    twoIntsStruct * data;
    data = NULL; 
    {
        
        static twoIntsStruct dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i].intOne = 1;
                dataBuffer[i].intTwo = 1;
            }
        }
        data = dataBuffer;
    }
"
5428,0,CWE590_Free_Memory_Not_on_Heap__delete_long_placement_new_81_bad.cpp,"Label Definition File: CWE590_Free_Memory_Not_on_Heap__delete.pointer.label.xml
Template File: sources-sink-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 590 Free Memory Not on Heap
 * BadSource: placement_new Data buffer is declared on the stack
 * GoodSource: Allocate memory on the heap
 * Sinks:
 *    BadSink : Print then free data
 * Flow Variant: 81 Data flow: data passed in a parameter to a virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE590_Free_Memory_Not_on_Heap__delete_long_placement_new_81.h""

namespace CWE590_Free_Memory_Not_on_Heap__delete_long_placement_new_81
{

void CWE590_Free_Memory_Not_on_Heap__delete_long_placement_new_81_bad::action(long * data) const
{
    printLongLine(*data);
    
    delete data;
}

}
"
3788,0,CWE197_Numeric_Truncation_Error__int_rand_to_short_52a.c,"    int data;
    
    data = -1;
    
    data = RAND32();
"
1533,0,CWE401_Memory_Leak__new_array_int64_t_13.cpp,"    int64_t * data;
    data = NULL;
    if(GLOBAL_CONST_FIVE==5)
    {
        
        data = new int64_t[100];
        
        data[0] = 5LL;
        printLongLongLine(data[0]);
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        
        ; 
"
1671,0,CWE475_Undefined_Behavior_for_Input_to_API__char_14.c,"    if(globalFive==5)
    {
        {
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            strcpy(data, ""abcdefghijklmnopqrstuvwxyz"");
            
            memcpy(data + 6, data + 4, 10*sizeof(char));
            printLine(data);
        }
"
11960,0,CWE401_Memory_Leak__int_malloc_42.c,"    int * data;
    data = NULL;
    data = badSource(data);
    
"
16804,0,CWE197_Numeric_Truncation_Error__short_fscanf_08.c,"    short data;
    
    data = -1;
    if(staticReturnsTrue())
    {
        
        fscanf (stdin, ""%hd"", &data);
    }
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
8638,0,CWE197_Numeric_Truncation_Error__int_listen_socket_to_char_51a.c,"    int data;
    
    data = -1;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
15293,0,CWE369_Divide_by_Zero__int_fgets_modulo_84_bad.cpp,"Label Definition File: CWE369_Divide_by_Zero__int.label.xml
Template File: sources-sinks-84_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 369 Divide by Zero
 * BadSource: fgets Read data from the console using fgets()
 * GoodSource: Non-zero
 * Sinks: modulo
 *    GoodSink: Check for zero before modulo
 *    BadSink : Modulo a constant with data
 * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE369_Divide_by_Zero__int_fgets_modulo_84.h""

#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)

namespace CWE369_Divide_by_Zero__int_fgets_modulo_84
{
CWE369_Divide_by_Zero__int_fgets_modulo_84_bad::CWE369_Divide_by_Zero__int_fgets_modulo_84_bad(int dataCopy)
{
    data = dataCopy;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
}

CWE369_Divide_by_Zero__int_fgets_modulo_84_bad::~CWE369_Divide_by_Zero__int_fgets_modulo_84_bad()
{
    
    printIntLine(100 % data);
}
}
"
1795,0,CWE190_Integer_Overflow__int64_t_fscanf_multiply_21.c,"    int64_t data;
    data = 0LL;
    
    fscanf (stdin, ""%"" SCNd64, &data);
    badStatic = 1; 
"
7225,0,CWE190_Integer_Overflow__int_fscanf_multiply_81_bad.cpp,"Label Definition File: CWE190_Integer_Overflow__int.label.xml
Template File: sources-sinks-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 190 Integer Overflow
 * BadSource: fscanf Read data from the console using fscanf()
 * GoodSource: Set data to a small, non-zero number (two)
 * Sinks: multiply
 *    GoodSink: Ensure there will not be an overflow before multiplying data by 2
 *    BadSink : If data is positive, multiply by 2, which can cause an overflow
 * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE190_Integer_Overflow__int_fscanf_multiply_81.h""

namespace CWE190_Integer_Overflow__int_fscanf_multiply_81
{

void CWE190_Integer_Overflow__int_fscanf_multiply_81_bad::action(int data) const
{
    if(data > 0) 
    {
        
        int result = data * 2;
        printIntLine(result);
    }
}

}
"
13204,0,CWE401_Memory_Leak__new_array_char_34.cpp,"    char * data;
    unionType myUnion;
    data = NULL;
    
    data = new char[100];
    
    strcpy(data, ""A String"");
    printLine(data);
    myUnion.unionFirst = data;
    {
        char * data = myUnion.unionSecond;
        
        ; 
"
10058,0,CWE676_Use_of_Potentially_Dangerous_Function__basic_03.cpp,"    if(5==5)
    {
        {
            char charBuffer[CHAR_BUFFER_SIZE];
            
            
            cin >> charBuffer;
            charBuffer[CHAR_BUFFER_SIZE-1] = '\0';
            printLine(charBuffer);
        }
"
15547,0,CWE457_Use_of_Uninitialized_Variable__struct_09.c,"    twoIntsStruct data;
    if(GLOBAL_CONST_TRUE)
    {
        
        ; 
    }
    if(GLOBAL_CONST_TRUE)
    {
        
        printIntLine(data.intOne);
        printIntLine(data.intTwo);
"
13650,0,CWE190_Integer_Overflow__short_fscanf_multiply_61a.c,"    short data;
    data = 0;
    data = CWE190_Integer_Overflow__short_fscanf_multiply_61b_badSource(data);
    if(data > 0) 
    {
        
        short result = data * 2;
        printIntLine(result);
"
13519,1,CWE476_NULL_Pointer_Dereference__binary_if_10.c,"    if(globalTrue)
    {
        {
            twoIntsStruct *twoIntsStructPointer = NULL;
            /* FIX: Use && in the if statement so that if the left side of the expression fails then
             * the right side will not be evaluated */
            if ((twoIntsStructPointer != NULL) && (twoIntsStructPointer->intOne == 5))
            {
                printLine(""intOne == 5"");
            }
        }
"
777,0,CWE690_NULL_Deref_From_Return__int_malloc_15.c,"    int * data;
    data = NULL; 
    
    data = (int *)malloc(1*sizeof(int));
    switch(6)
    {
    case 6:
        
        data[0] = 5;
        printIntLine(data[0]);
        free(data);
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
16243,0,CWE590_Free_Memory_Not_on_Heap__free_struct_declare_11.c,"    twoIntsStruct * data;
    data = NULL; 
    if(globalReturnsTrue())
    {
        {
            
            twoIntsStruct dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i].intOne = 1;
                    dataBuffer[i].intTwo = 1;
                }
            }
            data = dataBuffer;
        }
    }
    printStructLine(&data[0]);
    
"
7768,0,CWE190_Integer_Overflow__char_fscanf_preinc_42.c,"    char data;
    data = ' ';
    data = badSource(data);
    {
        
        ++data;
        char result = data;
        printHexCharLine(result);
"
19284,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_67a.c,"    size_t data;
    CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_67_structType myStruct;
    
    data = 0;
    
    data = rand();
    myStruct.structFirst = data;
"
15970,0,CWE590_Free_Memory_Not_on_Heap__delete_array_int64_t_alloca_41.cpp,"    int64_t * data;
    data = NULL; 
    {
        
        int64_t * dataBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5LL;
            }
        }
        data = dataBuffer;
    }
"
17352,0,CWE401_Memory_Leak__char_realloc_04.c,"    char * data;
    data = NULL;
    if(STATIC_CONST_TRUE)
    {
        
        data = (char *)realloc(data, 100*sizeof(char));
        if (data == NULL) {exit(-1);}
        
        strcpy(data, ""A String"");
        printLine(data);
    }
    if(STATIC_CONST_TRUE)
    {
        
        ; 
"
2291,0,CWE190_Integer_Overflow__char_rand_add_67a.c,"    char data;
    CWE190_Integer_Overflow__char_rand_add_67_structType myStruct;
    data = ' ';
    
    data = (char)RAND32();
    myStruct.structFirst = data;
"
13089,0,CWE190_Integer_Overflow__int64_t_rand_preinc_11.c,"    int64_t data;
    data = 0LL;
    if(globalReturnsTrue())
    {
        
        data = (int64_t)RAND64();
    }
    if(globalReturnsTrue())
    {
        {
            
            ++data;
            int64_t result = data;
            printLongLongLine(result);
        }
"
17404,0,CWE252_Unchecked_Return_Value__char_remove_15.c,"    switch(6)
    {
    case 6:
        
        REMOVE(""removemebad.txt"");
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
245,0,CWE252_Unchecked_Return_Value__char_scanf_18.c,"    goto sink;
sink:
    {
        /* By initializing dataBuffer, we ensure this will not be the
         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
        char dataBuffer[100] = """";
        char * data = dataBuffer;
        
        scanf(""%99s\0"", data);
"
10761,0,CWE590_Free_Memory_Not_on_Heap__delete_char_alloca_18.cpp,"    char * data;
    data = NULL; 
    goto source;
source:
    {
        
        char * dataBuffer = (char *)ALLOCA(sizeof(char));
        *dataBuffer = 'A';
        data = dataBuffer;
    }
    printHexCharLine(*data);
    
"
15299,0,CWE590_Free_Memory_Not_on_Heap__delete_array_class_declare_13.cpp,"    TwoIntsClass * data;
    data = NULL; 
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            
            TwoIntsClass dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i].intOne = 1;
                    dataBuffer[i].intTwo = 1;
                }
            }
            data = dataBuffer;
        }
    }
    printIntLine(data[0].intOne);
    
"
13730,0,CWE457_Use_of_Uninitialized_Variable__int_array_malloc_partial_init_10.c,"    int * data;
    data = (int *)malloc(10*sizeof(int));
    if (data == NULL) {exit(-1);}
    if(globalTrue)
    {
        
        {
            int i;
            for(i=0; i<(10/2); i++)
            {
                data[i] = i;
            }
        }
    }
    if(globalTrue)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i]);
            }
        }
"
16915,0,CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_34.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    {
        char * dataCopy = data;
        char * data = dataCopy;
        badVaSink(data, data);
"
1974,0,CWE190_Integer_Overflow__char_max_multiply_54a.c,"    char data;
    data = ' ';
    
    data = CHAR_MAX;
"
3853,0,CWE590_Free_Memory_Not_on_Heap__delete_struct_static_01.cpp,"    twoIntsStruct * data;
    data = NULL; 
    {
        
        static twoIntsStruct dataBuffer;
        dataBuffer.intOne = 1;
        dataBuffer.intTwo = 1;
        data = &dataBuffer;
    }
    printStructLine(data);
    
"
17549,0,CWE476_NULL_Pointer_Dereference__long_32.c,"    long * data;
    long * *dataPtr1 = &data;
    long * *dataPtr2 = &data;
    {
        long * data = *dataPtr1;
        
        data = NULL;
        *dataPtr1 = data;
    }
    {
        long * data = *dataPtr2;
        
        printLongLine(*data);
"
12249,0,CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_81a.cpp,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    const CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_81_base& baseObject = CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_81_bad();
"
12515,0,CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_01.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    {
        char dest[100] = """";
        
        SNPRINTF(dest, 100-1, data);
        printLine(dest);
"
15783,0,CWE190_Integer_Overflow__unsigned_int_rand_preinc_68a.c,"    unsigned int data;
    data = 0;
    
    data = (unsigned int)RAND32();
    CWE190_Integer_Overflow__unsigned_int_rand_preinc_68_badData = data;
"
15844,1,CWE758_Undefined_Behavior__long_alloca_use_10.c,"    if(globalTrue)
    {
        {
            long data;
            long * pointer = (long *)ALLOCA(sizeof(long));
            data = 5L;
            *pointer = data; 
            {
                long data = *pointer;
                printLongLine(data);
            }
        }
"
15791,0,CWE369_Divide_by_Zero__int_fscanf_divide_61a.c,"    int data;
    
    data = -1;
    data = CWE369_Divide_by_Zero__int_fscanf_divide_61b_badSource(data);
    
"
7302,0,CWE190_Integer_Overflow__unsigned_int_rand_preinc_13.c,"    unsigned int data;
    data = 0;
    if(GLOBAL_CONST_FIVE==5)
    {
        
        data = (unsigned int)RAND32();
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            
            ++data;
            unsigned int result = data;
            printUnsignedLine(result);
        }
"
4678,1,CWE252_Unchecked_Return_Value__char_putchar_03.c,"    if(5!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        
        if (putchar((int)'A') == EOF)
        {
            printLine(""putchar failed!"");
        }
"
17644,0,CWE416_Use_After_Free__malloc_free_struct_10.c,"    twoIntsStruct * data;
    
    data = NULL;
    if(globalTrue)
    {
        data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
        if (data == NULL) {exit(-1);}
        {
            size_t i;
            for(i = 0; i < 100; i++)
            {
                data[i].intOne = 1;
                data[i].intTwo = 2;
            }
        }
        
        free(data);
    }
    if(globalTrue)
    {
        
        printStructLine(&data[0]);
        
"
12739,0,CWE476_NULL_Pointer_Dereference__struct_08.c,"    twoIntsStruct * data;
    if(staticReturnsTrue())
    {
        
        data = NULL;
    }
    if(staticReturnsTrue())
    {
        
        printIntLine(data->intOne);
"
9335,0,CWE415_Double_Free__new_delete_long_43.cpp,"    long * data;
    
    data = NULL;
    badSource(data);
    
"
12959,0,CWE78_OS_Command_Injection__char_connect_socket_system_10.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(globalTrue)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET connectSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
"
2329,1,CWE758_Undefined_Behavior__int_malloc_use_05.c,"    if(staticTrue)
    {
        {
            int data;
            int * pointer = (int *)malloc(sizeof(int));
            if (pointer == NULL) {exit(-1);}
            data = 5;
            *pointer = data; 
            {
                int data = *pointer;
                printIntLine(data);
            }
            free(pointer);
        }
"
17912,1,CWE469_Use_of_Pointer_Subtraction_to_Determine_Size__char_03.c,"    if(5!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            char string1[] = SOURCE_STRING;
            char * slashInString1;
            size_t indexOfSlashInString1;
            slashInString1 = strchr(string1, '/');
            if (slashInString1 == NULL)
            {
                exit(1);
            }
            
            indexOfSlashInString1 = (size_t)(slashInString1 - string1);
            
            printUnsignedLine(indexOfSlashInString1);
        }
"
18813,0,CWE758_Undefined_Behavior__char_new_use_16.cpp,"    while(1)
    {
        {
            char * pointer = new char;
            char data = *pointer; 
            delete pointer;
            printHexCharLine(data);
        }
        break;
"
18398,0,CWE415_Double_Free__new_delete_array_int64_t_53a.cpp,"    int64_t * data;
    
    data = NULL;
    data = new int64_t[100];
    
    delete [] data;
"
4499,0,CWE190_Integer_Overflow__unsigned_int_max_multiply_51a.c,"    unsigned int data;
    data = 0;
    
    data = UINT_MAX;
"
299,0,CWE415_Double_Free__malloc_free_struct_74a.cpp,"    twoIntsStruct * data;
    map<int, twoIntsStruct *> dataMap;
    
    data = NULL;
    data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
    if (data == NULL) {exit(-1);}
    
    free(data);
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
602,0,CWE134_Uncontrolled_Format_String__char_file_vfprintf_32.c,"    char * data;
    char * *dataPtr1 = &data;
    char * *dataPtr2 = &data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        char * data = *dataPtr1;
        {
            
            size_t dataLen = strlen(data);
            FILE * pFile;
            
            if (100-dataLen > 1)
            {
                pFile = fopen(FILENAME, ""r"");
                if (pFile != NULL)
                {
                    
                    if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                    {
                        printLine(""fgets() failed"");
                        
                        data[dataLen] = '\0';
                    }
                    fclose(pFile);
                }
            }
        }
        *dataPtr1 = data;
    }
    {
        char * data = *dataPtr2;
        badVaSink(data, data);
"
12532,0,CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_83_bad.cpp,"Label Definition File: CWE134_Uncontrolled_Format_String.label.xml
Template File: sources-sinks-83_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 134 Uncontrolled Format String
 * BadSource: listen_socket Read data using a listen socket (server side)
 * GoodSource: Copy a fixed string into data
 * Sinks: fprintf
 *    GoodSink: fprintf with ""%s"" as the second argument and data as the third
 *    BadSink : fprintf with data as the second argument
 * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_83.h""

#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif

#define TCP_PORT 27015
#define LISTEN_BACKLOG 5

namespace CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_83
{
CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_83_bad::CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_83_bad(char * dataCopy)
{
    data = dataCopy;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
}

CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_83_bad::~CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_83_bad()
{
    
    fprintf(stdout, data);
}
}
"
3729,0,CWE590_Free_Memory_Not_on_Heap__free_int_alloca_81a.cpp,"    int * data;
    data = NULL; 
    {
        
        int * dataBuffer = (int *)ALLOCA(100*sizeof(int));
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5;
            }
        }
        data = dataBuffer;
    }
    const CWE590_Free_Memory_Not_on_Heap__free_int_alloca_81_base& baseObject = CWE590_Free_Memory_Not_on_Heap__free_int_alloca_81_bad();
"
14230,0,CWE369_Divide_by_Zero__float_fgets_42.c,"    float data;
    
    data = 0.0F;
    data = badSource(data);
    {
        
        int result = (int)(100.0 / data);
        printIntLine(result);
"
633,0,CWE401_Memory_Leak__new_array_twointsStruct_51a.cpp,"    twoIntsStruct * data;
    data = NULL;
    
    data = new twoIntsStruct[100];
    
    data[0].intOne = 0;
    data[0].intTwo = 0;
    printStructLine(&data[0]);
"
4912,0,CWE190_Integer_Overflow__int_connect_socket_multiply_53a.c,"    int data;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
11706,0,CWE190_Integer_Overflow__short_fscanf_add_04.c,"    short data;
    data = 0;
    if(STATIC_CONST_TRUE)
    {
        
        fscanf (stdin, ""%hd"", &data);
    }
    if(STATIC_CONST_TRUE)
    {
        {
            
            short result = data + 1;
            printIntLine(result);
        }
"
13700,0,CWE457_Use_of_Uninitialized_Variable__int_array_declare_no_init_10.c,"    int * data;
    int dataUninitArray[10];
    data = dataUninitArray;
    if(globalTrue)
    {
        
        ; 
    }
    if(globalTrue)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i]);
            }
        }
"
16372,1,CWE252_Unchecked_Return_Value__char_putc_12.c,"    if(globalReturnsTrueOrFalse())
    {
        
        if (putc((int)'A', stdout) == EOF)
        {
            printLine(""putc failed!"");
        }
    }
    else
    {
        
        if (putc((int)'A', stdout) == EOF)
        {
            printLine(""putc failed!"");
        }
"
10177,0,CWE401_Memory_Leak__malloc_realloc_struct_twoIntsStruct_10.c,"    if(globalTrue)
    {
        {
            struct _twoIntsStruct * data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));
            if (data == NULL) {exit(-1);}
            
            data[0].intOne = 0;
            data[0].intTwo = 0;
            printStructLine((twoIntsStruct *)&data[0]);
            
            data = (struct _twoIntsStruct *)realloc(data, (130000)*sizeof(struct _twoIntsStruct));
            if (data != NULL)
            {
                
                data[0].intOne = 1;
                data[0].intTwo = 1;
                printStructLine((twoIntsStruct *)&data[0]);
                free(data);
            }
        }
"
18756,0,CWE190_Integer_Overflow__int_connect_socket_preinc_65a.c,"    int data;
    
    void (*funcPtr) (int) = CWE190_Integer_Overflow__int_connect_socket_preinc_65b_badSink;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
"
2424,0,CWE134_Uncontrolled_Format_String__char_console_vfprintf_01.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        
        if (100-dataLen > 1)
        {
            
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgets() */
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
                    data[dataLen-1] = '\0';
                }
            }
            else
            {
                printLine(""fgets() failed"");
                
                data[dataLen] = '\0';
            }
        }
    }
"
1867,0,CWE563_Unused_Variable__unused_init_variable_long_83a.cpp,"    long data;
"
13178,1,CWE252_Unchecked_Return_Value__char_fwrite_06.c,"    if(STATIC_CONST_FIVE==5)
    {
        
        if (fwrite((char *)""string"", sizeof(char), strlen(""string""), stdout) != strlen(""string""))
        {
            printLine(""fwrite failed!"");
        }
"
2334,0,CWE690_NULL_Deref_From_Return__long_malloc_81a.cpp,"    long * data;
    data = NULL; 
    
    data = (long *)malloc(1*sizeof(long));
    const CWE690_NULL_Deref_From_Return__long_malloc_81_base& baseObject = CWE690_NULL_Deref_From_Return__long_malloc_81_bad();
"
612,1,CWE252_Unchecked_Return_Value__char_fprintf_18.c,"    goto sink;
sink:
    
    if (fprintf(stdout, ""%s\n"", ""string"") < 0)
    {
        printLine(""fprintf failed!"");
"
893,0,CWE190_Integer_Overflow__short_fscanf_postinc_11.c,"    short data;
    data = 0;
    if(globalReturnsTrue())
    {
        
        fscanf (stdin, ""%hd"", &data);
    }
    if(globalReturnsTrue())
    {
        {
            
            data++;
            short result = data;
            printIntLine(result);
        }
"
7728,0,CWE134_Uncontrolled_Format_String__char_file_vprintf_45.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        FILE * pFile;
        
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
    CWE134_Uncontrolled_Format_String__char_file_vprintf_45_badData = data;
"
14490,0,CWE190_Integer_Overflow__int_fscanf_multiply_13.c,"    int data;
    
    data = 0;
    if(GLOBAL_CONST_FIVE==5)
    {
        
        fscanf(stdin, ""%d"", &data);
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        if(data > 0) 
        {
            
            int result = data * 2;
            printIntLine(result);
        }
"
769,0,CWE690_NULL_Deref_From_Return__char_calloc_15.c,"    char * data;
    data = NULL; 
    
    data = (char *)calloc(20, sizeof(char));
    switch(6)
    {
    case 6:
        
        strcpy(data, ""Initialize"");
        printLine(data);
        free(data);
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
8539,0,CWE134_Uncontrolled_Format_String__char_environment_printf_05.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(staticTrue)
    {
        {
            
            size_t dataLen = strlen(data);
            char * environment = GETENV(ENV_VARIABLE);
            
            if (environment != NULL)
            {
                
                strncat(data+dataLen, environment, 100-dataLen-1);
            }
        }
    }
    if(staticTrue)
    {
        
        printf(data);
"
16950,0,CWE134_Uncontrolled_Format_String__char_environment_printf_61a.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    data = CWE134_Uncontrolled_Format_String__char_environment_printf_61b_badSource(data);
    
"
6445,0,CWE590_Free_Memory_Not_on_Heap__delete_array_struct_static_03.cpp,"    twoIntsStruct * data;
    data = NULL; 
    if(5==5)
    {
        {
            
            static twoIntsStruct dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i].intOne = 1;
                    dataBuffer[i].intTwo = 1;
                }
            }
            data = dataBuffer;
        }
    }
    printStructLine(&data[0]);
    
"
8244,0,CWE197_Numeric_Truncation_Error__int_rand_to_char_12.c,"    int data;
    
    data = -1;
    if(globalReturnsTrueOrFalse())
    {
        
        data = RAND32();
    }
    else
    {
        
        data = CHAR_MAX-5;
    }
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
8816,0,CWE78_OS_Command_Injection__char_file_popen_44.c,"    char * data;
    
    void (*funcPtr) (char *) = badSink;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
        
        size_t dataLen = strlen(data);
        FILE * pFile;
        
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
    
"
9461,0,CWE401_Memory_Leak__new_twoIntsStruct_82_bad.cpp,"Label Definition File: CWE401_Memory_Leak__new.label.xml
Template File: sources-sinks-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 401 Memory Leak
 * BadSource:  Allocate data using new
 * GoodSource: Allocate data on the stack
 * Sinks:
 *    GoodSink: call delete on data
 *    BadSink : no deallocation of data
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE401_Memory_Leak__new_twoIntsStruct_82.h""

namespace CWE401_Memory_Leak__new_twoIntsStruct_82
{

void CWE401_Memory_Leak__new_twoIntsStruct_82_bad::action(twoIntsStruct * data)
{
    
    ; 
}

}
"
7383,0,CWE369_Divide_by_Zero__int_fscanf_divide_54a.c,"    int data;
    
    data = -1;
    
    fscanf(stdin, ""%d"", &data);
"
4997,0,CWE690_NULL_Deref_From_Return__int_calloc_65a.c,"    int * data;
    
    void (*funcPtr) (int *) = CWE690_NULL_Deref_From_Return__int_calloc_65b_badSink;
    data = NULL; 
    
    data = (int *)calloc(1, sizeof(int));
    
"
10863,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_04.c,"    size_t data;
    
    data = 0;
    if(STATIC_CONST_TRUE)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = strtoul(inputBuffer, NULL, 0);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(STATIC_CONST_TRUE)
    {
        {
            char * myString;
            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
             * for the strcpy() function to not cause a buffer overflow */
            
            if (data > strlen(HELLO_STRING))
            {
                myString = (char *)malloc(data*sizeof(char));
                if (myString == NULL) {exit(-1);}
                
                strcpy(myString, HELLO_STRING);
                printLine(myString);
                free(myString);
            }
            else
            {
                printLine(""Input is less than the length of the source string"");
            }
        }
"
19056,0,CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_01.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
10680,1,CWE252_Unchecked_Return_Value__char_rename_03.c,"    if(5==5)
    {
        
        if (RENAME(OLD_GOOD_FILE_NAME, ""newgoodfilename.txt"") != 0)
        {
            printLine(""rename failed!"");
        }
"
8273,0,CWE78_OS_Command_Injection__char_connect_socket_popen_84_bad.cpp,"Label Definition File: CWE78_OS_Command_Injection.one_string.label.xml
Template File: sources-sink-84_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 78 OS Command Injection
 * BadSource: connect_socket Read data using a connect socket (client side)
 * GoodSource: Fixed string
 * Sinks: popen
 *    BadSink : Execute command in data using popen()
 * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE78_OS_Command_Injection__char_connect_socket_popen_84.h""
"
8887,0,CWE415_Double_Free__new_delete_array_long_73a.cpp,"    long * data;
    list<long *> dataList;
    
    data = NULL;
    data = new long[100];
    
    delete [] data;
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
5788,0,CWE190_Integer_Overflow__int_listen_socket_preinc_15.c,"    int data;
    
    data = 0;
    switch(6)
    {
    case 6:
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
    {
        
        ++data;
        int result = data;
        printIntLine(result);
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
5851,0,CWE476_NULL_Pointer_Dereference__deref_after_check_03.c,"    if(5==5)
    {
        {
            
            int *intPointer = NULL;
            if (intPointer == NULL)
            {
                printIntLine(*intPointer);
            }
        }
"
12673,0,CWE190_Integer_Overflow__int_connect_socket_multiply_45.c,"    int data;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    CWE190_Integer_Overflow__int_connect_socket_multiply_45_badData = data;
"
15315,0,CWE190_Integer_Overflow__int_listen_socket_square_82_bad.cpp,"Label Definition File: CWE190_Integer_Overflow__int.label.xml
Template File: sources-sinks-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 190 Integer Overflow
 * BadSource: listen_socket Read data using a listen socket (server side)
 * GoodSource: Set data to a small, non-zero number (two)
 * Sinks: square
 *    GoodSink: Ensure there will not be an overflow before squaring data
 *    BadSink : Square data, which can lead to overflow
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE190_Integer_Overflow__int_listen_socket_square_82.h""

#include <math.h>

namespace CWE190_Integer_Overflow__int_listen_socket_square_82
{

void CWE190_Integer_Overflow__int_listen_socket_square_82_bad::action(int data)
{
    {
        
        int result = data * data;
        printIntLine(result);
    }
}

}
"
15262,1,CWE252_Unchecked_Return_Value__char_puts_08.c,"    if(staticReturnsTrue())
    {
        
        if (PUTS(""string"") == EOF)
        {
            printLine(""puts failed!"");
        }
"
3236,0,CWE197_Numeric_Truncation_Error__short_fscanf_45.c,"    short data;
    
    data = -1;
    
    fscanf (stdin, ""%hd"", &data);
    CWE197_Numeric_Truncation_Error__short_fscanf_45_badData = data;
"
17274,0,CWE590_Free_Memory_Not_on_Heap__delete_array_struct_declare_51a.cpp,"    twoIntsStruct * data;
    data = NULL; 
    {
        
        twoIntsStruct dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i].intOne = 1;
                dataBuffer[i].intTwo = 1;
            }
        }
        data = dataBuffer;
    }
"
3424,0,CWE190_Integer_Overflow__int_listen_socket_square_06.c,"    int data;
    
    data = 0;
    if(STATIC_CONST_FIVE==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(STATIC_CONST_FIVE==5)
    {
        {
            
            int result = data * data;
            printIntLine(result);
        }
"
15408,0,CWE758_Undefined_Behavior__int64_t_new_use_02.cpp,"    if(1)
    {
        {
            int64_t * pointer = new int64_t;
            int64_t data = *pointer; 
            delete pointer;
            printLongLongLine(data);
        }
"
6137,1,CWE758_Undefined_Behavior__int_pointer_alloca_use_03.c,"    if(5!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            int * data;
            int * * pointer = (int * *)ALLOCA(sizeof(int *));
            
            data = (int *)malloc(sizeof(int));
            if (data == NULL) {exit(-1);}
            *data = 5;
            *pointer = data; 
            {
                int * data = *pointer;
                printIntLine(*data);
            }
        }
"
9810,0,CWE590_Free_Memory_Not_on_Heap__delete_array_int64_t_static_51a.cpp,"    int64_t * data;
    data = NULL; 
    {
        
        static int64_t dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5LL;
            }
        }
        data = dataBuffer;
    }
"
9165,0,CWE134_Uncontrolled_Format_String__char_console_printf_81a.cpp,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        
        if (100-dataLen > 1)
        {
            
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgets() */
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
                    data[dataLen-1] = '\0';
                }
            }
            else
            {
                printLine(""fgets() failed"");
                
                data[dataLen] = '\0';
            }
        }
    }
    const CWE134_Uncontrolled_Format_String__char_console_printf_81_base& baseObject = CWE134_Uncontrolled_Format_String__char_console_printf_81_bad();
"
16370,1,CWE252_Unchecked_Return_Value__char_fread_13.c,"    if(GLOBAL_CONST_FIVE==5)
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            
            if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) != 100-1)
            {
                printLine(""fread failed!"");
            }
        }
"
15873,0,CWE590_Free_Memory_Not_on_Heap__free_struct_alloca_34.c,"    twoIntsStruct * data;
    CWE590_Free_Memory_Not_on_Heap__free_struct_alloca_34_unionType myUnion;
    data = NULL; 
    {
        
        twoIntsStruct * dataBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i].intOne = 1;
                dataBuffer[i].intTwo = 1;
            }
        }
        data = dataBuffer;
    }
    myUnion.unionFirst = data;
    {
        twoIntsStruct * data = myUnion.unionSecond;
        printStructLine(&data[0]);
        
        free(data);
"
15401,0,CWE401_Memory_Leak__struct_twoIntsStruct_calloc_84_bad.cpp,"Label Definition File: CWE401_Memory_Leak.c.label.xml
Template File: sources-sinks-84_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 401 Memory Leak
 * BadSource: calloc Allocate data using calloc()
 * GoodSource: Allocate data on the stack
 * Sinks:
 *    GoodSink: call free() on data
 *    BadSink : no deallocation of data
 * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE401_Memory_Leak__struct_twoIntsStruct_calloc_84.h""

namespace CWE401_Memory_Leak__struct_twoIntsStruct_calloc_84
{
CWE401_Memory_Leak__struct_twoIntsStruct_calloc_84_bad::CWE401_Memory_Leak__struct_twoIntsStruct_calloc_84_bad(struct _twoIntsStruct * dataCopy)
{
    data = dataCopy;
    
    data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));
    if (data == NULL) {exit(-1);}
    
    data[0].intOne = 0;
    data[0].intTwo = 0;
    printStructLine((twoIntsStruct *)&data[0]);
}

CWE401_Memory_Leak__struct_twoIntsStruct_calloc_84_bad::~CWE401_Memory_Leak__struct_twoIntsStruct_calloc_84_bad()
{
    
    ; 
}
}
"
14871,1,CWE252_Unchecked_Return_Value__char_puts_16.c,"    while(1)
    {
        
        if (PUTS(""string"") == EOF)
        {
            printLine(""puts failed!"");
        }
        break;
"
2636,0,CWE190_Integer_Overflow__int_max_square_06.c,"    int data;
    
    data = 0;
    if(STATIC_CONST_FIVE==5)
    {
        
        data = INT_MAX;
    }
    if(STATIC_CONST_FIVE==5)
    {
        {
            
            int result = data * data;
            printIntLine(result);
        }
"
18789,0,CWE190_Integer_Overflow__unsigned_int_max_multiply_32.c,"    unsigned int data;
    unsigned int *dataPtr1 = &data;
    unsigned int *dataPtr2 = &data;
    data = 0;
    {
        unsigned int data = *dataPtr1;
        
        data = UINT_MAX;
        *dataPtr1 = data;
    }
    {
        unsigned int data = *dataPtr2;
        if(data > 0) 
        {
            
            unsigned int result = data * 2;
            printUnsignedLine(result);
        }
"
8851,0,CWE134_Uncontrolled_Format_String__char_console_vprintf_31.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        
        if (100-dataLen > 1)
        {
            
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgets() */
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
                    data[dataLen-1] = '\0';
                }
            }
            else
            {
                printLine(""fgets() failed"");
                
                data[dataLen] = '\0';
            }
        }
    }
    {
        char * dataCopy = data;
        char * data = dataCopy;
        badVaSink(data, data);
"
19397,0,CWE415_Double_Free__new_delete_array_long_15.cpp,"    long * data;
    
    data = NULL;
    switch(6)
    {
    case 6:
        data = new long[100];
        
        delete [] data;
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
        
        delete [] data;
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
7124,0,CWE401_Memory_Leak__new_twoIntsStruct_45.cpp,"    twoIntsStruct * data;
    data = NULL;
    
    data = new twoIntsStruct;
    
    data->intOne = 0;
    data->intTwo = 0;
    printStructLine(data);
    badData = data;
"
19518,0,CWE590_Free_Memory_Not_on_Heap__delete_char_declare_32.cpp,"    char * data;
    char * *dataPtr1 = &data;
    char * *dataPtr2 = &data;
    data = NULL; 
    {
        char * data = *dataPtr1;
        {
            
            char dataBuffer;
            dataBuffer = 'A';
            data = &dataBuffer;
        }
        *dataPtr1 = data;
    }
    {
        char * data = *dataPtr2;
        printHexCharLine(*data);
        
        delete data;
"
13185,0,CWE758_Undefined_Behavior__struct_pointer_malloc_use_17.c,"    int j;
    for(j = 0; j < 1; j++)
    {
        {
            twoIntsStruct * * pointer = (twoIntsStruct * *)malloc(sizeof(twoIntsStruct *));
            if (pointer == NULL) {exit(-1);}
            twoIntsStruct * data = *pointer; 
            free(pointer);
            printIntLine(data->intOne);
            printIntLine(data->intTwo);
        }
"
7161,0,CWE190_Integer_Overflow__int_max_square_16.c,"    int data;
    
    data = 0;
    while(1)
    {
        
        data = INT_MAX;
        break;
    }
    while(1)
    {
        {
            
            int result = data * data;
            printIntLine(result);
        }
        break;
"
11538,0,CWE590_Free_Memory_Not_on_Heap__delete_array_char_static_65a.cpp,"    char * data;
    
    void (*funcPtr) (char *) = badSink;
    data = NULL; 
    {
        
        static char dataBuffer[100];
        memset(dataBuffer, 'A', 100-1); 
        dataBuffer[100-1] = '\0'; 
        data = dataBuffer;
    }
    
"
17554,0,CWE190_Integer_Overflow__int_rand_add_43.cpp,"    int data;
    
    data = 0;
    badSource(data);
    {
        
        int result = data + 1;
        printIntLine(result);
"
4970,0,CWE134_Uncontrolled_Format_String__char_connect_socket_printf_02.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(1)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET connectSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                
                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                data[dataLen + recvResult / sizeof(char)] = '\0';
                
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(1)
    {
        
        printf(data);
"
18999,0,CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_82_bad.cpp,"Label Definition File: CWE134_Uncontrolled_Format_String.vasinks.label.xml
Template File: sources-vasinks-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 134 Uncontrolled Format String
 * BadSource: listen_socket Read data using a listen socket (server side)
 * GoodSource: Copy a fixed string into data
 * Sinks: vprintf
 *    GoodSink: vprintf with a format string
 *    BadSink : vprintf without a format string
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include <stdarg.h>
#include ""std_testcase.h""
#include ""CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_82.h""

namespace CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_82
{

static void badVaSink(char * data, ...)
{
    {
        va_list args;
        va_start(args, data);
        
        vprintf(data, args);
        va_end(args);
    }
}

void CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_82_bad::action(char * data)
{
    badVaSink(data, data);
}

}
"
10690,0,CWE190_Integer_Overflow__unsigned_int_max_postinc_41.c,"    unsigned int data;
    data = 0;
    
    data = UINT_MAX;
"
9892,0,CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_64a.c,"    unsigned int data;
    data = 0;
    
    fscanf (stdin, ""%u"", &data);
"
1105,1,CWE758_Undefined_Behavior__struct_malloc_use_02.c,"    if(1)
    {
        {
            twoIntsStruct data;
            twoIntsStruct * pointer = (twoIntsStruct *)malloc(sizeof(twoIntsStruct));
            if (pointer == NULL) {exit(-1);}
            data.intOne = 1;
            data.intTwo = 2;
            *pointer = data; 
            {
                twoIntsStruct data = *pointer;
                printIntLine(data.intOne);
                printIntLine(data.intTwo);
            }
            free(pointer);
        }
"
15498,0,CWE758_Undefined_Behavior__char_alloca_use_17.c,"    int j;
    for(j = 0; j < 1; j++)
    {
        {
            char * pointer = (char *)ALLOCA(sizeof(char));
            char data = *pointer; 
            printHexCharLine(data);
        }
"
12359,0,CWE563_Unused_Variable__unused_value_char_72a.cpp,"    char data;
    vector<char> dataVector;
    
    data = 'C';
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
13520,0,CWE190_Integer_Overflow__int_fgets_square_62a.cpp,"    int data;
    
    data = 0;
    badSource(data);
    {
        
        int result = data * data;
        printIntLine(result);
"
2985,1,CWE252_Unchecked_Return_Value__char_fgets_13.c,"    if(GLOBAL_CONST_FIVE!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            printLine(""Please enter a string: "");
            
            if (fgets(data, 100, stdin) == NULL)
            {
                printLine(""fgets failed!"");
                exit(1);
            }
            printLine(data);
        }
"
13951,0,CWE590_Free_Memory_Not_on_Heap__free_int_declare_45.c,"    int * data;
    data = NULL; 
    {
        
        int dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5;
            }
        }
        data = dataBuffer;
    }
    CWE590_Free_Memory_Not_on_Heap__free_int_declare_45_badData = data;
"
8128,0,CWE457_Use_of_Uninitialized_Variable__int_array_declare_partial_init_63a.c,"    int * data;
    int dataUninitArray[10];
    data = dataUninitArray;
    
    {
        int i;
        for(i=0; i<(10/2); i++)
        {
            data[i] = i;
        }
    }
"
4804,1,CWE401_Memory_Leak__malloc_realloc_int_05.c,"    if(staticFalse)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            int * data = (int *)malloc(100*sizeof(int));
            if (data == NULL) {exit(-1);}
            int * tmpData;
            
            data[0] = 5;
            printIntLine(data[0]);
            tmpData = (int *)realloc(data, (130000)*sizeof(int));
            /* FIX: Ensure realloc() was successful before assigning data to the memory block
            * allocated with realloc() */
            if (tmpData != NULL)
            {
                data = tmpData;
                
                data[0] = 10;
                printIntLine(data[0]);
            }
            free(data);
        }
"
2219,0,CWE190_Integer_Overflow__int64_t_fscanf_preinc_51a.c,"    int64_t data;
    data = 0LL;
    
    fscanf (stdin, ""%"" SCNd64, &data);
"
3872,0,CWE401_Memory_Leak__new_array_twointsStruct_13.cpp,"    twoIntsStruct * data;
    data = NULL;
    if(GLOBAL_CONST_FIVE==5)
    {
        
        data = new twoIntsStruct[100];
        
        data[0].intOne = 0;
        data[0].intTwo = 0;
        printStructLine(&data[0]);
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        
        ; 
"
5227,0,CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_21.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    badStatic = 1; 
"
19195,0,CWE190_Integer_Overflow__char_max_multiply_07.c,"    char data;
    data = ' ';
    if(staticFive==5)
    {
        
        data = CHAR_MAX;
    }
    if(staticFive==5)
    {
        if(data > 0) 
        {
            
            char result = data * 2;
            printHexCharLine(result);
        }
"
5459,0,CWE197_Numeric_Truncation_Error__int_large_to_short_33.cpp,"    int data;
    int &dataRef = data;
    
    data = -1;
    
    data = SHRT_MAX + 5;
    {
        int data = dataRef;
        {
            
            short shortData = (short)data;
            printShortLine(shortData);
        }
"
11060,0,CWE197_Numeric_Truncation_Error__int_fscanf_to_char_16.c,"    int data;
    
    data = -1;
    while(1)
    {
        
        fscanf(stdin, ""%d"", &data);
        break;
    }
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
8148,0,CWE190_Integer_Overflow__int64_t_fscanf_square_41.c,"    int64_t data;
    data = 0LL;
    
    fscanf (stdin, ""%"" SCNd64, &data);
"
1799,0,CWE590_Free_Memory_Not_on_Heap__free_char_alloca_66a.c,"    char * data;
    char * dataArray[5];
    data = NULL; 
    {
        
        char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
        memset(dataBuffer, 'A', 100-1); 
        dataBuffer[100-1] = '\0'; 
        data = dataBuffer;
    }
    
    dataArray[2] = data;
"
3075,0,CWE590_Free_Memory_Not_on_Heap__free_struct_alloca_32.c,"    twoIntsStruct * data;
    twoIntsStruct * *dataPtr1 = &data;
    twoIntsStruct * *dataPtr2 = &data;
    data = NULL; 
    {
        twoIntsStruct * data = *dataPtr1;
        {
            
            twoIntsStruct * dataBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i].intOne = 1;
                    dataBuffer[i].intTwo = 1;
                }
            }
            data = dataBuffer;
        }
        *dataPtr1 = data;
    }
    {
        twoIntsStruct * data = *dataPtr2;
        printStructLine(&data[0]);
        
        free(data);
"
8574,0,CWE590_Free_Memory_Not_on_Heap__delete_array_struct_alloca_12.cpp,"    twoIntsStruct * data;
    data = NULL; 
    if(globalReturnsTrueOrFalse())
    {
        {
            
            twoIntsStruct * dataBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i].intOne = 1;
                    dataBuffer[i].intTwo = 1;
                }
            }
            data = dataBuffer;
        }
    }
    else
    {
        {
            
            twoIntsStruct * dataBuffer = new twoIntsStruct[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i].intOne = 1;
                    dataBuffer[i].intTwo = 1;
                }
            }
            data = dataBuffer;
        }
    }
    printStructLine(&data[0]);
    
"
16858,0,CWE190_Integer_Overflow__int64_t_rand_multiply_51a.c,"    int64_t data;
    data = 0LL;
    
    data = (int64_t)RAND64();
"
6856,0,CWE190_Integer_Overflow__unsigned_int_fscanf_add_42.c,"    unsigned int data;
    data = 0;
    data = badSource(data);
    {
        
        unsigned int result = data + 1;
        printUnsignedLine(result);
"
17040,0,CWE457_Use_of_Uninitialized_Variable__twointsclass_array_new_partial_init_06.cpp,"    TwoIntsClass * data;
    data = new TwoIntsClass[10];
    if(STATIC_CONST_FIVE==5)
    {
        
        for(int i=0; i<(10/2); i++)
        {
            data[i].intOne = i;
            data[i].intTwo = i;
        }
    }
    if(STATIC_CONST_FIVE==5)
    {
        
        for(int i=0; i<10; i++)
        {
            printIntLine(data[i].intOne);
            printIntLine(data[i].intTwo);
        }
"
16519,0,CWE190_Integer_Overflow__unsigned_int_max_preinc_09.c,"    unsigned int data;
    data = 0;
    if(GLOBAL_CONST_TRUE)
    {
        
        data = UINT_MAX;
    }
    if(GLOBAL_CONST_TRUE)
    {
        {
            
            ++data;
            unsigned int result = data;
            printUnsignedLine(result);
        }
"
10417,0,CWE190_Integer_Overflow__int_listen_socket_add_74a.cpp,"    int data;
    map<int, int> dataMap;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
367,0,CWE690_NULL_Deref_From_Return__int_realloc_66a.c,"    int * data;
    int * dataArray[5];
    data = NULL; 
    
    data = (int *)realloc(data, 1*sizeof(int));
    
    dataArray[2] = data;
"
8119,0,CWE789_Uncontrolled_Mem_Alloc__new_char_listen_socket_03.cpp,"    size_t data;
    
    data = 0;
    if(5==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = strtoul(inputBuffer, NULL, 0);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(5==5)
    {
        {
            char * myString;
            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
             * for the strcpy() function to not cause a buffer overflow */
            
            if (data > strlen(HELLO_STRING))
            {
                myString = new char[data];
                
                strcpy(myString, HELLO_STRING);
                printLine(myString);
                delete [] myString;
            }
            else
            {
                printLine(""Input is less than the length of the source string"");
            }
        }
"
3092,1,CWE758_Undefined_Behavior__int_new_use_10.cpp,"    if(globalTrue)
    {
        {
            int data;
            data = 5;
            int * pointer = new int;
            *pointer = data; 
            {
                int data = *pointer;
                printIntLine(data);
            }
            delete pointer;
        }
"
12842,0,CWE590_Free_Memory_Not_on_Heap__free_int_declare_64a.c,"    int * data;
    data = NULL; 
    {
        
        int dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5;
            }
        }
        data = dataBuffer;
    }
"
15209,0,CWE190_Integer_Overflow__int64_t_rand_postinc_34.c,"    int64_t data;
    CWE190_Integer_Overflow__int64_t_rand_postinc_34_unionType myUnion;
    data = 0LL;
    
    data = (int64_t)RAND64();
    myUnion.unionFirst = data;
    {
        int64_t data = myUnion.unionSecond;
        {
            
            data++;
            int64_t result = data;
            printLongLongLine(result);
        }
"
16035,1,CWE401_Memory_Leak__malloc_realloc_twoIntsStruct_06.c,"    if(STATIC_CONST_FIVE==5)
    {
        {
            twoIntsStruct * data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
            if (data == NULL) {exit(-1);}
            twoIntsStruct * tmpData;
            
            data[0].intOne = 0;
            data[0].intTwo = 0;
            printStructLine(&data[0]);
            tmpData = (twoIntsStruct *)realloc(data, (130000)*sizeof(twoIntsStruct));
            /* FIX: Ensure realloc() was successful before assigning data to the memory block
            * allocated with realloc() */
            if (tmpData != NULL)
            {
                data = tmpData;
                
                data[0].intOne = 1;
                data[0].intTwo = 1;
                printStructLine(&data[0]);
            }
            free(data);
        }
"
11795,0,CWE369_Divide_by_Zero__int_fscanf_divide_11.c,"    int data;
    
    data = -1;
    if(globalReturnsTrue())
    {
        
        fscanf(stdin, ""%d"", &data);
    }
    if(globalReturnsTrue())
    {
        
        printIntLine(100 / data);
"
10692,0,CWE590_Free_Memory_Not_on_Heap__delete_array_char_declare_12.cpp,"    char * data;
    data = NULL; 
    if(globalReturnsTrueOrFalse())
    {
        {
            
            char dataBuffer[100];
            memset(dataBuffer, 'A', 100-1); 
            dataBuffer[100-1] = '\0'; 
            data = dataBuffer;
        }
    }
    else
    {
        {
            
            char * dataBuffer = new char[100];
            memset(dataBuffer, 'A', 100-1); 
            dataBuffer[100-1] = '\0'; 
            data = dataBuffer;
        }
    }
    printLine(data);
    
"
5141,0,CWE197_Numeric_Truncation_Error__int_fscanf_to_char_31.c,"    int data;
    
    data = -1;
    
    fscanf(stdin, ""%d"", &data);
    {
        int dataCopy = data;
        int data = dataCopy;
        {
            
            char charData = (char)data;
            printHexCharLine(charData);
        }
"
16185,0,CWE190_Integer_Overflow__short_max_square_15.c,"    short data;
    data = 0;
    switch(6)
    {
    case 6:
        
        data = SHRT_MAX;
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
    {
        
        short result = data * data;
        printIntLine(result);
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
6973,0,CWE590_Free_Memory_Not_on_Heap__free_int64_t_static_65a.c,"    int64_t * data;
    
    void (*funcPtr) (int64_t *) = CWE590_Free_Memory_Not_on_Heap__free_int64_t_static_65b_badSink;
    data = NULL; 
    {
        
        static int64_t dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5LL;
            }
        }
        data = dataBuffer;
    }
    
"
11531,0,CWE690_NULL_Deref_From_Return__struct_calloc_82_bad.cpp,"Label Definition File: CWE690_NULL_Deref_From_Return.free.label.xml
Template File: source-sinks-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 690 Unchecked Return Value To NULL Pointer
 * BadSource: calloc Allocate data using calloc()
 * Sinks:
 *    GoodSink: Check to see if the data allocation failed and if not, use data
 *    BadSink : Don't check for NULL and use data
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE690_NULL_Deref_From_Return__struct_calloc_82.h""

namespace CWE690_NULL_Deref_From_Return__struct_calloc_82
{

void CWE690_NULL_Deref_From_Return__struct_calloc_82_bad::action(twoIntsStruct * data)
{
    
    data[0].intOne = 1;
    data[0].intTwo = 1;
    printStructLine(&data[0]);
    free(data);
}

}
"
6384,0,CWE415_Double_Free__new_delete_int64_t_07.cpp,"    int64_t * data;
    
    data = NULL;
    if(staticFive==5)
    {
        data = new int64_t;
        
        delete data;
    }
    if(staticFive==5)
    {
        
        delete data;
"
8101,0,CWE590_Free_Memory_Not_on_Heap__delete_struct_static_09.cpp,"    twoIntsStruct * data;
    data = NULL; 
    if(GLOBAL_CONST_TRUE)
    {
        {
            
            static twoIntsStruct dataBuffer;
            dataBuffer.intOne = 1;
            dataBuffer.intTwo = 1;
            data = &dataBuffer;
        }
    }
    printStructLine(data);
    
"
3034,0,CWE134_Uncontrolled_Format_String__char_console_snprintf_13.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            
            size_t dataLen = strlen(data);
            
            if (100-dataLen > 1)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
                {
                    /* The next few lines remove the carriage return from the string that is
                     * inserted by fgets() */
                    dataLen = strlen(data);
                    if (dataLen > 0 && data[dataLen-1] == '\n')
                    {
                        data[dataLen-1] = '\0';
                    }
                }
                else
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
            }
        }
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            char dest[100] = """";
            
            SNPRINTF(dest, 100-1, data);
            printLine(dest);
        }
"
14732,0,CWE563_Unused_Variable__unused_init_variable_int_10.c,"    int data;
    
    data = 5;
    if(globalTrue)
    {
        
        
        ; 
"
4288,1,CWE467_Use_of_sizeof_on_Pointer_Type__int_11.c,"    if(globalReturnsFalse())
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            int * goodInt = NULL;
            
            goodInt = (int *)malloc(sizeof(*goodInt));
            if (goodInt == NULL) {exit(-1);}
            *goodInt = 6;
            printIntLine(*goodInt);
            free(goodInt);
        }
"
16729,0,CWE190_Integer_Overflow__int_rand_square_84_bad.cpp,"Label Definition File: CWE190_Integer_Overflow__int.label.xml
Template File: sources-sinks-84_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 190 Integer Overflow
 * BadSource: rand Set data to result of rand(), which may be zero
 * GoodSource: Set data to a small, non-zero number (two)
 * Sinks: square
 *    GoodSink: Ensure there will not be an overflow before squaring data
 *    BadSink : Square data, which can lead to overflow
 * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE190_Integer_Overflow__int_rand_square_84.h""

#include <math.h>

namespace CWE190_Integer_Overflow__int_rand_square_84
{
CWE190_Integer_Overflow__int_rand_square_84_bad::CWE190_Integer_Overflow__int_rand_square_84_bad(int dataCopy)
{
    data = dataCopy;
    
    data = RAND32();
}

CWE190_Integer_Overflow__int_rand_square_84_bad::~CWE190_Integer_Overflow__int_rand_square_84_bad()
{
    {
        
        int result = data * data;
        printIntLine(result);
    }
}
}
"
1796,0,CWE415_Double_Free__new_delete_array_int64_t_54a.cpp,"    int64_t * data;
    
    data = NULL;
    data = new int64_t[100];
    
    delete [] data;
"
12588,0,CWE563_Unused_Variable__unused_uninit_variable_char_73a.cpp,"    char data;
    list<char> dataList;
    
    ; 
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
9475,0,CWE197_Numeric_Truncation_Error__int_fscanf_to_short_34.c,"    int data;
    CWE197_Numeric_Truncation_Error__int_fscanf_to_short_34_unionType myUnion;
    
    data = -1;
    
    fscanf(stdin, ""%d"", &data);
    myUnion.unionFirst = data;
    {
        int data = myUnion.unionSecond;
        {
            
            short shortData = (short)data;
            printShortLine(shortData);
        }
"
2535,0,CWE369_Divide_by_Zero__int_rand_divide_02.c,"    int data;
    
    data = -1;
    if(1)
    {
        
        data = RAND32();
    }
    if(1)
    {
        
        printIntLine(100 / data);
"
10738,0,CWE590_Free_Memory_Not_on_Heap__delete_array_int64_t_static_65a.cpp,"    int64_t * data;
    
    void (*funcPtr) (int64_t *) = badSink;
    data = NULL; 
    {
        
        static int64_t dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5LL;
            }
        }
        data = dataBuffer;
    }
    
"
9357,0,CWE78_OS_Command_Injection__char_console_execlp_81_bad.cpp,"Label Definition File: CWE78_OS_Command_Injection.strings.label.xml
Template File: sources-sink-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 78 OS Command Injection
 * BadSource: console Read input from the console
 * GoodSource: Fixed string
 * Sinks: execlp
 *    BadSink : execute command with execlp
 * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE78_OS_Command_Injection__char_console_execlp_81.h""
"
5777,0,CWE369_Divide_by_Zero__float_fscanf_01.c,"    float data;
    
    data = 0.0F;
    
    fscanf (stdin, ""%f"", &data);
    {
        
        int result = (int)(100.0 / data);
        printIntLine(result);
"
3202,0,CWE476_NULL_Pointer_Dereference__int64_t_18.c,"    int64_t * data;
    goto source;
source:
    
    data = NULL;
    goto sink;
sink:
    
"
10916,0,CWE190_Integer_Overflow__int_listen_socket_postinc_31.c,"    int data;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    {
        int dataCopy = data;
        int data = dataCopy;
        {
            
            data++;
            int result = data;
            printIntLine(result);
        }
"
18546,0,CWE197_Numeric_Truncation_Error__short_listen_socket_09.c,"    short data;
    
    data = -1;
    if(GLOBAL_CONST_TRUE)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = (short)atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
12904,1,CWE252_Unchecked_Return_Value__char_putchar_05.c,"    if(staticFalse)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        
        if (putchar((int)'A') == EOF)
        {
            printLine(""putchar failed!"");
        }
"
6666,0,CWE690_NULL_Deref_From_Return__struct_realloc_04.c,"    twoIntsStruct * data;
    data = NULL; 
    
    data = (twoIntsStruct *)realloc(data, 1*sizeof(twoIntsStruct));
    if(STATIC_CONST_TRUE)
    {
        
        data[0].intOne = 1;
        data[0].intTwo = 1;
        printStructLine(&data[0]);
        free(data);
"
6264,0,CWE590_Free_Memory_Not_on_Heap__delete_array_int64_t_declare_16.cpp,"    int64_t * data;
    data = NULL; 
    while(1)
    {
        {
            
            int64_t dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5LL;
                }
            }
            data = dataBuffer;
        }
        break;
    }
    printLongLongLine(data[0]);
    
"
11162,0,CWE134_Uncontrolled_Format_String__char_console_vprintf_51a.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        
        if (100-dataLen > 1)
        {
            
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgets() */
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
                    data[dataLen-1] = '\0';
                }
            }
            else
            {
                printLine(""fgets() failed"");
                
                data[dataLen] = '\0';
            }
        }
    }
"
17785,1,CWE467_Use_of_sizeof_on_Pointer_Type__short_03.c,"    if(5==5)
    {
        {
            short * goodShort = NULL;
            
            goodShort = (short *)malloc(sizeof(*goodShort));
            if (goodShort == NULL) {exit(-1);}
            *goodShort = 6;
            printShortLine(*goodShort);
            free(goodShort);
        }
"
4812,0,CWE190_Integer_Overflow__int_fscanf_preinc_22a.c,"    int data;
    
    data = 0;
    
    fscanf(stdin, ""%d"", &data);
    CWE190_Integer_Overflow__int_fscanf_preinc_22_badGlobal = 1; 
"
11076,1,CWE758_Undefined_Behavior__struct_new_use_18.cpp,"    goto sink;
sink:
    {
        twoIntsStruct data;
        data.intOne = 1;
        data.intTwo = 2;
        twoIntsStruct * pointer = new twoIntsStruct;
        *pointer = data; 
        {
            twoIntsStruct data = *pointer;
            printIntLine(data.intOne);
            printIntLine(data.intTwo);
        }
        delete pointer;
"
10660,0,CWE401_Memory_Leak__malloc_realloc_int64_t_10.c,"    if(globalTrue)
    {
        {
            int64_t * data = (int64_t *)malloc(100*sizeof(int64_t));
            if (data == NULL) {exit(-1);}
            
            data[0] = 5LL;
            printLongLongLine(data[0]);
            
            data = (int64_t *)realloc(data, (130000)*sizeof(int64_t));
            if (data != NULL)
            {
                
                data[0] = 10LL;
                printLongLongLine(data[0]);
                free(data);
            }
        }
"
7162,0,CWE401_Memory_Leak__new_array_int_81_bad.cpp,"Label Definition File: CWE401_Memory_Leak__new_array.label.xml
Template File: sources-sinks-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 401 Memory Leak
 * BadSource:  Allocate data using new[]
 * GoodSource: Point data to a stack buffer
 * Sinks:
 *    GoodSink: call delete[] on data
 *    BadSink : no deallocation of data
 * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE401_Memory_Leak__new_array_int_81.h""

namespace CWE401_Memory_Leak__new_array_int_81
{

void CWE401_Memory_Leak__new_array_int_81_bad::action(int * data) const
{
    
    ; 
}

}
"
17512,0,CWE190_Integer_Overflow__unsigned_int_max_add_04.c,"    unsigned int data;
    data = 0;
    if(STATIC_CONST_TRUE)
    {
        
        data = UINT_MAX;
    }
    if(STATIC_CONST_TRUE)
    {
        {
            
            unsigned int result = data + 1;
            printUnsignedLine(result);
        }
"
17627,0,CWE590_Free_Memory_Not_on_Heap__delete_class_alloca_53a.cpp,"    TwoIntsClass * data;
    data = NULL; 
    {
        
        TwoIntsClass * dataBuffer = (TwoIntsClass *)ALLOCA(sizeof(TwoIntsClass));
        dataBuffer->intOne = 2;
        dataBuffer->intTwo = 2;
        data = dataBuffer;
    }
"
11401,0,CWE590_Free_Memory_Not_on_Heap__delete_array_long_declare_06.cpp,"    long * data;
    data = NULL; 
    if(STATIC_CONST_FIVE==5)
    {
        {
            
            long dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5L;
                }
            }
            data = dataBuffer;
        }
    }
    printLongLine(data[0]);
    
"
4518,0,CWE78_OS_Command_Injection__char_connect_socket_system_64a.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
10501,1,CWE758_Undefined_Behavior__struct_alloca_use_05.c,"    if(staticFalse)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            twoIntsStruct data;
            twoIntsStruct * pointer = (twoIntsStruct *)ALLOCA(sizeof(twoIntsStruct));
            data.intOne = 1;
            data.intTwo = 2;
            *pointer = data; 
            {
                twoIntsStruct data = *pointer;
                printIntLine(data.intOne);
                printIntLine(data.intTwo);
            }
        }
"
12059,0,CWE457_Use_of_Uninitialized_Variable__double_pointer_14.c,"    double * data;
    if(globalFive==5)
    {
        
        ; 
    }
    if(globalFive==5)
    {
        
        printDoubleLine(*data);
"
5855,0,CWE197_Numeric_Truncation_Error__short_large_82a.cpp,"    short data;
    
    data = -1;
    
    data = CHAR_MAX + 1;
    CWE197_Numeric_Truncation_Error__short_large_82_base* baseObject = new CWE197_Numeric_Truncation_Error__short_large_82_bad;
    baseObject->action(data);
"
1133,1,CWE758_Undefined_Behavior__double_pointer_alloca_use_07.c,"    if(staticFive!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            double * data;
            double * * pointer = (double * *)ALLOCA(sizeof(double *));
            
            data = (double *)malloc(sizeof(double));
            if (data == NULL) {exit(-1);}
            *data = 5.0;
            *pointer = data; 
            {
                double * data = *pointer;
                printDoubleLine(*data);
            }
        }
"
4195,0,CWE590_Free_Memory_Not_on_Heap__delete_class_declare_13.cpp,"    TwoIntsClass * data;
    data = NULL; 
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            
            TwoIntsClass dataBuffer;
            dataBuffer.intOne = 1;
            dataBuffer.intTwo = 1;
            data = &dataBuffer;
        }
    }
    printIntLine(data->intOne);
    
"
9096,0,CWE134_Uncontrolled_Format_String__char_file_vfprintf_04.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(STATIC_CONST_TRUE)
    {
        {
            
            size_t dataLen = strlen(data);
            FILE * pFile;
            
            if (100-dataLen > 1)
            {
                pFile = fopen(FILENAME, ""r"");
                if (pFile != NULL)
                {
                    
                    if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                    {
                        printLine(""fgets() failed"");
                        
                        data[dataLen] = '\0';
                    }
                    fclose(pFile);
                }
            }
        }
    }
    if(STATIC_CONST_TRUE)
    {
        badVaSinkB(data, data);
"
7868,0,CWE78_OS_Command_Injection__char_console_execlp_42.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    data = badSource(data);
    /* execlp - searches for the location of the command among
     * the directories specified by the PATH environment variable */
    
    EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}

#endif 

#ifndef OMITGOOD

static char * goodG2BSource(char * data)
{
    
"
9269,0,CWE190_Integer_Overflow__char_rand_square_63a.c,"    char data;
    data = ' ';
    
    data = (char)RAND32();
"
11040,0,CWE789_Uncontrolled_Mem_Alloc__new_char_rand_04.cpp,"    size_t data;
    
    data = 0;
    if(STATIC_CONST_TRUE)
    {
        
        data = rand();
    }
    if(STATIC_CONST_TRUE)
    {
        {
            char * myString;
            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
             * for the strcpy() function to not cause a buffer overflow */
            
            if (data > strlen(HELLO_STRING))
            {
                myString = new char[data];
                
                strcpy(myString, HELLO_STRING);
                printLine(myString);
                delete [] myString;
            }
            else
            {
                printLine(""Input is less than the length of the source string"");
            }
        }
"
1458,0,CWE401_Memory_Leak__malloc_realloc_int_03.c,"    if(5==5)
    {
        {
            int * data = (int *)malloc(100*sizeof(int));
            if (data == NULL) {exit(-1);}
            
            data[0] = 5;
            printIntLine(data[0]);
            
            data = (int *)realloc(data, (130000)*sizeof(int));
            if (data != NULL)
            {
                
                data[0] = 10;
                printIntLine(data[0]);
                free(data);
            }
        }
"
5430,1,CWE758_Undefined_Behavior__int_malloc_use_03.c,"    if(5!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            int data;
            int * pointer = (int *)malloc(sizeof(int));
            if (pointer == NULL) {exit(-1);}
            data = 5;
            *pointer = data; 
            {
                int data = *pointer;
                printIntLine(data);
            }
            free(pointer);
        }
"
4918,0,CWE590_Free_Memory_Not_on_Heap__delete_int_alloca_03.cpp,"    int * data;
    data = NULL; 
    if(5==5)
    {
        {
            
            int * dataBuffer = (int *)ALLOCA(sizeof(int));
            *dataBuffer = 5;
            data = dataBuffer;
        }
    }
    printIntLine(*data);
    
"
12122,1,CWE676_Use_of_Potentially_Dangerous_Function__basic_09.cpp,"    if(GLOBAL_CONST_TRUE)
    {
        {
            char charBuffer[CHAR_BUFFER_SIZE];
            
            cin.width(CHAR_BUFFER_SIZE);
            cin >> charBuffer;
            charBuffer[CHAR_BUFFER_SIZE-1] = '\0';
            printLine(charBuffer);
        }
"
17566,0,CWE190_Integer_Overflow__char_max_multiply_62a.cpp,"    char data;
    data = ' ';
    badSource(data);
    if(data > 0) 
    {
        
        char result = data * 2;
        printHexCharLine(result);
"
1609,0,CWE590_Free_Memory_Not_on_Heap__delete_class_alloca_33.cpp,"    TwoIntsClass * data;
    TwoIntsClass * &dataRef = data;
    data = NULL; 
    {
        
        TwoIntsClass * dataBuffer = (TwoIntsClass *)ALLOCA(sizeof(TwoIntsClass));
        dataBuffer->intOne = 2;
        dataBuffer->intTwo = 2;
        data = dataBuffer;
    }
    {
        TwoIntsClass * data = dataRef;
        printIntLine(data->intOne);
        
        delete data;
"
833,0,CWE78_OS_Command_Injection__char_environment_execlp_83_bad.cpp,"Label Definition File: CWE78_OS_Command_Injection.strings.label.xml
Template File: sources-sink-83_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 78 OS Command Injection
 * BadSource: environment Read input from an environment variable
 * GoodSource: Fixed string
 * Sinks: execlp
 *    BadSink : execute command with execlp
 * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE78_OS_Command_Injection__char_environment_execlp_83.h""

#define ENV_VARIABLE ""ADD""

#ifdef _WIN32
#define GETENV getenv
#else
#define GETENV getenv
#endif

#ifdef _WIN32
#include <process.h>
#define EXECLP _execlp
#else 
#define EXECLP execlp
#endif

namespace CWE78_OS_Command_Injection__char_environment_execlp_83
{
CWE78_OS_Command_Injection__char_environment_execlp_83_bad::CWE78_OS_Command_Injection__char_environment_execlp_83_bad(char * dataCopy)
{
    data = dataCopy;
    {
        
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        
        if (environment != NULL)
        {
            
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
}

CWE78_OS_Command_Injection__char_environment_execlp_83_bad::~CWE78_OS_Command_Injection__char_environment_execlp_83_bad()
{
    /* execlp - searches for the location of the command among
     * the directories specified by the PATH environment variable */
    
    EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
}
"
11217,0,CWE190_Integer_Overflow__char_rand_add_44.c,"    char data;
    
    void (*funcPtr) (char) = badSink;
    data = ' ';
    
    data = (char)RAND32();
    
"
19348,0,CWE690_NULL_Deref_From_Return__long_calloc_13.c,"    long * data;
    data = NULL; 
    
    data = (long *)calloc(1, sizeof(long));
    if(GLOBAL_CONST_FIVE==5)
    {
        
        data[0] = 5L;
        printLongLine(data[0]);
        free(data);
"
10823,0,CWE78_OS_Command_Injection__char_connect_socket_popen_52a.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
18099,0,CWE758_Undefined_Behavior__struct_pointer_alloca_use_05.c,"    if(staticTrue)
    {
        {
            twoIntsStruct * * pointer = (twoIntsStruct * *)ALLOCA(sizeof(twoIntsStruct *));
            twoIntsStruct * data = *pointer; 
            printIntLine(data->intOne);
            printIntLine(data->intTwo);
        }
"
3116,1,CWE758_Undefined_Behavior__struct_alloca_use_14.c,"    if(globalFive!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            twoIntsStruct data;
            twoIntsStruct * pointer = (twoIntsStruct *)ALLOCA(sizeof(twoIntsStruct));
            data.intOne = 1;
            data.intTwo = 2;
            *pointer = data; 
            {
                twoIntsStruct data = *pointer;
                printIntLine(data.intOne);
                printIntLine(data.intTwo);
            }
        }
"
73,0,CWE401_Memory_Leak__int_malloc_61a.c,"    int * data;
    data = NULL;
    data = CWE401_Memory_Leak__int_malloc_61b_badSource(data);
    
"
5810,0,CWE401_Memory_Leak__int64_t_realloc_81_bad.cpp,"Label Definition File: CWE401_Memory_Leak.c.label.xml
Template File: sources-sinks-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 401 Memory Leak
 * BadSource: realloc Allocate data using realloc()
 * GoodSource: Allocate data on the stack
 * Sinks:
 *    GoodSink: call free() on data
 *    BadSink : no deallocation of data
 * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE401_Memory_Leak__int64_t_realloc_81.h""

namespace CWE401_Memory_Leak__int64_t_realloc_81
{

void CWE401_Memory_Leak__int64_t_realloc_81_bad::action(int64_t * data) const
{
    
    ; 
}

}
"
4332,0,CWE590_Free_Memory_Not_on_Heap__delete_long_static_17.cpp,"    int i;
    long * data;
    data = NULL; 
    for(i = 0; i < 1; i++)
    {
        {
            
            static long dataBuffer;
            dataBuffer = 5L;
            data = &dataBuffer;
        }
    }
    printLongLine(*data);
    
"
8182,0,CWE590_Free_Memory_Not_on_Heap__delete_int_declare_01.cpp,"    int * data;
    data = NULL; 
    {
        
        int dataBuffer;
        dataBuffer = 5;
        data = &dataBuffer;
    }
    printIntLine(*data);
    
"
3458,0,CWE416_Use_After_Free__new_delete_int_17.cpp,"    int i,j;
    int * data;
    
    data = NULL;
    for(i = 0; i < 1; i++)
    {
        data = new int;
        *data = 5;
        
        delete data;
    }
    for(j = 0; j < 1; j++)
    {
        
        printIntLine(*data);
        
"
16621,1,CWE401_Memory_Leak__malloc_realloc_int_03.c,"    if(5!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            int * data = (int *)malloc(100*sizeof(int));
            if (data == NULL) {exit(-1);}
            int * tmpData;
            
            data[0] = 5;
            printIntLine(data[0]);
            tmpData = (int *)realloc(data, (130000)*sizeof(int));
            /* FIX: Ensure realloc() was successful before assigning data to the memory block
            * allocated with realloc() */
            if (tmpData != NULL)
            {
                data = tmpData;
                
                data[0] = 10;
                printIntLine(data[0]);
            }
            free(data);
        }
"
8560,0,CWE252_Unchecked_Return_Value__char_fgets_02.c,"    if(1)
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            printLine(""Please enter a string: "");
            
            fgets(data, 100, stdin);
            printLine(data);
        }
"
433,0,CWE190_Integer_Overflow__unsigned_int_max_preinc_07.c,"    unsigned int data;
    data = 0;
    if(staticFive==5)
    {
        
        data = UINT_MAX;
    }
    if(staticFive==5)
    {
        {
            
            ++data;
            unsigned int result = data;
            printUnsignedLine(result);
        }
"
6302,0,CWE369_Divide_by_Zero__int_listen_socket_divide_61a.c,"    int data;
    
    data = -1;
    data = CWE369_Divide_by_Zero__int_listen_socket_divide_61b_badSource(data);
    
"
5158,0,CWE401_Memory_Leak__new_array_int_82_bad.cpp,"Label Definition File: CWE401_Memory_Leak__new_array.label.xml
Template File: sources-sinks-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 401 Memory Leak
 * BadSource:  Allocate data using new[]
 * GoodSource: Point data to a stack buffer
 * Sinks:
 *    GoodSink: call delete[] on data
 *    BadSink : no deallocation of data
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE401_Memory_Leak__new_array_int_82.h""

namespace CWE401_Memory_Leak__new_array_int_82
{

void CWE401_Memory_Leak__new_array_int_82_bad::action(int * data)
{
    
    ; 
}

}
"
13947,0,CWE590_Free_Memory_Not_on_Heap__delete_char_placement_new_65a.cpp,"    char * data;
    
    void (*funcPtr) (char *) = badSink;
    data = NULL; 
    {
        
        char buffer[sizeof(char)];
        char * dataBuffer = new(buffer) char;
        *dataBuffer = 'A';
        data = dataBuffer;
    }
    
"
11583,0,CWE78_OS_Command_Injection__char_environment_execl_05.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(staticTrue)
    {
        {
            
            size_t dataLen = strlen(data);
            char * environment = GETENV(ENV_VARIABLE);
            
            if (environment != NULL)
            {
                
                strncat(data+dataLen, environment, 100-dataLen-1);
            }
        }
    }
    
    
"
13576,0,CWE190_Integer_Overflow__char_fscanf_multiply_41.c,"    char data;
    data = ' ';
    
    fscanf (stdin, ""%c"", &data);
"
18610,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_65a.c,"    size_t data;
    
    void (*funcPtr) (size_t) = CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_65b_badSink;
    
    data = 0;
    
    fscanf(stdin, ""%zu"", &data);
    
"
12630,0,CWE190_Integer_Overflow__int64_t_max_multiply_51a.c,"    int64_t data;
    data = 0LL;
    
    data = LLONG_MAX;
"
12815,0,CWE190_Integer_Overflow__int_fgets_multiply_54a.c,"    int data;
    
    data = 0;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
"
12051,0,CWE415_Double_Free__new_delete_int_82a.cpp,"    int * data;
    
    data = NULL;
    data = new int;
    
    delete data;
    CWE415_Double_Free__new_delete_int_82_base* baseObject = new CWE415_Double_Free__new_delete_int_82_bad;
    baseObject->action(data);
"
8622,0,CWE190_Integer_Overflow__unsigned_int_max_square_54a.c,"    unsigned int data;
    data = 0;
    
    data = UINT_MAX;
"
7947,0,CWE78_OS_Command_Injection__char_console_execlp_10.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(globalTrue)
    {
        {
            
            size_t dataLen = strlen(data);
            
            if (100-dataLen > 1)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
                {
                    /* The next few lines remove the carriage return from the string that is
                     * inserted by fgets() */
                    dataLen = strlen(data);
"
4124,0,CWE401_Memory_Leak__int_realloc_33.cpp,"    int * data;
    int * &dataRef = data;
    data = NULL;
    
    data = (int *)realloc(data, 100*sizeof(int));
    if (data == NULL) {exit(-1);}
    
    data[0] = 5;
    printIntLine(data[0]);
    {
        int * data = dataRef;
        
        ; 
"
3977,0,CWE252_Unchecked_Return_Value__char_scanf_17.c,"    int j;
    for(j = 0; j < 1; j++)
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            
            scanf(""%99s\0"", data);
        }
"
7054,1,CWE587_Assignment_of_Fixed_Address_to_Pointer__basic_05.c,"    if(staticTrue)
    {
        {
            
            char charStack = 'a';
            char *charPointer = &charStack;
            printHexCharLine(*charPointer);
        }
"
9595,0,CWE690_NULL_Deref_From_Return__int_calloc_66a.c,"    int * data;
    int * dataArray[5];
    data = NULL; 
    
    data = (int *)calloc(1, sizeof(int));
    
    dataArray[2] = data;
"
12336,0,CWE416_Use_After_Free__return_freed_ptr_01.c,"    {
        
        char * reversedString = helperBad(""BadSink"");
        printLine(reversedString);
        /* free(reversedString);
         * This call to free() was removed because we want the tool to detect the use after free,
         * but we don't want that function to be free(). Essentially we want to avoid a double free
         */
"
17048,0,CWE415_Double_Free__new_delete_array_char_08.cpp,"    char * data;
    
    data = NULL;
    if(staticReturnsTrue())
    {
        data = new char[100];
        
        delete [] data;
    }
    if(staticReturnsTrue())
    {
        
        delete [] data;
"
15640,0,CWE758_Undefined_Behavior__int_alloca_use_15.c,"    switch(6)
    {
    case 6:
    {
        int * pointer = (int *)ALLOCA(sizeof(int));
        int data = *pointer; 
        printIntLine(data);
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
5531,1,CWE758_Undefined_Behavior__long_new_use_11.cpp,"    if(globalReturnsFalse())
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            long data;
            data = 5L;
            long * pointer = new long;
            *pointer = data; 
            {
                long data = *pointer;
                printLongLine(data);
            }
            delete pointer;
        }
"
12827,0,CWE590_Free_Memory_Not_on_Heap__delete_long_alloca_33.cpp,"    long * data;
    long * &dataRef = data;
    data = NULL; 
    {
        
        long * dataBuffer = (long *)ALLOCA(sizeof(long));
        *dataBuffer = 5L;
        data = dataBuffer;
    }
    {
        long * data = dataRef;
        printLongLine(*data);
        
        delete data;
"
9656,1,CWE467_Use_of_sizeof_on_Pointer_Type__short_14.c,"    if(globalFive==5)
    {
        {
            short * goodShort = NULL;
            
            goodShort = (short *)malloc(sizeof(*goodShort));
            if (goodShort == NULL) {exit(-1);}
            *goodShort = 6;
            printShortLine(*goodShort);
            free(goodShort);
        }
"
2202,0,CWE190_Integer_Overflow__int_fgets_square_33.cpp,"    int data;
    int &dataRef = data;
    
    data = 0;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    {
        int data = dataRef;
        {
            
            int result = data * data;
            printIntLine(result);
        }
"
16452,0,CWE401_Memory_Leak__new_int64_t_82_bad.cpp,"Label Definition File: CWE401_Memory_Leak__new.label.xml
Template File: sources-sinks-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 401 Memory Leak
 * BadSource:  Allocate data using new
 * GoodSource: Allocate data on the stack
 * Sinks:
 *    GoodSink: call delete on data
 *    BadSink : no deallocation of data
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE401_Memory_Leak__new_int64_t_82.h""

namespace CWE401_Memory_Leak__new_int64_t_82
{

void CWE401_Memory_Leak__new_int64_t_82_bad::action(int64_t * data)
{
    
    ; 
}

}
"
7676,1,CWE676_Use_of_Potentially_Dangerous_Function__basic_13.cpp,"    if(GLOBAL_CONST_FIVE!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            char charBuffer[CHAR_BUFFER_SIZE];
            
            cin.width(CHAR_BUFFER_SIZE);
            cin >> charBuffer;
            charBuffer[CHAR_BUFFER_SIZE-1] = '\0';
            printLine(charBuffer);
        }
"
16951,0,CWE190_Integer_Overflow__int_listen_socket_preinc_44.c,"    int data;
    
    void (*funcPtr) (int) = badSink;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
"
15164,1,CWE467_Use_of_sizeof_on_Pointer_Type__short_14.c,"    if(globalFive!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            short * goodShort = NULL;
            
            goodShort = (short *)malloc(sizeof(*goodShort));
            if (goodShort == NULL) {exit(-1);}
            *goodShort = 6;
            printShortLine(*goodShort);
            free(goodShort);
        }
"
7448,0,CWE563_Unused_Variable__unused_init_variable_int_81a.cpp,"    int data;
    
    data = 5;
    const CWE563_Unused_Variable__unused_init_variable_int_81_base& baseObject = CWE563_Unused_Variable__unused_init_variable_int_81_bad();
"
16492,0,CWE190_Integer_Overflow__char_rand_postinc_18.c,"    char data;
    data = ' ';
    goto source;
source:
    
    data = (char)RAND32();
    goto sink;
sink:
    {
        
        data++;
        char result = data;
        printHexCharLine(result);
"
375,0,CWE475_Undefined_Behavior_for_Input_to_API__char_12.c,"    if(globalReturnsTrueOrFalse())
    {
        {
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            strcpy(data, ""abcdefghijklmnopqrstuvwxyz"");
            
            memcpy(data + 6, data + 4, 10*sizeof(char));
            printLine(data);
        }
    }
    else
    {
        {
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            strcpy(data, ""abcdefghijklmnopqrstuvwxyz"");
            
            memmove(data + 6, data + 4, 10*sizeof(char));
            printLine(data);
        }
"
16376,0,CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_65a.c,"    char * data;
    
    void (*funcPtr) (char *, ...) = CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_65b_badVaSink;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
"
18877,0,CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_63a.c,"    unsigned int data;
    data = 0;
    
    fscanf (stdin, ""%u"", &data);
"
14059,0,CWE190_Integer_Overflow__short_max_square_67a.c,"    short data;
    CWE190_Integer_Overflow__short_max_square_67_structType myStruct;
    data = 0;
    
    data = SHRT_MAX;
    myStruct.structFirst = data;
"
5020,0,CWE401_Memory_Leak__twoIntsStruct_malloc_10.c,"    twoIntsStruct * data;
    data = NULL;
    if(globalTrue)
    {
        
        data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
        if (data == NULL) {exit(-1);}
        
        data[0].intOne = 0;
        data[0].intTwo = 0;
        printStructLine(&data[0]);
    }
    if(globalTrue)
    {
        
        ; 
"
16911,0,CWE190_Integer_Overflow__int64_t_rand_add_42.c,"    int64_t data;
    data = 0LL;
    data = badSource(data);
    {
        
        int64_t result = data + 1;
        printLongLongLine(result);
"
19364,0,CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_08.c,"    unsigned int data;
    data = 0;
    if(staticReturnsTrue())
    {
        
        fscanf (stdin, ""%u"", &data);
    }
    if(staticReturnsTrue())
    {
        {
            
            data++;
            unsigned int result = data;
            printUnsignedLine(result);
        }
"
332,0,CWE415_Double_Free__new_delete_array_int_62a.cpp,"    int * data;
    
    data = NULL;
    badSource(data);
    
"
10380,0,CWE190_Integer_Overflow__int_listen_socket_postinc_04.c,"    int data;
    
    data = 0;
    if(STATIC_CONST_TRUE)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(STATIC_CONST_TRUE)
    {
        {
            
            data++;
            int result = data;
            printIntLine(result);
        }
"
9372,0,CWE789_Uncontrolled_Mem_Alloc__new_char_connect_socket_51a.cpp,"    size_t data;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = strtoul(inputBuffer, NULL, 0);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
13838,0,CWE457_Use_of_Uninitialized_Variable__double_array_alloca_partial_init_17.c,"    int i,j;
    double * data;
    data = (double *)ALLOCA(10*sizeof(double));
    for(i = 0; i < 1; i++)
    {
        
        {
            int i;
            for(i=0; i<(10/2); i++)
            {
                data[i] = (double)i;
            }
        }
    }
    for(j = 0; j < 1; j++)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printDoubleLine(data[i]);
            }
        }
"
10964,0,CWE758_Undefined_Behavior__long_new_use_04.cpp,"    if(STATIC_CONST_TRUE)
    {
        {
            long * pointer = new long;
            long data = *pointer; 
            delete pointer;
            printLongLine(data);
        }
"
2970,1,CWE758_Undefined_Behavior__struct_alloca_use_11.c,"    if(globalReturnsFalse())
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            twoIntsStruct data;
            twoIntsStruct * pointer = (twoIntsStruct *)ALLOCA(sizeof(twoIntsStruct));
            data.intOne = 1;
            data.intTwo = 2;
            *pointer = data; 
            {
                twoIntsStruct data = *pointer;
                printIntLine(data.intOne);
                printIntLine(data.intTwo);
            }
        }
"
408,0,CWE415_Double_Free__malloc_free_struct_03.c,"    twoIntsStruct * data;
    
    data = NULL;
    if(5==5)
    {
        data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
        if (data == NULL) {exit(-1);}
        
        free(data);
    }
    if(5==5)
    {
        
        free(data);
"
15524,0,CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_34.cpp,"    size_t data;
    unionType myUnion;
    
    data = 0;
    
    fscanf(stdin, ""%zu"", &data);
    myUnion.unionFirst = data;
    {
        size_t data = myUnion.unionSecond;
        {
            char * myString;
            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
             * for the strcpy() function to not cause a buffer overflow */
            
            if (data > strlen(HELLO_STRING))
            {
                myString = new char[data];
                
                strcpy(myString, HELLO_STRING);
                printLine(myString);
                delete [] myString;
            }
            else
            {
                printLine(""Input is less than the length of the source string"");
            }
        }
"
15953,0,CWE415_Double_Free__new_delete_int_17.cpp,"    int i,j;
    int * data;
    
    data = NULL;
    for(i = 0; i < 1; i++)
    {
        data = new int;
        
        delete data;
    }
    for(j = 0; j < 1; j++)
    {
        
        delete data;
"
5161,0,CWE690_NULL_Deref_From_Return__long_realloc_44.c,"    long * data;
    
    void (*funcPtr) (long *) = badSink;
    data = NULL; 
    
    data = (long *)realloc(data, 1*sizeof(long));
    
"
12604,0,CWE190_Integer_Overflow__unsigned_int_rand_preinc_65a.c,"    unsigned int data;
    
    void (*funcPtr) (unsigned int) = CWE190_Integer_Overflow__unsigned_int_rand_preinc_65b_badSink;
    data = 0;
    
    data = (unsigned int)RAND32();
    
"
817,0,CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_06.c,"    unsigned int data;
    data = 0;
    if(STATIC_CONST_FIVE==5)
    {
        
        fscanf (stdin, ""%u"", &data);
    }
    if(STATIC_CONST_FIVE==5)
    {
        {
            
            ++data;
            unsigned int result = data;
            printUnsignedLine(result);
        }
"
10629,0,CWE134_Uncontrolled_Format_String__char_environment_fprintf_82_bad.cpp,"Label Definition File: CWE134_Uncontrolled_Format_String.label.xml
Template File: sources-sinks-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 134 Uncontrolled Format String
 * BadSource: environment Read input from an environment variable
 * GoodSource: Copy a fixed string into data
 * Sinks: fprintf
 *    GoodSink: fprintf with ""%s"" as the second argument and data as the third
 *    BadSink : fprintf with data as the second argument
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE134_Uncontrolled_Format_String__char_environment_fprintf_82.h""

namespace CWE134_Uncontrolled_Format_String__char_environment_fprintf_82
{

void CWE134_Uncontrolled_Format_String__char_environment_fprintf_82_bad::action(char * data)
{
    
    fprintf(stdout, data);
}

}
"
1072,0,CWE563_Unused_Variable__unused_value_int64_t_04.c,"    int64_t data;
    if(STATIC_CONST_TRUE)
    {
        
        data = 5LL;
    }
    if(STATIC_CONST_TRUE)
    {
        
        data = 10LL;
        printLongLongLine(data);
"
14704,0,CWE190_Integer_Overflow__int64_t_fscanf_square_51a.c,"    int64_t data;
    data = 0LL;
    
    fscanf (stdin, ""%"" SCNd64, &data);
"
15013,0,CWE190_Integer_Overflow__int_max_preinc_41.c,"    int data;
    
    data = 0;
    
    data = INT_MAX;
"
4824,0,CWE457_Use_of_Uninitialized_Variable__struct_array_malloc_no_init_15.c,"    twoIntsStruct * data;
    data = (twoIntsStruct *)malloc(10*sizeof(twoIntsStruct));
    if (data == NULL) {exit(-1);}
    switch(6)
    {
    case 6:
        
        ; 
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
        
    {
        int i;
        for(i=0; i<10; i++)
        {
            printIntLine(data[i].intOne);
            printIntLine(data[i].intTwo);
        }
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
8006,0,CWE563_Unused_Variable__unused_init_variable_char_74a.cpp,"    char data;
    map<int, char> dataMap;
    
    data = 'C';
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
5444,0,CWE78_OS_Command_Injection__char_environment_execl_73a.cpp,"    char * data;
    list<char *> dataList;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        
        if (environment != NULL)
        {
            
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
4659,0,CWE190_Integer_Overflow__int_max_add_10.c,"    int data;
    
    data = 0;
    if(globalTrue)
    {
        
        data = INT_MAX;
    }
    if(globalTrue)
    {
        {
            
            int result = data + 1;
            printIntLine(result);
        }
"
321,0,CWE590_Free_Memory_Not_on_Heap__delete_array_char_static_31.cpp,"    char * data;
    data = NULL; 
    {
        
        static char dataBuffer[100];
        memset(dataBuffer, 'A', 100-1); 
        dataBuffer[100-1] = '\0'; 
        data = dataBuffer;
    }
    {
        char * dataCopy = data;
        char * data = dataCopy;
        printLine(data);
        
        delete [] data;
"
732,0,CWE401_Memory_Leak__twoIntsStruct_calloc_04.c,"    twoIntsStruct * data;
    data = NULL;
    if(STATIC_CONST_TRUE)
    {
        
        data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));
        if (data == NULL) {exit(-1);}
        
        data[0].intOne = 0;
        data[0].intTwo = 0;
        printStructLine(&data[0]);
    }
    if(STATIC_CONST_TRUE)
    {
        
        ; 
"
4378,0,CWE789_Uncontrolled_Mem_Alloc__new_char_fgets_51a.cpp,"    size_t data;
    
    data = 0;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = strtoul(inputBuffer, NULL, 0);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
"
10245,0,CWE590_Free_Memory_Not_on_Heap__free_long_static_11.c,"    long * data;
    data = NULL; 
    if(globalReturnsTrue())
    {
        {
            
            static long dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5L;
                }
            }
            data = dataBuffer;
        }
    }
    printLongLine(data[0]);
    
"
9537,0,CWE690_NULL_Deref_From_Return__long_malloc_82a.cpp,"    long * data;
    data = NULL; 
    
    data = (long *)malloc(1*sizeof(long));
    CWE690_NULL_Deref_From_Return__long_malloc_82_base* baseObject = new CWE690_NULL_Deref_From_Return__long_malloc_82_bad;
    baseObject->action(data);
"
12278,0,CWE563_Unused_Variable__unused_value_long_33.cpp,"    long data;
    long &dataRef = data;
    
    data = 5L;
    {
        long data = dataRef;
        
        data = 10L;
        printLongLine(data);
"
3529,0,CWE401_Memory_Leak__int_realloc_21.c,"    int * data;
    data = NULL;
    
    data = (int *)realloc(data, 100*sizeof(int));
    if (data == NULL) {exit(-1);}
    
    data[0] = 5;
    printIntLine(data[0]);
    badStatic = 1; 
"
12490,0,CWE197_Numeric_Truncation_Error__short_listen_socket_54a.c,"    short data;
    
    data = -1;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = (short)atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
16378,0,CWE190_Integer_Overflow__int_fscanf_multiply_03.c,"    int data;
    
    data = 0;
    if(5==5)
    {
        
        fscanf(stdin, ""%d"", &data);
    }
    if(5==5)
    {
        if(data > 0) 
        {
            
            int result = data * 2;
            printIntLine(result);
        }
"
17413,0,CWE78_OS_Command_Injection__char_environment_system_44.c,"    char * data;
    
    void (*funcPtr) (char *) = badSink;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
        
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        
        if (environment != NULL)
        {
            
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    
"
10824,0,CWE197_Numeric_Truncation_Error__short_rand_63a.c,"    short data;
    
    data = -1;
    
    data = (short)RAND32();
"
2155,0,CWE369_Divide_by_Zero__int_rand_divide_51a.c,"    int data;
    
    data = -1;
    
    data = RAND32();
"
9684,0,CWE190_Integer_Overflow__char_rand_add_72a.cpp,"    char data;
    vector<char> dataVector;
    data = ' ';
    
    data = (char)RAND32();
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
6042,0,CWE401_Memory_Leak__struct_twoIntsStruct_malloc_08.c,"    struct _twoIntsStruct * data;
    data = NULL;
    if(staticReturnsTrue())
    {
        
        data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));
        if (data == NULL) {exit(-1);}
        
        data[0].intOne = 0;
        data[0].intTwo = 0;
        printStructLine((twoIntsStruct *)&data[0]);
    }
    if(staticReturnsTrue())
    {
        
        ; 
"
8787,1,CWE758_Undefined_Behavior__class_new_use_12.cpp,"    if(globalReturnsTrueOrFalse())
    {
        {
            TwoIntsClass data;
            data.intOne = 1;
            data.intTwo = 2;
            TwoIntsClass * pointer = new TwoIntsClass;
            *pointer = data; 
            {
                TwoIntsClass data = *pointer;
                printIntLine(data.intOne);
                printIntLine(data.intTwo);
            }
            delete pointer;
        }
    }
    else
    {
        {
            TwoIntsClass data;
            data.intOne = 1;
            data.intTwo = 2;
            TwoIntsClass * pointer = new TwoIntsClass;
            *pointer = data; 
            {
                TwoIntsClass data = *pointer;
                printIntLine(data.intOne);
                printIntLine(data.intTwo);
            }
            delete pointer;
        }
"
18171,0,CWE197_Numeric_Truncation_Error__short_fgets_32.c,"    short data;
    short *dataPtr1 = &data;
    short *dataPtr2 = &data;
    
    data = -1;
    {
        short data = *dataPtr1;
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                
                data = (short)atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
        *dataPtr1 = data;
    }
    {
        short data = *dataPtr2;
        {
            
            char charData = (char)data;
            printHexCharLine(charData);
        }
"
16251,0,CWE190_Integer_Overflow__int64_t_rand_add_31.c,"    int64_t data;
    data = 0LL;
    
    data = (int64_t)RAND64();
    {
        int64_t dataCopy = data;
        int64_t data = dataCopy;
        {
            
            int64_t result = data + 1;
            printLongLongLine(result);
        }
"
15543,0,CWE190_Integer_Overflow__int_rand_postinc_04.c,"    int data;
    
    data = 0;
    if(STATIC_CONST_TRUE)
    {
        
        data = RAND32();
    }
    if(STATIC_CONST_TRUE)
    {
        {
            
            data++;
            int result = data;
            printIntLine(result);
        }
"
12735,0,CWE690_NULL_Deref_From_Return__int_calloc_12.c,"    int * data;
    data = NULL; 
    
    data = (int *)calloc(1, sizeof(int));
    if(globalReturnsTrueOrFalse())
    {
        
        data[0] = 5;
        printIntLine(data[0]);
        free(data);
    }
    else
    {
        
        if (data != NULL)
        {
            data[0] = 5;
            printIntLine(data[0]);
            free(data);
        }
"
12136,0,CWE415_Double_Free__malloc_free_long_53a.c,"    long * data;
    
    data = NULL;
    data = (long *)malloc(100*sizeof(long));
    if (data == NULL) {exit(-1);}
    
    free(data);
"
12749,0,CWE78_OS_Command_Injection__char_listen_socket_popen_53a.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
11695,0,CWE563_Unused_Variable__unused_value_long_14.c,"    long data;
    if(globalFive==5)
    {
        
        data = 5L;
    }
    if(globalFive==5)
    {
        
        data = 10L;
        printLongLine(data);
"
7864,0,CWE467_Use_of_sizeof_on_Pointer_Type__int_14.c,"    if(globalFive==5)
    {
        {
            int * badInt = NULL;
            
            badInt = (int *)malloc(sizeof(badInt));
            if (badInt == NULL) {exit(-1);}
            *badInt = 5;
            printIntLine(*badInt);
            free(badInt);
        }
"
1569,0,CWE415_Double_Free__new_delete_char_17.cpp,"    int i,j;
    char * data;
    
    data = NULL;
    for(i = 0; i < 1; i++)
    {
        data = new char;
        
        delete data;
    }
    for(j = 0; j < 1; j++)
    {
        
        delete data;
"
4780,0,CWE590_Free_Memory_Not_on_Heap__free_long_alloca_82_bad.cpp,"Label Definition File: CWE590_Free_Memory_Not_on_Heap__free.label.xml
Template File: sources-sink-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 590 Free Memory Not on Heap
 * BadSource: alloca Data buffer is allocated on the stack with alloca()
 * GoodSource: Allocate memory on the heap
 * Sinks:
 *    BadSink : Print then free data
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE590_Free_Memory_Not_on_Heap__free_long_alloca_82.h""

namespace CWE590_Free_Memory_Not_on_Heap__free_long_alloca_82
{

void CWE590_Free_Memory_Not_on_Heap__free_long_alloca_82_bad::action(long * data)
{
    printLongLine(data[0]);
    
    free(data);
}

}
"
11724,0,CWE252_Unchecked_Return_Value__char_fprintf_03.c,"    if(5==5)
    {
        
        fprintf(stdout, ""%s\n"", ""string"");
"
13039,0,CWE190_Integer_Overflow__int64_t_rand_multiply_84a.cpp,"    int64_t data;
    data = 0LL;
    CWE190_Integer_Overflow__int64_t_rand_multiply_84_bad * badObject = new CWE190_Integer_Overflow__int64_t_rand_multiply_84_bad(data);
"
9320,0,CWE415_Double_Free__malloc_free_long_81a.cpp,"    long * data;
    
    data = NULL;
    data = (long *)malloc(100*sizeof(long));
    if (data == NULL) {exit(-1);}
    
    free(data);
    const CWE415_Double_Free__malloc_free_long_81_base& baseObject = CWE415_Double_Free__malloc_free_long_81_bad();
"
8625,0,CWE190_Integer_Overflow__short_fscanf_square_34.c,"    short data;
    CWE190_Integer_Overflow__short_fscanf_square_34_unionType myUnion;
    data = 0;
    
    fscanf (stdin, ""%hd"", &data);
    myUnion.unionFirst = data;
    {
        short data = myUnion.unionSecond;
        {
            
            short result = data * data;
            printIntLine(result);
        }
"
13651,0,CWE457_Use_of_Uninitialized_Variable__char_pointer_01.c,"    char * data;
    
    ; 
    
"
18675,0,CWE369_Divide_by_Zero__int_zero_divide_63a.c,"    int data;
    
    data = -1;
    
    data = 0;
"
8745,0,CWE190_Integer_Overflow__short_max_multiply_65a.c,"    short data;
    
    void (*funcPtr) (short) = CWE190_Integer_Overflow__short_max_multiply_65b_badSink;
    data = 0;
    
    data = SHRT_MAX;
    
"
9764,0,CWE369_Divide_by_Zero__int_zero_modulo_31.c,"    int data;
    
    data = -1;
    
    data = 0;
    {
        int dataCopy = data;
        int data = dataCopy;
        
        printIntLine(100 % data);
"
9086,0,CWE197_Numeric_Truncation_Error__int_fscanf_to_short_53a.c,"    int data;
    
    data = -1;
    
    fscanf(stdin, ""%d"", &data);
"
15446,0,CWE401_Memory_Leak__strdup_char_73a.cpp,"    char * data;
    list<char *> dataList;
    data = NULL;
    {
        char myString[] = ""myString"";
        
        data = strdup(myString);
        
        printLine(data);
    }
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
11645,1,CWE476_NULL_Pointer_Dereference__null_check_after_deref_14.c,"    if(globalFive!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            int *intPointer = NULL;
            intPointer = (int *)malloc(sizeof(int));
            *intPointer = 5;
            printIntLine(*intPointer);
            
            *intPointer = 10;
            printIntLine(*intPointer);
        }
"
3376,1,CWE252_Unchecked_Return_Value__char_puts_08.c,"    if(staticReturnsFalse())
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        
        if (PUTS(""string"") == EOF)
        {
            printLine(""puts failed!"");
        }
"
10168,0,CWE134_Uncontrolled_Format_String__char_console_printf_09.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(GLOBAL_CONST_TRUE)
    {
        {
            
            size_t dataLen = strlen(data);
            
            if (100-dataLen > 1)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
                {
                    /* The next few lines remove the carriage return from the string that is
                     * inserted by fgets() */
                    dataLen = strlen(data);
                    if (dataLen > 0 && data[dataLen-1] == '\n')
                    {
                        data[dataLen-1] = '\0';
                    }
                }
                else
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
            }
        }
    }
    if(GLOBAL_CONST_TRUE)
    {
        
        printf(data);
"
13613,0,CWE415_Double_Free__malloc_free_int64_t_74a.cpp,"    int64_t * data;
    map<int, int64_t *> dataMap;
    
    data = NULL;
    data = (int64_t *)malloc(100*sizeof(int64_t));
    if (data == NULL) {exit(-1);}
    
    free(data);
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
12108,0,CWE590_Free_Memory_Not_on_Heap__delete_int64_t_alloca_66a.cpp,"    int64_t * data;
    int64_t * dataArray[5];
    data = NULL; 
    {
        
        int64_t * dataBuffer = (int64_t *)ALLOCA(sizeof(int64_t));
        *dataBuffer = 5LL;
        data = dataBuffer;
    }
    
    dataArray[2] = data;
"
11646,0,CWE197_Numeric_Truncation_Error__int_connect_socket_to_short_45.c,"    int data;
    
    data = -1;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    CWE197_Numeric_Truncation_Error__int_connect_socket_to_short_45_badData = data;
"
15529,0,CWE78_OS_Command_Injection__char_console_system_82a.cpp,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
        
        size_t dataLen = strlen(data);
        
        if (100-dataLen > 1)
        {
            
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgets() */
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
                    data[dataLen-1] = '\0';
                }
            }
            else
            {
                printLine(""fgets() failed"");
                
                data[dataLen] = '\0';
            }
        }
    }
    CWE78_OS_Command_Injection__char_console_system_82_base* baseObject = new CWE78_OS_Command_Injection__char_console_system_82_bad;
    baseObject->action(data);
"
16834,0,CWE134_Uncontrolled_Format_String__char_console_vprintf_45.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        
        if (100-dataLen > 1)
        {
            
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgets() */
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
                    data[dataLen-1] = '\0';
                }
            }
            else
            {
                printLine(""fgets() failed"");
                
                data[dataLen] = '\0';
            }
        }
    }
    CWE134_Uncontrolled_Format_String__char_console_vprintf_45_badData = data;
"
16142,0,CWE690_NULL_Deref_From_Return__int_calloc_22a.c,"    int * data;
    data = NULL; 
    
    data = (int *)calloc(1, sizeof(int));
    CWE690_NULL_Deref_From_Return__int_calloc_22_badGlobal = 1; 
"
2346,0,CWE190_Integer_Overflow__int_connect_socket_multiply_07.c,"    int data;
    
    data = 0;
    if(staticFive==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(staticFive==5)
    {
        if(data > 0) 
        {
            
            int result = data * 2;
            printIntLine(result);
        }
"
1557,0,CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_12.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(globalReturnsTrueOrFalse())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET connectSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                
                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                data[dataLen + recvResult / sizeof(char)] = '\0';
                
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    else
    {
        
        strcpy(data, ""fixedstringtest"");
    }
    if(globalReturnsTrueOrFalse())
    {
        
        fprintf(stdout, data);
    }
    else
    {
        
        fprintf(stdout, ""%s\n"", data);
"
15497,0,CWE590_Free_Memory_Not_on_Heap__delete_int64_t_static_08.cpp,"    int64_t * data;
    data = NULL; 
    if(staticReturnsTrue())
    {
        {
            
            static int64_t dataBuffer;
            dataBuffer = 5LL;
            data = &dataBuffer;
        }
    }
    printLongLongLine(*data);
    
"
427,0,CWE590_Free_Memory_Not_on_Heap__delete_long_declare_81a.cpp,"    long * data;
    data = NULL; 
    {
        
        long dataBuffer;
        dataBuffer = 5L;
        data = &dataBuffer;
    }
    const CWE590_Free_Memory_Not_on_Heap__delete_long_declare_81_base& baseObject = CWE590_Free_Memory_Not_on_Heap__delete_long_declare_81_bad();
"
15850,1,CWE476_NULL_Pointer_Dereference__deref_after_check_18.c,"    goto sink;
sink:
    {
        
        int *intPointer = NULL;
        if (intPointer == NULL)
        {
            printLine(""pointer is NULL"");
        }
"
15599,0,CWE190_Integer_Overflow__unsigned_int_rand_multiply_17.c,"    int i,j;
    unsigned int data;
    data = 0;
    for(i = 0; i < 1; i++)
    {
        
        data = (unsigned int)RAND32();
    }
    for(j = 0; j < 1; j++)
    {
        if(data > 0) 
        {
            
            unsigned int result = data * 2;
            printUnsignedLine(result);
        }
"
17628,0,CWE190_Integer_Overflow__int_max_multiply_16.c,"    int data;
    
    data = 0;
    while(1)
    {
        
        data = INT_MAX;
        break;
    }
    while(1)
    {
        if(data > 0) 
        {
            
            int result = data * 2;
            printIntLine(result);
        }
        break;
"
6705,0,CWE590_Free_Memory_Not_on_Heap__delete_array_long_alloca_13.cpp,"    long * data;
    data = NULL; 
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            
            long * dataBuffer = (long *)ALLOCA(100*sizeof(long));
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5L;
                }
            }
            data = dataBuffer;
        }
    }
    printLongLine(data[0]);
    
"
11762,0,CWE190_Integer_Overflow__int64_t_rand_add_04.c,"    int64_t data;
    data = 0LL;
    if(STATIC_CONST_TRUE)
    {
        
        data = (int64_t)RAND64();
    }
    if(STATIC_CONST_TRUE)
    {
        {
            
            int64_t result = data + 1;
            printLongLongLine(result);
        }
"
1792,1,CWE758_Undefined_Behavior__double_pointer_alloca_use_15.c,"    switch(6)
    {
    case 6:
    {
        double * data;
        double * * pointer = (double * *)ALLOCA(sizeof(double *));
        
        data = (double *)malloc(sizeof(double));
        if (data == NULL) {exit(-1);}
        *data = 5.0;
        *pointer = data; 
        {
            double * data = *pointer;
            printDoubleLine(*data);
        }
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
14827,0,CWE690_NULL_Deref_From_Return__int_calloc_68a.c,"    int * data;
    data = NULL; 
    
    data = (int *)calloc(1, sizeof(int));
    CWE690_NULL_Deref_From_Return__int_calloc_68_badDataForBadSink = data;
"
4215,0,CWE415_Double_Free__malloc_free_int_17.c,"    int i,j;
    int * data;
    
    data = NULL;
    for(i = 0; i < 1; i++)
    {
        data = (int *)malloc(100*sizeof(int));
        if (data == NULL) {exit(-1);}
        
        free(data);
    }
    for(j = 0; j < 1; j++)
    {
        
        free(data);
"
3597,0,CWE415_Double_Free__new_delete_int64_t_68a.cpp,"    int64_t * data;
    
    data = NULL;
    data = new int64_t;
    
    delete data;
    badData = data;
"
766,0,CWE690_NULL_Deref_From_Return__int64_t_calloc_61a.c,"    int64_t * data;
    data = NULL; 
    data = CWE690_NULL_Deref_From_Return__int64_t_calloc_61b_badSource(data);
    
    data[0] = 5LL;
    printLongLongLine(data[0]);
"
9781,0,CWE690_NULL_Deref_From_Return__long_realloc_63a.c,"    long * data;
    data = NULL; 
    
    data = (long *)realloc(data, 1*sizeof(long));
"
5215,0,CWE758_Undefined_Behavior__int64_t_malloc_use_07.c,"    if(staticFive==5)
    {
        {
            int64_t * pointer = (int64_t *)malloc(sizeof(int64_t));
            if (pointer == NULL) {exit(-1);}
            int64_t data = *pointer; 
            free(pointer);
            printLongLongLine(data);
        }
"
4377,1,CWE758_Undefined_Behavior__char_new_use_06.cpp,"    if(STATIC_CONST_FIVE!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            char data;
            data = 5;
            char * pointer = new char;
            *pointer = data; 
            {
                char data = *pointer;
                printHexCharLine(data);
            }
            delete pointer;
        }
"
17658,0,CWE758_Undefined_Behavior__struct_malloc_use_10.c,"    if(globalTrue)
    {
        {
            twoIntsStruct * pointer = (twoIntsStruct *)malloc(sizeof(twoIntsStruct));
            if (pointer == NULL) {exit(-1);}
            twoIntsStruct data = *pointer; 
            free(pointer);
            printIntLine(data.intOne);
            printIntLine(data.intTwo);
        }
"
6752,0,CWE476_NULL_Pointer_Dereference__int_31.c,"    int * data;
    
    data = NULL;
    {
        int * dataCopy = data;
        int * data = dataCopy;
        
        printIntLine(*data);
"
17856,0,CWE369_Divide_by_Zero__int_listen_socket_divide_16.c,"    int data;
    
    data = -1;
    while(1)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
        break;
    }
    while(1)
    {
        
        printIntLine(100 / data);
        break;
"
2831,0,CWE190_Integer_Overflow__short_max_add_64a.c,"    short data;
    data = 0;
    
    data = SHRT_MAX;
"
2662,0,CWE401_Memory_Leak__new_int_08.cpp,"    int * data;
    data = NULL;
    if(staticReturnsTrue())
    {
        
        data = new int;
        
        *data = 5;
        printIntLine(*data);
    }
    if(staticReturnsTrue())
    {
        
        ; 
"
444,0,CWE688_Function_Call_With_Incorrect_Variable_or_Reference_as_Argument__basic_01.c,"    {
        char dest[DEST_SIZE];
        int intFive = 5;
        
        sprintf(dest, ""%s"", intFive);
        printLine(dest);
"
18848,1,CWE476_NULL_Pointer_Dereference__binary_if_08.c,"    if(staticReturnsFalse())
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            twoIntsStruct *twoIntsStructPointer = NULL;
            /* FIX: Use && in the if statement so that if the left side of the expression fails then
             * the right side will not be evaluated */
            if ((twoIntsStructPointer != NULL) && (twoIntsStructPointer->intOne == 5))
            {
                printLine(""intOne == 5"");
            }
        }
"
195,0,CWE415_Double_Free__new_delete_array_int_52a.cpp,"    int * data;
    
    data = NULL;
    data = new int[100];
    
    delete [] data;
"
12410,0,CWE190_Integer_Overflow__short_fscanf_add_62a.cpp,"    short data;
    data = 0;
    badSource(data);
    {
        
        short result = data + 1;
        printIntLine(result);
"
12150,0,CWE758_Undefined_Behavior__int_pointer_new_use_15.cpp,"    switch(6)
    {
    case 6:
    {
        int * * pointer = new int *;
        int * data = *pointer; 
        delete pointer;
        printIntLine(*data);
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
16198,1,CWE688_Function_Call_With_Incorrect_Variable_or_Reference_as_Argument__basic_04.c,"    if(STATIC_CONST_FALSE)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            char dest[DEST_SIZE];
            int intFive = 5;
            
            sprintf(dest, ""%d"", intFive);
            printLine(dest);
        }
"
10243,0,CWE197_Numeric_Truncation_Error__short_large_08.c,"    short data;
    
    data = -1;
    if(staticReturnsTrue())
    {
        
        data = CHAR_MAX + 1;
    }
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
9032,1,CWE758_Undefined_Behavior__char_pointer_malloc_use_10.c,"    if(globalTrue)
    {
        {
            char * data;
            char * * pointer = (char * *)malloc(sizeof(char *));
            if (pointer == NULL) {exit(-1);}
            data = ""string"";
            *pointer = data; 
            {
                char * data = *pointer;
                printLine(data);
            }
            free(pointer);
        }
"
13571,0,CWE415_Double_Free__malloc_free_int64_t_13.c,"    int64_t * data;
    
    data = NULL;
    if(GLOBAL_CONST_FIVE==5)
    {
        data = (int64_t *)malloc(100*sizeof(int64_t));
        if (data == NULL) {exit(-1);}
        
        free(data);
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        
        free(data);
"
306,0,CWE190_Integer_Overflow__short_max_square_72a.cpp,"    short data;
    vector<short> dataVector;
    data = 0;
    
    data = SHRT_MAX;
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
17669,0,CWE190_Integer_Overflow__int_listen_socket_square_64a.c,"    int data;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
1439,0,CWE190_Integer_Overflow__int_max_preinc_09.c,"    int data;
    
    data = 0;
    if(GLOBAL_CONST_TRUE)
    {
        
        data = INT_MAX;
    }
    if(GLOBAL_CONST_TRUE)
    {
        {
            
            ++data;
            int result = data;
            printIntLine(result);
        }
"
11442,0,CWE190_Integer_Overflow__unsigned_int_fscanf_add_73a.cpp,"    unsigned int data;
    list<unsigned int> dataList;
    data = 0;
    
    fscanf (stdin, ""%u"", &data);
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
11641,0,CWE690_NULL_Deref_From_Return__int64_t_calloc_41.c,"    int64_t * data;
    data = NULL; 
    
    data = (int64_t *)calloc(1, sizeof(int64_t));
"
10299,0,CWE369_Divide_by_Zero__int_fgets_modulo_01.c,"    int data;
    
    data = -1;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    
"
11344,0,CWE190_Integer_Overflow__int64_t_rand_multiply_32.c,"    int64_t data;
    int64_t *dataPtr1 = &data;
    int64_t *dataPtr2 = &data;
    data = 0LL;
    {
        int64_t data = *dataPtr1;
        
        data = (int64_t)RAND64();
        *dataPtr1 = data;
    }
    {
        int64_t data = *dataPtr2;
        if(data > 0) 
        {
            
            int64_t result = data * 2;
            printLongLongLine(result);
        }
"
18738,0,CWE467_Use_of_sizeof_on_Pointer_Type__int_17.c,"    int j;
    for(j = 0; j < 1; j++)
    {
        {
            int * badInt = NULL;
            
            badInt = (int *)malloc(sizeof(badInt));
            if (badInt == NULL) {exit(-1);}
            *badInt = 5;
            printIntLine(*badInt);
            free(badInt);
        }
"
7475,0,CWE190_Integer_Overflow__unsigned_int_rand_preinc_21.c,"    unsigned int data;
    data = 0;
    
    data = (unsigned int)RAND32();
    badStatic = 1; 
"
6583,0,CWE690_NULL_Deref_From_Return__long_realloc_72a.cpp,"    long * data;
    vector<long *> dataVector;
    data = NULL; 
    
    data = (long *)realloc(data, 1*sizeof(long));
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
11783,0,CWE590_Free_Memory_Not_on_Heap__delete_int64_t_alloca_11.cpp,"    int64_t * data;
    data = NULL; 
    if(globalReturnsTrue())
    {
        {
            
            int64_t * dataBuffer = (int64_t *)ALLOCA(sizeof(int64_t));
            *dataBuffer = 5LL;
            data = dataBuffer;
        }
    }
    printLongLongLine(*data);
    
"
6275,0,CWE134_Uncontrolled_Format_String__char_console_vfprintf_73a.cpp,"    char * data;
    list<char *> dataList;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        
        if (100-dataLen > 1)
        {
            
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgets() */
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
                    data[dataLen-1] = '\0';
                }
            }
            else
            {
                printLine(""fgets() failed"");
                
                data[dataLen] = '\0';
            }
        }
    }
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
13752,1,CWE252_Unchecked_Return_Value__char_fputc_07.c,"    if(staticFive==5)
    {
        
        if (fputc((int)'A', stdout) == EOF)
        {
            printLine(""fputc failed!"");
        }
"
5391,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_10.c,"    size_t data;
    
    data = 0;
    if(globalTrue)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = strtoul(inputBuffer, NULL, 0);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(globalTrue)
    {
        {
            char * myString;
            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
             * for the strcpy() function to not cause a buffer overflow */
            
            if (data > strlen(HELLO_STRING))
            {
                myString = (char *)malloc(data*sizeof(char));
                if (myString == NULL) {exit(-1);}
                
                strcpy(myString, HELLO_STRING);
                printLine(myString);
                free(myString);
            }
            else
            {
                printLine(""Input is less than the length of the source string"");
            }
        }
"
11145,0,CWE369_Divide_by_Zero__float_fscanf_84_bad.cpp,"Label Definition File: CWE369_Divide_by_Zero__float.label.xml
Template File: sources-sinks-84_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 369 Divide by Zero
 * BadSource: fscanf Read data from the console using fscanf()
 * GoodSource: A hardcoded non-zero number (two)
 * Sinks:
 *    GoodSink: Check value of or near zero before dividing
 *    BadSink : Divide a constant by data
 * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE369_Divide_by_Zero__float_fscanf_84.h""

namespace CWE369_Divide_by_Zero__float_fscanf_84
{
CWE369_Divide_by_Zero__float_fscanf_84_bad::CWE369_Divide_by_Zero__float_fscanf_84_bad(float dataCopy)
{
    data = dataCopy;
    
    fscanf (stdin, ""%f"", &data);
}

CWE369_Divide_by_Zero__float_fscanf_84_bad::~CWE369_Divide_by_Zero__float_fscanf_84_bad()
{
    {
        
        int result = (int)(100.0 / data);
        printIntLine(result);
    }
}
}
"
12797,0,CWE457_Use_of_Uninitialized_Variable__double_array_malloc_no_init_17.c,"    int i,j;
    double * data;
    data = (double *)malloc(10*sizeof(double));
    if (data == NULL) {exit(-1);}
    for(i = 0; i < 1; i++)
    {
        
        ; 
    }
    for(j = 0; j < 1; j++)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printDoubleLine(data[i]);
            }
        }
"
9319,0,CWE590_Free_Memory_Not_on_Heap__delete_array_long_declare_15.cpp,"    long * data;
    data = NULL; 
    switch(6)
    {
    case 6:
    {
        
        long dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5L;
            }
        }
        data = dataBuffer;
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    printLongLine(data[0]);
    
"
18263,1,CWE476_NULL_Pointer_Dereference__binary_if_06.c,"    if(STATIC_CONST_FIVE!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            twoIntsStruct *twoIntsStructPointer = NULL;
            /* FIX: Use && in the if statement so that if the left side of the expression fails then
             * the right side will not be evaluated */
            if ((twoIntsStructPointer != NULL) && (twoIntsStructPointer->intOne == 5))
            {
                printLine(""intOne == 5"");
            }
        }
"
1773,0,CWE134_Uncontrolled_Format_String__char_environment_snprintf_18.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    goto source;
source:
    {
        
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        
        if (environment != NULL)
        {
            
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    goto sink;
sink:
    {
        char dest[100] = """";
        
        SNPRINTF(dest, 100-1, data);
        printLine(dest);
"
11395,0,CWE416_Use_After_Free__new_delete_int64_t_62a.cpp,"    int64_t * data;
    
    data = NULL;
    badSource(data);
    
    printLongLongLine(*data);
"
18558,0,CWE590_Free_Memory_Not_on_Heap__delete_array_long_declare_18.cpp,"    long * data;
    data = NULL; 
    goto source;
source:
    {
        
        long dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5L;
            }
        }
        data = dataBuffer;
    }
    printLongLine(data[0]);
    
"
10770,0,CWE197_Numeric_Truncation_Error__int_fgets_to_short_81a.cpp,"    int data;
    
    data = -1;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    const CWE197_Numeric_Truncation_Error__int_fgets_to_short_81_base& baseObject = CWE197_Numeric_Truncation_Error__int_fgets_to_short_81_bad();
"
1452,0,CWE758_Undefined_Behavior__int_alloca_use_11.c,"    if(globalReturnsTrue())
    {
        {
            int * pointer = (int *)ALLOCA(sizeof(int));
            int data = *pointer; 
            printIntLine(data);
        }
"
6198,0,CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_17.c,"    int i,j;
    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    for(i = 0; i < 1; i++)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                data[dataLen + recvResult / sizeof(char)] = '\0';
                
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    for(j = 0; j < 1; j++)
    {
        
        fprintf(stdout, data);
"
8037,0,CWE78_OS_Command_Injection__char_console_execlp_06.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(STATIC_CONST_FIVE==5)
    {
        {
            
            size_t dataLen = strlen(data);
            
            if (100-dataLen > 1)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
                {
                    /* The next few lines remove the carriage return from the string that is
                     * inserted by fgets() */
                    dataLen = strlen(data);
"
6476,0,CWE416_Use_After_Free__new_delete_int64_t_01.cpp,"    int64_t * data;
    
    data = NULL;
    data = new int64_t;
    *data = 5LL;
    
    delete data;
    
    printLongLongLine(*data);
"
5334,0,CWE190_Integer_Overflow__int64_t_fscanf_postinc_07.c,"    int64_t data;
    data = 0LL;
    if(staticFive==5)
    {
        
        fscanf (stdin, ""%"" SCNd64, &data);
    }
    if(staticFive==5)
    {
        {
            
            data++;
            int64_t result = data;
            printLongLongLine(result);
        }
"
1709,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_53a.c,"    size_t data;
    
    data = 0;
    
    fscanf(stdin, ""%zu"", &data);
"
3779,1,CWE758_Undefined_Behavior__struct_pointer_malloc_use_04.c,"    if(STATIC_CONST_FALSE)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            twoIntsStruct * data;
            twoIntsStruct * * pointer = (twoIntsStruct * *)malloc(sizeof(twoIntsStruct *));
            if (pointer == NULL) {exit(-1);}
            
            data = (twoIntsStruct *)malloc(sizeof(twoIntsStruct));
            if (data == NULL) {exit(-1);}
            data->intOne = 5;
            data->intTwo = 6;
            *pointer = data; 
            {
                twoIntsStruct * data = *pointer;
                printIntLine(data->intOne);
                printIntLine(data->intTwo);
            }
            free(pointer);
        }
"
425,0,CWE590_Free_Memory_Not_on_Heap__delete_array_class_static_82a.cpp,"    TwoIntsClass * data;
    data = NULL; 
    {
        
        static TwoIntsClass dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i].intOne = 1;
                dataBuffer[i].intTwo = 1;
            }
        }
        data = dataBuffer;
    }
    CWE590_Free_Memory_Not_on_Heap__delete_array_class_static_82_base* baseObject = new CWE590_Free_Memory_Not_on_Heap__delete_array_class_static_82_bad;
    baseObject->action(data);
"
17125,0,CWE401_Memory_Leak__int64_t_malloc_12.c,"    int64_t * data;
    data = NULL;
    if(globalReturnsTrueOrFalse())
    {
        
        data = (int64_t *)malloc(100*sizeof(int64_t));
        if (data == NULL) {exit(-1);}
        
        data[0] = 5LL;
        printLongLongLine(data[0]);
    }
    else
    {
        
        data = (int64_t *)ALLOCA(100*sizeof(int64_t));
        
        data[0] = 5LL;
        printLongLongLine(data[0]);
    }
    if(globalReturnsTrueOrFalse())
    {
        
        ; 
    }
    else
    {
        
        free(data);
"
7479,0,CWE190_Integer_Overflow__char_max_square_11.c,"    char data;
    data = ' ';
    if(globalReturnsTrue())
    {
        
        data = CHAR_MAX;
    }
    if(globalReturnsTrue())
    {
        {
            
            char result = data * data;
            printHexCharLine(result);
        }
"
16944,0,CWE758_Undefined_Behavior__struct_pointer_malloc_use_01.c,"    {
        twoIntsStruct * * pointer = (twoIntsStruct * *)malloc(sizeof(twoIntsStruct *));
        if (pointer == NULL) {exit(-1);}
        twoIntsStruct * data = *pointer; 
        free(pointer);
        printIntLine(data->intOne);
        printIntLine(data->intTwo);
"
13682,1,CWE758_Undefined_Behavior__char_pointer_malloc_use_06.c,"    if(STATIC_CONST_FIVE==5)
    {
        {
            char * data;
            char * * pointer = (char * *)malloc(sizeof(char *));
            if (pointer == NULL) {exit(-1);}
            data = ""string"";
            *pointer = data; 
            {
                char * data = *pointer;
                printLine(data);
            }
            free(pointer);
        }
"
5051,0,CWE590_Free_Memory_Not_on_Heap__delete_array_int64_t_declare_04.cpp,"    int64_t * data;
    data = NULL; 
    if(STATIC_CONST_TRUE)
    {
        {
            
            int64_t dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5LL;
                }
            }
            data = dataBuffer;
        }
    }
    printLongLongLine(data[0]);
    
"
4274,0,CWE758_Undefined_Behavior__int_pointer_alloca_use_15.c,"    switch(6)
    {
    case 6:
    {
        int * * pointer = (int * *)ALLOCA(sizeof(int *));
        int * data = *pointer; 
        printIntLine(*data);
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
8225,1,CWE758_Undefined_Behavior__char_pointer_alloca_use_13.c,"    if(GLOBAL_CONST_FIVE==5)
    {
        {
            char * data;
            char * * pointer = (char * *)ALLOCA(sizeof(char *));
            data = ""string"";
            *pointer = data; 
            {
                char * data = *pointer;
                printLine(data);
            }
        }
"
15175,0,CWE197_Numeric_Truncation_Error__int_fgets_to_short_54a.c,"    int data;
    
    data = -1;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
"
4944,0,CWE758_Undefined_Behavior__struct_malloc_use_18.c,"    goto sink;
sink:
    {
        twoIntsStruct * pointer = (twoIntsStruct *)malloc(sizeof(twoIntsStruct));
        if (pointer == NULL) {exit(-1);}
        twoIntsStruct data = *pointer; 
        free(pointer);
        printIntLine(data.intOne);
        printIntLine(data.intTwo);
"
11187,0,CWE190_Integer_Overflow__short_max_preinc_22a.c,"    short data;
    data = 0;
    
    data = SHRT_MAX;
    CWE190_Integer_Overflow__short_max_preinc_22_badGlobal = 1; 
"
16125,0,CWE78_OS_Command_Injection__char_file_system_84_bad.cpp,"Label Definition File: CWE78_OS_Command_Injection.one_string.label.xml
Template File: sources-sink-84_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 78 OS Command Injection
 * BadSource: file Read input from a file
 * GoodSource: Fixed string
 * Sinks: system
 *    BadSink : Execute command in data using system()
 * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE78_OS_Command_Injection__char_file_system_84.h""

#ifdef _WIN32
#define FILENAME ""C:\\temp\\file.txt""
#else
#define FILENAME ""/tmp/file.txt""
#endif

#ifdef _WIN32
#define SYSTEM system
#else 
#define SYSTEM system
#endif

namespace CWE78_OS_Command_Injection__char_file_system_84
{
CWE78_OS_Command_Injection__char_file_system_84_bad::CWE78_OS_Command_Injection__char_file_system_84_bad(char * dataCopy)
{
    data = dataCopy;
    {
        
        size_t dataLen = strlen(data);
        FILE * pFile;
        
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
}

CWE78_OS_Command_Injection__char_file_system_84_bad::~CWE78_OS_Command_Injection__char_file_system_84_bad()
{
    
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
    }
}
}
"
19509,0,CWE457_Use_of_Uninitialized_Variable__new_double_array_no_init_12.cpp,"    double * data;
    data = new double[10];
    if(globalReturnsTrueOrFalse())
    {
        
        ; 
    }
    else
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                data[i] = (double)i;
            }
        }
    }
    if(globalReturnsTrueOrFalse())
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printDoubleLine(data[i]);
            }
        }
        
        delete [] data;
    }
    else
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                data[i] = (double)i;
            }
        }
        {
            int i;
            for(i=0; i<10; i++)
            {
                printDoubleLine(data[i]);
            }
        }
        
        delete [] data;
"
8911,1,CWE252_Unchecked_Return_Value__char_fwrite_02.c,"    if(0)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        
        if (fwrite((char *)""string"", sizeof(char), strlen(""string""), stdout) != strlen(""string""))
        {
            printLine(""fwrite failed!"");
        }
"
16749,0,CWE78_OS_Command_Injection__char_environment_popen_83a.cpp,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
"
18994,0,CWE369_Divide_by_Zero__int_connect_socket_modulo_68a.c,"    int data;
    
    data = -1;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    CWE369_Divide_by_Zero__int_connect_socket_modulo_68_badData = data;
"
1000,0,CWE590_Free_Memory_Not_on_Heap__delete_struct_alloca_44.cpp,"    twoIntsStruct * data;
    
    void (*funcPtr) (twoIntsStruct *) = badSink;
    data = NULL; 
    {
        
        twoIntsStruct * dataBuffer = (twoIntsStruct *)ALLOCA(sizeof(twoIntsStruct));
        dataBuffer->intOne = 1;
        dataBuffer->intTwo = 1;
        data = dataBuffer;
    }
    
"
594,0,CWE758_Undefined_Behavior__int_pointer_malloc_use_03.c,"    if(5==5)
    {
        {
            int * * pointer = (int * *)malloc(sizeof(int *));
            if (pointer == NULL) {exit(-1);}
            int * data = *pointer; 
            free(pointer);
            printIntLine(*data);
        }
"
10085,0,CWE690_NULL_Deref_From_Return__char_malloc_54a.c,"    char * data;
    data = NULL; 
    
    data = (char *)malloc(20*sizeof(char));
"
8309,0,CWE416_Use_After_Free__new_delete_array_long_64a.cpp,"    long * data;
    
    data = NULL;
    data = new long[100];
    {
        size_t i;
        for(i = 0; i < 100; i++)
        {
            data[i] = 5L;
        }
    }
    
    delete [] data;
"
17328,0,CWE758_Undefined_Behavior__struct_malloc_use_06.c,"    if(STATIC_CONST_FIVE==5)
    {
        {
            twoIntsStruct * pointer = (twoIntsStruct *)malloc(sizeof(twoIntsStruct));
            if (pointer == NULL) {exit(-1);}
            twoIntsStruct data = *pointer; 
            free(pointer);
            printIntLine(data.intOne);
            printIntLine(data.intTwo);
        }
"
11737,0,CWE590_Free_Memory_Not_on_Heap__delete_array_struct_alloca_81a.cpp,"    twoIntsStruct * data;
    data = NULL; 
    {
        
        twoIntsStruct * dataBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i].intOne = 1;
                dataBuffer[i].intTwo = 1;
            }
        }
        data = dataBuffer;
    }
    const CWE590_Free_Memory_Not_on_Heap__delete_array_struct_alloca_81_base& baseObject = CWE590_Free_Memory_Not_on_Heap__delete_array_struct_alloca_81_bad();
"
10484,0,CWE476_NULL_Pointer_Dereference__long_11.c,"    long * data;
    if(globalReturnsTrue())
    {
        
        data = NULL;
    }
    if(globalReturnsTrue())
    {
        
        printLongLine(*data);
"
14288,0,CWE590_Free_Memory_Not_on_Heap__delete_char_static_74a.cpp,"    char * data;
    map<int, char *> dataMap;
    data = NULL; 
    {
        
        static char dataBuffer;
        dataBuffer = 'A';
        data = &dataBuffer;
    }
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
11227,0,CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_02.c,"    int data;
    
    data = -1;
    if(1)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
13647,0,CWE590_Free_Memory_Not_on_Heap__delete_long_static_01.cpp,"    long * data;
    data = NULL; 
    {
        
        static long dataBuffer;
        dataBuffer = 5L;
        data = &dataBuffer;
    }
    printLongLine(*data);
    
"
16808,0,CWE190_Integer_Overflow__short_fscanf_square_84_bad.cpp,"Label Definition File: CWE190_Integer_Overflow.label.xml
Template File: sources-sinks-84_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 190 Integer Overflow
 * BadSource: fscanf Read data from the console using fscanf()
 * GoodSource: Set data to a small, non-zero number (two)
 * Sinks: square
 *    GoodSink: Ensure there will not be an overflow before squaring data
 *    BadSink : Square data, which can lead to overflow
 * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE190_Integer_Overflow__short_fscanf_square_84.h""

#include <math.h>

namespace CWE190_Integer_Overflow__short_fscanf_square_84
{
CWE190_Integer_Overflow__short_fscanf_square_84_bad::CWE190_Integer_Overflow__short_fscanf_square_84_bad(short dataCopy)
{
    data = dataCopy;
    
    fscanf (stdin, ""%hd"", &data);
}

CWE190_Integer_Overflow__short_fscanf_square_84_bad::~CWE190_Integer_Overflow__short_fscanf_square_84_bad()
{
    {
        
        short result = data * data;
        printIntLine(result);
    }
}
}
"
11301,1,CWE252_Unchecked_Return_Value__char_fread_06.c,"    if(STATIC_CONST_FIVE==5)
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            
            if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) != 100-1)
            {
                printLine(""fread failed!"");
            }
        }
"
1814,0,CWE457_Use_of_Uninitialized_Variable__twointsclass_array_malloc_partial_init_08.cpp,"    TwoIntsClass * data;
    data = reinterpret_cast<TwoIntsClass *>(malloc(10*sizeof(TwoIntsClass)));
    if (data == NULL) {exit(-1);}
    if(staticReturnsTrue())
    {
        
        for(int i=0; i<(10/2); i++)
        {
            data[i].intOne = i;
            data[i].intTwo = i;
        }
    }
    if(staticReturnsTrue())
    {
        
        for(int i=0; i<10; i++)
        {
            printIntLine(data[i].intOne);
            printIntLine(data[i].intTwo);
        }
"
12188,0,CWE190_Integer_Overflow__int_max_postinc_07.c,"    int data;
    
    data = 0;
    if(staticFive==5)
    {
        
        data = INT_MAX;
    }
    if(staticFive==5)
    {
        {
            
            data++;
            int result = data;
            printIntLine(result);
        }
"
8177,0,CWE590_Free_Memory_Not_on_Heap__delete_class_declare_72a.cpp,"    TwoIntsClass * data;
    vector<TwoIntsClass *> dataVector;
    data = NULL; 
    {
        
        TwoIntsClass dataBuffer;
        dataBuffer.intOne = 1;
        dataBuffer.intTwo = 1;
        data = &dataBuffer;
    }
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
11382,1,CWE476_NULL_Pointer_Dereference__binary_if_04.c,"    if(STATIC_CONST_FALSE)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            twoIntsStruct *twoIntsStructPointer = NULL;
            /* FIX: Use && in the if statement so that if the left side of the expression fails then
             * the right side will not be evaluated */
            if ((twoIntsStructPointer != NULL) && (twoIntsStructPointer->intOne == 5))
            {
                printLine(""intOne == 5"");
            }
        }
"
14313,0,CWE457_Use_of_Uninitialized_Variable__struct_array_alloca_no_init_07.c,"    twoIntsStruct * data;
    data = (twoIntsStruct *)ALLOCA(10*sizeof(twoIntsStruct));
    if(staticFive==5)
    {
        
        ; 
    }
    if(staticFive==5)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i].intOne);
                printIntLine(data[i].intTwo);
            }
        }
"
6682,0,CWE190_Integer_Overflow__unsigned_int_fscanf_square_10.c,"    unsigned int data;
    data = 0;
    if(globalTrue)
    {
        
        fscanf (stdin, ""%u"", &data);
    }
    if(globalTrue)
    {
        {
            
            unsigned int result = data * data;
            printUnsignedLine(result);
        }
"
12368,0,CWE197_Numeric_Truncation_Error__int_large_to_char_52a.c,"    int data;
    
    data = -1;
    
    data = SHRT_MAX + 5;
"
14155,0,CWE758_Undefined_Behavior__char_pointer_new_use_07.cpp,"    if(staticFive==5)
    {
        {
            char * * pointer = new char *;
            char * data = *pointer; 
            delete pointer;
            printLine(data);
        }
"
19370,0,CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_17.cpp,"    int i,j;
    size_t data;
    
    data = 0;
    for(i = 0; i < 1; i++)
    {
        
        fscanf(stdin, ""%zu"", &data);
    }
    for(j = 0; j < 1; j++)
    {
        {
            char * myString;
            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
             * for the strcpy() function to not cause a buffer overflow */
            
            if (data > strlen(HELLO_STRING))
            {
                myString = new char[data];
                
                strcpy(myString, HELLO_STRING);
                printLine(myString);
                delete [] myString;
            }
            else
            {
                printLine(""Input is less than the length of the source string"");
            }
        }
"
7960,0,CWE590_Free_Memory_Not_on_Heap__delete_array_char_alloca_07.cpp,"    char * data;
    data = NULL; 
    if(staticFive==5)
    {
        {
            
            char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
            memset(dataBuffer, 'A', 100-1); 
            dataBuffer[100-1] = '\0'; 
            data = dataBuffer;
        }
    }
    printLine(data);
    
"
4435,0,CWE590_Free_Memory_Not_on_Heap__delete_array_struct_static_45.cpp,"    twoIntsStruct * data;
    data = NULL; 
    {
        
        static twoIntsStruct dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i].intOne = 1;
                dataBuffer[i].intTwo = 1;
            }
        }
        data = dataBuffer;
    }
    badData = data;
"
5427,0,CWE401_Memory_Leak__new_int64_t_04.cpp,"    int64_t * data;
    data = NULL;
    if(STATIC_CONST_TRUE)
    {
        
        data = new int64_t;
        
        *data = 5LL;
        printLongLongLine(*data);
    }
    if(STATIC_CONST_TRUE)
    {
        
        ; 
"
11513,0,CWE590_Free_Memory_Not_on_Heap__free_long_declare_11.c,"    long * data;
    data = NULL; 
    if(globalReturnsTrue())
    {
        {
            
            long dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5L;
                }
            }
            data = dataBuffer;
        }
    }
    printLongLine(data[0]);
    
"
8246,0,CWE590_Free_Memory_Not_on_Heap__delete_array_int_static_68a.cpp,"    int * data;
    data = NULL; 
    {
        
        static int dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5;
            }
        }
        data = dataBuffer;
    }
    CWE590_Free_Memory_Not_on_Heap__delete_array_int_static_68_badData = data;
"
11383,0,CWE190_Integer_Overflow__int64_t_fscanf_preinc_06.c,"    int64_t data;
    data = 0LL;
    if(STATIC_CONST_FIVE==5)
    {
        
        fscanf (stdin, ""%"" SCNd64, &data);
    }
    if(STATIC_CONST_FIVE==5)
    {
        {
            
            ++data;
            int64_t result = data;
            printLongLongLine(result);
        }
"
14104,0,CWE190_Integer_Overflow__int_max_add_45.c,"    int data;
    
    data = 0;
    
    data = INT_MAX;
    CWE190_Integer_Overflow__int_max_add_45_badData = data;
"
16202,0,CWE476_NULL_Pointer_Dereference__null_check_after_deref_05.c,"    if(staticTrue)
    {
        {
            int *intPointer = NULL;
            intPointer = (int *)malloc(sizeof(int));
            *intPointer = 5;
            printIntLine(*intPointer);
            
            if (intPointer != NULL)
            {
                *intPointer = 10;
            }
            printIntLine(*intPointer);
        }
"
16039,0,CWE369_Divide_by_Zero__int_fgets_modulo_18.c,"    int data;
    
    data = -1;
    goto source;
source:
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    goto sink;
sink:
    
"
7758,0,CWE401_Memory_Leak__twoIntsStruct_calloc_18.c,"    twoIntsStruct * data;
    data = NULL;
    goto source;
source:
    
    data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));
    if (data == NULL) {exit(-1);}
    
    data[0].intOne = 0;
    data[0].intTwo = 0;
    printStructLine(&data[0]);
    goto sink;
sink:
    
"
6151,0,CWE190_Integer_Overflow__char_max_square_17.c,"    int i,j;
    char data;
    data = ' ';
    for(i = 0; i < 1; i++)
    {
        
        data = CHAR_MAX;
    }
    for(j = 0; j < 1; j++)
    {
        {
            
            char result = data * data;
            printHexCharLine(result);
        }
"
12245,0,CWE197_Numeric_Truncation_Error__short_listen_socket_67a.c,"    short data;
    CWE197_Numeric_Truncation_Error__short_listen_socket_67_structType myStruct;
    
    data = -1;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = (short)atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    myStruct.structFirst = data;
"
9383,0,CWE590_Free_Memory_Not_on_Heap__delete_char_declare_51a.cpp,"    char * data;
    data = NULL; 
    {
        
        char dataBuffer;
        dataBuffer = 'A';
        data = &dataBuffer;
    }
"
14556,0,CWE415_Double_Free__new_delete_struct_11.cpp,"    twoIntsStruct * data;
    
    data = NULL;
    if(globalReturnsTrue())
    {
        data = new twoIntsStruct;
        
        delete data;
    }
    if(globalReturnsTrue())
    {
        
        delete data;
"
9534,0,CWE190_Integer_Overflow__unsigned_int_rand_multiply_67a.c,"    unsigned int data;
    CWE190_Integer_Overflow__unsigned_int_rand_multiply_67_structType myStruct;
    data = 0;
    
    data = (unsigned int)RAND32();
    myStruct.structFirst = data;
"
8740,0,CWE78_OS_Command_Injection__char_file_popen_72a.cpp,"    char * data;
    vector<char *> dataVector;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
        
        size_t dataLen = strlen(data);
        FILE * pFile;
        
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
511,0,CWE690_NULL_Deref_From_Return__fopen_81a.cpp,"    FILE * data;
    
    data = NULL;
    
    data = fopen(""file.txt"", ""w+"");
    const CWE690_NULL_Deref_From_Return__fopen_81_base& baseObject = CWE690_NULL_Deref_From_Return__fopen_81_bad();
"
5463,0,CWE197_Numeric_Truncation_Error__int_large_to_char_84_bad.cpp,"Label Definition File: CWE197_Numeric_Truncation_Error__int.label.xml
Template File: sources-sink-84_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 197 Numeric Truncation Error
 * BadSource: large Set data to a number larger than SHRT_MAX
 * GoodSource: Less than CHAR_MAX
 * Sinks: to_char
 *    BadSink : Convert data to a char
 * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE197_Numeric_Truncation_Error__int_large_to_char_84.h""

namespace CWE197_Numeric_Truncation_Error__int_large_to_char_84
{
CWE197_Numeric_Truncation_Error__int_large_to_char_84_bad::CWE197_Numeric_Truncation_Error__int_large_to_char_84_bad(int dataCopy)
{
    data = dataCopy;
    
    data = SHRT_MAX + 5;
}

CWE197_Numeric_Truncation_Error__int_large_to_char_84_bad::~CWE197_Numeric_Truncation_Error__int_large_to_char_84_bad()
{
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
    }
}
}
"
2088,0,CWE190_Integer_Overflow__int64_t_max_add_63a.c,"    int64_t data;
    data = 0LL;
    
    data = LLONG_MAX;
"
3895,0,CWE369_Divide_by_Zero__int_zero_modulo_65a.c,"    int data;
    
    void (*funcPtr) (int) = CWE369_Divide_by_Zero__int_zero_modulo_65b_badSink;
    
    data = -1;
    
    data = 0;
    
"
2608,0,CWE590_Free_Memory_Not_on_Heap__delete_array_char_alloca_68a.cpp,"    char * data;
    data = NULL; 
    {
        
        char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
        memset(dataBuffer, 'A', 100-1); 
        dataBuffer[100-1] = '\0'; 
        data = dataBuffer;
    }
    CWE590_Free_Memory_Not_on_Heap__delete_array_char_alloca_68_badData = data;
"
1306,0,CWE476_NULL_Pointer_Dereference__int64_t_14.c,"    int64_t * data;
    if(globalFive==5)
    {
        
        data = NULL;
    }
    if(globalFive==5)
    {
        
        printLongLongLine(*data);
"
14833,0,CWE401_Memory_Leak__int64_t_malloc_51a.c,"    int64_t * data;
    data = NULL;
    
    data = (int64_t *)malloc(100*sizeof(int64_t));
    if (data == NULL) {exit(-1);}
    
    data[0] = 5LL;
    printLongLongLine(data[0]);
"
6487,1,CWE401_Memory_Leak__malloc_realloc_struct_twoIntsStruct_14.c,"    if(globalFive!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            struct _twoIntsStruct * data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));
            if (data == NULL) {exit(-1);}
            struct _twoIntsStruct * tmpData;
            
            data[0].intOne = 0;
            data[0].intTwo = 0;
            printStructLine((twoIntsStruct *)&data[0]);
            tmpData = (struct _twoIntsStruct *)realloc(data, (130000)*sizeof(struct _twoIntsStruct));
            /* FIX: Ensure realloc() was successful before assigning data to the memory block
            * allocated with realloc() */
            if (tmpData != NULL)
            {
                data = tmpData;
                
                data[0].intOne = 1;
                data[0].intTwo = 1;
                printStructLine((twoIntsStruct *)&data[0]);
            }
            free(data);
        }
"
15388,0,CWE457_Use_of_Uninitialized_Variable__struct_array_malloc_no_init_02.c,"    twoIntsStruct * data;
    data = (twoIntsStruct *)malloc(10*sizeof(twoIntsStruct));
    if (data == NULL) {exit(-1);}
    if(1)
    {
        
        ; 
    }
    if(1)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i].intOne);
                printIntLine(data[i].intTwo);
            }
        }
"
5013,0,CWE78_OS_Command_Injection__char_environment_system_68a.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
        
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        
        if (environment != NULL)
        {
            
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    CWE78_OS_Command_Injection__char_environment_system_68_badData = data;
"
11827,0,CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_21.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    badStatic = 1; 
"
18410,0,CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_10.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(globalTrue)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET connectSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                
                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                data[dataLen + recvResult / sizeof(char)] = '\0';
                
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(globalTrue)
    {
        {
            char dest[100] = """";
            
            SNPRINTF(dest, 100-1, data);
            printLine(dest);
        }
"
12456,0,CWE401_Memory_Leak__int64_t_calloc_63a.c,"    int64_t * data;
    data = NULL;
    
    data = (int64_t *)calloc(100, sizeof(int64_t));
    if (data == NULL) {exit(-1);}
    
    data[0] = 5LL;
    printLongLongLine(data[0]);
"
12810,0,CWE758_Undefined_Behavior__int64_t_new_use_03.cpp,"    if(5==5)
    {
        {
            int64_t * pointer = new int64_t;
            int64_t data = *pointer; 
            delete pointer;
            printLongLongLine(data);
        }
"
7478,1,CWE252_Unchecked_Return_Value__char_putc_02.c,"    if(1)
    {
        
        if (putc((int)'A', stdout) == EOF)
        {
            printLine(""putc failed!"");
        }
"
10031,0,CWE590_Free_Memory_Not_on_Heap__delete_char_placement_new_09.cpp,"    char * data;
    data = NULL; 
    if(GLOBAL_CONST_TRUE)
    {
        {
            
            char buffer[sizeof(char)];
            char * dataBuffer = new(buffer) char;
            *dataBuffer = 'A';
            data = dataBuffer;
        }
    }
    printHexCharLine(*data);
    
"
12897,0,CWE590_Free_Memory_Not_on_Heap__delete_int_static_13.cpp,"    int * data;
    data = NULL; 
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            
            static int dataBuffer;
            dataBuffer = 5;
            data = &dataBuffer;
        }
    }
    printIntLine(*data);
    
"
4856,0,CWE457_Use_of_Uninitialized_Variable__int64_t_16.c,"    int64_t data;
    while(1)
    {
        
        ; 
        break;
    }
    while(1)
    {
        
        printLongLongLine(data);
        break;
"
11450,0,CWE457_Use_of_Uninitialized_Variable__int_array_declare_partial_init_13.c,"    int * data;
    int dataUninitArray[10];
    data = dataUninitArray;
    if(GLOBAL_CONST_FIVE==5)
    {
        
        {
            int i;
            for(i=0; i<(10/2); i++)
            {
                data[i] = i;
            }
        }
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i]);
            }
        }
"
15519,1,CWE401_Memory_Leak__malloc_realloc_char_18.c,"    goto sink;
sink:
    {
        char * data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        char * tmpData;
        
        strcpy(data, ""A String"");
        printLine(data);
        tmpData = (char *)realloc(data, (130000)*sizeof(char));
        /* FIX: Ensure realloc() was successful before assigning data to the memory block
        * allocated with realloc() */
        if (tmpData != NULL)
        {
            data = tmpData;
            
            strcpy(data, ""New String"");
            printLine(data);
        }
        free(data);
"
13559,0,CWE590_Free_Memory_Not_on_Heap__free_struct_alloca_63a.c,"    twoIntsStruct * data;
    data = NULL; 
    {
        
        twoIntsStruct * dataBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i].intOne = 1;
                dataBuffer[i].intTwo = 1;
            }
        }
        data = dataBuffer;
    }
"
17622,0,CWE78_OS_Command_Injection__char_console_execlp_09.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(GLOBAL_CONST_TRUE)
    {
        {
            
            size_t dataLen = strlen(data);
            
            if (100-dataLen > 1)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
                {
                    /* The next few lines remove the carriage return from the string that is
                     * inserted by fgets() */
                    dataLen = strlen(data);
"
19391,0,CWE190_Integer_Overflow__unsigned_int_max_add_84_bad.cpp,"Label Definition File: CWE190_Integer_Overflow.label.xml
Template File: sources-sinks-84_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 190 Integer Overflow
 * BadSource: max Set data to the max value for unsigned int
 * GoodSource: Set data to a small, non-zero number (two)
 * Sinks: add
 *    GoodSink: Ensure there will not be an overflow before adding 1 to data
 *    BadSink : Add 1 to data, which can cause an overflow
 * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE190_Integer_Overflow__unsigned_int_max_add_84.h""

namespace CWE190_Integer_Overflow__unsigned_int_max_add_84
{
CWE190_Integer_Overflow__unsigned_int_max_add_84_bad::CWE190_Integer_Overflow__unsigned_int_max_add_84_bad(unsigned int dataCopy)
{
    data = dataCopy;
    
    data = UINT_MAX;
}

CWE190_Integer_Overflow__unsigned_int_max_add_84_bad::~CWE190_Integer_Overflow__unsigned_int_max_add_84_bad()
{
    {
        
        unsigned int result = data + 1;
        printUnsignedLine(result);
    }
}
}
"
12754,0,CWE369_Divide_by_Zero__int_zero_modulo_21.c,"    int data;
    
    data = -1;
    
    data = 0;
    badStatic = 1; 
"
7288,0,CWE690_NULL_Deref_From_Return__struct_malloc_17.c,"    int j;
    twoIntsStruct * data;
    data = NULL; 
    
    data = (twoIntsStruct *)malloc(1*sizeof(twoIntsStruct));
    for(j = 0; j < 1; j++)
    {
        
        data[0].intOne = 1;
        data[0].intTwo = 1;
        printStructLine(&data[0]);
        free(data);
"
8058,0,CWE476_NULL_Pointer_Dereference__char_63a.c,"    char * data;
    
    data = NULL;
"
2020,0,CWE690_NULL_Deref_From_Return__struct_realloc_22a.c,"    twoIntsStruct * data;
    data = NULL; 
    
    data = (twoIntsStruct *)realloc(data, 1*sizeof(twoIntsStruct));
    CWE690_NULL_Deref_From_Return__struct_realloc_22_badGlobal = 1; 
"
9255,1,CWE252_Unchecked_Return_Value__char_fputc_05.c,"    if(staticTrue)
    {
        
        if (fputc((int)'A', stdout) == EOF)
        {
            printLine(""fputc failed!"");
        }
"
14109,0,CWE369_Divide_by_Zero__int_fgets_modulo_74a.cpp,"    int data;
    map<int, int> dataMap;
    
    data = -1;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
8387,0,CWE590_Free_Memory_Not_on_Heap__delete_int_static_72a.cpp,"    int * data;
    vector<int *> dataVector;
    data = NULL; 
    {
        
        static int dataBuffer;
        dataBuffer = 5;
        data = &dataBuffer;
    }
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
10284,0,CWE78_OS_Command_Injection__char_console_system_06.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(STATIC_CONST_FIVE==5)
    {
        {
            
            size_t dataLen = strlen(data);
            
            if (100-dataLen > 1)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
                {
                    /* The next few lines remove the carriage return from the string that is
                     * inserted by fgets() */
                    dataLen = strlen(data);
"
3229,0,CWE457_Use_of_Uninitialized_Variable__new_int_array_partial_init_08.cpp,"    int * data;
    data = new int[10];
    if(staticReturnsTrue())
    {
        
        {
            int i;
            for(i=0; i<(10/2); i++)
            {
                data[i] = i;
            }
        }
    }
    if(staticReturnsTrue())
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i]);
            }
        }
        
        delete [] data;
"
714,0,CWE690_NULL_Deref_From_Return__struct_malloc_74a.cpp,"    twoIntsStruct * data;
    map<int, twoIntsStruct *> dataMap;
    data = NULL; 
    
    data = (twoIntsStruct *)malloc(1*sizeof(twoIntsStruct));
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
10599,0,CWE690_NULL_Deref_From_Return__long_calloc_54a.c,"    long * data;
    data = NULL; 
    
    data = (long *)calloc(1, sizeof(long));
"
5493,0,CWE190_Integer_Overflow__unsigned_int_max_square_07.c,"    unsigned int data;
    data = 0;
    if(staticFive==5)
    {
        
        data = UINT_MAX;
    }
    if(staticFive==5)
    {
        {
            
            unsigned int result = data * data;
            printUnsignedLine(result);
        }
"
9808,0,CWE190_Integer_Overflow__int_listen_socket_postinc_52a.c,"    int data;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
12125,0,CWE563_Unused_Variable__unused_uninit_variable_char_18.c,"    char data;
    
    ; 
    goto sink;
sink:
    
    
"
8727,0,CWE590_Free_Memory_Not_on_Heap__delete_array_int_static_81a.cpp,"    int * data;
    data = NULL; 
    {
        
        static int dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5;
            }
        }
        data = dataBuffer;
    }
    const CWE590_Free_Memory_Not_on_Heap__delete_array_int_static_81_base& baseObject = CWE590_Free_Memory_Not_on_Heap__delete_array_int_static_81_bad();
"
12417,0,CWE190_Integer_Overflow__unsigned_int_max_multiply_34.c,"    unsigned int data;
    CWE190_Integer_Overflow__unsigned_int_max_multiply_34_unionType myUnion;
    data = 0;
    
    data = UINT_MAX;
    myUnion.unionFirst = data;
    {
        unsigned int data = myUnion.unionSecond;
        if(data > 0) 
        {
            
            unsigned int result = data * 2;
            printUnsignedLine(result);
        }
"
7424,0,CWE401_Memory_Leak__new_array_int64_t_09.cpp,"    int64_t * data;
    data = NULL;
    if(GLOBAL_CONST_TRUE)
    {
        
        data = new int64_t[100];
        
        data[0] = 5LL;
        printLongLongLine(data[0]);
    }
    if(GLOBAL_CONST_TRUE)
    {
        
        ; 
"
770,0,CWE690_NULL_Deref_From_Return__long_realloc_06.c,"    long * data;
    data = NULL; 
    
    data = (long *)realloc(data, 1*sizeof(long));
    if(STATIC_CONST_FIVE==5)
    {
        
        data[0] = 5L;
        printLongLine(data[0]);
        free(data);
"
6416,0,CWE563_Unused_Variable__unused_uninit_variable_int64_t_33.cpp,"    int64_t data;
    int64_t &dataRef = data;
    
    ; 
    {
        int64_t data = dataRef;
        
        
        ; 
"
13244,0,CWE197_Numeric_Truncation_Error__short_large_53a.c,"    short data;
    
    data = -1;
    
    data = CHAR_MAX + 1;
"
4688,1,CWE758_Undefined_Behavior__int_alloca_use_10.c,"    if(globalTrue)
    {
        {
            int data;
            int * pointer = (int *)ALLOCA(sizeof(int));
            data = 5;
            *pointer = data; 
            {
                int data = *pointer;
                printIntLine(data);
            }
        }
"
3686,0,CWE401_Memory_Leak__char_calloc_72a.cpp,"    char * data;
    vector<char *> dataVector;
    data = NULL;
    
    data = (char *)calloc(100, sizeof(char));
    if (data == NULL) {exit(-1);}
    
    strcpy(data, ""A String"");
    printLine(data);
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
3,0,CWE190_Integer_Overflow__int_rand_preinc_41.c,"    int data;
    
    data = 0;
    
    data = RAND32();
"
985,0,CWE457_Use_of_Uninitialized_Variable__int_array_alloca_no_init_15.c,"    int * data;
    data = (int *)ALLOCA(10*sizeof(int));
    switch(6)
    {
    case 6:
        
        ; 
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
        
    {
        int i;
        for(i=0; i<10; i++)
        {
            printIntLine(data[i]);
        }
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
3033,0,CWE415_Double_Free__new_delete_array_int64_t_72a.cpp,"    int64_t * data;
    vector<int64_t *> dataVector;
    
    data = NULL;
    data = new int64_t[100];
    
    delete [] data;
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
8602,0,CWE590_Free_Memory_Not_on_Heap__delete_array_int64_t_declare_41.cpp,"    int64_t * data;
    data = NULL; 
    {
        
        int64_t dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5LL;
            }
        }
        data = dataBuffer;
    }
"
5234,0,CWE590_Free_Memory_Not_on_Heap__delete_class_declare_12.cpp,"    TwoIntsClass * data;
    data = NULL; 
    if(globalReturnsTrueOrFalse())
    {
        {
            
            TwoIntsClass dataBuffer;
            dataBuffer.intOne = 1;
            dataBuffer.intTwo = 1;
            data = &dataBuffer;
        }
    }
    else
    {
        {
            
            TwoIntsClass * dataBuffer = new TwoIntsClass;
            dataBuffer->intOne = 2;
            dataBuffer->intTwo = 2;
            data = dataBuffer;
        }
    }
    printIntLine(data->intOne);
    
"
13602,0,CWE690_NULL_Deref_From_Return__int64_t_calloc_62a.cpp,"    int64_t * data;
    data = NULL; 
    badSource(data);
    
    data[0] = 5LL;
    printLongLongLine(data[0]);
"
5792,0,CWE190_Integer_Overflow__short_rand_add_74a.cpp,"    short data;
    map<int, short> dataMap;
    data = 0;
    
    data = (short)RAND32();
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
13207,0,CWE416_Use_After_Free__new_delete_array_struct_06.cpp,"    twoIntsStruct * data;
    
    data = NULL;
    if(STATIC_CONST_FIVE==5)
    {
        data = new twoIntsStruct[100];
        {
            size_t i;
            for(i = 0; i < 100; i++)
            {
                data[i].intOne = 1;
                data[i].intTwo = 2;
            }
        }
        
        delete [] data;
    }
    if(STATIC_CONST_FIVE==5)
    {
        
        printStructLine(&data[0]);
        
"
2080,0,CWE369_Divide_by_Zero__int_rand_modulo_03.c,"    int data;
    
    data = -1;
    if(5==5)
    {
        
        data = RAND32();
    }
    if(5==5)
    {
        
        printIntLine(100 % data);
"
100,0,CWE401_Memory_Leak__int_malloc_21.c,"    int * data;
    data = NULL;
    
    data = (int *)malloc(100*sizeof(int));
    if (data == NULL) {exit(-1);}
    
    data[0] = 5;
    printIntLine(data[0]);
    badStatic = 1; 
"
608,0,CWE401_Memory_Leak__new_array_TwoIntsClass_12.cpp,"    TwoIntsClass * data;
    data = NULL;
    if(globalReturnsTrueOrFalse())
    {
        
        data = new TwoIntsClass[100];
        
        data[0].intOne = 0;
        data[0].intTwo = 0;
        printIntLine(data[0].intOne);
        printIntLine(data[0].intTwo);
    }
    else
    {
        
        TwoIntsClass dataGoodBuffer[100];
        data = dataGoodBuffer;
        
        data[0].intOne = 0;
        data[0].intTwo = 0;
        printIntLine(data[0].intOne);
        printIntLine(data[0].intTwo);
    }
    if(globalReturnsTrueOrFalse())
    {
        
        ; 
    }
    else
    {
        
        delete[] data;
"
2298,0,CWE758_Undefined_Behavior__int_malloc_use_11.c,"    if(globalReturnsTrue())
    {
        {
            int * pointer = (int *)malloc(sizeof(int));
            if (pointer == NULL) {exit(-1);}
            int data = *pointer; 
            free(pointer);
            printIntLine(data);
        }
"
1907,0,CWE563_Unused_Variable__unused_init_variable_int_04.c,"    int data;
    
    data = 5;
    if(STATIC_CONST_TRUE)
    {
        
        
        ; 
"
116,0,CWE78_OS_Command_Injection__char_environment_system_21.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    badStatic = 1; 
    data = badSource(data);
    
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
"
8002,0,CWE252_Unchecked_Return_Value__char_remove_03.c,"    if(5==5)
    {
        
        REMOVE(""removemebad.txt"");
"
11358,1,CWE758_Undefined_Behavior__char_pointer_new_use_08.cpp,"    if(staticReturnsFalse())
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            char * data;
            data = ""string"";
            char * * pointer = new char *;
            *pointer = data; 
            {
                char * data = *pointer;
                printLine(data);
            }
            delete pointer;
        }
"
6340,0,CWE416_Use_After_Free__new_delete_array_long_13.cpp,"    long * data;
    
    data = NULL;
    if(GLOBAL_CONST_FIVE==5)
    {
        data = new long[100];
        {
            size_t i;
            for(i = 0; i < 100; i++)
            {
                data[i] = 5L;
            }
        }
        
        delete [] data;
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        
        printLongLine(data[0]);
        
"
3315,0,CWE197_Numeric_Truncation_Error__int_fgets_to_short_64a.c,"    int data;
    
    data = -1;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
"
3273,0,CWE789_Uncontrolled_Mem_Alloc__new_char_rand_43.cpp,"    size_t data;
    
    data = 0;
    badSource(data);
    {
        char * myString;
        /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
         * for the strcpy() function to not cause a buffer overflow */
        
        if (data > strlen(HELLO_STRING))
        {
            myString = new char[data];
            
            strcpy(myString, HELLO_STRING);
            printLine(myString);
            delete [] myString;
        }
        else
        {
            printLine(""Input is less than the length of the source string"");
        }
"
2339,0,CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_68a.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_68_badData = data;
"
16845,0,CWE690_NULL_Deref_From_Return__int_calloc_32.c,"    int * data;
    int * *dataPtr1 = &data;
    int * *dataPtr2 = &data;
    data = NULL; 
    {
        int * data = *dataPtr1;
        
        data = (int *)calloc(1, sizeof(int));
        *dataPtr1 = data;
    }
    {
        int * data = *dataPtr2;
        
        data[0] = 5;
        printIntLine(data[0]);
        free(data);
"
11534,0,CWE415_Double_Free__new_delete_class_04.cpp,"    TwoIntsClass * data;
    
    data = NULL;
    if(STATIC_CONST_TRUE)
    {
        data = new TwoIntsClass;
        
        delete data;
    }
    if(STATIC_CONST_TRUE)
    {
        
        delete data;
"
11937,0,CWE415_Double_Free__new_delete_class_63a.cpp,"    TwoIntsClass * data;
    
    data = NULL;
    data = new TwoIntsClass;
    
    delete data;
"
7966,0,CWE590_Free_Memory_Not_on_Heap__delete_array_int_declare_01.cpp,"    int * data;
    data = NULL; 
    {
        
        int dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5;
            }
        }
        data = dataBuffer;
    }
    printIntLine(data[0]);
    
"
15347,1,CWE252_Unchecked_Return_Value__char_fputc_13.c,"    if(GLOBAL_CONST_FIVE!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        
        if (fputc((int)'A', stdout) == EOF)
        {
            printLine(""fputc failed!"");
        }
"
9237,0,CWE190_Integer_Overflow__char_fscanf_add_74a.cpp,"    char data;
    map<int, char> dataMap;
    data = ' ';
    
    fscanf (stdin, ""%c"", &data);
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
13262,0,CWE190_Integer_Overflow__int_connect_socket_multiply_22a.c,"    int data;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    CWE190_Integer_Overflow__int_connect_socket_multiply_22_badGlobal = 1; 
"
14502,0,CWE190_Integer_Overflow__int_rand_square_21.c,"    int data;
    
    data = 0;
    
    data = RAND32();
    badStatic = 1; 
"
4266,0,CWE401_Memory_Leak__new_int_12.cpp,"    int * data;
    data = NULL;
    if(globalReturnsTrueOrFalse())
    {
        
        data = new int;
        
        *data = 5;
        printIntLine(*data);
    }
    else
    {
        
        int dataGoodBuffer;
        data = &dataGoodBuffer;
        
        *data = 5;
        printIntLine(*data);
    }
    if(globalReturnsTrueOrFalse())
    {
        
        ; 
    }
    else
    {
        
        delete data;
"
7771,0,CWE590_Free_Memory_Not_on_Heap__delete_int_placement_new_16.cpp,"    int * data;
    data = NULL; 
    while(1)
    {
        {
            
            char buffer[sizeof(int)];
            int * dataBuffer = new(buffer) int;
            *dataBuffer = 5;
            data = dataBuffer;
        }
        break;
    }
    printIntLine(*data);
    
"
814,0,CWE190_Integer_Overflow__int_fscanf_preinc_44.c,"    int data;
    
    void (*funcPtr) (int) = badSink;
    
    data = 0;
    
    fscanf(stdin, ""%d"", &data);
    
"
8243,0,CWE415_Double_Free__malloc_free_int64_t_54a.c,"    int64_t * data;
    
    data = NULL;
    data = (int64_t *)malloc(100*sizeof(int64_t));
    if (data == NULL) {exit(-1);}
    
    free(data);
"
2871,0,CWE590_Free_Memory_Not_on_Heap__delete_array_class_alloca_72a.cpp,"    TwoIntsClass * data;
    vector<TwoIntsClass *> dataVector;
    data = NULL; 
    {
        
        TwoIntsClass * dataBuffer = (TwoIntsClass *)ALLOCA(100*sizeof(TwoIntsClass));
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i].intOne = 1;
                dataBuffer[i].intTwo = 1;
            }
        }
        data = dataBuffer;
    }
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
19308,0,CWE197_Numeric_Truncation_Error__int_listen_socket_to_short_16.c,"    int data;
    
    data = -1;
    while(1)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
        break;
    }
    {
        
        short shortData = (short)data;
        printShortLine(shortData);
"
4239,0,CWE457_Use_of_Uninitialized_Variable__int_array_alloca_no_init_43.cpp,"    int * data;
    data = (int *)ALLOCA(10*sizeof(int));
    badSource(data);
    
    {
        int i;
        for(i=0; i<10; i++)
        {
            printIntLine(data[i]);
        }
"
6861,0,CWE197_Numeric_Truncation_Error__int_fscanf_to_char_15.c,"    int data;
    
    data = -1;
    switch(6)
    {
    case 6:
        
        fscanf(stdin, ""%d"", &data);
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
10691,0,CWE690_NULL_Deref_From_Return__long_malloc_52a.c,"    long * data;
    data = NULL; 
    
    data = (long *)malloc(1*sizeof(long));
"
528,0,CWE401_Memory_Leak__struct_twoIntsStruct_malloc_61a.c,"    struct _twoIntsStruct * data;
    data = NULL;
    data = CWE401_Memory_Leak__struct_twoIntsStruct_malloc_61b_badSource(data);
    
"
2999,0,CWE401_Memory_Leak__new_array_char_05.cpp,"    char * data;
    data = NULL;
    if(staticTrue)
    {
        
        data = new char[100];
        
        strcpy(data, ""A String"");
        printLine(data);
    }
    if(staticTrue)
    {
        
        ; 
"
13115,0,CWE401_Memory_Leak__twoIntsStruct_realloc_03.c,"    twoIntsStruct * data;
    data = NULL;
    if(5==5)
    {
        
        data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));
        if (data == NULL) {exit(-1);}
        
        data[0].intOne = 0;
        data[0].intTwo = 0;
        printStructLine(&data[0]);
    }
    if(5==5)
    {
        
        ; 
"
8914,0,CWE190_Integer_Overflow__int64_t_fscanf_square_10.c,"    int64_t data;
    data = 0LL;
    if(globalTrue)
    {
        
        fscanf (stdin, ""%"" SCNd64, &data);
    }
    if(globalTrue)
    {
        {
            
            int64_t result = data * data;
            printLongLongLine(result);
        }
"
19444,0,CWE78_OS_Command_Injection__char_listen_socket_popen_06.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(STATIC_CONST_FIVE==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                data[dataLen + recvResult / sizeof(char)] = '\0';
                
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    {
        FILE *pipe;
        
        pipe = POPEN(data, ""w"");
        if (pipe != NULL)
        {
            PCLOSE(pipe);
        }
"
12248,0,CWE690_NULL_Deref_From_Return__int64_t_malloc_05.c,"    int64_t * data;
    data = NULL; 
    
    data = (int64_t *)malloc(1*sizeof(int64_t));
    if(staticTrue)
    {
        
        data[0] = 5LL;
        printLongLongLine(data[0]);
        free(data);
"
11101,0,CWE415_Double_Free__new_delete_array_struct_08.cpp,"    twoIntsStruct * data;
    
    data = NULL;
    if(staticReturnsTrue())
    {
        data = new twoIntsStruct[100];
        
        delete [] data;
    }
    if(staticReturnsTrue())
    {
        
        delete [] data;
"
1051,0,CWE401_Memory_Leak__int64_t_realloc_63a.c,"    int64_t * data;
    data = NULL;
    
    data = (int64_t *)realloc(data, 100*sizeof(int64_t));
    if (data == NULL) {exit(-1);}
    
    data[0] = 5LL;
    printLongLongLine(data[0]);
"
2158,0,CWE401_Memory_Leak__twoIntsStruct_realloc_04.c,"    twoIntsStruct * data;
    data = NULL;
    if(STATIC_CONST_TRUE)
    {
        
        data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));
        if (data == NULL) {exit(-1);}
        
        data[0].intOne = 0;
        data[0].intTwo = 0;
        printStructLine(&data[0]);
    }
    if(STATIC_CONST_TRUE)
    {
        
        ; 
"
10872,0,CWE190_Integer_Overflow__int_max_square_43.cpp,"    int data;
    
    data = 0;
    badSource(data);
    {
        
        int result = data * data;
        printIntLine(result);
"
7516,0,CWE758_Undefined_Behavior__class_new_use_10.cpp,"    if(globalTrue)
    {
        {
            TwoIntsClass * pointer = new TwoIntsClass;
            TwoIntsClass data = *pointer; 
            delete pointer;
            printIntLine(data.intOne);
            printIntLine(data.intTwo);
        }
"
7073,0,CWE369_Divide_by_Zero__int_connect_socket_modulo_84a.cpp,"    int data;
    
    data = -1;
    CWE369_Divide_by_Zero__int_connect_socket_modulo_84_bad * badObject = new CWE369_Divide_by_Zero__int_connect_socket_modulo_84_bad(data);
"
3269,0,CWE457_Use_of_Uninitialized_Variable__twointsclass_array_malloc_no_init_11.cpp,"    TwoIntsClass * data;
    data = reinterpret_cast<TwoIntsClass *>(malloc(10*sizeof(TwoIntsClass)));
    if (data == NULL) {exit(-1);}
    if(globalReturnsTrue())
    {
        
        ; 
    }
    if(globalReturnsTrue())
    {
        
        for(int i=0; i<10; i++)
        {
            printIntLine(data[i].intOne);
            printIntLine(data[i].intTwo);
        }
"
4808,1,CWE252_Unchecked_Return_Value__char_rename_05.c,"    if(staticFalse)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        
        if (RENAME(OLD_GOOD_FILE_NAME, ""newgoodfilename.txt"") != 0)
        {
            printLine(""rename failed!"");
        }
"
16068,0,CWE190_Integer_Overflow__short_rand_add_11.c,"    short data;
    data = 0;
    if(globalReturnsTrue())
    {
        
        data = (short)RAND32();
    }
    if(globalReturnsTrue())
    {
        {
            
            short result = data + 1;
            printIntLine(result);
        }
"
5426,0,CWE457_Use_of_Uninitialized_Variable__struct_array_declare_partial_init_17.c,"    int i,j;
    twoIntsStruct * data;
    twoIntsStruct dataUninitArray[10];
    data = dataUninitArray;
    for(i = 0; i < 1; i++)
    {
        
        {
            int i;
            for(i=0; i<(10/2); i++)
            {
                data[i].intOne = i;
                data[i].intTwo = i;
            }
        }
    }
    for(j = 0; j < 1; j++)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i].intOne);
                printIntLine(data[i].intTwo);
            }
        }
"
3136,1,CWE758_Undefined_Behavior__char_malloc_use_01.c,"    {
        char data;
        char * pointer = (char *)malloc(sizeof(char));
        if (pointer == NULL) {exit(-1);}
        data = 5;
        *pointer = data; 
        {
            char data = *pointer;
            printHexCharLine(data);
        }
        free(pointer);
"
5192,0,CWE590_Free_Memory_Not_on_Heap__free_int_declare_81_bad.cpp,"Label Definition File: CWE590_Free_Memory_Not_on_Heap__free.label.xml
Template File: sources-sink-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 590 Free Memory Not on Heap
 * BadSource: declare Data buffer is declared on the stack
 * GoodSource: Allocate memory on the heap
 * Sinks:
 *    BadSink : Print then free data
 * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE590_Free_Memory_Not_on_Heap__free_int_declare_81.h""

namespace CWE590_Free_Memory_Not_on_Heap__free_int_declare_81
{

void CWE590_Free_Memory_Not_on_Heap__free_int_declare_81_bad::action(int * data) const
{
    printIntLine(data[0]);
    
    free(data);
}

}
"
15564,0,CWE401_Memory_Leak__int_calloc_62a.cpp,"    int * data;
    data = NULL;
    badSource(data);
    
"
11158,0,CWE401_Memory_Leak__char_realloc_03.c,"    char * data;
    data = NULL;
    if(5==5)
    {
        
        data = (char *)realloc(data, 100*sizeof(char));
        if (data == NULL) {exit(-1);}
        
        strcpy(data, ""A String"");
        printLine(data);
    }
    if(5==5)
    {
        
        ; 
"
8730,0,CWE590_Free_Memory_Not_on_Heap__free_char_static_51a.c,"    char * data;
    data = NULL; 
    {
        
        static char dataBuffer[100];
        memset(dataBuffer, 'A', 100-1); 
        dataBuffer[100-1] = '\0'; 
        data = dataBuffer;
    }
"
9627,0,CWE78_OS_Command_Injection__char_console_execl_02.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(1)
    {
        {
            
            size_t dataLen = strlen(data);
            
            if (100-dataLen > 1)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
                {
                    /* The next few lines remove the carriage return from the string that is
                     * inserted by fgets() */
                    dataLen = strlen(data);
"
15607,0,CWE401_Memory_Leak__new_twoIntsStruct_11.cpp,"    twoIntsStruct * data;
    data = NULL;
    if(globalReturnsTrue())
    {
        
        data = new twoIntsStruct;
        
        data->intOne = 0;
        data->intTwo = 0;
        printStructLine(data);
    }
    if(globalReturnsTrue())
    {
        
        ; 
"
1683,0,CWE369_Divide_by_Zero__float_connect_socket_52a.c,"    float data;
    
    data = 0.0F;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = (float)atof(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
16143,0,CWE416_Use_After_Free__malloc_free_struct_12.c,"    twoIntsStruct * data;
    
    data = NULL;
    if(globalReturnsTrueOrFalse())
    {
        data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
        if (data == NULL) {exit(-1);}
        {
            size_t i;
            for(i = 0; i < 100; i++)
            {
                data[i].intOne = 1;
                data[i].intTwo = 2;
            }
        }
        
        free(data);
    }
    else
    {
        data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
        if (data == NULL) {exit(-1);}
        {
            size_t i;
            for(i = 0; i < 100; i++)
            {
                data[i].intOne = 1;
                data[i].intTwo = 2;
            }
        }
        
    }
    if(globalReturnsTrueOrFalse())
    {
        
        printStructLine(&data[0]);
        
    }
    else
    {
        
        
        
        ; 
"
12616,0,CWE190_Integer_Overflow__short_fscanf_preinc_34.c,"    short data;
    CWE190_Integer_Overflow__short_fscanf_preinc_34_unionType myUnion;
    data = 0;
    
    fscanf (stdin, ""%hd"", &data);
    myUnion.unionFirst = data;
    {
        short data = myUnion.unionSecond;
        {
            
            ++data;
            short result = data;
            printIntLine(result);
        }
"
438,0,CWE401_Memory_Leak__strdup_char_10.c,"    char * data;
    data = NULL;
    if(globalTrue)
    {
        {
            char myString[] = ""myString"";
            
            data = strdup(myString);
            
            printLine(data);
        }
    }
    if(globalTrue)
    {
        
        
        ; 
"
16583,0,CWE197_Numeric_Truncation_Error__int_rand_to_short_04.c,"    int data;
    
    data = -1;
    if(STATIC_CONST_TRUE)
    {
        
        data = RAND32();
    }
    {
        
        short shortData = (short)data;
        printShortLine(shortData);
"
13129,0,CWE476_NULL_Pointer_Dereference__struct_68a.c,"    twoIntsStruct * data;
    
    data = NULL;
    CWE476_NULL_Pointer_Dereference__struct_68_badData = data;
"
2223,0,CWE401_Memory_Leak__char_realloc_63a.c,"    char * data;
    data = NULL;
    
    data = (char *)realloc(data, 100*sizeof(char));
    if (data == NULL) {exit(-1);}
    
    strcpy(data, ""A String"");
    printLine(data);
"
17137,0,CWE457_Use_of_Uninitialized_Variable__struct_array_declare_partial_init_08.c,"    twoIntsStruct * data;
    twoIntsStruct dataUninitArray[10];
    data = dataUninitArray;
    if(staticReturnsTrue())
    {
        
        {
            int i;
            for(i=0; i<(10/2); i++)
            {
                data[i].intOne = i;
                data[i].intTwo = i;
            }
        }
    }
    if(staticReturnsTrue())
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i].intOne);
                printIntLine(data[i].intTwo);
            }
        }
"
9744,1,CWE467_Use_of_sizeof_on_Pointer_Type__char_13.c,"    if(GLOBAL_CONST_FIVE==5)
    {
        {
            char * goodChar = NULL;
            
            goodChar = (char *)malloc(sizeof(*goodChar));
            if (goodChar == NULL) {exit(-1);}
            *goodChar = 'G';
            printHexCharLine(*goodChar);
            free(goodChar);
        }
"
7598,0,CWE401_Memory_Leak__twoIntsStruct_malloc_03.c,"    twoIntsStruct * data;
    data = NULL;
    if(5==5)
    {
        
        data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
        if (data == NULL) {exit(-1);}
        
        data[0].intOne = 0;
        data[0].intTwo = 0;
        printStructLine(&data[0]);
    }
    if(5==5)
    {
        
        ; 
"
15038,0,CWE457_Use_of_Uninitialized_Variable__new_struct_array_partial_init_17.cpp,"    int i,j;
    twoIntsStruct * data;
    data = new twoIntsStruct[10];
    for(i = 0; i < 1; i++)
    {
        
        {
            int i;
            for(i=0; i<(10/2); i++)
            {
                data[i].intOne = i;
                data[i].intTwo = i;
            }
        }
    }
    for(j = 0; j < 1; j++)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i].intOne);
                printIntLine(data[i].intTwo);
            }
        }
        
        delete [] data;
"
15660,0,CWE190_Integer_Overflow__short_rand_multiply_16.c,"    short data;
    data = 0;
    while(1)
    {
        
        data = (short)RAND32();
        break;
    }
    while(1)
    {
        if(data > 0) 
        {
            
            short result = data * 2;
            printIntLine(result);
        }
        break;
"
9870,0,CWE758_Undefined_Behavior__class_pointer_new_use_07.cpp,"    if(staticFive==5)
    {
        {
            TwoIntsClass * * pointer = new TwoIntsClass *;
            TwoIntsClass * data = *pointer; 
            delete pointer;
            printIntLine(data->intOne);
            printIntLine(data->intTwo);
        }
"
13848,0,CWE190_Integer_Overflow__int_connect_socket_multiply_63a.c,"    int data;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
868,0,CWE401_Memory_Leak__char_calloc_62a.cpp,"    char * data;
    data = NULL;
    badSource(data);
    
"
11030,0,CWE690_NULL_Deref_From_Return__int_realloc_43.cpp,"    int * data;
    data = NULL; 
    badSource(data);
    
    data[0] = 5;
    printIntLine(data[0]);
"
13169,0,CWE401_Memory_Leak__new_array_struct_twoIntsStruct_14.cpp,"    struct _twoIntsStruct * data;
    data = NULL;
    if(globalFive==5)
    {
        
        data = new struct _twoIntsStruct[100];
        
        data[0].intOne = 0;
        data[0].intTwo = 0;
        printStructLine((twoIntsStruct *)&data[0]);
    }
    if(globalFive==5)
    {
        
        ; 
"
15657,0,CWE190_Integer_Overflow__char_max_add_73a.cpp,"    char data;
    list<char> dataList;
    data = ' ';
    
    data = CHAR_MAX;
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
7863,1,CWE758_Undefined_Behavior__int_pointer_malloc_use_10.c,"    if(globalTrue)
    {
        {
            int * data;
            int * * pointer = (int * *)malloc(sizeof(int *));
            if (pointer == NULL) {exit(-1);}
            
            data = (int *)malloc(sizeof(int));
            if (data == NULL) {exit(-1);}
            *data = 5;
            *pointer = data; 
            {
                int * data = *pointer;
                printIntLine(*data);
            }
            free(pointer);
        }
"
13387,0,CWE416_Use_After_Free__new_delete_array_long_12.cpp,"    long * data;
    
    data = NULL;
    if(globalReturnsTrueOrFalse())
    {
        data = new long[100];
        {
            size_t i;
            for(i = 0; i < 100; i++)
            {
                data[i] = 5L;
            }
        }
        
        delete [] data;
    }
    else
    {
        data = new long[100];
        {
            size_t i;
            for(i = 0; i < 100; i++)
            {
                data[i] = 5L;
            }
        }
        
    }
    if(globalReturnsTrueOrFalse())
    {
        
        printLongLine(data[0]);
        
    }
    else
    {
        
        
        
        ; 
"
1551,0,CWE590_Free_Memory_Not_on_Heap__delete_array_char_static_05.cpp,"    char * data;
    data = NULL; 
    if(staticTrue)
    {
        {
            
            static char dataBuffer[100];
            memset(dataBuffer, 'A', 100-1); 
            dataBuffer[100-1] = '\0'; 
            data = dataBuffer;
        }
    }
    printLine(data);
    
"
6884,0,CWE590_Free_Memory_Not_on_Heap__delete_long_static_02.cpp,"    long * data;
    data = NULL; 
    if(1)
    {
        {
            
            static long dataBuffer;
            dataBuffer = 5L;
            data = &dataBuffer;
        }
    }
    printLongLine(*data);
    
"
8047,0,CWE190_Integer_Overflow__int64_t_max_multiply_32.c,"    int64_t data;
    int64_t *dataPtr1 = &data;
    int64_t *dataPtr2 = &data;
    data = 0LL;
    {
        int64_t data = *dataPtr1;
        
        data = LLONG_MAX;
        *dataPtr1 = data;
    }
    {
        int64_t data = *dataPtr2;
        if(data > 0) 
        {
            
            int64_t result = data * 2;
            printLongLongLine(result);
        }
"
19043,0,CWE457_Use_of_Uninitialized_Variable__double_array_declare_no_init_04.c,"    double * data;
    double dataUninitArray[10];
    data = dataUninitArray;
    if(STATIC_CONST_TRUE)
    {
        
        ; 
    }
    if(STATIC_CONST_TRUE)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printDoubleLine(data[i]);
            }
        }
"
2888,1,CWE758_Undefined_Behavior__char_malloc_use_06.c,"    if(STATIC_CONST_FIVE!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            char data;
            char * pointer = (char *)malloc(sizeof(char));
            if (pointer == NULL) {exit(-1);}
            data = 5;
            *pointer = data; 
            {
                char data = *pointer;
                printHexCharLine(data);
            }
            free(pointer);
        }
"
13269,0,CWE476_NULL_Pointer_Dereference__int_22a.c,"    int * data;
    
    data = NULL;
    CWE476_NULL_Pointer_Dereference__int_22_badGlobal = 1; 
"
19404,0,CWE590_Free_Memory_Not_on_Heap__delete_array_struct_declare_31.cpp,"    twoIntsStruct * data;
    data = NULL; 
    {
        
        twoIntsStruct dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i].intOne = 1;
                dataBuffer[i].intTwo = 1;
            }
        }
        data = dataBuffer;
    }
    {
        twoIntsStruct * dataCopy = data;
        twoIntsStruct * data = dataCopy;
        printStructLine(&data[0]);
        
        delete [] data;
"
3834,0,CWE590_Free_Memory_Not_on_Heap__free_int64_t_declare_68a.c,"    int64_t * data;
    data = NULL; 
    {
        
        int64_t dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5LL;
            }
        }
        data = dataBuffer;
    }
    CWE590_Free_Memory_Not_on_Heap__free_int64_t_declare_68_badData = data;
"
11202,0,CWE190_Integer_Overflow__int_listen_socket_square_11.c,"    int data;
    
    data = 0;
    if(globalReturnsTrue())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(globalReturnsTrue())
    {
        {
            
            int result = data * data;
            printIntLine(result);
        }
"
19052,0,CWE252_Unchecked_Return_Value__char_fwrite_10.c,"    if(globalTrue)
    {
        
        fwrite((char *)""string"", sizeof(char), strlen(""string""), stdout);
"
6278,0,CWE190_Integer_Overflow__char_fscanf_postinc_65a.c,"    char data;
    
    void (*funcPtr) (char) = CWE190_Integer_Overflow__char_fscanf_postinc_65b_badSink;
    data = ' ';
    
    fscanf (stdin, ""%c"", &data);
    
"
17071,0,CWE415_Double_Free__malloc_free_char_81a.cpp,"    char * data;
    
    data = NULL;
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    
    free(data);
    const CWE415_Double_Free__malloc_free_char_81_base& baseObject = CWE415_Double_Free__malloc_free_char_81_bad();
"
14260,0,CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_73a.cpp,"    size_t data;
    list<size_t> dataList;
    
    data = 0;
    
    fscanf(stdin, ""%zu"", &data);
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
1705,0,CWE369_Divide_by_Zero__float_fscanf_04.c,"    float data;
    
    data = 0.0F;
    if(STATIC_CONST_TRUE)
    {
        
        fscanf (stdin, ""%f"", &data);
    }
    if(STATIC_CONST_TRUE)
    {
        {
            
            int result = (int)(100.0 / data);
            printIntLine(result);
        }
"
14793,0,CWE590_Free_Memory_Not_on_Heap__delete_int64_t_placement_new_09.cpp,"    int64_t * data;
    data = NULL; 
    if(GLOBAL_CONST_TRUE)
    {
        {
            
            char buffer[sizeof(int64_t)];
            int64_t * dataBuffer = new(buffer) int64_t;
            *dataBuffer = 5LL;
            data = dataBuffer;
        }
    }
    printLongLongLine(*data);
    
"
8445,0,CWE789_Uncontrolled_Mem_Alloc__new_char_rand_67a.cpp,"    size_t data;
    structType myStruct;
    
    data = 0;
    
    data = rand();
    myStruct.structFirst = data;
"
7313,0,CWE190_Integer_Overflow__char_rand_square_82_bad.cpp,"Label Definition File: CWE190_Integer_Overflow.label.xml
Template File: sources-sinks-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 190 Integer Overflow
 * BadSource: rand Set data to result of rand()
 * GoodSource: Set data to a small, non-zero number (two)
 * Sinks: square
 *    GoodSink: Ensure there will not be an overflow before squaring data
 *    BadSink : Square data, which can lead to overflow
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE190_Integer_Overflow__char_rand_square_82.h""

#include <math.h>

namespace CWE190_Integer_Overflow__char_rand_square_82
{

void CWE190_Integer_Overflow__char_rand_square_82_bad::action(char data)
{
    {
        
        char result = data * data;
        printHexCharLine(result);
    }
}

}
"
3306,0,CWE190_Integer_Overflow__int_connect_socket_postinc_07.c,"    int data;
    
    data = 0;
    if(staticFive==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(staticFive==5)
    {
        {
            
            data++;
            int result = data;
            printIntLine(result);
        }
"
9377,0,CWE252_Unchecked_Return_Value__char_snprintf_15.c,"    switch(6)
    {
    case 6:
    {
        /* By initializing dataBuffer, we ensure this will not be the
         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
        char dataBuffer[100] = """";
        char * data = dataBuffer;
        
        SNPRINTF(data,100-strlen(SRC)-1, ""%s\n"", SRC);
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
19044,0,CWE78_OS_Command_Injection__char_console_execl_18.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    goto source;
source:
    {
        
        size_t dataLen = strlen(data);
        
        if (100-dataLen > 1)
        {
            
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgets() */
                dataLen = strlen(data);
"
5133,0,CWE401_Memory_Leak__char_calloc_12.c,"    char * data;
    data = NULL;
    if(globalReturnsTrueOrFalse())
    {
        
        data = (char *)calloc(100, sizeof(char));
        if (data == NULL) {exit(-1);}
        
        strcpy(data, ""A String"");
        printLine(data);
    }
    else
    {
        
        data = (char *)ALLOCA(100*sizeof(char));
        
        strcpy(data, ""A String"");
        printLine(data);
    }
    if(globalReturnsTrueOrFalse())
    {
        
        ; 
    }
    else
    {
        
        free(data);
"
4610,0,CWE590_Free_Memory_Not_on_Heap__free_int64_t_declare_04.c,"    int64_t * data;
    data = NULL; 
    if(STATIC_CONST_TRUE)
    {
        {
            
            int64_t dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5LL;
                }
            }
            data = dataBuffer;
        }
    }
    printLongLongLine(data[0]);
    
"
18343,0,CWE78_OS_Command_Injection__char_console_execlp_17.c,"    int i;
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    for(i = 0; i < 1; i++)
    {
        {
            
            size_t dataLen = strlen(data);
            
            if (100-dataLen > 1)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
                {
                    /* The next few lines remove the carriage return from the string that is
                     * inserted by fgets() */
"
9954,0,CWE415_Double_Free__new_delete_struct_42.cpp,"    twoIntsStruct * data;
    
    data = NULL;
    data = badSource(data);
    
"
17582,0,CWE690_NULL_Deref_From_Return__char_realloc_84_bad.cpp,"Label Definition File: CWE690_NULL_Deref_From_Return.free.label.xml
Template File: source-sinks-84_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 690 Unchecked Return Value To NULL Pointer
 * BadSource: realloc Allocate data using realloc()
 * Sinks:
 *    GoodSink: Check to see if the data allocation failed and if not, use data
 *    BadSink : Don't check for NULL and use data
 * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE690_NULL_Deref_From_Return__char_realloc_84.h""

namespace CWE690_NULL_Deref_From_Return__char_realloc_84
{
CWE690_NULL_Deref_From_Return__char_realloc_84_bad::CWE690_NULL_Deref_From_Return__char_realloc_84_bad(char * dataCopy)
{
    data = dataCopy;
    
    data = (char *)realloc(data, 20*sizeof(char));
}

CWE690_NULL_Deref_From_Return__char_realloc_84_bad::~CWE690_NULL_Deref_From_Return__char_realloc_84_bad()
{
    
    strcpy(data, ""Initialize"");
    printLine(data);
    free(data);
}
}
"
6909,0,CWE190_Integer_Overflow__short_max_postinc_51a.c,"    short data;
    data = 0;
    
    data = SHRT_MAX;
"
17983,0,CWE563_Unused_Variable__unused_init_variable_char_01.c,"    char data;
    
    data = 'C';
    
    
"
14046,0,CWE415_Double_Free__new_delete_array_int64_t_63a.cpp,"    int64_t * data;
    
    data = NULL;
    data = new int64_t[100];
    
    delete [] data;
"
10845,0,CWE190_Integer_Overflow__int_listen_socket_square_51a.c,"    int data;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
3585,0,CWE190_Integer_Overflow__int_fgets_postinc_01.c,"    int data;
    
    data = 0;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    {
        
        data++;
        int result = data;
        printIntLine(result);
"
12356,0,CWE690_NULL_Deref_From_Return__struct_calloc_22a.c,"    twoIntsStruct * data;
    data = NULL; 
    
    data = (twoIntsStruct *)calloc(1, sizeof(twoIntsStruct));
    CWE690_NULL_Deref_From_Return__struct_calloc_22_badGlobal = 1; 
"
13080,0,CWE190_Integer_Overflow__int_listen_socket_multiply_16.c,"    int data;
    
    data = 0;
    while(1)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
        break;
    }
    while(1)
    {
        if(data > 0) 
        {
            
            int result = data * 2;
            printIntLine(result);
        }
        break;
"
11639,0,CWE190_Integer_Overflow__int64_t_fscanf_square_14.c,"    int64_t data;
    data = 0LL;
    if(globalFive==5)
    {
        
        fscanf (stdin, ""%"" SCNd64, &data);
    }
    if(globalFive==5)
    {
        {
            
            int64_t result = data * data;
            printLongLongLine(result);
        }
"
19335,0,CWE190_Integer_Overflow__int_max_preinc_12.c,"    int data;
    
    data = 0;
    if(globalReturnsTrueOrFalse())
    {
        
        data = INT_MAX;
    }
    else
    {
        
        data = 2;
    }
    if(globalReturnsTrueOrFalse())
    {
        {
            
            ++data;
            int result = data;
            printIntLine(result);
        }
    }
    else
    {
        
        if (data < INT_MAX)
        {
            ++data;
            int result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
"
16494,0,CWE78_OS_Command_Injection__char_connect_socket_system_82a.cpp,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    CWE78_OS_Command_Injection__char_connect_socket_system_82_base* baseObject = new CWE78_OS_Command_Injection__char_connect_socket_system_82_bad;
    baseObject->action(data);
"
10051,0,CWE190_Integer_Overflow__int_max_multiply_21.c,"    int data;
    
    data = 0;
    
    data = INT_MAX;
    badStatic = 1; 
"
8750,0,CWE401_Memory_Leak__int64_t_calloc_54a.c,"    int64_t * data;
    data = NULL;
    
    data = (int64_t *)calloc(100, sizeof(int64_t));
    if (data == NULL) {exit(-1);}
    
    data[0] = 5LL;
    printLongLongLine(data[0]);
"
8970,0,CWE758_Undefined_Behavior__int_pointer_new_use_03.cpp,"    if(5==5)
    {
        {
            int * * pointer = new int *;
            int * data = *pointer; 
            delete pointer;
            printIntLine(*data);
        }
"
13180,0,CWE190_Integer_Overflow__int_fscanf_preinc_45.c,"    int data;
    
    data = 0;
    
    fscanf(stdin, ""%d"", &data);
    CWE190_Integer_Overflow__int_fscanf_preinc_45_badData = data;
"
3632,0,CWE590_Free_Memory_Not_on_Heap__free_int_static_13.c,"    int * data;
    data = NULL; 
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            
            static int dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5;
                }
            }
            data = dataBuffer;
        }
    }
    printIntLine(data[0]);
    
"
7859,0,CWE369_Divide_by_Zero__int_listen_socket_modulo_44.c,"    int data;
    
    void (*funcPtr) (int) = badSink;
    
    data = -1;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
"
7226,0,CWE590_Free_Memory_Not_on_Heap__delete_array_class_declare_81a.cpp,"    TwoIntsClass * data;
    data = NULL; 
    {
        
        TwoIntsClass dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i].intOne = 1;
                dataBuffer[i].intTwo = 1;
            }
        }
        data = dataBuffer;
    }
    const CWE590_Free_Memory_Not_on_Heap__delete_array_class_declare_81_base& baseObject = CWE590_Free_Memory_Not_on_Heap__delete_array_class_declare_81_bad();
"
18400,1,CWE252_Unchecked_Return_Value__char_fwrite_14.c,"    if(globalFive!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        
        if (fwrite((char *)""string"", sizeof(char), strlen(""string""), stdout) != strlen(""string""))
        {
            printLine(""fwrite failed!"");
        }
"
9789,0,CWE134_Uncontrolled_Format_String__char_file_vprintf_22a.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        FILE * pFile;
        
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
    CWE134_Uncontrolled_Format_String__char_file_vprintf_22_badGlobal = 1; 
"
15972,1,CWE401_Memory_Leak__malloc_realloc_twoIntsStruct_14.c,"    if(globalFive!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            twoIntsStruct * data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
            if (data == NULL) {exit(-1);}
            twoIntsStruct * tmpData;
            
            data[0].intOne = 0;
            data[0].intTwo = 0;
            printStructLine(&data[0]);
            tmpData = (twoIntsStruct *)realloc(data, (130000)*sizeof(twoIntsStruct));
            /* FIX: Ensure realloc() was successful before assigning data to the memory block
            * allocated with realloc() */
            if (tmpData != NULL)
            {
                data = tmpData;
                
                data[0].intOne = 1;
                data[0].intTwo = 1;
                printStructLine(&data[0]);
            }
            free(data);
        }
"
2256,0,CWE190_Integer_Overflow__char_rand_square_10.c,"    char data;
    data = ' ';
    if(globalTrue)
    {
        
        data = (char)RAND32();
    }
    if(globalTrue)
    {
        {
            
            char result = data * data;
            printHexCharLine(result);
        }
"
12724,0,CWE401_Memory_Leak__char_calloc_01.c,"    char * data;
    data = NULL;
    
    data = (char *)calloc(100, sizeof(char));
    if (data == NULL) {exit(-1);}
    
    strcpy(data, ""A String"");
    printLine(data);
    
"
18998,0,CWE590_Free_Memory_Not_on_Heap__delete_class_placement_new_06.cpp,"    TwoIntsClass * data;
    data = NULL; 
    if(STATIC_CONST_FIVE==5)
    {
        {
            
            char buffer[sizeof(TwoIntsClass)];
            TwoIntsClass * dataBuffer = new(buffer) TwoIntsClass;
            dataBuffer->intOne = 2;
            dataBuffer->intTwo = 2;
            data = dataBuffer;
        }
    }
    printIntLine(data->intOne);
    
"
10844,0,CWE369_Divide_by_Zero__int_rand_modulo_16.c,"    int data;
    
    data = -1;
    while(1)
    {
        
        data = RAND32();
        break;
    }
    while(1)
    {
        
        printIntLine(100 % data);
        break;
"
4196,0,CWE690_NULL_Deref_From_Return__int64_t_calloc_18.c,"    int64_t * data;
    data = NULL; 
    
    data = (int64_t *)calloc(1, sizeof(int64_t));
    goto sink;
sink:
    
    data[0] = 5LL;
    printLongLongLine(data[0]);
"
7199,0,CWE401_Memory_Leak__malloc_realloc_int_17.c,"    int j;
    for(j = 0; j < 1; j++)
    {
        {
            int * data = (int *)malloc(100*sizeof(int));
            if (data == NULL) {exit(-1);}
            
            data[0] = 5;
            printIntLine(data[0]);
            
            data = (int *)realloc(data, (130000)*sizeof(int));
            if (data != NULL)
            {
                
                data[0] = 10;
                printIntLine(data[0]);
                free(data);
            }
        }
"
9284,1,CWE758_Undefined_Behavior__class_new_use_05.cpp,"    if(staticFalse)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            TwoIntsClass data;
            data.intOne = 1;
            data.intTwo = 2;
            TwoIntsClass * pointer = new TwoIntsClass;
            *pointer = data; 
            {
                TwoIntsClass data = *pointer;
                printIntLine(data.intOne);
                printIntLine(data.intTwo);
            }
            delete pointer;
        }
"
2996,0,CWE190_Integer_Overflow__char_max_square_21.c,"    char data;
    data = ' ';
    
    data = CHAR_MAX;
    badStatic = 1; 
"
1603,0,CWE190_Integer_Overflow__int64_t_max_preinc_53a.c,"    int64_t data;
    data = 0LL;
    
    data = LLONG_MAX;
"
8056,0,CWE563_Unused_Variable__unused_init_variable_struct_84a.cpp,"    twoIntsStruct data;
    CWE563_Unused_Variable__unused_init_variable_struct_84_bad * badObject = new CWE563_Unused_Variable__unused_init_variable_struct_84_bad(data);
"
917,0,CWE190_Integer_Overflow__int64_t_rand_postinc_42.c,"    int64_t data;
    data = 0LL;
    data = badSource(data);
    {
        
        data++;
        int64_t result = data;
        printLongLongLine(result);
"
11990,0,CWE190_Integer_Overflow__int_connect_socket_square_16.c,"    int data;
    
    data = 0;
    while(1)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
        break;
    }
    while(1)
    {
        {
            
            int result = data * data;
            printIntLine(result);
        }
        break;
"
9261,0,CWE78_OS_Command_Injection__char_connect_socket_execl_68a.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    CWE78_OS_Command_Injection__char_connect_socket_execl_68_badData = data;
"
137,0,CWE457_Use_of_Uninitialized_Variable__twointsclass_array_alloca_partial_init_15.cpp,"    TwoIntsClass * data;
    data = reinterpret_cast<TwoIntsClass *>(ALLOCA(10*sizeof(TwoIntsClass)));
    switch(6)
    {
    case 6:
        
        for(int i=0; i<(10/2); i++)
        {
            data[i].intOne = i;
            data[i].intTwo = i;
        }
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
        
        for(int i=0; i<10; i++)
        {
            printIntLine(data[i].intOne);
            printIntLine(data[i].intTwo);
        }
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
18028,0,CWE190_Integer_Overflow__short_rand_multiply_34.c,"    short data;
    CWE190_Integer_Overflow__short_rand_multiply_34_unionType myUnion;
    data = 0;
    
    data = (short)RAND32();
    myUnion.unionFirst = data;
    {
        short data = myUnion.unionSecond;
        if(data > 0) 
        {
            
            short result = data * 2;
            printIntLine(result);
        }
"
4611,1,CWE758_Undefined_Behavior__int_pointer_new_use_17.cpp,"    int k;
    for(k = 0; k < 1; k++)
    {
        {
            int * data;
            
            data = new int;
            *data = 5;
            int * * pointer = new int *;
            *pointer = data; 
            {
                int * data = *pointer;
                printIntLine(*data);
            }
            delete pointer;
        }
"
11968,0,CWE190_Integer_Overflow__int64_t_rand_add_14.c,"    int64_t data;
    data = 0LL;
    if(globalFive==5)
    {
        
        data = (int64_t)RAND64();
    }
    if(globalFive==5)
    {
        {
            
            int64_t result = data + 1;
            printLongLongLine(result);
        }
"
7957,0,CWE190_Integer_Overflow__int_max_preinc_01.c,"    int data;
    
    data = 0;
    
    data = INT_MAX;
    {
        
        ++data;
        int result = data;
        printIntLine(result);
"
13779,0,CWE190_Integer_Overflow__int_connect_socket_square_14.c,"    int data;
    
    data = 0;
    if(globalFive==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(globalFive==5)
    {
        {
            
            int result = data * data;
            printIntLine(result);
        }
"
10633,0,CWE590_Free_Memory_Not_on_Heap__delete_class_alloca_51a.cpp,"    TwoIntsClass * data;
    data = NULL; 
    {
        
        TwoIntsClass * dataBuffer = (TwoIntsClass *)ALLOCA(sizeof(TwoIntsClass));
        dataBuffer->intOne = 2;
        dataBuffer->intTwo = 2;
        data = dataBuffer;
    }
"
14024,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_62a.cpp,"    size_t data;
    
    data = 0;
    badSource(data);
    {
        char * myString;
        /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
         * for the strcpy() function to not cause a buffer overflow */
        
        if (data > strlen(HELLO_STRING))
        {
            myString = (char *)malloc(data*sizeof(char));
            if (myString == NULL) {exit(-1);}
            
            strcpy(myString, HELLO_STRING);
            printLine(myString);
            free(myString);
        }
        else
        {
            printLine(""Input is less than the length of the source string"");
        }
"
11882,0,CWE690_NULL_Deref_From_Return__int64_t_realloc_61a.c,"    int64_t * data;
    data = NULL; 
    data = CWE690_NULL_Deref_From_Return__int64_t_realloc_61b_badSource(data);
    
    data[0] = 5LL;
    printLongLongLine(data[0]);
"
7325,0,CWE190_Integer_Overflow__int64_t_rand_postinc_10.c,"    int64_t data;
    data = 0LL;
    if(globalTrue)
    {
        
        data = (int64_t)RAND64();
    }
    if(globalTrue)
    {
        {
            
            data++;
            int64_t result = data;
            printLongLongLine(result);
        }
"
10923,0,CWE415_Double_Free__new_delete_char_42.cpp,"    char * data;
    
    data = NULL;
    data = badSource(data);
    
"
4544,0,CWE190_Integer_Overflow__char_fscanf_square_10.c,"    char data;
    data = ' ';
    if(globalTrue)
    {
        
        fscanf (stdin, ""%c"", &data);
    }
    if(globalTrue)
    {
        {
            
            char result = data * data;
            printHexCharLine(result);
        }
"
7577,0,CWE590_Free_Memory_Not_on_Heap__free_int64_t_alloca_06.c,"    int64_t * data;
    data = NULL; 
    if(STATIC_CONST_FIVE==5)
    {
        {
            
            int64_t * dataBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5LL;
                }
            }
            data = dataBuffer;
        }
    }
    printLongLongLine(data[0]);
    
"
13375,1,CWE467_Use_of_sizeof_on_Pointer_Type__char_16.c,"    while(1)
    {
        {
            char * goodChar = NULL;
            
            goodChar = (char *)malloc(sizeof(*goodChar));
            if (goodChar == NULL) {exit(-1);}
            *goodChar = 'G';
            printHexCharLine(*goodChar);
            free(goodChar);
        }
        break;
"
4468,0,CWE590_Free_Memory_Not_on_Heap__delete_int64_t_static_10.cpp,"    int64_t * data;
    data = NULL; 
    if(globalTrue)
    {
        {
            
            static int64_t dataBuffer;
            dataBuffer = 5LL;
            data = &dataBuffer;
        }
    }
    printLongLongLine(*data);
    
"
14917,0,CWE415_Double_Free__malloc_free_int64_t_67a.c,"    int64_t * data;
    CWE415_Double_Free__malloc_free_int64_t_67_structType myStruct;
    
    data = NULL;
    data = (int64_t *)malloc(100*sizeof(int64_t));
    if (data == NULL) {exit(-1);}
    
    free(data);
    myStruct.structFirst = data;
"
15231,0,CWE190_Integer_Overflow__char_fscanf_preinc_15.c,"    char data;
    data = ' ';
    switch(6)
    {
    case 6:
        
        fscanf (stdin, ""%c"", &data);
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
    {
        
        ++data;
        char result = data;
        printHexCharLine(result);
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
14465,0,CWE401_Memory_Leak__malloc_realloc_int_02.c,"    if(1)
    {
        {
            int * data = (int *)malloc(100*sizeof(int));
            if (data == NULL) {exit(-1);}
            
            data[0] = 5;
            printIntLine(data[0]);
            
            data = (int *)realloc(data, (130000)*sizeof(int));
            if (data != NULL)
            {
                
                data[0] = 10;
                printIntLine(data[0]);
                free(data);
            }
        }
"
5805,0,CWE789_Uncontrolled_Mem_Alloc__new_char_listen_socket_10.cpp,"    size_t data;
    
    data = 0;
    if(globalTrue)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = strtoul(inputBuffer, NULL, 0);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(globalTrue)
    {
        {
            char * myString;
            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
             * for the strcpy() function to not cause a buffer overflow */
            
            if (data > strlen(HELLO_STRING))
            {
                myString = new char[data];
                
                strcpy(myString, HELLO_STRING);
                printLine(myString);
                delete [] myString;
            }
            else
            {
                printLine(""Input is less than the length of the source string"");
            }
        }
"
6646,1,CWE758_Undefined_Behavior__int_new_use_06.cpp,"    if(STATIC_CONST_FIVE!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            int data;
            data = 5;
            int * pointer = new int;
            *pointer = data; 
            {
                int data = *pointer;
                printIntLine(data);
            }
            delete pointer;
        }
"
15744,0,CWE78_OS_Command_Injection__char_file_popen_01.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
        
        size_t dataLen = strlen(data);
        FILE * pFile;
        
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
    {
        FILE *pipe;
        
        pipe = POPEN(data, ""w"");
        if (pipe != NULL)
        {
            PCLOSE(pipe);
        }
"
6147,0,CWE190_Integer_Overflow__int_listen_socket_postinc_09.c,"    int data;
    
    data = 0;
    if(GLOBAL_CONST_TRUE)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(GLOBAL_CONST_TRUE)
    {
        {
            
            data++;
            int result = data;
            printIntLine(result);
        }
"
15800,0,CWE690_NULL_Deref_From_Return__int_malloc_67a.c,"    int * data;
    CWE690_NULL_Deref_From_Return__int_malloc_67_structType myStruct;
    data = NULL; 
    
    data = (int *)malloc(1*sizeof(int));
    myStruct.structFirst = data;
"
2396,0,CWE415_Double_Free__new_delete_array_int64_t_02.cpp,"    int64_t * data;
    
    data = NULL;
    if(1)
    {
        data = new int64_t[100];
        
        delete [] data;
    }
    if(1)
    {
        
        delete [] data;
"
58,0,CWE590_Free_Memory_Not_on_Heap__delete_array_int64_t_static_68a.cpp,"    int64_t * data;
    data = NULL; 
    {
        
        static int64_t dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5LL;
            }
        }
        data = dataBuffer;
    }
    CWE590_Free_Memory_Not_on_Heap__delete_array_int64_t_static_68_badData = data;
"
14227,0,CWE190_Integer_Overflow__short_rand_multiply_74a.cpp,"    short data;
    map<int, short> dataMap;
    data = 0;
    
    data = (short)RAND32();
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
15075,0,CWE401_Memory_Leak__char_malloc_14.c,"    char * data;
    data = NULL;
    if(globalFive==5)
    {
        
        data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        
        strcpy(data, ""A String"");
        printLine(data);
    }
    if(globalFive==5)
    {
        
        ; 
"
14875,0,CWE401_Memory_Leak__twoIntsStruct_malloc_65a.c,"    twoIntsStruct * data;
    
    void (*funcPtr) (twoIntsStruct *) = CWE401_Memory_Leak__twoIntsStruct_malloc_65b_badSink;
    data = NULL;
    
    data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
    if (data == NULL) {exit(-1);}
    
    data[0].intOne = 0;
    data[0].intTwo = 0;
    printStructLine(&data[0]);
    
"
4146,0,CWE401_Memory_Leak__char_realloc_32.c,"    char * data;
    char * *dataPtr1 = &data;
    char * *dataPtr2 = &data;
    data = NULL;
    {
        char * data = *dataPtr1;
        
        data = (char *)realloc(data, 100*sizeof(char));
        if (data == NULL) {exit(-1);}
        
        strcpy(data, ""A String"");
        printLine(data);
        *dataPtr1 = data;
    }
    {
        char * data = *dataPtr2;
        
        ; 
"
16503,0,CWE190_Integer_Overflow__int_rand_square_18.c,"    int data;
    
    data = 0;
    goto source;
source:
    
    data = RAND32();
    goto sink;
sink:
    {
        
        int result = data * data;
        printIntLine(result);
"
12056,0,CWE563_Unused_Variable__unused_uninit_variable_struct_84a.cpp,"    twoIntsStruct data;
    CWE563_Unused_Variable__unused_uninit_variable_struct_84_bad * badObject = new CWE563_Unused_Variable__unused_uninit_variable_struct_84_bad(data);
"
8714,0,CWE190_Integer_Overflow__int64_t_max_preinc_32.c,"    int64_t data;
    int64_t *dataPtr1 = &data;
    int64_t *dataPtr2 = &data;
    data = 0LL;
    {
        int64_t data = *dataPtr1;
        
        data = LLONG_MAX;
        *dataPtr1 = data;
    }
    {
        int64_t data = *dataPtr2;
        {
            
            ++data;
            int64_t result = data;
            printLongLongLine(result);
        }
"
15968,0,CWE190_Integer_Overflow__char_max_square_13.c,"    char data;
    data = ' ';
    if(GLOBAL_CONST_FIVE==5)
    {
        
        data = CHAR_MAX;
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            
            char result = data * data;
            printHexCharLine(result);
        }
"
14923,0,CWE758_Undefined_Behavior__int_malloc_use_08.c,"    if(staticReturnsTrue())
    {
        {
            int * pointer = (int *)malloc(sizeof(int));
            if (pointer == NULL) {exit(-1);}
            int data = *pointer; 
            free(pointer);
            printIntLine(data);
        }
"
10101,0,CWE590_Free_Memory_Not_on_Heap__free_long_static_34.c,"    long * data;
    CWE590_Free_Memory_Not_on_Heap__free_long_static_34_unionType myUnion;
    data = NULL; 
    {
        
        static long dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5L;
            }
        }
        data = dataBuffer;
    }
    myUnion.unionFirst = data;
    {
        long * data = myUnion.unionSecond;
        printLongLine(data[0]);
        
        free(data);
"
1059,0,CWE190_Integer_Overflow__unsigned_int_rand_add_02.c,"    unsigned int data;
    data = 0;
    if(1)
    {
        
        data = (unsigned int)RAND32();
    }
    if(1)
    {
        {
            
            unsigned int result = data + 1;
            printUnsignedLine(result);
        }
"
15298,0,CWE78_OS_Command_Injection__char_file_popen_16.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    while(1)
    {
        {
            
            size_t dataLen = strlen(data);
            FILE * pFile;
            
            if (100-dataLen > 1)
            {
                pFile = fopen(FILENAME, ""r"");
                if (pFile != NULL)
                {
                    
                    if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                    {
                        printLine(""fgets() failed"");
                        
                        data[dataLen] = '\0';
                    }
                    fclose(pFile);
                }
            }
        }
        break;
    }
    {
        FILE *pipe;
        
        pipe = POPEN(data, ""w"");
        if (pipe != NULL)
        {
            PCLOSE(pipe);
        }
"
12881,0,CWE134_Uncontrolled_Format_String__char_file_snprintf_82_bad.cpp,"Label Definition File: CWE134_Uncontrolled_Format_String.label.xml
Template File: sources-sinks-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 134 Uncontrolled Format String
 * BadSource: file Read input from a file
 * GoodSource: Copy a fixed string into data
 * Sinks: snprintf
 *    GoodSink: snprintf with ""%s"" as the third argument and data as the fourth
 *    BadSink : snprintf with data as the third argument
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE134_Uncontrolled_Format_String__char_file_snprintf_82.h""

#ifdef _WIN32
#define SNPRINTF _snprintf
#else
#define SNPRINTF snprintf
#endif

namespace CWE134_Uncontrolled_Format_String__char_file_snprintf_82
{

void CWE134_Uncontrolled_Format_String__char_file_snprintf_82_bad::action(char * data)
{
    {
        char dest[100] = """";
        
        SNPRINTF(dest, 100-1, data);
        printLine(dest);
    }
}

}
"
8267,0,CWE415_Double_Free__new_delete_class_83a.cpp,"    TwoIntsClass * data;
    
    data = NULL;
"
10055,0,CWE190_Integer_Overflow__int_fscanf_preinc_54a.c,"    int data;
    
    data = 0;
    
    fscanf(stdin, ""%d"", &data);
"
15080,0,CWE665_Improper_Initialization__char_ncat_43.cpp,"    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    badSource(data);
    {
        size_t sourceLen;
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        sourceLen = strlen(source);
        
        strncat(data, source, sourceLen);
        printLine(data);
"
5316,0,CWE590_Free_Memory_Not_on_Heap__delete_struct_placement_new_41.cpp,"    twoIntsStruct * data;
    data = NULL; 
    {
        
        char buffer[sizeof(twoIntsStruct)];
        twoIntsStruct * dataBuffer = new(buffer) twoIntsStruct;
        dataBuffer->intOne = 1;
        dataBuffer->intTwo = 1;
        data = dataBuffer;
    }
"
11824,0,CWE369_Divide_by_Zero__int_fscanf_modulo_01.c,"    int data;
    
    data = -1;
    
    fscanf(stdin, ""%d"", &data);
    
"
1926,0,CWE252_Unchecked_Return_Value__char_putc_11.c,"    if(globalReturnsTrue())
    {
        
        putc((int)'A', stdout);
"
14921,0,CWE190_Integer_Overflow__int_connect_socket_preinc_31.c,"    int data;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    {
        int dataCopy = data;
        int data = dataCopy;
        {
            
            ++data;
            int result = data;
            printIntLine(result);
        }
"
12847,0,CWE190_Integer_Overflow__unsigned_int_max_square_33.cpp,"    unsigned int data;
    unsigned int &dataRef = data;
    data = 0;
    
    data = UINT_MAX;
    {
        unsigned int data = dataRef;
        {
            
            unsigned int result = data * data;
            printUnsignedLine(result);
        }
"
19525,0,CWE190_Integer_Overflow__int64_t_rand_multiply_81a.cpp,"    int64_t data;
    data = 0LL;
    
    data = (int64_t)RAND64();
    const CWE190_Integer_Overflow__int64_t_rand_multiply_81_base& baseObject = CWE190_Integer_Overflow__int64_t_rand_multiply_81_bad();
"
7139,0,CWE590_Free_Memory_Not_on_Heap__free_int64_t_alloca_16.c,"    int64_t * data;
    data = NULL; 
    while(1)
    {
        {
            
            int64_t * dataBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5LL;
                }
            }
            data = dataBuffer;
        }
        break;
    }
    printLongLongLine(data[0]);
    
"
12250,0,CWE190_Integer_Overflow__int64_t_fscanf_preinc_44.c,"    int64_t data;
    
    void (*funcPtr) (int64_t) = badSink;
    data = 0LL;
    
    fscanf (stdin, ""%"" SCNd64, &data);
    
"
8592,0,CWE78_OS_Command_Injection__char_file_execl_43.cpp,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    badSource(data);
    
    
"
10897,1,CWE758_Undefined_Behavior__int_alloca_use_02.c,"    if(1)
    {
        {
            int data;
            int * pointer = (int *)ALLOCA(sizeof(int));
            data = 5;
            *pointer = data; 
            {
                int data = *pointer;
                printIntLine(data);
            }
        }
"
4131,0,CWE415_Double_Free__new_delete_long_53a.cpp,"    long * data;
    
    data = NULL;
    data = new long;
    
    delete data;
"
1521,0,CWE369_Divide_by_Zero__float_fgets_06.c,"    float data;
    
    data = 0.0F;
    if(STATIC_CONST_FIVE==5)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE];
            
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                
                data = (float)atof(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    if(STATIC_CONST_FIVE==5)
    {
        {
            
            int result = (int)(100.0 / data);
            printIntLine(result);
        }
"
143,0,CWE467_Use_of_sizeof_on_Pointer_Type__int_04.c,"    if(STATIC_CONST_TRUE)
    {
        {
            int * badInt = NULL;
            
            badInt = (int *)malloc(sizeof(badInt));
            if (badInt == NULL) {exit(-1);}
            *badInt = 5;
            printIntLine(*badInt);
            free(badInt);
        }
"
1685,0,CWE590_Free_Memory_Not_on_Heap__delete_struct_alloca_73a.cpp,"    twoIntsStruct * data;
    list<twoIntsStruct *> dataList;
    data = NULL; 
    {
        
        twoIntsStruct * dataBuffer = (twoIntsStruct *)ALLOCA(sizeof(twoIntsStruct));
        dataBuffer->intOne = 1;
        dataBuffer->intTwo = 1;
        data = dataBuffer;
    }
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
16480,0,CWE415_Double_Free__malloc_free_struct_52a.c,"    twoIntsStruct * data;
    
    data = NULL;
    data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
    if (data == NULL) {exit(-1);}
    
    free(data);
"
18997,0,CWE190_Integer_Overflow__int_connect_socket_square_44.c,"    int data;
    
    void (*funcPtr) (int) = badSink;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
"
7098,0,CWE190_Integer_Overflow__char_max_postinc_06.c,"    char data;
    data = ' ';
    if(STATIC_CONST_FIVE==5)
    {
        
        data = CHAR_MAX;
    }
    if(STATIC_CONST_FIVE==5)
    {
        {
            
            data++;
            char result = data;
            printHexCharLine(result);
        }
"
10994,0,CWE190_Integer_Overflow__int_connect_socket_add_67a.c,"    int data;
    CWE190_Integer_Overflow__int_connect_socket_add_67_structType myStruct;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    myStruct.structFirst = data;
"
19061,0,CWE590_Free_Memory_Not_on_Heap__delete_array_int_static_82a.cpp,"    int * data;
    data = NULL; 
    {
        
        static int dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5;
            }
        }
        data = dataBuffer;
    }
    CWE590_Free_Memory_Not_on_Heap__delete_array_int_static_82_base* baseObject = new CWE590_Free_Memory_Not_on_Heap__delete_array_int_static_82_bad;
    baseObject->action(data);
"
1184,0,CWE78_OS_Command_Injection__char_connect_socket_execlp_52a.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
13110,0,CWE563_Unused_Variable__unused_static_global_value_01.c,"    
    staticGlobalBad = 10;
"
16528,0,CWE190_Integer_Overflow__int64_t_max_postinc_14.c,"    int64_t data;
    data = 0LL;
    if(globalFive==5)
    {
        
        data = LLONG_MAX;
    }
    if(globalFive==5)
    {
        {
            
            data++;
            int64_t result = data;
            printLongLongLine(result);
        }
"
12360,0,CWE190_Integer_Overflow__int_max_multiply_17.c,"    int i,j;
    int data;
    
    data = 0;
    for(i = 0; i < 1; i++)
    {
        
        data = INT_MAX;
    }
    for(j = 0; j < 1; j++)
    {
        if(data > 0) 
        {
            
            int result = data * 2;
            printIntLine(result);
        }
"
15936,0,CWE590_Free_Memory_Not_on_Heap__free_long_declare_09.c,"    long * data;
    data = NULL; 
    if(GLOBAL_CONST_TRUE)
    {
        {
            
            long dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5L;
                }
            }
            data = dataBuffer;
        }
    }
    printLongLine(data[0]);
    
"
15386,0,CWE590_Free_Memory_Not_on_Heap__delete_int_placement_new_09.cpp,"    int * data;
    data = NULL; 
    if(GLOBAL_CONST_TRUE)
    {
        {
            
            char buffer[sizeof(int)];
            int * dataBuffer = new(buffer) int;
            *dataBuffer = 5;
            data = dataBuffer;
        }
    }
    printIntLine(*data);
    
"
10993,0,CWE190_Integer_Overflow__unsigned_int_max_square_84a.cpp,"    unsigned int data;
    data = 0;
    CWE190_Integer_Overflow__unsigned_int_max_square_84_bad * badObject = new CWE190_Integer_Overflow__unsigned_int_max_square_84_bad(data);
"
3002,0,CWE401_Memory_Leak__malloc_realloc_int_11.c,"    if(globalReturnsTrue())
    {
        {
            int * data = (int *)malloc(100*sizeof(int));
            if (data == NULL) {exit(-1);}
            
            data[0] = 5;
            printIntLine(data[0]);
            
            data = (int *)realloc(data, (130000)*sizeof(int));
            if (data != NULL)
            {
                
                data[0] = 10;
                printIntLine(data[0]);
                free(data);
            }
        }
"
6862,0,CWE190_Integer_Overflow__int_fscanf_square_68a.c,"    int data;
    
    data = 0;
    
    fscanf(stdin, ""%d"", &data);
    CWE190_Integer_Overflow__int_fscanf_square_68_badData = data;
"
6386,0,CWE369_Divide_by_Zero__float_connect_socket_06.c,"    float data;
    
    data = 0.0F;
    if(STATIC_CONST_FIVE==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = (float)atof(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(STATIC_CONST_FIVE==5)
    {
        {
            
            int result = (int)(100.0 / data);
            printIntLine(result);
        }
"
11690,0,CWE401_Memory_Leak__int64_t_realloc_05.c,"    int64_t * data;
    data = NULL;
    if(staticTrue)
    {
        
        data = (int64_t *)realloc(data, 100*sizeof(int64_t));
        if (data == NULL) {exit(-1);}
        
        data[0] = 5LL;
        printLongLongLine(data[0]);
    }
    if(staticTrue)
    {
        
        ; 
"
4483,0,CWE78_OS_Command_Injection__char_connect_socket_popen_82a.cpp,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    CWE78_OS_Command_Injection__char_connect_socket_popen_82_base* baseObject = new CWE78_OS_Command_Injection__char_connect_socket_popen_82_bad;
    baseObject->action(data);
"
1118,0,CWE190_Integer_Overflow__int64_t_max_multiply_62a.cpp,"    int64_t data;
    data = 0LL;
    badSource(data);
    if(data > 0) 
    {
        
        int64_t result = data * 2;
        printLongLongLine(result);
"
12653,0,CWE190_Integer_Overflow__int64_t_fscanf_square_82_bad.cpp,"Label Definition File: CWE190_Integer_Overflow.label.xml
Template File: sources-sinks-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 190 Integer Overflow
 * BadSource: fscanf Read data from the console using fscanf()
 * GoodSource: Set data to a small, non-zero number (two)
 * Sinks: square
 *    GoodSink: Ensure there will not be an overflow before squaring data
 *    BadSink : Square data, which can lead to overflow
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE190_Integer_Overflow__int64_t_fscanf_square_82.h""

#include <math.h>
#include <inttypes.h>

namespace CWE190_Integer_Overflow__int64_t_fscanf_square_82
{

void CWE190_Integer_Overflow__int64_t_fscanf_square_82_bad::action(int64_t data)
{
    {
        
        int64_t result = data * data;
        printLongLongLine(result);
    }
}

}
"
17297,0,CWE401_Memory_Leak__int64_t_realloc_82a.cpp,"    int64_t * data;
    data = NULL;
    
    data = (int64_t *)realloc(data, 100*sizeof(int64_t));
    if (data == NULL) {exit(-1);}
    
    data[0] = 5LL;
    printLongLongLine(data[0]);
    CWE401_Memory_Leak__int64_t_realloc_82_base* baseObject = new CWE401_Memory_Leak__int64_t_realloc_82_bad;
    baseObject->action(data);
"
2164,0,CWE563_Unused_Variable__unused_value_long_21.c,"    long data;
    
    data = 5L;
    badStatic = 1; 
"
13474,0,CWE190_Integer_Overflow__char_fscanf_multiply_62a.cpp,"    char data;
    data = ' ';
    badSource(data);
    if(data > 0) 
    {
        
        char result = data * 2;
        printHexCharLine(result);
"
19489,0,CWE190_Integer_Overflow__int_connect_socket_postinc_64a.c,"    int data;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
12227,0,CWE457_Use_of_Uninitialized_Variable__double_array_declare_no_init_01.c,"    double * data;
    double dataUninitArray[10];
    data = dataUninitArray;
    
    ; 
    
    {
        int i;
        for(i=0; i<10; i++)
        {
            printDoubleLine(data[i]);
        }
"
7628,0,CWE457_Use_of_Uninitialized_Variable__int_array_alloca_partial_init_14.c,"    int * data;
    data = (int *)ALLOCA(10*sizeof(int));
    if(globalFive==5)
    {
        
        {
            int i;
            for(i=0; i<(10/2); i++)
            {
                data[i] = i;
            }
        }
    }
    if(globalFive==5)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i]);
            }
        }
"
2427,0,CWE415_Double_Free__new_delete_array_int64_t_17.cpp,"    int i,j;
    int64_t * data;
    
    data = NULL;
    for(i = 0; i < 1; i++)
    {
        data = new int64_t[100];
        
        delete [] data;
    }
    for(j = 0; j < 1; j++)
    {
        
        delete [] data;
"
1711,0,CWE401_Memory_Leak__int_calloc_17.c,"    int i,j;
    int * data;
    data = NULL;
    for(i = 0; i < 1; i++)
    {
        
        data = (int *)calloc(100, sizeof(int));
        if (data == NULL) {exit(-1);}
        
        data[0] = 5;
        printIntLine(data[0]);
    }
    for(j = 0; j < 1; j++)
    {
        
        ; 
"
1179,0,CWE690_NULL_Deref_From_Return__int_realloc_41.c,"    int * data;
    data = NULL; 
    
    data = (int *)realloc(data, 1*sizeof(int));
"
8018,0,CWE190_Integer_Overflow__unsigned_int_max_postinc_42.c,"    unsigned int data;
    data = 0;
    data = badSource(data);
    {
        
        data++;
        unsigned int result = data;
        printUnsignedLine(result);
"
19315,0,CWE78_OS_Command_Injection__char_listen_socket_execl_22a.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    CWE78_OS_Command_Injection__char_listen_socket_execl_22_badGlobal = 1; 
    data = CWE78_OS_Command_Injection__char_listen_socket_execl_22_badSource(data);
    
    
"
4633,0,CWE415_Double_Free__new_delete_array_class_22a.cpp,"    TwoIntsClass * data;
    
    data = NULL;
    data = new TwoIntsClass[100];
    
    delete [] data;
    badGlobal = 1; 
"
7987,0,CWE197_Numeric_Truncation_Error__int_fscanf_to_char_84a.cpp,"    int data;
    
    data = -1;
    CWE197_Numeric_Truncation_Error__int_fscanf_to_char_84_bad * badObject = new CWE197_Numeric_Truncation_Error__int_fscanf_to_char_84_bad(data);
"
14469,0,CWE457_Use_of_Uninitialized_Variable__int_array_declare_partial_init_14.c,"    int * data;
    int dataUninitArray[10];
    data = dataUninitArray;
    if(globalFive==5)
    {
        
        {
            int i;
            for(i=0; i<(10/2); i++)
            {
                data[i] = i;
            }
        }
    }
    if(globalFive==5)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i]);
            }
        }
"
6527,0,CWE190_Integer_Overflow__short_rand_preinc_52a.c,"    short data;
    data = 0;
    
    data = (short)RAND32();
"
18723,1,CWE758_Undefined_Behavior__int_alloca_use_09.c,"    if(GLOBAL_CONST_FALSE)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            int data;
            int * pointer = (int *)ALLOCA(sizeof(int));
            data = 5;
            *pointer = data; 
            {
                int data = *pointer;
                printIntLine(data);
            }
        }
"
1188,0,CWE690_NULL_Deref_From_Return__int64_t_calloc_54a.c,"    int64_t * data;
    data = NULL; 
    
    data = (int64_t *)calloc(1, sizeof(int64_t));
"
9435,1,CWE758_Undefined_Behavior__struct_malloc_use_09.c,"    if(GLOBAL_CONST_FALSE)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            twoIntsStruct data;
            twoIntsStruct * pointer = (twoIntsStruct *)malloc(sizeof(twoIntsStruct));
            if (pointer == NULL) {exit(-1);}
            data.intOne = 1;
            data.intTwo = 2;
            *pointer = data; 
            {
                twoIntsStruct data = *pointer;
                printIntLine(data.intOne);
                printIntLine(data.intTwo);
            }
            free(pointer);
        }
"
9622,0,CWE415_Double_Free__malloc_free_int_09.c,"    int * data;
    
    data = NULL;
    if(GLOBAL_CONST_TRUE)
    {
        data = (int *)malloc(100*sizeof(int));
        if (data == NULL) {exit(-1);}
        
        free(data);
    }
    if(GLOBAL_CONST_TRUE)
    {
        
        free(data);
"
9933,0,CWE401_Memory_Leak__struct_twoIntsStruct_calloc_41.c,"    struct _twoIntsStruct * data;
    data = NULL;
    
    data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));
    if (data == NULL) {exit(-1);}
    
    data[0].intOne = 0;
    data[0].intTwo = 0;
    printStructLine((twoIntsStruct *)&data[0]);
"
17470,0,CWE690_NULL_Deref_From_Return__int64_t_realloc_64a.c,"    int64_t * data;
    data = NULL; 
    
    data = (int64_t *)realloc(data, 1*sizeof(int64_t));
"
8706,0,CWE401_Memory_Leak__int_malloc_10.c,"    int * data;
    data = NULL;
    if(globalTrue)
    {
        
        data = (int *)malloc(100*sizeof(int));
        if (data == NULL) {exit(-1);}
        
        data[0] = 5;
        printIntLine(data[0]);
    }
    if(globalTrue)
    {
        
        ; 
"
6432,0,CWE78_OS_Command_Injection__char_environment_popen_17.c,"    int i;
    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    for(i = 0; i < 1; i++)
    {
        {
            
            size_t dataLen = strlen(data);
            char * environment = GETENV(ENV_VARIABLE);
            
            if (environment != NULL)
            {
                
                strncat(data+dataLen, environment, 100-dataLen-1);
            }
        }
    }
    {
        FILE *pipe;
        
        pipe = POPEN(data, ""w"");
        if (pipe != NULL)
        {
            PCLOSE(pipe);
        }
"
15402,0,CWE197_Numeric_Truncation_Error__short_large_03.c,"    short data;
    
    data = -1;
    if(5==5)
    {
        
        data = CHAR_MAX + 1;
    }
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
2004,1,CWE476_NULL_Pointer_Dereference__binary_if_07.c,"    if(staticFive==5)
    {
        {
            twoIntsStruct *twoIntsStructPointer = NULL;
            /* FIX: Use && in the if statement so that if the left side of the expression fails then
             * the right side will not be evaluated */
            if ((twoIntsStructPointer != NULL) && (twoIntsStructPointer->intOne == 5))
            {
                printLine(""intOne == 5"");
            }
        }
"
15340,0,CWE590_Free_Memory_Not_on_Heap__delete_array_char_alloca_53a.cpp,"    char * data;
    data = NULL; 
    {
        
        char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
        memset(dataBuffer, 'A', 100-1); 
        dataBuffer[100-1] = '\0'; 
        data = dataBuffer;
    }
"
7006,0,CWE197_Numeric_Truncation_Error__int_fscanf_to_short_52a.c,"    int data;
    
    data = -1;
    
    fscanf(stdin, ""%d"", &data);
"
13695,0,CWE190_Integer_Overflow__unsigned_int_fscanf_add_05.c,"    unsigned int data;
    data = 0;
    if(staticTrue)
    {
        
        fscanf (stdin, ""%u"", &data);
    }
    if(staticTrue)
    {
        {
            
            unsigned int result = data + 1;
            printUnsignedLine(result);
        }
"
4462,0,CWE190_Integer_Overflow__int_fgets_add_14.c,"    int data;
    
    data = 0;
    if(globalFive==5)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    if(globalFive==5)
    {
        {
            
            int result = data + 1;
            printIntLine(result);
        }
"
12362,0,CWE688_Function_Call_With_Incorrect_Variable_or_Reference_as_Argument__basic_15.c,"    switch(6)
    {
    case 6:
    {
        char dest[DEST_SIZE];
        int intFive = 5;
        
        sprintf(dest, ""%s"", intFive);
        printLine(dest);
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
922,0,CWE563_Unused_Variable__unused_init_variable_char_81a.cpp,"    char data;
    
    data = 'C';
    const CWE563_Unused_Variable__unused_init_variable_char_81_base& baseObject = CWE563_Unused_Variable__unused_init_variable_char_81_bad();
"
8506,1,CWE758_Undefined_Behavior__int_pointer_new_use_08.cpp,"    if(staticReturnsFalse())
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            int * data;
            
            data = new int;
            *data = 5;
            int * * pointer = new int *;
            *pointer = data; 
            {
                int * data = *pointer;
                printIntLine(*data);
            }
            delete pointer;
        }
"
15551,0,CWE190_Integer_Overflow__char_rand_preinc_07.c,"    char data;
    data = ' ';
    if(staticFive==5)
    {
        
        data = (char)RAND32();
    }
    if(staticFive==5)
    {
        {
            
            ++data;
            char result = data;
            printHexCharLine(result);
        }
"
17880,0,CWE416_Use_After_Free__return_freed_ptr_03.c,"    if(5==5)
    {
        {
            
            char * reversedString = helperBad(""BadSink"");
            printLine(reversedString);
            /* free(reversedString);
             * This call to free() was removed because we want the tool to detect the use after free,
             * but we don't want that function to be free(). Essentially we want to avoid a double free
             */
        }
"
10352,0,CWE563_Unused_Variable__unused_value_int64_t_22a.c,"    int64_t data;
    
    data = 5LL;
    CWE563_Unused_Variable__unused_value_int64_t_22_badGlobal = 1; 
"
19321,0,CWE457_Use_of_Uninitialized_Variable__struct_array_declare_no_init_18.c,"    twoIntsStruct * data;
    twoIntsStruct dataUninitArray[10];
    data = dataUninitArray;
    goto source;
source:
    
    ; 
    goto sink;
sink:
    
    {
        int i;
        for(i=0; i<10; i++)
        {
            printIntLine(data[i].intOne);
            printIntLine(data[i].intTwo);
        }
"
4861,0,CWE190_Integer_Overflow__int_max_add_73a.cpp,"    int data;
    list<int> dataList;
    
    data = 0;
    
    data = INT_MAX;
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
2459,0,CWE190_Integer_Overflow__short_max_preinc_64a.c,"    short data;
    data = 0;
    
    data = SHRT_MAX;
"
6928,0,CWE690_NULL_Deref_From_Return__int_realloc_81a.cpp,"    int * data;
    data = NULL; 
    
    data = (int *)realloc(data, 1*sizeof(int));
    const CWE690_NULL_Deref_From_Return__int_realloc_81_base& baseObject = CWE690_NULL_Deref_From_Return__int_realloc_81_bad();
"
2906,0,CWE134_Uncontrolled_Format_String__char_file_printf_54a.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        FILE * pFile;
        
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
"
13261,0,CWE415_Double_Free__new_delete_array_class_41.cpp,"    TwoIntsClass * data;
    
    data = NULL;
    data = new TwoIntsClass[100];
    
    delete [] data;
"
17222,0,CWE190_Integer_Overflow__int_connect_socket_postinc_31.c,"    int data;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    {
        int dataCopy = data;
        int data = dataCopy;
        {
            
            data++;
            int result = data;
            printIntLine(result);
        }
"
7820,0,CWE401_Memory_Leak__new_array_TwoIntsClass_16.cpp,"    TwoIntsClass * data;
    data = NULL;
    while(1)
    {
        
        data = new TwoIntsClass[100];
        
        data[0].intOne = 0;
        data[0].intTwo = 0;
        printIntLine(data[0].intOne);
        printIntLine(data[0].intTwo);
        break;
    }
    while(1)
    {
        
        ; 
        break;
"
13948,0,CWE134_Uncontrolled_Format_String__char_console_fprintf_15.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    switch(6)
    {
    case 6:
    {
        
        size_t dataLen = strlen(data);
        
        if (100-dataLen > 1)
        {
            
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgets() */
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
                    data[dataLen-1] = '\0';
                }
            }
            else
            {
                printLine(""fgets() failed"");
                
                data[dataLen] = '\0';
            }
        }
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
        
        fprintf(stdout, data);
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
10868,0,CWE369_Divide_by_Zero__int_listen_socket_divide_14.c,"    int data;
    
    data = -1;
    if(globalFive==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(globalFive==5)
    {
        
        printIntLine(100 / data);
"
18659,0,CWE590_Free_Memory_Not_on_Heap__free_int_alloca_18.c,"    int * data;
    data = NULL; 
    goto source;
source:
    {
        
        int * dataBuffer = (int *)ALLOCA(100*sizeof(int));
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5;
            }
        }
        data = dataBuffer;
    }
    printIntLine(data[0]);
    
"
14911,0,CWE190_Integer_Overflow__unsigned_int_fscanf_add_68a.c,"    unsigned int data;
    data = 0;
    
    fscanf (stdin, ""%u"", &data);
    CWE190_Integer_Overflow__unsigned_int_fscanf_add_68_badData = data;
"
17002,0,CWE416_Use_After_Free__malloc_free_int_12.c,"    int * data;
    
    data = NULL;
    if(globalReturnsTrueOrFalse())
    {
        data = (int *)malloc(100*sizeof(int));
        if (data == NULL) {exit(-1);}
        {
            size_t i;
            for(i = 0; i < 100; i++)
            {
                data[i] = 5;
            }
        }
        
        free(data);
    }
    else
    {
        data = (int *)malloc(100*sizeof(int));
        if (data == NULL) {exit(-1);}
        {
            size_t i;
            for(i = 0; i < 100; i++)
            {
                data[i] = 5;
            }
        }
        
    }
    if(globalReturnsTrueOrFalse())
    {
        
        printIntLine(data[0]);
        
    }
    else
    {
        
        
        
        ; 
"
189,0,CWE134_Uncontrolled_Format_String__char_environment_snprintf_11.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(globalReturnsTrue())
    {
        {
            
            size_t dataLen = strlen(data);
            char * environment = GETENV(ENV_VARIABLE);
            
            if (environment != NULL)
            {
                
                strncat(data+dataLen, environment, 100-dataLen-1);
            }
        }
    }
    if(globalReturnsTrue())
    {
        {
            char dest[100] = """";
            
            SNPRINTF(dest, 100-1, data);
            printLine(dest);
        }
"
2139,0,CWE590_Free_Memory_Not_on_Heap__delete_array_long_alloca_18.cpp,"    long * data;
    data = NULL; 
    goto source;
source:
    {
        
        long * dataBuffer = (long *)ALLOCA(100*sizeof(long));
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5L;
            }
        }
        data = dataBuffer;
    }
    printLongLine(data[0]);
    
"
4022,0,CWE457_Use_of_Uninitialized_Variable__double_array_alloca_no_init_05.c,"    double * data;
    data = (double *)ALLOCA(10*sizeof(double));
    if(staticTrue)
    {
        
        ; 
    }
    if(staticTrue)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printDoubleLine(data[i]);
            }
        }
"
12834,1,CWE758_Undefined_Behavior__double_pointer_malloc_use_08.c,"    if(staticReturnsTrue())
    {
        {
            double * data;
            double * * pointer = (double * *)malloc(sizeof(double *));
            if (pointer == NULL) {exit(-1);}
            
            data = (double *)malloc(sizeof(double));
            if (data == NULL) {exit(-1);}
            *data = 5.0;
            *pointer = data; 
            {
                double * data = *pointer;
                printDoubleLine(*data);
            }
            free(pointer);
        }
"
14621,0,CWE252_Unchecked_Return_Value__char_sscanf_15.c,"    switch(6)
    {
    case 6:
    {
        /* By initializing dataBuffer, we ensure this will not be the
         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
        char dataBuffer[100] = """";
        char * data = dataBuffer;
        
        sscanf(SRC, ""%99s\0"", data);
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
4010,1,CWE758_Undefined_Behavior__long_new_use_07.cpp,"    if(staticFive!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            long data;
            data = 5L;
            long * pointer = new long;
            *pointer = data; 
            {
                long data = *pointer;
                printLongLine(data);
            }
            delete pointer;
        }
"
8186,0,CWE457_Use_of_Uninitialized_Variable__new_int_array_partial_init_04.cpp,"    int * data;
    data = new int[10];
    if(STATIC_CONST_TRUE)
    {
        
        {
            int i;
            for(i=0; i<(10/2); i++)
            {
                data[i] = i;
            }
        }
    }
    if(STATIC_CONST_TRUE)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i]);
            }
        }
        
        delete [] data;
"
10759,0,CWE369_Divide_by_Zero__int_connect_socket_modulo_53a.c,"    int data;
    
    data = -1;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
1410,0,CWE590_Free_Memory_Not_on_Heap__delete_class_alloca_04.cpp,"    TwoIntsClass * data;
    data = NULL; 
    if(STATIC_CONST_TRUE)
    {
        {
            
            TwoIntsClass * dataBuffer = (TwoIntsClass *)ALLOCA(sizeof(TwoIntsClass));
            dataBuffer->intOne = 2;
            dataBuffer->intTwo = 2;
            data = dataBuffer;
        }
    }
    printIntLine(data->intOne);
    
"
18376,0,CWE190_Integer_Overflow__int_max_postinc_15.c,"    int data;
    
    data = 0;
    switch(6)
    {
    case 6:
        
        data = INT_MAX;
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
    {
        
        data++;
        int result = data;
        printIntLine(result);
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
7347,0,CWE197_Numeric_Truncation_Error__short_listen_socket_01.c,"    short data;
    
    data = -1;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = (short)atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
15776,0,CWE457_Use_of_Uninitialized_Variable__double_14.c,"    double data;
    if(globalFive==5)
    {
        
        ; 
    }
    if(globalFive==5)
    {
        
        printDoubleLine(data);
"
7918,0,CWE190_Integer_Overflow__unsigned_int_max_add_41.c,"    unsigned int data;
    data = 0;
    
    data = UINT_MAX;
"
14723,0,CWE190_Integer_Overflow__unsigned_int_rand_add_83_bad.cpp,"Label Definition File: CWE190_Integer_Overflow.label.xml
Template File: sources-sinks-83_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 190 Integer Overflow
 * BadSource: rand Set data to result of rand()
 * GoodSource: Set data to a small, non-zero number (two)
 * Sinks: add
 *    GoodSink: Ensure there will not be an overflow before adding 1 to data
 *    BadSink : Add 1 to data, which can cause an overflow
 * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE190_Integer_Overflow__unsigned_int_rand_add_83.h""

namespace CWE190_Integer_Overflow__unsigned_int_rand_add_83
{
CWE190_Integer_Overflow__unsigned_int_rand_add_83_bad::CWE190_Integer_Overflow__unsigned_int_rand_add_83_bad(unsigned int dataCopy)
{
    data = dataCopy;
    
    data = (unsigned int)RAND32();
}

CWE190_Integer_Overflow__unsigned_int_rand_add_83_bad::~CWE190_Integer_Overflow__unsigned_int_rand_add_83_bad()
{
    {
        
        unsigned int result = data + 1;
        printUnsignedLine(result);
    }
}
}
"
3674,0,CWE590_Free_Memory_Not_on_Heap__delete_array_int_alloca_05.cpp,"    int * data;
    data = NULL; 
    if(staticTrue)
    {
        {
            
            int * dataBuffer = (int *)ALLOCA(100*sizeof(int));
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5;
                }
            }
            data = dataBuffer;
        }
    }
    printIntLine(data[0]);
    
"
1426,0,CWE190_Integer_Overflow__short_rand_add_32.c,"    short data;
    short *dataPtr1 = &data;
    short *dataPtr2 = &data;
    data = 0;
    {
        short data = *dataPtr1;
        
        data = (short)RAND32();
        *dataPtr1 = data;
    }
    {
        short data = *dataPtr2;
        {
            
            short result = data + 1;
            printIntLine(result);
        }
"
15915,0,CWE457_Use_of_Uninitialized_Variable__new_int_array_no_init_10.cpp,"    int * data;
    data = new int[10];
    if(globalTrue)
    {
        
        ; 
    }
    if(globalTrue)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i]);
            }
        }
        
        delete [] data;
"
12164,0,CWE415_Double_Free__new_delete_array_class_66a.cpp,"    TwoIntsClass * data;
    TwoIntsClass * dataArray[5];
    
    data = NULL;
    data = new TwoIntsClass[100];
    
    delete [] data;
    
    dataArray[2] = data;
"
500,0,CWE415_Double_Free__malloc_free_struct_83_bad.cpp,"Label Definition File: CWE415_Double_Free__malloc_free.label.xml
Template File: sources-sinks-83_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 415 Double Free
 * BadSource:  Allocate data using malloc() and Deallocate data using free()
 * GoodSource: Allocate data using malloc()
 * Sinks:
 *    GoodSink: do nothing
 *    BadSink : Deallocate data using free()
 * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE415_Double_Free__malloc_free_struct_83.h""

namespace CWE415_Double_Free__malloc_free_struct_83
{
CWE415_Double_Free__malloc_free_struct_83_bad::CWE415_Double_Free__malloc_free_struct_83_bad(twoIntsStruct * dataCopy)
{
    data = dataCopy;
    data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
    if (data == NULL) {exit(-1);}
    
    free(data);
}

CWE415_Double_Free__malloc_free_struct_83_bad::~CWE415_Double_Free__malloc_free_struct_83_bad()
{
    
    free(data);
}
}
"
4349,0,CWE134_Uncontrolled_Format_String__char_environment_vprintf_41.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        
        if (environment != NULL)
        {
            
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
"
10077,0,CWE190_Integer_Overflow__int_max_square_82a.cpp,"    int data;
    
    data = 0;
    
    data = INT_MAX;
    CWE190_Integer_Overflow__int_max_square_82_base* baseObject = new CWE190_Integer_Overflow__int_max_square_82_bad;
    baseObject->action(data);
"
316,0,CWE252_Unchecked_Return_Value__char_fscanf_15.c,"    switch(6)
    {
    case 6:
    {
        /* By initializing dataBuffer, we ensure this will not be the
         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
        char dataBuffer[100] = """";
        char * data = dataBuffer;
        
        fscanf(stdin, ""%99s\0"", data);
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
9966,0,CWE590_Free_Memory_Not_on_Heap__delete_array_struct_static_04.cpp,"    twoIntsStruct * data;
    data = NULL; 
    if(STATIC_CONST_TRUE)
    {
        {
            
            static twoIntsStruct dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i].intOne = 1;
                    dataBuffer[i].intTwo = 1;
                }
            }
            data = dataBuffer;
        }
    }
    printStructLine(&data[0]);
    
"
18996,0,CWE190_Integer_Overflow__unsigned_int_rand_multiply_84a.cpp,"    unsigned int data;
    data = 0;
    CWE190_Integer_Overflow__unsigned_int_rand_multiply_84_bad * badObject = new CWE190_Integer_Overflow__unsigned_int_rand_multiply_84_bad(data);
"
17564,0,CWE590_Free_Memory_Not_on_Heap__delete_array_struct_alloca_82_bad.cpp,"Label Definition File: CWE590_Free_Memory_Not_on_Heap__delete_array.label.xml
Template File: sources-sink-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 590 Free Memory Not on Heap
 * BadSource: alloca Data buffer is allocated on the stack with alloca()
 * GoodSource: Allocate memory on the heap
 * Sinks:
 *    BadSink : Print then free data
 * Flow Variant: 82 Data flow: data passed in a parameter to a virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE590_Free_Memory_Not_on_Heap__delete_array_struct_alloca_82.h""

namespace CWE590_Free_Memory_Not_on_Heap__delete_array_struct_alloca_82
{

void CWE590_Free_Memory_Not_on_Heap__delete_array_struct_alloca_82_bad::action(twoIntsStruct * data)
{
    printStructLine(&data[0]);
    
    delete [] data;
}

}
"
8509,0,CWE415_Double_Free__new_delete_long_09.cpp,"    long * data;
    
    data = NULL;
    if(GLOBAL_CONST_TRUE)
    {
        data = new long;
        
        delete data;
    }
    if(GLOBAL_CONST_TRUE)
    {
        
        delete data;
"
9268,0,CWE369_Divide_by_Zero__float_fscanf_74a.cpp,"    float data;
    map<int, float> dataMap;
    
    data = 0.0F;
    
    fscanf (stdin, ""%f"", &data);
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
8163,0,CWE476_NULL_Pointer_Dereference__class_05.cpp,"    TwoIntsClass * data;
    if(staticTrue)
    {
        
        data = NULL;
    }
    if(staticTrue)
    {
        
        printIntLine(data->intOne);
        
        delete data;
"
11649,0,CWE590_Free_Memory_Not_on_Heap__delete_int64_t_alloca_14.cpp,"    int64_t * data;
    data = NULL; 
    if(globalFive==5)
    {
        {
            
            int64_t * dataBuffer = (int64_t *)ALLOCA(sizeof(int64_t));
            *dataBuffer = 5LL;
            data = dataBuffer;
        }
    }
    printLongLongLine(*data);
    
"
17766,1,CWE758_Undefined_Behavior__int_malloc_use_12.c,"    if(globalReturnsTrueOrFalse())
    {
        {
            int data;
            int * pointer = (int *)malloc(sizeof(int));
            if (pointer == NULL) {exit(-1);}
            data = 5;
            *pointer = data; 
            {
                int data = *pointer;
                printIntLine(data);
            }
            free(pointer);
        }
    }
    else
    {
        {
            int data;
            int * pointer = (int *)malloc(sizeof(int));
            if (pointer == NULL) {exit(-1);}
            data = 5;
            *pointer = data; 
            {
                int data = *pointer;
                printIntLine(data);
            }
            free(pointer);
        }
"
9124,0,CWE190_Integer_Overflow__int_max_add_13.c,"    int data;
    
    data = 0;
    if(GLOBAL_CONST_FIVE==5)
    {
        
        data = INT_MAX;
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            
            int result = data + 1;
            printIntLine(result);
        }
"
1783,1,CWE252_Unchecked_Return_Value__char_sscanf_13.c,"    if(GLOBAL_CONST_FIVE==5)
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            
            if (sscanf(SRC, ""%99s\0"", data) == EOF)
            {
                printLine(""sscanf failed!"");
            }
        }
"
12400,0,CWE590_Free_Memory_Not_on_Heap__delete_char_declare_53a.cpp,"    char * data;
    data = NULL; 
    {
        
        char dataBuffer;
        dataBuffer = 'A';
        data = &dataBuffer;
    }
"
1715,0,CWE190_Integer_Overflow__int_listen_socket_add_53a.c,"    int data;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
9524,0,CWE690_NULL_Deref_From_Return__struct_realloc_33.cpp,"    twoIntsStruct * data;
    twoIntsStruct * &dataRef = data;
    data = NULL; 
    
    data = (twoIntsStruct *)realloc(data, 1*sizeof(twoIntsStruct));
    {
        twoIntsStruct * data = dataRef;
        
        data[0].intOne = 1;
        data[0].intTwo = 1;
        printStructLine(&data[0]);
        free(data);
"
18120,0,CWE476_NULL_Pointer_Dereference__class_82_bad.cpp,"Label Definition File: CWE476_NULL_Pointer_Dereference__class.label.xml
Template File: sources-sinks-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 476 NULL Pointer Dereference
 * BadSource:  Set data to NULL
 * GoodSource: Initialize data
 * Sinks:
 *    GoodSink: Check data for NULL before attempting to print data->a
 *    BadSink : Print data->a
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE476_NULL_Pointer_Dereference__class_82.h""

namespace CWE476_NULL_Pointer_Dereference__class_82
{

void CWE476_NULL_Pointer_Dereference__class_82_bad::action(TwoIntsClass * data)
{
    
    printIntLine(data->intOne);
    
    delete data;
}

}
"
13161,0,CWE563_Unused_Variable__unused_uninit_variable_int_15.c,"    int data;
    
    ; 
    switch(6)
    {
    case 6:
        
        
        ; 
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
7940,0,CWE190_Integer_Overflow__int_listen_socket_postinc_18.c,"    int data;
    
    data = 0;
    goto source;
source:
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    goto sink;
sink:
    {
        
        data++;
        int result = data;
        printIntLine(result);
"
8340,0,CWE78_OS_Command_Injection__char_connect_socket_system_43.cpp,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    badSource(data);
    
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
    }
}

#endif 

#ifndef OMITGOOD


"
12689,0,CWE401_Memory_Leak__new_array_int_65a.cpp,"    int * data;
    
    void (*funcPtr) (int *) = badSink;
    data = NULL;
    
    data = new int[100];
    
    data[0] = 5;
    printIntLine(data[0]);
    
"
11075,0,CWE467_Use_of_sizeof_on_Pointer_Type__short_12.c,"    if(globalReturnsTrueOrFalse())
    {
        {
            short * badShort = NULL;
            
            badShort = (short *)malloc(sizeof(badShort));
            if (badShort == NULL) {exit(-1);}
            *badShort = 5;
            printShortLine(*badShort);
            free(badShort);
        }
    }
    else
    {
        {
            short * goodShort = NULL;
            
            goodShort = (short *)malloc(sizeof(*goodShort));
            if (goodShort == NULL) {exit(-1);}
            *goodShort = 6;
            printShortLine(*goodShort);
            free(goodShort);
        }
"
3854,0,CWE563_Unused_Variable__unused_init_variable_struct_08.c,"    twoIntsStruct data;
    
    data.intOne = 0;
    data.intTwo = 0;
    if(staticReturnsTrue())
    {
        
        
        ; 
"
16927,0,CWE590_Free_Memory_Not_on_Heap__delete_long_static_53a.cpp,"    long * data;
    data = NULL; 
    {
        
        static long dataBuffer;
        dataBuffer = 5L;
        data = &dataBuffer;
    }
"
13965,0,CWE197_Numeric_Truncation_Error__short_large_81_bad.cpp,"Label Definition File: CWE197_Numeric_Truncation_Error__short.label.xml
Template File: sources-sink-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 197 Numeric Truncation Error
 * BadSource: large Set data to a number larger than CHAR_MAX
 * GoodSource: Less than CHAR_MAX
 * Sinks:
 *    BadSink : Convert data to a char
 * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE197_Numeric_Truncation_Error__short_large_81.h""

namespace CWE197_Numeric_Truncation_Error__short_large_81
{

void CWE197_Numeric_Truncation_Error__short_large_81_bad::action(short data) const
{
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
    }
}

}
"
2303,0,CWE401_Memory_Leak__char_calloc_03.c,"    char * data;
    data = NULL;
    if(5==5)
    {
        
        data = (char *)calloc(100, sizeof(char));
        if (data == NULL) {exit(-1);}
        
        strcpy(data, ""A String"");
        printLine(data);
    }
    if(5==5)
    {
        
        ; 
"
10771,0,CWE401_Memory_Leak__char_malloc_74a.cpp,"    char * data;
    map<int, char *> dataMap;
    data = NULL;
    
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    
    strcpy(data, ""A String"");
    printLine(data);
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
3343,0,CWE690_NULL_Deref_From_Return__char_malloc_33.cpp,"    char * data;
    char * &dataRef = data;
    data = NULL; 
    
    data = (char *)malloc(20*sizeof(char));
    {
        char * data = dataRef;
        
        strcpy(data, ""Initialize"");
        printLine(data);
        free(data);
"
5722,0,CWE190_Integer_Overflow__int_max_preinc_66a.c,"    int data;
    int dataArray[5];
    
    data = 0;
    
    data = INT_MAX;
    
    dataArray[2] = data;
"
8871,0,CWE78_OS_Command_Injection__char_file_execlp_65a.c,"    char * data;
    
    void (*funcPtr) (char *) = CWE78_OS_Command_Injection__char_file_execlp_65b_badSink;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        FILE * pFile;
        
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
    
"
18249,0,CWE197_Numeric_Truncation_Error__int_fscanf_to_char_11.c,"    int data;
    
    data = -1;
    if(globalReturnsTrue())
    {
        
        fscanf(stdin, ""%d"", &data);
    }
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
12692,0,CWE134_Uncontrolled_Format_String__char_file_vfprintf_72a.cpp,"    char * data;
    vector<char *> dataVector;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        FILE * pFile;
        
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
7350,0,CWE690_NULL_Deref_From_Return__char_malloc_43.cpp,"    char * data;
    data = NULL; 
    badSource(data);
    
    strcpy(data, ""Initialize"");
    printLine(data);
"
7414,0,CWE416_Use_After_Free__malloc_free_char_05.c,"    char * data;
    
    data = NULL;
    if(staticTrue)
    {
        data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        memset(data, 'A', 100-1);
        data[100-1] = '\0';
        
        free(data);
    }
    if(staticTrue)
    {
        
        printLine(data);
        
"
7909,0,CWE369_Divide_by_Zero__int_fscanf_divide_06.c,"    int data;
    
    data = -1;
    if(STATIC_CONST_FIVE==5)
    {
        
        fscanf(stdin, ""%d"", &data);
    }
    if(STATIC_CONST_FIVE==5)
    {
        
        printIntLine(100 / data);
"
17277,0,CWE590_Free_Memory_Not_on_Heap__delete_long_declare_18.cpp,"    long * data;
    data = NULL; 
    goto source;
source:
    {
        
        long dataBuffer;
        dataBuffer = 5L;
        data = &dataBuffer;
    }
    printLongLine(*data);
    
"
443,0,CWE134_Uncontrolled_Format_String__char_console_snprintf_41.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        
        if (100-dataLen > 1)
        {
            
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgets() */
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
                    data[dataLen-1] = '\0';
                }
            }
            else
            {
                printLine(""fgets() failed"");
                
                data[dataLen] = '\0';
            }
        }
    }
"
4409,0,CWE590_Free_Memory_Not_on_Heap__delete_char_placement_new_41.cpp,"    char * data;
    data = NULL; 
    {
        
        char buffer[sizeof(char)];
        char * dataBuffer = new(buffer) char;
        *dataBuffer = 'A';
        data = dataBuffer;
    }
"
9146,0,CWE590_Free_Memory_Not_on_Heap__delete_array_char_alloca_11.cpp,"    char * data;
    data = NULL; 
    if(globalReturnsTrue())
    {
        {
            
            char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
            memset(dataBuffer, 'A', 100-1); 
            dataBuffer[100-1] = '\0'; 
            data = dataBuffer;
        }
    }
    printLine(data);
    
"
11280,0,CWE690_NULL_Deref_From_Return__struct_malloc_52a.c,"    twoIntsStruct * data;
    data = NULL; 
    
    data = (twoIntsStruct *)malloc(1*sizeof(twoIntsStruct));
"
4048,0,CWE190_Integer_Overflow__int64_t_fscanf_add_73a.cpp,"    int64_t data;
    list<int64_t> dataList;
    data = 0LL;
    
    fscanf (stdin, ""%"" SCNd64, &data);
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
11185,0,CWE401_Memory_Leak__int_calloc_32.c,"    int * data;
    int * *dataPtr1 = &data;
    int * *dataPtr2 = &data;
    data = NULL;
    {
        int * data = *dataPtr1;
        
        data = (int *)calloc(100, sizeof(int));
        if (data == NULL) {exit(-1);}
        
        data[0] = 5;
        printIntLine(data[0]);
        *dataPtr1 = data;
    }
    {
        int * data = *dataPtr2;
        
        ; 
"
17600,0,CWE190_Integer_Overflow__int64_t_max_multiply_52a.c,"    int64_t data;
    data = 0LL;
    
    data = LLONG_MAX;
"
15311,0,CWE590_Free_Memory_Not_on_Heap__free_int64_t_declare_01.c,"    int64_t * data;
    data = NULL; 
    {
        
        int64_t dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5LL;
            }
        }
        data = dataBuffer;
    }
    printLongLongLine(data[0]);
    
"
11834,0,CWE758_Undefined_Behavior__long_alloca_use_13.c,"    if(GLOBAL_CONST_FIVE==5)
    {
        {
            long * pointer = (long *)ALLOCA(sizeof(long));
            long data = *pointer; 
            printLongLine(data);
        }
"
14960,1,CWE758_Undefined_Behavior__int64_t_malloc_use_08.c,"    if(staticReturnsTrue())
    {
        {
            int64_t data;
            int64_t * pointer = (int64_t *)malloc(sizeof(int64_t));
            if (pointer == NULL) {exit(-1);}
            data = 5LL;
            *pointer = data; 
            {
                int64_t data = *pointer;
                printLongLongLine(data);
            }
            free(pointer);
        }
"
12449,0,CWE590_Free_Memory_Not_on_Heap__delete_array_char_static_45.cpp,"    char * data;
    data = NULL; 
    {
        
        static char dataBuffer[100];
        memset(dataBuffer, 'A', 100-1); 
        dataBuffer[100-1] = '\0'; 
        data = dataBuffer;
    }
    badData = data;
"
1892,0,CWE134_Uncontrolled_Format_String__char_connect_socket_printf_21.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    badStatic = 1; 
"
14660,0,CWE563_Unused_Variable__unused_uninit_variable_int_07.c,"    int data;
    
    ; 
    if(staticFive==5)
    {
        
        
        ; 
"
7892,0,CWE401_Memory_Leak__malloc_realloc_char_09.c,"    if(GLOBAL_CONST_TRUE)
    {
        {
            char * data = (char *)malloc(100*sizeof(char));
            if (data == NULL) {exit(-1);}
            
            strcpy(data, ""A String"");
            printLine(data);
            
            data = (char *)realloc(data, (130000)*sizeof(char));
            if (data != NULL)
            {
                
                strcpy(data, ""New String"");
                printLine(data);
                free(data);
            }
        }
"
10504,0,CWE401_Memory_Leak__struct_twoIntsStruct_realloc_61a.c,"    struct _twoIntsStruct * data;
    data = NULL;
    data = CWE401_Memory_Leak__struct_twoIntsStruct_realloc_61b_badSource(data);
    
"
11261,0,CWE401_Memory_Leak__struct_twoIntsStruct_malloc_74a.cpp,"    struct _twoIntsStruct * data;
    map<int, struct _twoIntsStruct *> dataMap;
    data = NULL;
    
    data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));
    if (data == NULL) {exit(-1);}
    
    data[0].intOne = 0;
    data[0].intTwo = 0;
    printStructLine((twoIntsStruct *)&data[0]);
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
13264,0,CWE457_Use_of_Uninitialized_Variable__double_array_malloc_partial_init_07.c,"    double * data;
    data = (double *)malloc(10*sizeof(double));
    if (data == NULL) {exit(-1);}
    if(staticFive==5)
    {
        
        {
            int i;
            for(i=0; i<(10/2); i++)
            {
                data[i] = (double)i;
            }
        }
    }
    if(staticFive==5)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printDoubleLine(data[i]);
            }
        }
"
6547,0,CWE190_Integer_Overflow__int64_t_rand_postinc_04.c,"    int64_t data;
    data = 0LL;
    if(STATIC_CONST_TRUE)
    {
        
        data = (int64_t)RAND64();
    }
    if(STATIC_CONST_TRUE)
    {
        {
            
            data++;
            int64_t result = data;
            printLongLongLine(result);
        }
"
16697,0,CWE197_Numeric_Truncation_Error__int_rand_to_char_01.c,"    int data;
    
    data = -1;
    
    data = RAND32();
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
15860,0,CWE590_Free_Memory_Not_on_Heap__delete_char_alloca_15.cpp,"    char * data;
    data = NULL; 
    switch(6)
    {
    case 6:
    {
        
        char * dataBuffer = (char *)ALLOCA(sizeof(char));
        *dataBuffer = 'A';
        data = dataBuffer;
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    printHexCharLine(*data);
    
"
15614,0,CWE369_Divide_by_Zero__int_connect_socket_modulo_04.c,"    int data;
    
    data = -1;
    if(STATIC_CONST_TRUE)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(STATIC_CONST_TRUE)
    {
        
        printIntLine(100 % data);
"
9857,0,CWE190_Integer_Overflow__int_fscanf_add_64a.c,"    int data;
    
    data = 0;
    
    fscanf(stdin, ""%d"", &data);
"
16955,0,CWE467_Use_of_sizeof_on_Pointer_Type__int_01.c,"    {
        int * badInt = NULL;
        
        badInt = (int *)malloc(sizeof(badInt));
        if (badInt == NULL) {exit(-1);}
        *badInt = 5;
        printIntLine(*badInt);
        free(badInt);
"
14448,0,CWE401_Memory_Leak__twoIntsStruct_realloc_22a.c,"    twoIntsStruct * data;
    data = NULL;
    
    data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));
    if (data == NULL) {exit(-1);}
    
    data[0].intOne = 0;
    data[0].intTwo = 0;
    printStructLine(&data[0]);
    CWE401_Memory_Leak__twoIntsStruct_realloc_22_badGlobal = 1; 
"
16945,0,CWE415_Double_Free__new_delete_int64_t_11.cpp,"    int64_t * data;
    
    data = NULL;
    if(globalReturnsTrue())
    {
        data = new int64_t;
        
        delete data;
    }
    if(globalReturnsTrue())
    {
        
        delete data;
"
8456,0,CWE690_NULL_Deref_From_Return__struct_malloc_42.c,"    twoIntsStruct * data;
    data = NULL; 
    data = badSource(data);
    
    data[0].intOne = 1;
    data[0].intTwo = 1;
    printStructLine(&data[0]);
"
6985,0,CWE590_Free_Memory_Not_on_Heap__free_int64_t_static_13.c,"    int64_t * data;
    data = NULL; 
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            
            static int64_t dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5LL;
                }
            }
            data = dataBuffer;
        }
    }
    printLongLongLine(data[0]);
    
"
4164,1,CWE758_Undefined_Behavior__int64_t_alloca_use_02.c,"    if(1)
    {
        {
            int64_t data;
            int64_t * pointer = (int64_t *)ALLOCA(sizeof(int64_t));
            data = 5LL;
            *pointer = data; 
            {
                int64_t data = *pointer;
                printLongLongLine(data);
            }
        }
"
7969,0,CWE401_Memory_Leak__char_malloc_81a.cpp,"    char * data;
    data = NULL;
    
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    
    strcpy(data, ""A String"");
    printLine(data);
    const CWE401_Memory_Leak__char_malloc_81_base& baseObject = CWE401_Memory_Leak__char_malloc_81_bad();
"
9465,0,CWE690_NULL_Deref_From_Return__int64_t_malloc_04.c,"    int64_t * data;
    data = NULL; 
    
    data = (int64_t *)malloc(1*sizeof(int64_t));
    if(STATIC_CONST_TRUE)
    {
        
        data[0] = 5LL;
        printLongLongLine(data[0]);
        free(data);
"
674,0,CWE78_OS_Command_Injection__char_listen_socket_execlp_67a.c,"    char * data;
    CWE78_OS_Command_Injection__char_listen_socket_execlp_67_structType myStruct;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    myStruct.structFirst = data;
"
19240,0,CWE415_Double_Free__new_delete_long_07.cpp,"    long * data;
    
    data = NULL;
    if(staticFive==5)
    {
        data = new long;
        
        delete data;
    }
    if(staticFive==5)
    {
        
        delete data;
"
19369,0,CWE197_Numeric_Truncation_Error__int_listen_socket_to_short_04.c,"    int data;
    
    data = -1;
    if(STATIC_CONST_TRUE)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    {
        
        short shortData = (short)data;
        printShortLine(shortData);
"
12304,0,CWE563_Unused_Variable__unused_init_variable_long_33.cpp,"    long data;
    long &dataRef = data;
    
    data = 5L;
    {
        long data = dataRef;
        
        
        ; 
"
14239,0,CWE590_Free_Memory_Not_on_Heap__free_struct_static_10.c,"    twoIntsStruct * data;
    data = NULL; 
    if(globalTrue)
    {
        {
            
            static twoIntsStruct dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i].intOne = 1;
                    dataBuffer[i].intTwo = 1;
                }
            }
            data = dataBuffer;
        }
    }
    printStructLine(&data[0]);
    
"
13955,0,CWE415_Double_Free__new_delete_long_10.cpp,"    long * data;
    
    data = NULL;
    if(globalTrue)
    {
        data = new long;
        
        delete data;
    }
    if(globalTrue)
    {
        
        delete data;
"
19219,0,CWE190_Integer_Overflow__int_connect_socket_preinc_54a.c,"    int data;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
12129,0,CWE190_Integer_Overflow__int_connect_socket_postinc_65a.c,"    int data;
    
    void (*funcPtr) (int) = CWE190_Integer_Overflow__int_connect_socket_postinc_65b_badSink;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
"
857,1,CWE252_Unchecked_Return_Value__char_puts_01.c,"    
    if (PUTS(""string"") == EOF)
    {
        printLine(""puts failed!"");
"
13857,0,CWE134_Uncontrolled_Format_String__char_environment_fprintf_65a.c,"    char * data;
    
    void (*funcPtr) (char *) = CWE134_Uncontrolled_Format_String__char_environment_fprintf_65b_badSink;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        
        if (environment != NULL)
        {
            
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    
"
11278,0,CWE78_OS_Command_Injection__char_environment_execl_18.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    goto source;
source:
    {
        
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        
        if (environment != NULL)
        {
            
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    
    
"
12795,0,CWE369_Divide_by_Zero__int_fgets_divide_41.c,"    int data;
    
    data = -1;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
"
15390,0,CWE369_Divide_by_Zero__int_listen_socket_divide_22a.c,"    int data;
    
    data = -1;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    CWE369_Divide_by_Zero__int_listen_socket_divide_22_badGlobal = 1; 
"
13922,0,CWE190_Integer_Overflow__char_rand_add_17.c,"    int i,j;
    char data;
    data = ' ';
    for(i = 0; i < 1; i++)
    {
        
        data = (char)RAND32();
    }
    for(j = 0; j < 1; j++)
    {
        {
            
            char result = data + 1;
            printHexCharLine(result);
        }
"
4618,0,CWE190_Integer_Overflow__unsigned_int_rand_add_01.c,"    unsigned int data;
    data = 0;
    
    data = (unsigned int)RAND32();
    {
        
        unsigned int result = data + 1;
        printUnsignedLine(result);
"
15596,0,CWE590_Free_Memory_Not_on_Heap__delete_char_declare_82_bad.cpp,"Label Definition File: CWE590_Free_Memory_Not_on_Heap__delete.nonpointer.label.xml
Template File: sources-sink-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 590 Free Memory Not on Heap
 * BadSource: declare Data buffer is declared on the stack
 * GoodSource: Allocate memory on the heap
 * Sinks:
 *    BadSink : Print then free data
 * Flow Variant: 82 Data flow: data passed in a parameter to a virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE590_Free_Memory_Not_on_Heap__delete_char_declare_82.h""

namespace CWE590_Free_Memory_Not_on_Heap__delete_char_declare_82
{

void CWE590_Free_Memory_Not_on_Heap__delete_char_declare_82_bad::action(char * data)
{
    printHexCharLine(*data);
    
    delete data;
}

}
"
17745,0,CWE190_Integer_Overflow__int_fgets_add_72a.cpp,"    int data;
    vector<int> dataVector;
    
    data = 0;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
2493,0,CWE590_Free_Memory_Not_on_Heap__delete_int_alloca_07.cpp,"    int * data;
    data = NULL; 
    if(staticFive==5)
    {
        {
            
            int * dataBuffer = (int *)ALLOCA(sizeof(int));
            *dataBuffer = 5;
            data = dataBuffer;
        }
    }
    printIntLine(*data);
    
"
1334,0,CWE78_OS_Command_Injection__char_listen_socket_execl_41.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
15,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_66a.c,"    size_t data;
    size_t dataArray[5];
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = strtoul(inputBuffer, NULL, 0);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
    dataArray[2] = data;
"
15772,0,CWE190_Integer_Overflow__int_connect_socket_add_15.c,"    int data;
    
    data = 0;
    switch(6)
    {
    case 6:
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
    {
        
        int result = data + 1;
        printIntLine(result);
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
13615,1,CWE758_Undefined_Behavior__double_pointer_new_use_17.cpp,"    int k;
    for(k = 0; k < 1; k++)
    {
        {
            double * data;
            
            data = new double;
            *data = 5.0;
            double * * pointer = new double *;
            *pointer = data; 
            {
                double * data = *pointer;
                printDoubleLine(*data);
            }
            delete pointer;
        }
"
18182,0,CWE190_Integer_Overflow__short_fscanf_multiply_64a.c,"    short data;
    data = 0;
    
    fscanf (stdin, ""%hd"", &data);
"
3990,0,CWE190_Integer_Overflow__int64_t_max_add_51a.c,"    int64_t data;
    data = 0LL;
    
    data = LLONG_MAX;
"
1714,0,CWE690_NULL_Deref_From_Return__struct_calloc_67a.c,"    twoIntsStruct * data;
    CWE690_NULL_Deref_From_Return__struct_calloc_67_structType myStruct;
    data = NULL; 
    
    data = (twoIntsStruct *)calloc(1, sizeof(twoIntsStruct));
    myStruct.structFirst = data;
"
17384,0,CWE78_OS_Command_Injection__char_console_system_21.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    badStatic = 1; 
    data = badSource(data);
    
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
    }
}

#endif 

#ifndef OMITGOOD

"
19120,0,CWE134_Uncontrolled_Format_String__char_console_vprintf_62a.cpp,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    badSource(data);
"
12029,0,CWE190_Integer_Overflow__int64_t_fscanf_postinc_15.c,"    int64_t data;
    data = 0LL;
    switch(6)
    {
    case 6:
        
        fscanf (stdin, ""%"" SCNd64, &data);
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
    {
        
        data++;
        int64_t result = data;
        printLongLongLine(result);
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
4082,0,CWE190_Integer_Overflow__int_fgets_preinc_01.c,"    int data;
    
    data = 0;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    {
        
        ++data;
        int result = data;
        printIntLine(result);
"
2870,0,CWE190_Integer_Overflow__short_max_multiply_84a.cpp,"    short data;
    data = 0;
    CWE190_Integer_Overflow__short_max_multiply_84_bad * badObject = new CWE190_Integer_Overflow__short_max_multiply_84_bad(data);
"
12007,0,CWE457_Use_of_Uninitialized_Variable__twointsclass_array_new_partial_init_04.cpp,"    TwoIntsClass * data;
    data = new TwoIntsClass[10];
    if(STATIC_CONST_TRUE)
    {
        
        for(int i=0; i<(10/2); i++)
        {
            data[i].intOne = i;
            data[i].intTwo = i;
        }
    }
    if(STATIC_CONST_TRUE)
    {
        
        for(int i=0; i<10; i++)
        {
            printIntLine(data[i].intOne);
            printIntLine(data[i].intTwo);
        }
"
18891,0,CWE415_Double_Free__new_delete_array_class_21.cpp,"    TwoIntsClass * data;
    
    data = NULL;
    data = new TwoIntsClass[100];
    
    delete [] data;
    badStatic = 1; 
"
8570,0,CWE590_Free_Memory_Not_on_Heap__delete_array_struct_static_10.cpp,"    twoIntsStruct * data;
    data = NULL; 
    if(globalTrue)
    {
        {
            
            static twoIntsStruct dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i].intOne = 1;
                    dataBuffer[i].intTwo = 1;
                }
            }
            data = dataBuffer;
        }
    }
    printStructLine(&data[0]);
    
"
9347,0,CWE416_Use_After_Free__new_delete_char_14.cpp,"    char * data;
    
    data = NULL;
    if(globalFive==5)
    {
        data = new char;
        *data = 'A';
        
        delete data;
    }
    if(globalFive==5)
    {
        
        printHexCharLine(*data);
        
"
12783,0,CWE415_Double_Free__new_delete_array_struct_84_bad.cpp,"Label Definition File: CWE415_Double_Free__new_delete_array.label.xml
Template File: sources-sinks-84_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 415 Double Free
 * BadSource:  Allocate data using new and Deallocae data using delete
 * GoodSource: Allocate data using new
 * Sinks:
 *    GoodSink: do nothing
 *    BadSink : Deallocate data using delete
 * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE415_Double_Free__new_delete_array_struct_84.h""

namespace CWE415_Double_Free__new_delete_array_struct_84
{
CWE415_Double_Free__new_delete_array_struct_84_bad::CWE415_Double_Free__new_delete_array_struct_84_bad(twoIntsStruct * dataCopy)
{
    data = dataCopy;
    data = new twoIntsStruct[100];
    
    delete [] data;
}

CWE415_Double_Free__new_delete_array_struct_84_bad::~CWE415_Double_Free__new_delete_array_struct_84_bad()
{
    
    delete [] data;
}
}
"
1052,0,CWE190_Integer_Overflow__int64_t_max_add_04.c,"    int64_t data;
    data = 0LL;
    if(STATIC_CONST_TRUE)
    {
        
        data = LLONG_MAX;
    }
    if(STATIC_CONST_TRUE)
    {
        {
            
            int64_t result = data + 1;
            printLongLongLine(result);
        }
"
12470,0,CWE190_Integer_Overflow__int64_t_rand_add_67a.c,"    int64_t data;
    CWE190_Integer_Overflow__int64_t_rand_add_67_structType myStruct;
    data = 0LL;
    
    data = (int64_t)RAND64();
    myStruct.structFirst = data;
"
4279,0,CWE590_Free_Memory_Not_on_Heap__delete_array_class_alloca_02.cpp,"    TwoIntsClass * data;
    data = NULL; 
    if(1)
    {
        {
            
            TwoIntsClass * dataBuffer = (TwoIntsClass *)ALLOCA(100*sizeof(TwoIntsClass));
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i].intOne = 1;
                    dataBuffer[i].intTwo = 1;
                }
            }
            data = dataBuffer;
        }
    }
    printIntLine(data[0].intOne);
    
"
13010,0,CWE665_Improper_Initialization__char_cat_33.cpp,"    char * data;
    char * &dataRef = data;
    char dataBuffer[100];
    data = dataBuffer;
    
    ; 
    {
        char * data = dataRef;
        {
            char source[100];
            memset(source, 'C', 100-1); 
            source[100-1] = '\0'; 
            
            strcat(data, source);
            printLine(data);
        }
"
1211,0,CWE590_Free_Memory_Not_on_Heap__delete_class_static_33.cpp,"    TwoIntsClass * data;
    TwoIntsClass * &dataRef = data;
    data = NULL; 
    {
        
        static TwoIntsClass dataBuffer;
        dataBuffer.intOne = 1;
        dataBuffer.intTwo = 1;
        data = &dataBuffer;
    }
    {
        TwoIntsClass * data = dataRef;
        printIntLine(data->intOne);
        
        delete data;
"
9379,0,CWE401_Memory_Leak__twoIntsStruct_realloc_62a.cpp,"    twoIntsStruct * data;
    data = NULL;
    badSource(data);
    
"
10227,0,CWE369_Divide_by_Zero__int_zero_modulo_66a.c,"    int data;
    int dataArray[5];
    
    data = -1;
    
    data = 0;
    
    dataArray[2] = data;
"
7513,0,CWE401_Memory_Leak__new_twoIntsStruct_09.cpp,"    twoIntsStruct * data;
    data = NULL;
    if(GLOBAL_CONST_TRUE)
    {
        
        data = new twoIntsStruct;
        
        data->intOne = 0;
        data->intTwo = 0;
        printStructLine(data);
    }
    if(GLOBAL_CONST_TRUE)
    {
        
        ; 
"
12379,0,CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_68a.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_68_badData = data;
"
12037,0,CWE78_OS_Command_Injection__char_connect_socket_execl_83a.cpp,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
"
7087,0,CWE590_Free_Memory_Not_on_Heap__delete_class_alloca_08.cpp,"    TwoIntsClass * data;
    data = NULL; 
    if(staticReturnsTrue())
    {
        {
            
            TwoIntsClass * dataBuffer = (TwoIntsClass *)ALLOCA(sizeof(TwoIntsClass));
            dataBuffer->intOne = 2;
            dataBuffer->intTwo = 2;
            data = dataBuffer;
        }
    }
    printIntLine(data->intOne);
    
"
6860,0,CWE690_NULL_Deref_From_Return__int64_t_calloc_73a.cpp,"    int64_t * data;
    list<int64_t *> dataList;
    data = NULL; 
    
    data = (int64_t *)calloc(1, sizeof(int64_t));
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
7343,0,CWE758_Undefined_Behavior__struct_alloca_use_03.c,"    if(5==5)
    {
        {
            twoIntsStruct * pointer = (twoIntsStruct *)ALLOCA(sizeof(twoIntsStruct));
            twoIntsStruct data = *pointer; 
            printIntLine(data.intOne);
            printIntLine(data.intTwo);
        }
"
18735,0,CWE190_Integer_Overflow__char_max_multiply_53a.c,"    char data;
    data = ' ';
    
    data = CHAR_MAX;
"
546,1,CWE469_Use_of_Pointer_Subtraction_to_Determine_Size__char_15.c,"    switch(5)
    {
    case 6:
        
        printLine(""Benign, fixed string"");
        break;
    default:
    {
        char string1[] = SOURCE_STRING;
        char * slashInString1;
        size_t indexOfSlashInString1;
        slashInString1 = strchr(string1, '/');
        if (slashInString1 == NULL)
        {
            exit(1);
        }
        
        indexOfSlashInString1 = (size_t)(slashInString1 - string1);
        
        printUnsignedLine(indexOfSlashInString1);
    }
    break;
"
7584,0,CWE590_Free_Memory_Not_on_Heap__delete_struct_placement_new_53a.cpp,"    twoIntsStruct * data;
    data = NULL; 
    {
        
        char buffer[sizeof(twoIntsStruct)];
        twoIntsStruct * dataBuffer = new(buffer) twoIntsStruct;
        dataBuffer->intOne = 1;
        dataBuffer->intTwo = 1;
        data = dataBuffer;
    }
"
13940,0,CWE563_Unused_Variable__unused_uninit_variable_char_16.c,"    char data;
    
    ; 
    while(1)
    {
        
        
        ; 
        break;
"
4148,0,CWE758_Undefined_Behavior__int_new_use_08.cpp,"    if(staticReturnsTrue())
    {
        {
            int * pointer = new int;
            int data = *pointer; 
            delete pointer;
            printIntLine(data);
        }
"
4588,0,CWE197_Numeric_Truncation_Error__int_fgets_to_char_82a.cpp,"    int data;
    
    data = -1;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    CWE197_Numeric_Truncation_Error__int_fgets_to_char_82_base* baseObject = new CWE197_Numeric_Truncation_Error__int_fgets_to_char_82_bad;
    baseObject->action(data);
"
15128,0,CWE190_Integer_Overflow__unsigned_int_rand_postinc_32.c,"    unsigned int data;
    unsigned int *dataPtr1 = &data;
    unsigned int *dataPtr2 = &data;
    data = 0;
    {
        unsigned int data = *dataPtr1;
        
        data = (unsigned int)RAND32();
        *dataPtr1 = data;
    }
    {
        unsigned int data = *dataPtr2;
        {
            
            data++;
            unsigned int result = data;
            printUnsignedLine(result);
        }
"
13827,0,CWE416_Use_After_Free__new_delete_char_02.cpp,"    char * data;
    
    data = NULL;
    if(1)
    {
        data = new char;
        *data = 'A';
        
        delete data;
    }
    if(1)
    {
        
        printHexCharLine(*data);
        
"
14477,0,CWE190_Integer_Overflow__short_fscanf_multiply_16.c,"    short data;
    data = 0;
    while(1)
    {
        
        fscanf (stdin, ""%hd"", &data);
        break;
    }
    while(1)
    {
        if(data > 0) 
        {
            
            short result = data * 2;
            printIntLine(result);
        }
        break;
"
10404,0,CWE134_Uncontrolled_Format_String__char_file_printf_67a.c,"    char * data;
    CWE134_Uncontrolled_Format_String__char_file_printf_67_structType myStruct;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        FILE * pFile;
        
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
    myStruct.structFirst = data;
"
7419,0,CWE758_Undefined_Behavior__struct_pointer_new_use_16.cpp,"    while(1)
    {
        {
            twoIntsStruct * * pointer = new twoIntsStruct *;
            twoIntsStruct * data = *pointer; 
            delete pointer;
            printIntLine(data->intOne);
            printIntLine(data->intTwo);
        }
        break;
"
3737,0,CWE415_Double_Free__new_delete_array_int_42.cpp,"    int * data;
    
    data = NULL;
    data = badSource(data);
    
"
3723,0,CWE590_Free_Memory_Not_on_Heap__free_struct_declare_74a.cpp,"    twoIntsStruct * data;
    map<int, twoIntsStruct *> dataMap;
    data = NULL; 
    {
        
        twoIntsStruct dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i].intOne = 1;
                dataBuffer[i].intTwo = 1;
            }
        }
        data = dataBuffer;
    }
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
19183,0,CWE190_Integer_Overflow__short_max_postinc_10.c,"    short data;
    data = 0;
    if(globalTrue)
    {
        
        data = SHRT_MAX;
    }
    if(globalTrue)
    {
        {
            
            data++;
            short result = data;
            printIntLine(result);
        }
"
10379,1,CWE758_Undefined_Behavior__int64_t_alloca_use_18.c,"    goto sink;
sink:
    {
        int64_t data;
        int64_t * pointer = (int64_t *)ALLOCA(sizeof(int64_t));
        data = 5LL;
        *pointer = data; 
        {
            int64_t data = *pointer;
            printLongLongLine(data);
        }
"
1863,0,CWE197_Numeric_Truncation_Error__int_fgets_to_char_13.c,"    int data;
    
    data = -1;
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
12406,0,CWE401_Memory_Leak__struct_twoIntsStruct_realloc_51a.c,"    struct _twoIntsStruct * data;
    data = NULL;
    
    data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));
    if (data == NULL) {exit(-1);}
    
    data[0].intOne = 0;
    data[0].intTwo = 0;
    printStructLine((twoIntsStruct *)&data[0]);
"
15985,0,CWE415_Double_Free__malloc_free_int_65a.c,"    int * data;
    
    void (*funcPtr) (int *) = CWE415_Double_Free__malloc_free_int_65b_badSink;
    
    data = NULL;
    data = (int *)malloc(100*sizeof(int));
    if (data == NULL) {exit(-1);}
    
    free(data);
    
"
9041,0,CWE457_Use_of_Uninitialized_Variable__int_16.c,"    int data;
    while(1)
    {
        
        ; 
        break;
    }
    while(1)
    {
        
        printIntLine(data);
        break;
"
8181,0,CWE563_Unused_Variable__unused_uninit_variable_struct_08.c,"    twoIntsStruct data;
    
    ; 
    if(staticReturnsTrue())
    {
        
        
        ; 
"
6015,1,CWE758_Undefined_Behavior__double_pointer_malloc_use_12.c,"    if(globalReturnsTrueOrFalse())
    {
        {
            double * data;
            double * * pointer = (double * *)malloc(sizeof(double *));
            if (pointer == NULL) {exit(-1);}
            
            data = (double *)malloc(sizeof(double));
            if (data == NULL) {exit(-1);}
            *data = 5.0;
            *pointer = data; 
            {
                double * data = *pointer;
                printDoubleLine(*data);
            }
            free(pointer);
        }
    }
    else
    {
        {
            double * data;
            double * * pointer = (double * *)malloc(sizeof(double *));
            if (pointer == NULL) {exit(-1);}
            
            data = (double *)malloc(sizeof(double));
            if (data == NULL) {exit(-1);}
            *data = 5.0;
            *pointer = data; 
            {
                double * data = *pointer;
                printDoubleLine(*data);
            }
            free(pointer);
        }
"
11318,0,CWE190_Integer_Overflow__short_fscanf_square_84a.cpp,"    short data;
    data = 0;
    CWE190_Integer_Overflow__short_fscanf_square_84_bad * badObject = new CWE190_Integer_Overflow__short_fscanf_square_84_bad(data);
"
3109,0,CWE78_OS_Command_Injection__char_console_execl_12.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(globalReturnsTrueOrFalse())
    {
        {
            
            size_t dataLen = strlen(data);
            
            if (100-dataLen > 1)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
                {
                    /* The next few lines remove the carriage return from the string that is
                     * inserted by fgets() */
                    dataLen = strlen(data);
"
914,0,CWE665_Improper_Initialization__char_ncat_32.c,"    char * data;
    char * *dataPtr1 = &data;
    char * *dataPtr2 = &data;
    char dataBuffer[100];
    data = dataBuffer;
    {
        char * data = *dataPtr1;
        
        ; 
        *dataPtr1 = data;
    }
    {
        char * data = *dataPtr2;
        {
            size_t sourceLen;
            char source[100];
            memset(source, 'C', 100-1); 
            source[100-1] = '\0'; 
            sourceLen = strlen(source);
            
            strncat(data, source, sourceLen);
            printLine(data);
        }
"
8331,0,CWE78_OS_Command_Injection__char_console_execl_68a.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        
        if (100-dataLen > 1)
        {
            
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgets() */
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
                    data[dataLen-1] = '\0';
                }
            }
            else
            {
                printLine(""fgets() failed"");
                
                data[dataLen] = '\0';
            }
        }
    }
    CWE78_OS_Command_Injection__char_console_execl_68_badData = data;
"
3418,0,CWE401_Memory_Leak__int64_t_calloc_01.c,"    int64_t * data;
    data = NULL;
    
    data = (int64_t *)calloc(100, sizeof(int64_t));
    if (data == NULL) {exit(-1);}
    
    data[0] = 5LL;
    printLongLongLine(data[0]);
    
"
3223,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_65a.c,"    size_t data;
    
    void (*funcPtr) (size_t) = CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_65b_badSink;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = strtoul(inputBuffer, NULL, 0);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
"
19297,0,CWE590_Free_Memory_Not_on_Heap__free_long_declare_32.c,"    long * data;
    long * *dataPtr1 = &data;
    long * *dataPtr2 = &data;
    data = NULL; 
    {
        long * data = *dataPtr1;
        {
            
            long dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5L;
                }
            }
            data = dataBuffer;
        }
        *dataPtr1 = data;
    }
    {
        long * data = *dataPtr2;
        printLongLine(data[0]);
        
        free(data);
"
6524,1,CWE401_Memory_Leak__malloc_realloc_char_08.c,"    if(staticReturnsTrue())
    {
        {
            char * data = (char *)malloc(100*sizeof(char));
            if (data == NULL) {exit(-1);}
            char * tmpData;
            
            strcpy(data, ""A String"");
            printLine(data);
            tmpData = (char *)realloc(data, (130000)*sizeof(char));
            /* FIX: Ensure realloc() was successful before assigning data to the memory block
            * allocated with realloc() */
            if (tmpData != NULL)
            {
                data = tmpData;
                
                strcpy(data, ""New String"");
                printLine(data);
            }
            free(data);
        }
"
5432,0,CWE78_OS_Command_Injection__char_listen_socket_popen_51a.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
4590,0,CWE563_Unused_Variable__unused_value_int_05.c,"    int data;
    if(staticTrue)
    {
        
        data = 5;
    }
    if(staticTrue)
    {
        
        data = 10;
        printIntLine(data);
"
14595,0,CWE590_Free_Memory_Not_on_Heap__free_int_alloca_01.c,"    int * data;
    data = NULL; 
    {
        
        int * dataBuffer = (int *)ALLOCA(100*sizeof(int));
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5;
            }
        }
        data = dataBuffer;
    }
    printIntLine(data[0]);
    
"
5170,0,CWE190_Integer_Overflow__unsigned_int_rand_add_81a.cpp,"    unsigned int data;
    data = 0;
    
    data = (unsigned int)RAND32();
    const CWE190_Integer_Overflow__unsigned_int_rand_add_81_base& baseObject = CWE190_Integer_Overflow__unsigned_int_rand_add_81_bad();
"
7425,0,CWE415_Double_Free__new_delete_class_01.cpp,"    TwoIntsClass * data;
    
    data = NULL;
    data = new TwoIntsClass;
    
    delete data;
    
"
10507,0,CWE401_Memory_Leak__int_malloc_44.c,"    int * data;
    
    void (*funcPtr) (int *) = badSink;
    data = NULL;
    
    data = (int *)malloc(100*sizeof(int));
    if (data == NULL) {exit(-1);}
    
    data[0] = 5;
    printIntLine(data[0]);
    
"
19535,0,CWE197_Numeric_Truncation_Error__short_connect_socket_68a.c,"    short data;
    
    data = -1;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = (short)atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    CWE197_Numeric_Truncation_Error__short_connect_socket_68_badData = data;
"
8073,0,CWE590_Free_Memory_Not_on_Heap__free_char_declare_32.c,"    char * data;
    char * *dataPtr1 = &data;
    char * *dataPtr2 = &data;
    data = NULL; 
    {
        char * data = *dataPtr1;
        {
            
            char dataBuffer[100];
            memset(dataBuffer, 'A', 100-1); 
            dataBuffer[100-1] = '\0'; 
            data = dataBuffer;
        }
        *dataPtr1 = data;
    }
    {
        char * data = *dataPtr2;
        printLine(data);
        
        free(data);
"
10388,0,CWE197_Numeric_Truncation_Error__int_rand_to_short_33.cpp,"    int data;
    int &dataRef = data;
    
    data = -1;
    
    data = RAND32();
    {
        int data = dataRef;
        {
            
            short shortData = (short)data;
            printShortLine(shortData);
        }
"
19519,0,CWE190_Integer_Overflow__int_connect_socket_multiply_18.c,"    int data;
    
    data = 0;
    goto source;
source:
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    goto sink;
sink:
    if(data > 0) 
    {
        
        int result = data * 2;
        printIntLine(result);
"
2421,0,CWE415_Double_Free__new_delete_array_struct_12.cpp,"    twoIntsStruct * data;
    
    data = NULL;
    if(globalReturnsTrueOrFalse())
    {
        data = new twoIntsStruct[100];
        
        delete [] data;
    }
    else
    {
        data = new twoIntsStruct[100];
        
    }
    if(globalReturnsTrueOrFalse())
    {
        
        delete [] data;
    }
    else
    {
        
        
        ; 
"
17855,0,CWE415_Double_Free__new_delete_array_char_12.cpp,"    char * data;
    
    data = NULL;
    if(globalReturnsTrueOrFalse())
    {
        data = new char[100];
        
        delete [] data;
    }
    else
    {
        data = new char[100];
        
    }
    if(globalReturnsTrueOrFalse())
    {
        
        delete [] data;
    }
    else
    {
        
        
        ; 
"
2657,0,CWE190_Integer_Overflow__int_rand_multiply_07.c,"    int data;
    
    data = 0;
    if(staticFive==5)
    {
        
        data = RAND32();
    }
    if(staticFive==5)
    {
        if(data > 0) 
        {
            
            int result = data * 2;
            printIntLine(result);
        }
"
15876,0,CWE190_Integer_Overflow__unsigned_int_rand_add_64a.c,"    unsigned int data;
    data = 0;
    
    data = (unsigned int)RAND32();
"
18801,0,CWE78_OS_Command_Injection__char_file_execlp_17.c,"    int i;
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    for(i = 0; i < 1; i++)
    {
        {
            
            size_t dataLen = strlen(data);
            FILE * pFile;
            
            if (100-dataLen > 1)
            {
                pFile = fopen(FILENAME, ""r"");
                if (pFile != NULL)
                {
                    
                    if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                    {
                        printLine(""fgets() failed"");
                        
                        data[dataLen] = '\0';
                    }
                    fclose(pFile);
                }
            }
        }
    }
    /* execlp - searches for the location of the command among
     * the directories specified by the PATH environment variable */
    
"
2665,0,CWE457_Use_of_Uninitialized_Variable__struct_array_declare_partial_init_14.c,"    twoIntsStruct * data;
    twoIntsStruct dataUninitArray[10];
    data = dataUninitArray;
    if(globalFive==5)
    {
        
        {
            int i;
            for(i=0; i<(10/2); i++)
            {
                data[i].intOne = i;
                data[i].intTwo = i;
            }
        }
    }
    if(globalFive==5)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i].intOne);
                printIntLine(data[i].intTwo);
            }
        }
"
14694,0,CWE563_Unused_Variable__unused_value_int_81_bad.cpp,"Label Definition File: CWE563_Unused_Variable__unused_value.label.xml
Template File: sources-sinks-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 563 Unused Variable
 * BadSource:  Initialize data
 * GoodSource: Initialize and use data
 * Sinks:
 *    GoodSink: Use data
 *    BadSink : Initialize and use data
 * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE563_Unused_Variable__unused_value_int_81.h""

namespace CWE563_Unused_Variable__unused_value_int_81
{

void CWE563_Unused_Variable__unused_value_int_81_bad::action(int data) const
{
    
    data = 10;
    printIntLine(data);
}

}
"
16490,0,CWE401_Memory_Leak__new_array_int64_t_45.cpp,"    int64_t * data;
    data = NULL;
    
    data = new int64_t[100];
    
    data[0] = 5LL;
    printLongLongLine(data[0]);
    badData = data;
"
7316,0,CWE690_NULL_Deref_From_Return__struct_realloc_41.c,"    twoIntsStruct * data;
    data = NULL; 
    
    data = (twoIntsStruct *)realloc(data, 1*sizeof(twoIntsStruct));
"
14697,0,CWE415_Double_Free__new_delete_array_char_41.cpp,"    char * data;
    
    data = NULL;
    data = new char[100];
    
    delete [] data;
"
15947,0,CWE134_Uncontrolled_Format_String__char_console_printf_41.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        
        if (100-dataLen > 1)
        {
            
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgets() */
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
                    data[dataLen-1] = '\0';
                }
            }
            else
            {
                printLine(""fgets() failed"");
                
                data[dataLen] = '\0';
            }
        }
    }
"
14271,0,CWE590_Free_Memory_Not_on_Heap__delete_class_placement_new_16.cpp,"    TwoIntsClass * data;
    data = NULL; 
    while(1)
    {
        {
            
            char buffer[sizeof(TwoIntsClass)];
            TwoIntsClass * dataBuffer = new(buffer) TwoIntsClass;
            dataBuffer->intOne = 2;
            dataBuffer->intTwo = 2;
            data = dataBuffer;
        }
        break;
    }
    printIntLine(data->intOne);
    
"
2040,0,CWE369_Divide_by_Zero__float_listenSocket_72a.cpp,"    float data;
    vector<float> dataVector;
    
    data = 0.0F;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = (float)atof(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
10934,0,CWE190_Integer_Overflow__short_rand_postinc_32.c,"    short data;
    short *dataPtr1 = &data;
    short *dataPtr2 = &data;
    data = 0;
    {
        short data = *dataPtr1;
        
        data = (short)RAND32();
        *dataPtr1 = data;
    }
    {
        short data = *dataPtr2;
        {
            
            data++;
            short result = data;
            printIntLine(result);
        }
"
3524,0,CWE190_Integer_Overflow__char_fscanf_multiply_22a.c,"    char data;
    data = ' ';
    
    fscanf (stdin, ""%c"", &data);
    CWE190_Integer_Overflow__char_fscanf_multiply_22_badGlobal = 1; 
"
15624,0,CWE590_Free_Memory_Not_on_Heap__free_int_static_15.c,"    int * data;
    data = NULL; 
    switch(6)
    {
    case 6:
    {
        
        static int dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5;
            }
        }
        data = dataBuffer;
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    printIntLine(data[0]);
    
"
13203,0,CWE190_Integer_Overflow__char_rand_preinc_68a.c,"    char data;
    data = ' ';
    
    data = (char)RAND32();
    CWE190_Integer_Overflow__char_rand_preinc_68_badData = data;
"
6695,0,CWE457_Use_of_Uninitialized_Variable__new_double_array_no_init_14.cpp,"    double * data;
    data = new double[10];
    if(globalFive==5)
    {
        
        ; 
    }
    if(globalFive==5)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printDoubleLine(data[i]);
            }
        }
        
        delete [] data;
"
15069,0,CWE190_Integer_Overflow__int_rand_postinc_41.c,"    int data;
    
    data = 0;
    
    data = RAND32();
"
11610,0,CWE457_Use_of_Uninitialized_Variable__new_int_array_partial_init_17.cpp,"    int i,j;
    int * data;
    data = new int[10];
    for(i = 0; i < 1; i++)
    {
        
        {
            int i;
            for(i=0; i<(10/2); i++)
            {
                data[i] = i;
            }
        }
    }
    for(j = 0; j < 1; j++)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i]);
            }
        }
        
        delete [] data;
"
5680,1,CWE476_NULL_Pointer_Dereference__deref_after_check_14.c,"    if(globalFive!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            
            int *intPointer = NULL;
            if (intPointer == NULL)
            {
                printLine(""pointer is NULL"");
            }
        }
"
9114,0,CWE190_Integer_Overflow__int_connect_socket_square_02.c,"    int data;
    
    data = 0;
    if(1)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(1)
    {
        {
            
            int result = data * data;
            printIntLine(result);
        }
"
9759,0,CWE190_Integer_Overflow__int_listen_socket_postinc_14.c,"    int data;
    
    data = 0;
    if(globalFive==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(globalFive==5)
    {
        {
            
            data++;
            int result = data;
            printIntLine(result);
        }
"
10578,0,CWE401_Memory_Leak__new_array_int64_t_04.cpp,"    int64_t * data;
    data = NULL;
    if(STATIC_CONST_TRUE)
    {
        
        data = new int64_t[100];
        
        data[0] = 5LL;
        printLongLongLine(data[0]);
    }
    if(STATIC_CONST_TRUE)
    {
        
        ; 
"
15488,0,CWE401_Memory_Leak__new_char_74a.cpp,"    char * data;
    map<int, char *> dataMap;
    data = NULL;
    
    data = new char;
    
    *data = 'A';
    printHexCharLine(*data);
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
9568,0,CWE190_Integer_Overflow__short_max_multiply_52a.c,"    short data;
    data = 0;
    
    data = SHRT_MAX;
"
17730,0,CWE690_NULL_Deref_From_Return__int64_t_realloc_68a.c,"    int64_t * data;
    data = NULL; 
    
    data = (int64_t *)realloc(data, 1*sizeof(int64_t));
    CWE690_NULL_Deref_From_Return__int64_t_realloc_68_badDataForBadSink = data;
"
17266,0,CWE401_Memory_Leak__char_realloc_54a.c,"    char * data;
    data = NULL;
    
    data = (char *)realloc(data, 100*sizeof(char));
    if (data == NULL) {exit(-1);}
    
    strcpy(data, ""A String"");
    printLine(data);
"
15332,0,CWE416_Use_After_Free__new_delete_class_62a.cpp,"    TwoIntsClass * data;
    
    data = NULL;
    badSource(data);
    
    printIntLine(data->intOne);
"
17998,0,CWE401_Memory_Leak__new_array_struct_twoIntsStruct_64a.cpp,"    struct _twoIntsStruct * data;
    data = NULL;
    
    data = new struct _twoIntsStruct[100];
    
    data[0].intOne = 0;
    data[0].intTwo = 0;
    printStructLine((twoIntsStruct *)&data[0]);
"
2480,0,CWE563_Unused_Variable__unused_uninit_variable_int64_t_06.c,"    int64_t data;
    
    ; 
    if(STATIC_CONST_FIVE==5)
    {
        
        
        ; 
"
7735,0,CWE457_Use_of_Uninitialized_Variable__twointsclass_06.cpp,"    TwoIntsClass data;
    if(STATIC_CONST_FIVE==5)
    {
        
        ; 
    }
    if(STATIC_CONST_FIVE==5)
    {
        
        printIntLine(data.intOne);
        printIntLine(data.intTwo);
"
14209,0,CWE134_Uncontrolled_Format_String__char_environment_printf_62a.cpp,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    badSource(data);
    
"
16554,0,CWE190_Integer_Overflow__int_listen_socket_postinc_06.c,"    int data;
    
    data = 0;
    if(STATIC_CONST_FIVE==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(STATIC_CONST_FIVE==5)
    {
        {
            
            data++;
            int result = data;
            printIntLine(result);
        }
"
8074,0,CWE134_Uncontrolled_Format_String__char_file_fprintf_73a.cpp,"    char * data;
    list<char *> dataList;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        FILE * pFile;
        
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
16377,0,CWE457_Use_of_Uninitialized_Variable__new_int_array_partial_init_14.cpp,"    int * data;
    data = new int[10];
    if(globalFive==5)
    {
        
        {
            int i;
            for(i=0; i<(10/2); i++)
            {
                data[i] = i;
            }
        }
    }
    if(globalFive==5)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i]);
            }
        }
        
        delete [] data;
"
16472,0,CWE590_Free_Memory_Not_on_Heap__delete_long_static_68a.cpp,"    long * data;
    data = NULL; 
    {
        
        static long dataBuffer;
        dataBuffer = 5L;
        data = &dataBuffer;
    }
    CWE590_Free_Memory_Not_on_Heap__delete_long_static_68_badData = data;
"
3393,0,CWE134_Uncontrolled_Format_String__char_file_fprintf_81a.cpp,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        FILE * pFile;
        
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
    const CWE134_Uncontrolled_Format_String__char_file_fprintf_81_base& baseObject = CWE134_Uncontrolled_Format_String__char_file_fprintf_81_bad();
"
342,0,CWE197_Numeric_Truncation_Error__short_rand_01.c,"    short data;
    
    data = -1;
    
    data = (short)RAND32();
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
380,0,CWE415_Double_Free__new_delete_struct_07.cpp,"    twoIntsStruct * data;
    
    data = NULL;
    if(staticFive==5)
    {
        data = new twoIntsStruct;
        
        delete data;
    }
    if(staticFive==5)
    {
        
        delete data;
"
18181,0,CWE190_Integer_Overflow__char_rand_add_68a.c,"    char data;
    data = ' ';
    
    data = (char)RAND32();
    CWE190_Integer_Overflow__char_rand_add_68_badData = data;
"
7458,0,CWE758_Undefined_Behavior__char_pointer_malloc_use_01.c,"    {
        char * * pointer = (char * *)malloc(sizeof(char *));
        if (pointer == NULL) {exit(-1);}
        char * data = *pointer; 
        free(pointer);
        printLine(data);
"
9223,0,CWE369_Divide_by_Zero__float_connect_socket_02.c,"    float data;
    
    data = 0.0F;
    if(1)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = (float)atof(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(1)
    {
        {
            
            int result = (int)(100.0 / data);
            printIntLine(result);
        }
"
1073,0,CWE78_OS_Command_Injection__char_file_popen_82_bad.cpp,"Label Definition File: CWE78_OS_Command_Injection.one_string.label.xml
Template File: sources-sink-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 78 OS Command Injection
 * BadSource: file Read input from a file
 * GoodSource: Fixed string
 * Sinks: popen
 *    BadSink : Execute command in data using popen()
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE78_OS_Command_Injection__char_file_popen_82.h""


#ifdef _WIN32
#define POPEN _popen
#define PCLOSE _pclose
#else 
#define POPEN popen
#define PCLOSE pclose
#endif

namespace CWE78_OS_Command_Injection__char_file_popen_82
{

void CWE78_OS_Command_Injection__char_file_popen_82_bad::action(char * data)
{
    {
        FILE *pipe;
        
        pipe = POPEN(data, ""w"");
        if (pipe != NULL)
        {
            PCLOSE(pipe);
        }
    }
}

}
"
3072,0,CWE416_Use_After_Free__new_delete_array_int64_t_17.cpp,"    int i,j;
    int64_t * data;
    
    data = NULL;
    for(i = 0; i < 1; i++)
    {
        data = new int64_t[100];
        {
            size_t i;
            for(i = 0; i < 100; i++)
            {
                data[i] = 5LL;
            }
        }
        
        delete [] data;
    }
    for(j = 0; j < 1; j++)
    {
        
        printLongLongLine(data[0]);
        
"
1398,0,CWE457_Use_of_Uninitialized_Variable__int_pointer_18.c,"    int * data;
    goto source;
source:
    
    ; 
    goto sink;
sink:
    
"
8817,0,CWE563_Unused_Variable__unused_value_struct_81a.cpp,"    twoIntsStruct data;
    
    data.intOne = 0;
    data.intTwo = 0;
    const CWE563_Unused_Variable__unused_value_struct_81_base& baseObject = CWE563_Unused_Variable__unused_value_struct_81_bad();
"
3714,1,CWE758_Undefined_Behavior__char_pointer_malloc_use_15.c,"    switch(6)
    {
    case 6:
    {
        char * data;
        char * * pointer = (char * *)malloc(sizeof(char *));
        if (pointer == NULL) {exit(-1);}
        data = ""string"";
        *pointer = data; 
        {
            char * data = *pointer;
            printLine(data);
        }
        free(pointer);
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
12745,0,CWE134_Uncontrolled_Format_String__char_connect_socket_printf_81a.cpp,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    const CWE134_Uncontrolled_Format_String__char_connect_socket_printf_81_base& baseObject = CWE134_Uncontrolled_Format_String__char_connect_socket_printf_81_bad();
"
16722,0,CWE563_Unused_Variable__unused_uninit_variable_int64_t_11.c,"    int64_t data;
    
    ; 
    if(globalReturnsTrue())
    {
        
        
        ; 
"
16115,0,CWE369_Divide_by_Zero__int_connect_socket_divide_83a.cpp,"    int data;
    
    data = -1;
"
9336,0,CWE197_Numeric_Truncation_Error__int_fscanf_to_short_12.c,"    int data;
    
    data = -1;
    if(globalReturnsTrueOrFalse())
    {
        
        fscanf(stdin, ""%d"", &data);
    }
    else
    {
        
        data = CHAR_MAX-5;
    }
    {
        
        short shortData = (short)data;
        printShortLine(shortData);
"
3717,0,CWE134_Uncontrolled_Format_String__char_file_fprintf_82_bad.cpp,"Label Definition File: CWE134_Uncontrolled_Format_String.label.xml
Template File: sources-sinks-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 134 Uncontrolled Format String
 * BadSource: file Read input from a file
 * GoodSource: Copy a fixed string into data
 * Sinks: fprintf
 *    GoodSink: fprintf with ""%s"" as the second argument and data as the third
 *    BadSink : fprintf with data as the second argument
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE134_Uncontrolled_Format_String__char_file_fprintf_82.h""

namespace CWE134_Uncontrolled_Format_String__char_file_fprintf_82
{

void CWE134_Uncontrolled_Format_String__char_file_fprintf_82_bad::action(char * data)
{
    
    fprintf(stdout, data);
}

}
"
12460,0,CWE415_Double_Free__new_delete_array_struct_44.cpp,"    twoIntsStruct * data;
    
    void (*funcPtr) (twoIntsStruct *) = badSink;
    
    data = NULL;
    data = new twoIntsStruct[100];
    
    delete [] data;
    
"
17122,0,CWE134_Uncontrolled_Format_String__char_connect_socket_printf_65a.c,"    char * data;
    
    void (*funcPtr) (char *) = CWE134_Uncontrolled_Format_String__char_connect_socket_printf_65b_badSink;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
"
7608,0,CWE401_Memory_Leak__int64_t_malloc_21.c,"    int64_t * data;
    data = NULL;
    
    data = (int64_t *)malloc(100*sizeof(int64_t));
    if (data == NULL) {exit(-1);}
    
    data[0] = 5LL;
    printLongLongLine(data[0]);
    badStatic = 1; 
"
17744,0,CWE134_Uncontrolled_Format_String__char_file_snprintf_41.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        FILE * pFile;
        
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
"
17206,0,CWE190_Integer_Overflow__int_fscanf_postinc_18.c,"    int data;
    
    data = 0;
    goto source;
source:
    
    fscanf(stdin, ""%d"", &data);
    goto sink;
sink:
    {
        
        data++;
        int result = data;
        printIntLine(result);
"
7901,0,CWE476_NULL_Pointer_Dereference__class_11.cpp,"    TwoIntsClass * data;
    if(globalReturnsTrue())
    {
        
        data = NULL;
    }
    if(globalReturnsTrue())
    {
        
        printIntLine(data->intOne);
        
        delete data;
"
17500,0,CWE190_Integer_Overflow__int_fscanf_add_05.c,"    int data;
    
    data = 0;
    if(staticTrue)
    {
        
        fscanf(stdin, ""%d"", &data);
    }
    if(staticTrue)
    {
        {
            
            int result = data + 1;
            printIntLine(result);
        }
"
10579,1,CWE467_Use_of_sizeof_on_Pointer_Type__int_06.c,"    if(STATIC_CONST_FIVE!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            int * goodInt = NULL;
            
            goodInt = (int *)malloc(sizeof(*goodInt));
            if (goodInt == NULL) {exit(-1);}
            *goodInt = 6;
            printIntLine(*goodInt);
            free(goodInt);
        }
"
7269,0,CWE590_Free_Memory_Not_on_Heap__free_char_static_05.c,"    char * data;
    data = NULL; 
    if(staticTrue)
    {
        {
            
            static char dataBuffer[100];
            memset(dataBuffer, 'A', 100-1); 
            dataBuffer[100-1] = '\0'; 
            data = dataBuffer;
        }
    }
    printLine(data);
    
"
5689,0,CWE190_Integer_Overflow__int64_t_fscanf_preinc_42.c,"    int64_t data;
    data = 0LL;
    data = badSource(data);
    {
        
        ++data;
        int64_t result = data;
        printLongLongLine(result);
"
1213,0,CWE197_Numeric_Truncation_Error__short_fscanf_65a.c,"    short data;
    
    void (*funcPtr) (short) = CWE197_Numeric_Truncation_Error__short_fscanf_65b_badSink;
    
    data = -1;
    
    fscanf (stdin, ""%hd"", &data);
    
"
16046,1,CWE252_Unchecked_Return_Value__char_fgets_14.c,"    if(globalFive!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            printLine(""Please enter a string: "");
            
            if (fgets(data, 100, stdin) == NULL)
            {
                printLine(""fgets failed!"");
                exit(1);
            }
            printLine(data);
        }
"
2290,0,CWE369_Divide_by_Zero__int_fgets_divide_84a.cpp,"    int data;
    
    data = -1;
    CWE369_Divide_by_Zero__int_fgets_divide_84_bad * badObject = new CWE369_Divide_by_Zero__int_fgets_divide_84_bad(data);
"
1548,0,CWE590_Free_Memory_Not_on_Heap__delete_int64_t_declare_15.cpp,"    int64_t * data;
    data = NULL; 
    switch(6)
    {
    case 6:
    {
        
        int64_t dataBuffer;
        dataBuffer = 5LL;
        data = &dataBuffer;
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    printLongLongLine(*data);
    
"
2882,0,CWE78_OS_Command_Injection__char_connect_socket_popen_16.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    while(1)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET connectSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
"
14987,0,CWE369_Divide_by_Zero__float_fgets_66a.c,"    float data;
    float dataArray[5];
    
    data = 0.0F;
    {
        char inputBuffer[CHAR_ARRAY_SIZE];
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = (float)atof(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    
    dataArray[2] = data;
"
17305,0,CWE590_Free_Memory_Not_on_Heap__free_char_declare_74a.cpp,"    char * data;
    map<int, char *> dataMap;
    data = NULL; 
    {
        
        char dataBuffer[100];
        memset(dataBuffer, 'A', 100-1); 
        dataBuffer[100-1] = '\0'; 
        data = dataBuffer;
    }
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
16668,0,CWE190_Integer_Overflow__int64_t_rand_postinc_41.c,"    int64_t data;
    data = 0LL;
    
    data = (int64_t)RAND64();
"
3308,0,CWE134_Uncontrolled_Format_String__char_file_fprintf_61a.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    data = CWE134_Uncontrolled_Format_String__char_file_fprintf_61b_badSource(data);
    
"
17573,0,CWE590_Free_Memory_Not_on_Heap__delete_long_static_12.cpp,"    long * data;
    data = NULL; 
    if(globalReturnsTrueOrFalse())
    {
        {
            
            static long dataBuffer;
            dataBuffer = 5L;
            data = &dataBuffer;
        }
    }
    else
    {
        {
            
            long * dataBuffer = new long;
            *dataBuffer = 5L;
            data = dataBuffer;
        }
    }
    printLongLine(*data);
    
"
2918,0,CWE563_Unused_Variable__unused_value_char_83_bad.cpp,"Label Definition File: CWE563_Unused_Variable__unused_value.label.xml
Template File: sources-sinks-83_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 563 Unused Variable
 * BadSource:  Initialize data
 * GoodSource: Initialize and use data
 * Sinks:
 *    GoodSink: Use data
 *    BadSink : Initialize and use data
 * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE563_Unused_Variable__unused_value_char_83.h""

namespace CWE563_Unused_Variable__unused_value_char_83
{
CWE563_Unused_Variable__unused_value_char_83_bad::CWE563_Unused_Variable__unused_value_char_83_bad(char dataCopy)
{
    data = dataCopy;
    
    data = 'C';
}

CWE563_Unused_Variable__unused_value_char_83_bad::~CWE563_Unused_Variable__unused_value_char_83_bad()
{
    
    data = 'Z';
    printHexCharLine(data);
}
}
"
10214,0,CWE134_Uncontrolled_Format_String__char_console_printf_04.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(STATIC_CONST_TRUE)
    {
        {
            
            size_t dataLen = strlen(data);
            
            if (100-dataLen > 1)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
                {
                    /* The next few lines remove the carriage return from the string that is
                     * inserted by fgets() */
                    dataLen = strlen(data);
                    if (dataLen > 0 && data[dataLen-1] == '\n')
                    {
                        data[dataLen-1] = '\0';
                    }
                }
                else
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
            }
        }
    }
    if(STATIC_CONST_TRUE)
    {
        
        printf(data);
"
9446,1,CWE252_Unchecked_Return_Value__char_putc_13.c,"    if(GLOBAL_CONST_FIVE==5)
    {
        
        if (putc((int)'A', stdout) == EOF)
        {
            printLine(""putc failed!"");
        }
"
14860,0,CWE665_Improper_Initialization__char_cat_81a.cpp,"    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    
    ; 
    const CWE665_Improper_Initialization__char_cat_81_base& baseObject = CWE665_Improper_Initialization__char_cat_81_bad();
"
16381,0,CWE190_Integer_Overflow__int_fscanf_square_62a.cpp,"    int data;
    
    data = 0;
    badSource(data);
    {
        
        int result = data * data;
        printIntLine(result);
"
11404,0,CWE190_Integer_Overflow__int_fscanf_postinc_07.c,"    int data;
    
    data = 0;
    if(staticFive==5)
    {
        
        fscanf(stdin, ""%d"", &data);
    }
    if(staticFive==5)
    {
        {
            
            data++;
            int result = data;
            printIntLine(result);
        }
"
17034,0,CWE190_Integer_Overflow__int_max_multiply_14.c,"    int data;
    
    data = 0;
    if(globalFive==5)
    {
        
        data = INT_MAX;
    }
    if(globalFive==5)
    {
        if(data > 0) 
        {
            
            int result = data * 2;
            printIntLine(result);
        }
"
10218,0,CWE197_Numeric_Truncation_Error__int_rand_to_char_13.c,"    int data;
    
    data = -1;
    if(GLOBAL_CONST_FIVE==5)
    {
        
        data = RAND32();
    }
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
12530,0,CWE78_OS_Command_Injection__char_listen_socket_system_66a.c,"    char * data;
    char * dataArray[5];
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
    dataArray[2] = data;
"
12348,0,CWE197_Numeric_Truncation_Error__short_fscanf_33.cpp,"    short data;
    short &dataRef = data;
    
    data = -1;
    
    fscanf (stdin, ""%hd"", &data);
    {
        short data = dataRef;
        {
            
            char charData = (char)data;
            printHexCharLine(charData);
        }
"
12937,0,CWE590_Free_Memory_Not_on_Heap__free_int64_t_declare_03.c,"    int64_t * data;
    data = NULL; 
    if(5==5)
    {
        {
            
            int64_t dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5LL;
                }
            }
            data = dataBuffer;
        }
    }
    printLongLongLine(data[0]);
    
"
17299,0,CWE590_Free_Memory_Not_on_Heap__free_struct_alloca_05.c,"    twoIntsStruct * data;
    data = NULL; 
    if(staticTrue)
    {
        {
            
            twoIntsStruct * dataBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i].intOne = 1;
                    dataBuffer[i].intTwo = 1;
                }
            }
            data = dataBuffer;
        }
    }
    printStructLine(&data[0]);
    
"
2519,0,CWE369_Divide_by_Zero__int_listen_socket_divide_08.c,"    int data;
    
    data = -1;
    if(staticReturnsTrue())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(staticReturnsTrue())
    {
        
        printIntLine(100 / data);
"
8828,0,CWE190_Integer_Overflow__int64_t_fscanf_postinc_10.c,"    int64_t data;
    data = 0LL;
    if(globalTrue)
    {
        
        fscanf (stdin, ""%"" SCNd64, &data);
    }
    if(globalTrue)
    {
        {
            
            data++;
            int64_t result = data;
            printLongLongLine(result);
        }
"
3869,0,CWE457_Use_of_Uninitialized_Variable__twointsclass_array_alloca_partial_init_08.cpp,"    TwoIntsClass * data;
    data = reinterpret_cast<TwoIntsClass *>(ALLOCA(10*sizeof(TwoIntsClass)));
    if(staticReturnsTrue())
    {
        
        for(int i=0; i<(10/2); i++)
        {
            data[i].intOne = i;
            data[i].intTwo = i;
        }
    }
    if(staticReturnsTrue())
    {
        
        for(int i=0; i<10; i++)
        {
            printIntLine(data[i].intOne);
            printIntLine(data[i].intTwo);
        }
"
6409,0,CWE134_Uncontrolled_Format_String__char_environment_snprintf_21.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        
        if (environment != NULL)
        {
            
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    badStatic = 1; 
"
7265,0,CWE401_Memory_Leak__struct_twoIntsStruct_malloc_14.c,"    struct _twoIntsStruct * data;
    data = NULL;
    if(globalFive==5)
    {
        
        data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));
        if (data == NULL) {exit(-1);}
        
        data[0].intOne = 0;
        data[0].intTwo = 0;
        printStructLine((twoIntsStruct *)&data[0]);
    }
    if(globalFive==5)
    {
        
        ; 
"
10295,0,CWE190_Integer_Overflow__int_max_add_84_bad.cpp,"Label Definition File: CWE190_Integer_Overflow__int.label.xml
Template File: sources-sinks-84_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 190 Integer Overflow
 * BadSource: max Set data to the max value for int
 * GoodSource: Set data to a small, non-zero number (two)
 * Sinks: add
 *    GoodSink: Ensure there will not be an overflow before adding 1 to data
 *    BadSink : Add 1 to data, which can cause an overflow
 * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE190_Integer_Overflow__int_max_add_84.h""

namespace CWE190_Integer_Overflow__int_max_add_84
{
CWE190_Integer_Overflow__int_max_add_84_bad::CWE190_Integer_Overflow__int_max_add_84_bad(int dataCopy)
{
    data = dataCopy;
    
    data = INT_MAX;
}

CWE190_Integer_Overflow__int_max_add_84_bad::~CWE190_Integer_Overflow__int_max_add_84_bad()
{
    {
        
        int result = data + 1;
        printIntLine(result);
    }
}
}
"
9833,0,CWE415_Double_Free__new_delete_class_02.cpp,"    TwoIntsClass * data;
    
    data = NULL;
    if(1)
    {
        data = new TwoIntsClass;
        
        delete data;
    }
    if(1)
    {
        
        delete data;
"
1615,0,CWE590_Free_Memory_Not_on_Heap__delete_struct_declare_63a.cpp,"    twoIntsStruct * data;
    data = NULL; 
    {
        
        twoIntsStruct dataBuffer;
        dataBuffer.intOne = 1;
        dataBuffer.intTwo = 1;
        data = &dataBuffer;
    }
"
8972,1,CWE758_Undefined_Behavior__int_alloca_use_02.c,"    if(0)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            int data;
            int * pointer = (int *)ALLOCA(sizeof(int));
            data = 5;
            *pointer = data; 
            {
                int data = *pointer;
                printIntLine(data);
            }
        }
"
9342,0,CWE190_Integer_Overflow__char_max_preinc_01.c,"    char data;
    data = ' ';
    
    data = CHAR_MAX;
    {
        
        ++data;
        char result = data;
        printHexCharLine(result);
"
9036,0,CWE78_OS_Command_Injection__char_listen_socket_system_72a.cpp,"    char * data;
    vector<char *> dataVector;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
5107,0,CWE415_Double_Free__malloc_free_int_52a.c,"    int * data;
    
    data = NULL;
    data = (int *)malloc(100*sizeof(int));
    if (data == NULL) {exit(-1);}
    
    free(data);
"
1258,0,CWE369_Divide_by_Zero__int_fgets_modulo_08.c,"    int data;
    
    data = -1;
    if(staticReturnsTrue())
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    if(staticReturnsTrue())
    {
        
        printIntLine(100 % data);
"
5421,0,CWE190_Integer_Overflow__int64_t_rand_preinc_22a.c,"    int64_t data;
    data = 0LL;
    
    data = (int64_t)RAND64();
    CWE190_Integer_Overflow__int64_t_rand_preinc_22_badGlobal = 1; 
"
10926,0,CWE563_Unused_Variable__unused_uninit_variable_long_74a.cpp,"    long data;
    map<int, long> dataMap;
    
    ; 
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
2464,0,CWE457_Use_of_Uninitialized_Variable__struct_array_declare_no_init_02.c,"    twoIntsStruct * data;
    twoIntsStruct dataUninitArray[10];
    data = dataUninitArray;
    if(1)
    {
        
        ; 
    }
    if(1)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i].intOne);
                printIntLine(data[i].intTwo);
            }
        }
"
8832,0,CWE369_Divide_by_Zero__int_listen_socket_divide_81a.cpp,"    int data;
    
    data = -1;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    const CWE369_Divide_by_Zero__int_listen_socket_divide_81_base& baseObject = CWE369_Divide_by_Zero__int_listen_socket_divide_81_bad();
"
4621,0,CWE457_Use_of_Uninitialized_Variable__twointsclass_09.cpp,"    TwoIntsClass data;
    if(GLOBAL_CONST_TRUE)
    {
        
        ; 
    }
    if(GLOBAL_CONST_TRUE)
    {
        
        printIntLine(data.intOne);
        printIntLine(data.intTwo);
"
6010,0,CWE590_Free_Memory_Not_on_Heap__free_long_declare_64a.c,"    long * data;
    data = NULL; 
    {
        
        long dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5L;
            }
        }
        data = dataBuffer;
    }
"
15051,0,CWE190_Integer_Overflow__int_rand_preinc_11.c,"    int data;
    
    data = 0;
    if(globalReturnsTrue())
    {
        
        data = RAND32();
    }
    if(globalReturnsTrue())
    {
        {
            
            ++data;
            int result = data;
            printIntLine(result);
        }
"
2044,0,CWE590_Free_Memory_Not_on_Heap__delete_int64_t_placement_new_01.cpp,"    int64_t * data;
    data = NULL; 
    {
        
        char buffer[sizeof(int64_t)];
        int64_t * dataBuffer = new(buffer) int64_t;
        *dataBuffer = 5LL;
        data = dataBuffer;
    }
    printLongLongLine(*data);
    
"
9713,0,CWE590_Free_Memory_Not_on_Heap__delete_array_char_declare_14.cpp,"    char * data;
    data = NULL; 
    if(globalFive==5)
    {
        {
            
            char dataBuffer[100];
            memset(dataBuffer, 'A', 100-1); 
            dataBuffer[100-1] = '\0'; 
            data = dataBuffer;
        }
    }
    printLine(data);
    
"
3414,0,CWE190_Integer_Overflow__short_max_square_83_bad.cpp,"Label Definition File: CWE190_Integer_Overflow.label.xml
Template File: sources-sinks-83_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 190 Integer Overflow
 * BadSource: max Set data to the max value for short
 * GoodSource: Set data to a small, non-zero number (two)
 * Sinks: square
 *    GoodSink: Ensure there will not be an overflow before squaring data
 *    BadSink : Square data, which can lead to overflow
 * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE190_Integer_Overflow__short_max_square_83.h""

#include <math.h>

namespace CWE190_Integer_Overflow__short_max_square_83
{
CWE190_Integer_Overflow__short_max_square_83_bad::CWE190_Integer_Overflow__short_max_square_83_bad(short dataCopy)
{
    data = dataCopy;
    
    data = SHRT_MAX;
}

CWE190_Integer_Overflow__short_max_square_83_bad::~CWE190_Integer_Overflow__short_max_square_83_bad()
{
    {
        
        short result = data * data;
        printIntLine(result);
    }
}
}
"
1445,0,CWE401_Memory_Leak__new_char_07.cpp,"    char * data;
    data = NULL;
    if(staticFive==5)
    {
        
        data = new char;
        
        *data = 'A';
        printHexCharLine(*data);
    }
    if(staticFive==5)
    {
        
        ; 
"
8669,1,CWE476_NULL_Pointer_Dereference__binary_if_04.c,"    if(STATIC_CONST_TRUE)
    {
        {
            twoIntsStruct *twoIntsStructPointer = NULL;
            /* FIX: Use && in the if statement so that if the left side of the expression fails then
             * the right side will not be evaluated */
            if ((twoIntsStructPointer != NULL) && (twoIntsStructPointer->intOne == 5))
            {
                printLine(""intOne == 5"");
            }
        }
"
13386,0,CWE190_Integer_Overflow__int_fscanf_multiply_52a.c,"    int data;
    
    data = 0;
    
    fscanf(stdin, ""%d"", &data);
"
8786,0,CWE190_Integer_Overflow__int_fscanf_square_81_bad.cpp,"Label Definition File: CWE190_Integer_Overflow__int.label.xml
Template File: sources-sinks-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 190 Integer Overflow
 * BadSource: fscanf Read data from the console using fscanf()
 * GoodSource: Set data to a small, non-zero number (two)
 * Sinks: square
 *    GoodSink: Ensure there will not be an overflow before squaring data
 *    BadSink : Square data, which can lead to overflow
 * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE190_Integer_Overflow__int_fscanf_square_81.h""

#include <math.h>

namespace CWE190_Integer_Overflow__int_fscanf_square_81
{

void CWE190_Integer_Overflow__int_fscanf_square_81_bad::action(int data) const
{
    {
        
        int result = data * data;
        printIntLine(result);
    }
}

}
"
247,0,CWE190_Integer_Overflow__char_rand_postinc_51a.c,"    char data;
    data = ' ';
    
    data = (char)RAND32();
"
3732,0,CWE190_Integer_Overflow__int_fgets_square_82_bad.cpp,"Label Definition File: CWE190_Integer_Overflow__int.label.xml
Template File: sources-sinks-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 190 Integer Overflow
 * BadSource: fgets Read data from the console using fgets()
 * GoodSource: Set data to a small, non-zero number (two)
 * Sinks: square
 *    GoodSink: Ensure there will not be an overflow before squaring data
 *    BadSink : Square data, which can lead to overflow
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE190_Integer_Overflow__int_fgets_square_82.h""

#include <math.h>

namespace CWE190_Integer_Overflow__int_fgets_square_82
{

void CWE190_Integer_Overflow__int_fgets_square_82_bad::action(int data)
{
    {
        
        int result = data * data;
        printIntLine(result);
    }
}

}
"
11197,0,CWE590_Free_Memory_Not_on_Heap__delete_int64_t_alloca_08.cpp,"    int64_t * data;
    data = NULL; 
    if(staticReturnsTrue())
    {
        {
            
            int64_t * dataBuffer = (int64_t *)ALLOCA(sizeof(int64_t));
            *dataBuffer = 5LL;
            data = dataBuffer;
        }
    }
    printLongLongLine(*data);
    
"
17861,0,CWE690_NULL_Deref_From_Return__int64_t_calloc_72a.cpp,"    int64_t * data;
    vector<int64_t *> dataVector;
    data = NULL; 
    
    data = (int64_t *)calloc(1, sizeof(int64_t));
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
17734,0,CWE190_Integer_Overflow__int_max_add_16.c,"    int data;
    
    data = 0;
    while(1)
    {
        
        data = INT_MAX;
        break;
    }
    while(1)
    {
        {
            
            int result = data + 1;
            printIntLine(result);
        }
        break;
"
7759,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_62a.cpp,"    size_t data;
    
    data = 0;
    badSource(data);
    {
        char * myString;
        /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
         * for the strcpy() function to not cause a buffer overflow */
        
        if (data > strlen(HELLO_STRING))
        {
            myString = (char *)malloc(data*sizeof(char));
            if (myString == NULL) {exit(-1);}
            
            strcpy(myString, HELLO_STRING);
            printLine(myString);
            free(myString);
        }
        else
        {
            printLine(""Input is less than the length of the source string"");
        }
"
16746,0,CWE78_OS_Command_Injection__char_listen_socket_system_01.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
"
3885,0,CWE190_Integer_Overflow__char_fscanf_square_43.cpp,"    char data;
    data = ' ';
    badSource(data);
    {
        
        char result = data * data;
        printHexCharLine(result);
"
12202,0,CWE457_Use_of_Uninitialized_Variable__struct_pointer_12.c,"    twoIntsStruct * data;
    if(globalReturnsTrueOrFalse())
    {
        
        ; 
    }
    else
    {
        
        
        data = (twoIntsStruct *)malloc(sizeof(twoIntsStruct));
        if (data == NULL) {exit(-1);}
        data->intOne = 5;
        data->intTwo = 6;
    }
    if(globalReturnsTrueOrFalse())
    {
        
        printIntLine(data->intOne);
        printIntLine(data->intTwo);
    }
    else
    {
        
        
        data = (twoIntsStruct *)malloc(sizeof(twoIntsStruct));
        if (data == NULL) {exit(-1);}
        data->intOne = 5;
        data->intTwo = 6;
        printIntLine(data->intOne);
        printIntLine(data->intTwo);
"
18741,0,CWE401_Memory_Leak__twoIntsStruct_realloc_07.c,"    twoIntsStruct * data;
    data = NULL;
    if(staticFive==5)
    {
        
        data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));
        if (data == NULL) {exit(-1);}
        
        data[0].intOne = 0;
        data[0].intTwo = 0;
        printStructLine(&data[0]);
    }
    if(staticFive==5)
    {
        
        ; 
"
19162,0,CWE590_Free_Memory_Not_on_Heap__free_int64_t_declare_11.c,"    int64_t * data;
    data = NULL; 
    if(globalReturnsTrue())
    {
        {
            
            int64_t dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5LL;
                }
            }
            data = dataBuffer;
        }
    }
    printLongLongLine(data[0]);
    
"
14727,0,CWE190_Integer_Overflow__char_fscanf_multiply_32.c,"    char data;
    char *dataPtr1 = &data;
    char *dataPtr2 = &data;
    data = ' ';
    {
        char data = *dataPtr1;
        
        fscanf (stdin, ""%c"", &data);
        *dataPtr1 = data;
    }
    {
        char data = *dataPtr2;
        if(data > 0) 
        {
            
            char result = data * 2;
            printHexCharLine(result);
        }
"
4685,0,CWE401_Memory_Leak__strdup_char_13.c,"    char * data;
    data = NULL;
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            char myString[] = ""myString"";
            
            data = strdup(myString);
            
            printLine(data);
        }
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        
        
        ; 
"
15246,0,CWE457_Use_of_Uninitialized_Variable__struct_08.c,"    twoIntsStruct data;
    if(staticReturnsTrue())
    {
        
        ; 
    }
    if(staticReturnsTrue())
    {
        
        printIntLine(data.intOne);
        printIntLine(data.intTwo);
"
9965,0,CWE415_Double_Free__new_delete_class_42.cpp,"    TwoIntsClass * data;
    
    data = NULL;
    data = badSource(data);
    
"
9582,0,CWE415_Double_Free__malloc_free_int64_t_43.cpp,"    int64_t * data;
    
    data = NULL;
    badSource(data);
    
"
12597,0,CWE190_Integer_Overflow__int_listen_socket_square_63a.c,"    int data;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
15881,0,CWE457_Use_of_Uninitialized_Variable__twointsclass_array_declare_no_init_12.cpp,"    TwoIntsClass * data;
    TwoIntsClass dataUninitArray[10];
    data = dataUninitArray;
    if(globalReturnsTrueOrFalse())
    {
        
        ; 
    }
    else
    {
        
        for(int i=0; i<10; i++)
        {
            data[i].intOne = i;
            data[i].intTwo = i;
        }
    }
    if(globalReturnsTrueOrFalse())
    {
        
        for(int i=0; i<10; i++)
        {
            printIntLine(data[i].intOne);
            printIntLine(data[i].intTwo);
        }
    }
    else
    {
        
        for(int i=0; i<10; i++)
        {
            data[i].intOne = i;
            data[i].intTwo = i;
        }
        for(int i=0; i<10; i++)
        {
            printIntLine(data[i].intOne);
            printIntLine(data[i].intTwo);
        }
"
5984,0,CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_10.cpp,"    size_t data;
    
    data = 0;
    if(globalTrue)
    {
        
        fscanf(stdin, ""%zu"", &data);
    }
    if(globalTrue)
    {
        {
            char * myString;
            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
             * for the strcpy() function to not cause a buffer overflow */
            
            if (data > strlen(HELLO_STRING))
            {
                myString = new char[data];
                
                strcpy(myString, HELLO_STRING);
                printLine(myString);
                delete [] myString;
            }
            else
            {
                printLine(""Input is less than the length of the source string"");
            }
        }
"
13949,0,CWE590_Free_Memory_Not_on_Heap__delete_struct_declare_14.cpp,"    twoIntsStruct * data;
    data = NULL; 
    if(globalFive==5)
    {
        {
            
            twoIntsStruct dataBuffer;
            dataBuffer.intOne = 1;
            dataBuffer.intTwo = 1;
            data = &dataBuffer;
        }
    }
    printStructLine(data);
    
"
7183,0,CWE369_Divide_by_Zero__int_fgets_divide_84_bad.cpp,"Label Definition File: CWE369_Divide_by_Zero__int.label.xml
Template File: sources-sinks-84_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 369 Divide by Zero
 * BadSource: fgets Read data from the console using fgets()
 * GoodSource: Non-zero
 * Sinks: divide
 *    GoodSink: Check for zero before dividing
 *    BadSink : Divide a constant by data
 * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE369_Divide_by_Zero__int_fgets_divide_84.h""

#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)

namespace CWE369_Divide_by_Zero__int_fgets_divide_84
{
CWE369_Divide_by_Zero__int_fgets_divide_84_bad::CWE369_Divide_by_Zero__int_fgets_divide_84_bad(int dataCopy)
{
    data = dataCopy;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
}

CWE369_Divide_by_Zero__int_fgets_divide_84_bad::~CWE369_Divide_by_Zero__int_fgets_divide_84_bad()
{
    
    printIntLine(100 / data);
}
}
"
19101,0,CWE401_Memory_Leak__new_char_64a.cpp,"    char * data;
    data = NULL;
    
    data = new char;
    
    *data = 'A';
    printHexCharLine(*data);
"
16462,1,CWE688_Function_Call_With_Incorrect_Variable_or_Reference_as_Argument__basic_18.c,"    goto sink;
sink:
    {
        char dest[DEST_SIZE];
        int intFive = 5;
        
        sprintf(dest, ""%d"", intFive);
        printLine(dest);
"
7021,0,CWE190_Integer_Overflow__int_connect_socket_multiply_04.c,"    int data;
    
    data = 0;
    if(STATIC_CONST_TRUE)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(STATIC_CONST_TRUE)
    {
        if(data > 0) 
        {
            
            int result = data * 2;
            printIntLine(result);
        }
"
12715,0,CWE590_Free_Memory_Not_on_Heap__free_struct_declare_67a.c,"    twoIntsStruct * data;
    CWE590_Free_Memory_Not_on_Heap__free_struct_declare_67_structType myStruct;
    data = NULL; 
    {
        
        twoIntsStruct dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i].intOne = 1;
                dataBuffer[i].intTwo = 1;
            }
        }
        data = dataBuffer;
    }
    myStruct.structFirst = data;
"
7049,0,CWE415_Double_Free__new_delete_array_class_07.cpp,"    TwoIntsClass * data;
    
    data = NULL;
    if(staticFive==5)
    {
        data = new TwoIntsClass[100];
        
        delete [] data;
    }
    if(staticFive==5)
    {
        
        delete [] data;
"
673,0,CWE563_Unused_Variable__unused_init_variable_char_21.c,"    char data;
    
    data = 'C';
    badStatic = 1; 
"
20,0,CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_13.cpp,"    size_t data;
    
    data = 0;
    if(GLOBAL_CONST_FIVE==5)
    {
        
        fscanf(stdin, ""%zu"", &data);
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            char * myString;
            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
             * for the strcpy() function to not cause a buffer overflow */
            
            if (data > strlen(HELLO_STRING))
            {
                myString = new char[data];
                
                strcpy(myString, HELLO_STRING);
                printLine(myString);
                delete [] myString;
            }
            else
            {
                printLine(""Input is less than the length of the source string"");
            }
        }
"
7572,0,CWE590_Free_Memory_Not_on_Heap__delete_int64_t_placement_new_17.cpp,"    int i;
    int64_t * data;
    data = NULL; 
    for(i = 0; i < 1; i++)
    {
        {
            
            char buffer[sizeof(int64_t)];
            int64_t * dataBuffer = new(buffer) int64_t;
            *dataBuffer = 5LL;
            data = dataBuffer;
        }
    }
    printLongLongLine(*data);
    
"
848,0,CWE415_Double_Free__new_delete_char_61a.cpp,"    char * data;
    
    data = NULL;
    data = badSource(data);
    
"
7690,0,CWE590_Free_Memory_Not_on_Heap__delete_char_declare_13.cpp,"    char * data;
    data = NULL; 
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            
            char dataBuffer;
            dataBuffer = 'A';
            data = &dataBuffer;
        }
    }
    printHexCharLine(*data);
    
"
10244,0,CWE401_Memory_Leak__struct_twoIntsStruct_realloc_32.c,"    struct _twoIntsStruct * data;
    struct _twoIntsStruct * *dataPtr1 = &data;
    struct _twoIntsStruct * *dataPtr2 = &data;
    data = NULL;
    {
        struct _twoIntsStruct * data = *dataPtr1;
        
        data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));
        if (data == NULL) {exit(-1);}
        
        data[0].intOne = 0;
        data[0].intTwo = 0;
        printStructLine((twoIntsStruct *)&data[0]);
        *dataPtr1 = data;
    }
    {
        struct _twoIntsStruct * data = *dataPtr2;
        
        ; 
"
8155,0,CWE590_Free_Memory_Not_on_Heap__free_int_alloca_17.c,"    int i;
    int * data;
    data = NULL; 
    for(i = 0; i < 1; i++)
    {
        {
            
            int * dataBuffer = (int *)ALLOCA(100*sizeof(int));
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5;
                }
            }
            data = dataBuffer;
        }
    }
    printIntLine(data[0]);
    
"
5453,0,CWE190_Integer_Overflow__short_max_square_13.c,"    short data;
    data = 0;
    if(GLOBAL_CONST_FIVE==5)
    {
        
        data = SHRT_MAX;
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            
            short result = data * data;
            printIntLine(result);
        }
"
8593,0,CWE416_Use_After_Free__malloc_free_int_08.c,"    int * data;
    
    data = NULL;
    if(staticReturnsTrue())
    {
        data = (int *)malloc(100*sizeof(int));
        if (data == NULL) {exit(-1);}
        {
            size_t i;
            for(i = 0; i < 100; i++)
            {
                data[i] = 5;
            }
        }
        
        free(data);
    }
    if(staticReturnsTrue())
    {
        
        printIntLine(data[0]);
        
"
8091,0,CWE457_Use_of_Uninitialized_Variable__twointsclass_62a.cpp,"    TwoIntsClass data;
    badSource(data);
    
    printIntLine(data.intOne);
"
1438,0,CWE590_Free_Memory_Not_on_Heap__free_long_static_68a.c,"    long * data;
    data = NULL; 
    {
        
        static long dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5L;
            }
        }
        data = dataBuffer;
    }
    CWE590_Free_Memory_Not_on_Heap__free_long_static_68_badData = data;
"
16867,0,CWE190_Integer_Overflow__short_rand_add_83_bad.cpp,"Label Definition File: CWE190_Integer_Overflow.label.xml
Template File: sources-sinks-83_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 190 Integer Overflow
 * BadSource: rand Set data to result of rand()
 * GoodSource: Set data to a small, non-zero number (two)
 * Sinks: add
 *    GoodSink: Ensure there will not be an overflow before adding 1 to data
 *    BadSink : Add 1 to data, which can cause an overflow
 * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE190_Integer_Overflow__short_rand_add_83.h""

namespace CWE190_Integer_Overflow__short_rand_add_83
{
CWE190_Integer_Overflow__short_rand_add_83_bad::CWE190_Integer_Overflow__short_rand_add_83_bad(short dataCopy)
{
    data = dataCopy;
    
    data = (short)RAND32();
}

CWE190_Integer_Overflow__short_rand_add_83_bad::~CWE190_Integer_Overflow__short_rand_add_83_bad()
{
    {
        
        short result = data + 1;
        printIntLine(result);
    }
}
}
"
11079,0,CWE590_Free_Memory_Not_on_Heap__delete_array_long_static_04.cpp,"    long * data;
    data = NULL; 
    if(STATIC_CONST_TRUE)
    {
        {
            
            static long dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5L;
                }
            }
            data = dataBuffer;
        }
    }
    printLongLine(data[0]);
    
"
16444,1,CWE758_Undefined_Behavior__char_malloc_use_15.c,"    switch(6)
    {
    case 6:
    {
        char data;
        char * pointer = (char *)malloc(sizeof(char));
        if (pointer == NULL) {exit(-1);}
        data = 5;
        *pointer = data; 
        {
            char data = *pointer;
            printHexCharLine(data);
        }
        free(pointer);
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
9188,1,CWE252_Unchecked_Return_Value__char_putchar_07.c,"    if(staticFive==5)
    {
        
        if (putchar((int)'A') == EOF)
        {
            printLine(""putchar failed!"");
        }
"
16022,0,CWE190_Integer_Overflow__int_fgets_add_04.c,"    int data;
    
    data = 0;
    if(STATIC_CONST_TRUE)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    if(STATIC_CONST_TRUE)
    {
        {
            
            int result = data + 1;
            printIntLine(result);
        }
"
14011,0,CWE190_Integer_Overflow__int64_t_max_preinc_02.c,"    int64_t data;
    data = 0LL;
    if(1)
    {
        
        data = LLONG_MAX;
    }
    if(1)
    {
        {
            
            ++data;
            int64_t result = data;
            printLongLongLine(result);
        }
"
6965,0,CWE590_Free_Memory_Not_on_Heap__delete_int64_t_alloca_15.cpp,"    int64_t * data;
    data = NULL; 
    switch(6)
    {
    case 6:
    {
        
        int64_t * dataBuffer = (int64_t *)ALLOCA(sizeof(int64_t));
        *dataBuffer = 5LL;
        data = dataBuffer;
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    printLongLongLine(*data);
    
"
17460,0,CWE190_Integer_Overflow__int_max_multiply_62a.cpp,"    int data;
    
    data = 0;
    badSource(data);
    if(data > 0) 
    {
        
        int result = data * 2;
        printIntLine(result);
"
9844,0,CWE415_Double_Free__new_delete_class_73a.cpp,"    TwoIntsClass * data;
    list<TwoIntsClass *> dataList;
    
    data = NULL;
    data = new TwoIntsClass;
    
    delete data;
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
1393,0,CWE190_Integer_Overflow__int_connect_socket_postinc_51a.c,"    int data;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
7688,0,CWE457_Use_of_Uninitialized_Variable__struct_array_alloca_partial_init_03.c,"    twoIntsStruct * data;
    data = (twoIntsStruct *)ALLOCA(10*sizeof(twoIntsStruct));
    if(5==5)
    {
        
        {
            int i;
            for(i=0; i<(10/2); i++)
            {
                data[i].intOne = i;
                data[i].intTwo = i;
            }
        }
    }
    if(5==5)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i].intOne);
                printIntLine(data[i].intTwo);
            }
        }
"
8471,0,CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_45.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_45_badData = data;
"
15669,1,CWE475_Undefined_Behavior_for_Input_to_API__char_18.c,"    goto sink;
sink:
    {
        char dataBuffer[100] = """";
        char * data = dataBuffer;
        strcpy(data, ""abcdefghijklmnopqrstuvwxyz"");
        
        memmove(data + 6, data + 4, 10*sizeof(char));
        printLine(data);
"
6364,0,CWE369_Divide_by_Zero__float_zero_51a.c,"    float data;
    
    data = 0.0F;
    
    data = 0.0F;
"
3028,0,CWE190_Integer_Overflow__short_max_preinc_44.c,"    short data;
    
    void (*funcPtr) (short) = badSink;
    data = 0;
    
    data = SHRT_MAX;
    
"
7953,0,CWE415_Double_Free__new_delete_array_long_83a.cpp,"    long * data;
    
    data = NULL;
"
8544,0,CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_44.c,"    char * data;
    
    void (*funcPtr) (char *) = badSink;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
"
12366,0,CWE78_OS_Command_Injection__char_listen_socket_execl_05.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(staticTrue)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                data[dataLen + recvResult / sizeof(char)] = '\0';
                
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    
    
"
17346,0,CWE197_Numeric_Truncation_Error__int_fgets_to_char_32.c,"    int data;
    int *dataPtr1 = &data;
    int *dataPtr2 = &data;
    
    data = -1;
    {
        int data = *dataPtr1;
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
        *dataPtr1 = data;
    }
    {
        int data = *dataPtr2;
        {
            
            char charData = (char)data;
            printHexCharLine(charData);
        }
"
12771,0,CWE690_NULL_Deref_From_Return__long_realloc_22a.c,"    long * data;
    data = NULL; 
    
    data = (long *)realloc(data, 1*sizeof(long));
    CWE690_NULL_Deref_From_Return__long_realloc_22_badGlobal = 1; 
"
14021,0,CWE190_Integer_Overflow__char_fscanf_multiply_67a.c,"    char data;
    CWE190_Integer_Overflow__char_fscanf_multiply_67_structType myStruct;
    data = ' ';
    
    fscanf (stdin, ""%c"", &data);
    myStruct.structFirst = data;
"
15611,0,CWE190_Integer_Overflow__short_max_add_21.c,"    short data;
    data = 0;
    
    data = SHRT_MAX;
    badStatic = 1; 
"
11034,1,CWE252_Unchecked_Return_Value__char_puts_07.c,"    if(staticFive==5)
    {
        
        if (PUTS(""string"") == EOF)
        {
            printLine(""puts failed!"");
        }
"
8646,0,CWE190_Integer_Overflow__int_listen_socket_preinc_01.c,"    int data;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    {
        
        ++data;
        int result = data;
        printIntLine(result);
"
7885,0,CWE590_Free_Memory_Not_on_Heap__delete_array_char_declare_67a.cpp,"    char * data;
    structType myStruct;
    data = NULL; 
    {
        
        char dataBuffer[100];
        memset(dataBuffer, 'A', 100-1); 
        dataBuffer[100-1] = '\0'; 
        data = dataBuffer;
    }
    myStruct.structFirst = data;
"
2727,0,CWE78_OS_Command_Injection__char_listen_socket_popen_10.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(globalTrue)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                data[dataLen + recvResult / sizeof(char)] = '\0';
                
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    {
        FILE *pipe;
        
        pipe = POPEN(data, ""w"");
        if (pipe != NULL)
        {
            PCLOSE(pipe);
        }
"
18188,0,CWE590_Free_Memory_Not_on_Heap__delete_array_long_declare_52a.cpp,"    long * data;
    data = NULL; 
    {
        
        long dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5L;
            }
        }
        data = dataBuffer;
    }
"
5272,0,CWE401_Memory_Leak__new_array_int64_t_01.cpp,"    int64_t * data;
    data = NULL;
    
    data = new int64_t[100];
    
    data[0] = 5LL;
    printLongLongLine(data[0]);
    
"
7838,0,CWE401_Memory_Leak__new_array_TwoIntsClass_68a.cpp,"    TwoIntsClass * data;
    data = NULL;
    
    data = new TwoIntsClass[100];
    
    data[0].intOne = 0;
    data[0].intTwo = 0;
    printIntLine(data[0].intOne);
    printIntLine(data[0].intTwo);
    badData = data;
"
13361,0,CWE590_Free_Memory_Not_on_Heap__delete_int64_t_declare_67a.cpp,"    int64_t * data;
    structType myStruct;
    data = NULL; 
    {
        
        int64_t dataBuffer;
        dataBuffer = 5LL;
        data = &dataBuffer;
    }
    myStruct.structFirst = data;
"
8820,1,CWE758_Undefined_Behavior__struct_pointer_malloc_use_13.c,"    if(GLOBAL_CONST_FIVE!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            twoIntsStruct * data;
            twoIntsStruct * * pointer = (twoIntsStruct * *)malloc(sizeof(twoIntsStruct *));
            if (pointer == NULL) {exit(-1);}
            
            data = (twoIntsStruct *)malloc(sizeof(twoIntsStruct));
            if (data == NULL) {exit(-1);}
            data->intOne = 5;
            data->intTwo = 6;
            *pointer = data; 
            {
                twoIntsStruct * data = *pointer;
                printIntLine(data->intOne);
                printIntLine(data->intTwo);
            }
            free(pointer);
        }
"
15642,0,CWE590_Free_Memory_Not_on_Heap__delete_array_struct_declare_74a.cpp,"    twoIntsStruct * data;
    map<int, twoIntsStruct *> dataMap;
    data = NULL; 
    {
        
        twoIntsStruct dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i].intOne = 1;
                dataBuffer[i].intTwo = 1;
            }
        }
        data = dataBuffer;
    }
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
2799,1,CWE758_Undefined_Behavior__char_pointer_malloc_use_08.c,"    if(staticReturnsTrue())
    {
        {
            char * data;
            char * * pointer = (char * *)malloc(sizeof(char *));
            if (pointer == NULL) {exit(-1);}
            data = ""string"";
            *pointer = data; 
            {
                char * data = *pointer;
                printLine(data);
            }
            free(pointer);
        }
"
10736,0,CWE190_Integer_Overflow__short_fscanf_square_43.cpp,"    short data;
    data = 0;
    badSource(data);
    {
        
        short result = data * data;
        printIntLine(result);
"
7094,0,CWE78_OS_Command_Injection__char_file_execl_14.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(globalFive==5)
    {
        {
            
            size_t dataLen = strlen(data);
            FILE * pFile;
            
            if (100-dataLen > 1)
            {
                pFile = fopen(FILENAME, ""r"");
                if (pFile != NULL)
                {
                    
                    if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                    {
                        printLine(""fgets() failed"");
                        
                        data[dataLen] = '\0';
                    }
                    fclose(pFile);
                }
            }
        }
    }
    
    
"
5713,0,CWE134_Uncontrolled_Format_String__char_listen_socket_printf_54a.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
7681,0,CWE457_Use_of_Uninitialized_Variable__double_array_declare_no_init_14.c,"    double * data;
    double dataUninitArray[10];
    data = dataUninitArray;
    if(globalFive==5)
    {
        
        ; 
    }
    if(globalFive==5)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printDoubleLine(data[i]);
            }
        }
"
5436,0,CWE475_Undefined_Behavior_for_Input_to_API__char_03.c,"    if(5==5)
    {
        {
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            strcpy(data, ""abcdefghijklmnopqrstuvwxyz"");
            
            memcpy(data + 6, data + 4, 10*sizeof(char));
            printLine(data);
        }
"
5659,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_64a.c,"    size_t data;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = strtoul(inputBuffer, NULL, 0);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
9821,0,CWE401_Memory_Leak__new_int_67a.cpp,"    int * data;
    structType myStruct;
    data = NULL;
    
    data = new int;
    
    *data = 5;
    printIntLine(*data);
    myStruct.structFirst = data;
"
8233,0,CWE590_Free_Memory_Not_on_Heap__free_struct_alloca_15.c,"    twoIntsStruct * data;
    data = NULL; 
    switch(6)
    {
    case 6:
    {
        
        twoIntsStruct * dataBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i].intOne = 1;
                dataBuffer[i].intTwo = 1;
            }
        }
        data = dataBuffer;
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    printStructLine(&data[0]);
    
"
327,0,CWE758_Undefined_Behavior__struct_malloc_use_08.c,"    if(staticReturnsTrue())
    {
        {
            twoIntsStruct * pointer = (twoIntsStruct *)malloc(sizeof(twoIntsStruct));
            if (pointer == NULL) {exit(-1);}
            twoIntsStruct data = *pointer; 
            free(pointer);
            printIntLine(data.intOne);
            printIntLine(data.intTwo);
        }
"
2834,0,CWE134_Uncontrolled_Format_String__char_environment_snprintf_45.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        
        if (environment != NULL)
        {
            
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    CWE134_Uncontrolled_Format_String__char_environment_snprintf_45_badData = data;
"
2236,1,CWE252_Unchecked_Return_Value__char_fread_02.c,"    if(1)
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            
            if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) != 100-1)
            {
                printLine(""fread failed!"");
            }
        }
"
1001,0,CWE134_Uncontrolled_Format_String__char_file_vfprintf_62a.cpp,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    badSource(data);
"
7090,0,CWE590_Free_Memory_Not_on_Heap__delete_array_long_declare_81a.cpp,"    long * data;
    data = NULL; 
    {
        
        long dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5L;
            }
        }
        data = dataBuffer;
    }
    const CWE590_Free_Memory_Not_on_Heap__delete_array_long_declare_81_base& baseObject = CWE590_Free_Memory_Not_on_Heap__delete_array_long_declare_81_bad();
"
18707,0,CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_51a.c,"    unsigned int data;
    data = 0;
    
    fscanf (stdin, ""%u"", &data);
"
3007,0,CWE369_Divide_by_Zero__int_listen_socket_modulo_54a.c,"    int data;
    
    data = -1;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
4485,0,CWE369_Divide_by_Zero__float_connect_socket_53a.c,"    float data;
    
    data = 0.0F;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = (float)atof(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
2201,1,CWE252_Unchecked_Return_Value__char_sscanf_14.c,"    if(globalFive!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            
            if (sscanf(SRC, ""%99s\0"", data) == EOF)
            {
                printLine(""sscanf failed!"");
            }
        }
"
14028,0,CWE415_Double_Free__new_delete_class_43.cpp,"    TwoIntsClass * data;
    
    data = NULL;
    badSource(data);
    
"
11250,0,CWE789_Uncontrolled_Mem_Alloc__new_char_fgets_45.cpp,"    size_t data;
    
    data = 0;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = strtoul(inputBuffer, NULL, 0);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    badData = data;
"
30,0,CWE369_Divide_by_Zero__int_fscanf_divide_68a.c,"    int data;
    
    data = -1;
    
    fscanf(stdin, ""%d"", &data);
    CWE369_Divide_by_Zero__int_fscanf_divide_68_badData = data;
"
998,0,CWE134_Uncontrolled_Format_String__char_environment_snprintf_41.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        
        if (environment != NULL)
        {
            
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
"
19009,0,CWE197_Numeric_Truncation_Error__short_fscanf_66a.c,"    short data;
    short dataArray[5];
    
    data = -1;
    
    fscanf (stdin, ""%hd"", &data);
    
    dataArray[2] = data;
"
4877,0,CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_11.c,"    int data;
    
    data = -1;
    if(globalReturnsTrue())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
7509,0,CWE690_NULL_Deref_From_Return__int_realloc_15.c,"    int * data;
    data = NULL; 
    
    data = (int *)realloc(data, 1*sizeof(int));
    switch(6)
    {
    case 6:
        
        data[0] = 5;
        printIntLine(data[0]);
        free(data);
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
14168,1,CWE758_Undefined_Behavior__class_new_use_11.cpp,"    if(globalReturnsFalse())
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            TwoIntsClass data;
            data.intOne = 1;
            data.intTwo = 2;
            TwoIntsClass * pointer = new TwoIntsClass;
            *pointer = data; 
            {
                TwoIntsClass data = *pointer;
                printIntLine(data.intOne);
                printIntLine(data.intTwo);
            }
            delete pointer;
        }
"
10208,0,CWE190_Integer_Overflow__short_max_square_09.c,"    short data;
    data = 0;
    if(GLOBAL_CONST_TRUE)
    {
        
        data = SHRT_MAX;
    }
    if(GLOBAL_CONST_TRUE)
    {
        {
            
            short result = data * data;
            printIntLine(result);
        }
"
8582,0,CWE190_Integer_Overflow__unsigned_int_max_postinc_53a.c,"    unsigned int data;
    data = 0;
    
    data = UINT_MAX;
"
11714,1,CWE758_Undefined_Behavior__long_new_use_17.cpp,"    int k;
    for(k = 0; k < 1; k++)
    {
        {
            long data;
            data = 5L;
            long * pointer = new long;
            *pointer = data; 
            {
                long data = *pointer;
                printLongLine(data);
            }
            delete pointer;
        }
"
11486,1,CWE758_Undefined_Behavior__double_pointer_new_use_09.cpp,"    if(GLOBAL_CONST_FALSE)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            double * data;
            
            data = new double;
            *data = 5.0;
            double * * pointer = new double *;
            *pointer = data; 
            {
                double * data = *pointer;
                printDoubleLine(*data);
            }
            delete pointer;
        }
"
17687,0,CWE690_NULL_Deref_From_Return__char_calloc_53a.c,"    char * data;
    data = NULL; 
    
    data = (char *)calloc(20, sizeof(char));
"
5568,0,CWE415_Double_Free__new_delete_array_int64_t_74a.cpp,"    int64_t * data;
    map<int, int64_t *> dataMap;
    
    data = NULL;
    data = new int64_t[100];
    
    delete [] data;
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
19180,1,CWE758_Undefined_Behavior__long_alloca_use_17.c,"    int k;
    for(k = 0; k < 1; k++)
    {
        {
            long data;
            long * pointer = (long *)ALLOCA(sizeof(long));
            data = 5L;
            *pointer = data; 
            {
                long data = *pointer;
                printLongLine(data);
            }
        }
"
16558,0,CWE563_Unused_Variable__unused_init_variable_int64_t_14.c,"    int64_t data;
    
    data = 5LL;
    if(globalFive==5)
    {
        
        
        ; 
"
7841,0,CWE401_Memory_Leak__int_calloc_54a.c,"    int * data;
    data = NULL;
    
    data = (int *)calloc(100, sizeof(int));
    if (data == NULL) {exit(-1);}
    
    data[0] = 5;
    printIntLine(data[0]);
"
11934,0,CWE369_Divide_by_Zero__int_rand_modulo_32.c,"    int data;
    int *dataPtr1 = &data;
    int *dataPtr2 = &data;
    
    data = -1;
    {
        int data = *dataPtr1;
        
        data = RAND32();
        *dataPtr1 = data;
    }
    {
        int data = *dataPtr2;
        
        printIntLine(100 % data);
"
6440,0,CWE415_Double_Free__new_delete_array_int_12.cpp,"    int * data;
    
    data = NULL;
    if(globalReturnsTrueOrFalse())
    {
        data = new int[100];
        
        delete [] data;
    }
    else
    {
        data = new int[100];
        
    }
    if(globalReturnsTrueOrFalse())
    {
        
        delete [] data;
    }
    else
    {
        
        
        ; 
"
3596,0,CWE190_Integer_Overflow__int_fgets_add_42.c,"    int data;
    
    data = 0;
    data = badSource(data);
    {
        
        int result = data + 1;
        printIntLine(result);
"
12952,1,CWE676_Use_of_Potentially_Dangerous_Function__basic_06.cpp,"    if(STATIC_CONST_FIVE!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            char charBuffer[CHAR_BUFFER_SIZE];
            
            cin.width(CHAR_BUFFER_SIZE);
            cin >> charBuffer;
            charBuffer[CHAR_BUFFER_SIZE-1] = '\0';
            printLine(charBuffer);
        }
"
10009,0,CWE369_Divide_by_Zero__int_rand_divide_42.c,"    int data;
    
    data = -1;
    data = badSource(data);
    
"
11603,0,CWE190_Integer_Overflow__int_fscanf_multiply_81a.cpp,"    int data;
    
    data = 0;
    
    fscanf(stdin, ""%d"", &data);
    const CWE190_Integer_Overflow__int_fscanf_multiply_81_base& baseObject = CWE190_Integer_Overflow__int_fscanf_multiply_81_bad();
"
15948,0,CWE190_Integer_Overflow__int_rand_postinc_31.c,"    int data;
    
    data = 0;
    
    data = RAND32();
    {
        int dataCopy = data;
        int data = dataCopy;
        {
            
            data++;
            int result = data;
            printIntLine(result);
        }
"
17915,1,CWE758_Undefined_Behavior__int64_t_alloca_use_10.c,"    if(globalTrue)
    {
        {
            int64_t data;
            int64_t * pointer = (int64_t *)ALLOCA(sizeof(int64_t));
            data = 5LL;
            *pointer = data; 
            {
                int64_t data = *pointer;
                printLongLongLine(data);
            }
        }
"
6619,0,CWE690_NULL_Deref_From_Return__fopen_16.c,"    FILE * data;
    
    data = NULL;
    
    data = fopen(""file.txt"", ""w+"");
    while(1)
    {
        
        fclose(data);
        break;
"
19490,0,CWE190_Integer_Overflow__int_listen_socket_add_62a.cpp,"    int data;
    
    data = 0;
    badSource(data);
    {
        
        int result = data + 1;
        printIntLine(result);
"
9970,0,CWE190_Integer_Overflow__int64_t_fscanf_multiply_06.c,"    int64_t data;
    data = 0LL;
    if(STATIC_CONST_FIVE==5)
    {
        
        fscanf (stdin, ""%"" SCNd64, &data);
    }
    if(STATIC_CONST_FIVE==5)
    {
        if(data > 0) 
        {
            
            int64_t result = data * 2;
            printLongLongLine(result);
        }
"
67,0,CWE190_Integer_Overflow__char_max_add_21.c,"    char data;
    data = ' ';
    
    data = CHAR_MAX;
    badStatic = 1; 
"
18731,0,CWE690_NULL_Deref_From_Return__fopen_67a.c,"    FILE * data;
    CWE690_NULL_Deref_From_Return__fopen_67_structType myStruct;
    
    data = NULL;
    
    data = fopen(""file.txt"", ""w+"");
    myStruct.structFirst = data;
"
4862,0,CWE369_Divide_by_Zero__float_rand_05.c,"    float data;
    
    data = 0.0F;
    if(staticTrue)
    {
        
        data = (float)RAND32();
    }
    if(staticTrue)
    {
        {
            
            int result = (int)(100.0 / data);
            printIntLine(result);
        }
"
11243,0,CWE401_Memory_Leak__struct_twoIntsStruct_malloc_10.c,"    struct _twoIntsStruct * data;
    data = NULL;
    if(globalTrue)
    {
        
        data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));
        if (data == NULL) {exit(-1);}
        
        data[0].intOne = 0;
        data[0].intTwo = 0;
        printStructLine((twoIntsStruct *)&data[0]);
    }
    if(globalTrue)
    {
        
        ; 
"
14302,0,CWE190_Integer_Overflow__short_max_postinc_41.c,"    short data;
    data = 0;
    
    data = SHRT_MAX;
"
14472,0,CWE190_Integer_Overflow__int64_t_max_square_13.c,"    int64_t data;
    data = 0LL;
    if(GLOBAL_CONST_FIVE==5)
    {
        
        data = LLONG_MAX;
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            
            int64_t result = data * data;
            printLongLongLine(result);
        }
"
17636,0,CWE134_Uncontrolled_Format_String__char_file_printf_61a.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    data = CWE134_Uncontrolled_Format_String__char_file_printf_61b_badSource(data);
    
"
4228,0,CWE665_Improper_Initialization__char_cat_83_bad.cpp,"Label Definition File: CWE665_Improper_Initialization.label.xml
Template File: sources-sink-83_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 665 Improper Initialization
 * BadSource:  Do not initialize data properly
 * GoodSource: Initialize data
 * Sinks: cat
 *    BadSink : Copy string to data using strcat
 * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE665_Improper_Initialization__char_cat_83.h""

namespace CWE665_Improper_Initialization__char_cat_83
{
CWE665_Improper_Initialization__char_cat_83_bad::CWE665_Improper_Initialization__char_cat_83_bad(char * dataCopy)
{
    data = dataCopy;
    
    ; 
}

CWE665_Improper_Initialization__char_cat_83_bad::~CWE665_Improper_Initialization__char_cat_83_bad()
{
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        
        strcat(data, source);
        printLine(data);
    }
}
}
"
6277,1,CWE758_Undefined_Behavior__int_malloc_use_18.c,"    goto sink;
sink:
    {
        int data;
        int * pointer = (int *)malloc(sizeof(int));
        if (pointer == NULL) {exit(-1);}
        data = 5;
        *pointer = data; 
        {
            int data = *pointer;
            printIntLine(data);
        }
        free(pointer);
"
941,1,CWE758_Undefined_Behavior__int_new_use_17.cpp,"    int k;
    for(k = 0; k < 1; k++)
    {
        {
            int data;
            data = 5;
            int * pointer = new int;
            *pointer = data; 
            {
                int data = *pointer;
                printIntLine(data);
            }
            delete pointer;
        }
"
13219,0,CWE590_Free_Memory_Not_on_Heap__delete_array_struct_declare_01.cpp,"    twoIntsStruct * data;
    data = NULL; 
    {
        
        twoIntsStruct dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i].intOne = 1;
                dataBuffer[i].intTwo = 1;
            }
        }
        data = dataBuffer;
    }
    printStructLine(&data[0]);
    
"
9008,0,CWE401_Memory_Leak__new_array_int64_t_82_bad.cpp,"Label Definition File: CWE401_Memory_Leak__new_array.label.xml
Template File: sources-sinks-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 401 Memory Leak
 * BadSource:  Allocate data using new[]
 * GoodSource: Point data to a stack buffer
 * Sinks:
 *    GoodSink: call delete[] on data
 *    BadSink : no deallocation of data
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE401_Memory_Leak__new_array_int64_t_82.h""

namespace CWE401_Memory_Leak__new_array_int64_t_82
{

void CWE401_Memory_Leak__new_array_int64_t_82_bad::action(int64_t * data)
{
    
    ; 
}

}
"
10790,0,CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_45.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_45_badData = data;
"
8528,0,CWE758_Undefined_Behavior__int_alloca_use_06.c,"    if(STATIC_CONST_FIVE==5)
    {
        {
            int * pointer = (int *)ALLOCA(sizeof(int));
            int data = *pointer; 
            printIntLine(data);
        }
"
1442,1,CWE758_Undefined_Behavior__char_pointer_new_use_09.cpp,"    if(GLOBAL_CONST_FALSE)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            char * data;
            data = ""string"";
            char * * pointer = new char *;
            *pointer = data; 
            {
                char * data = *pointer;
                printLine(data);
            }
            delete pointer;
        }
"
5663,0,CWE190_Integer_Overflow__short_rand_postinc_10.c,"    short data;
    data = 0;
    if(globalTrue)
    {
        
        data = (short)RAND32();
    }
    if(globalTrue)
    {
        {
            
            data++;
            short result = data;
            printIntLine(result);
        }
"
12967,0,CWE758_Undefined_Behavior__int64_t_new_use_18.cpp,"    goto sink;
sink:
    {
        int64_t * pointer = new int64_t;
        int64_t data = *pointer; 
        delete pointer;
        printLongLongLine(data);
"
16106,0,CWE690_NULL_Deref_From_Return__int64_t_malloc_43.cpp,"    int64_t * data;
    data = NULL; 
    badSource(data);
    
    data[0] = 5LL;
    printLongLongLine(data[0]);
"
4724,0,CWE190_Integer_Overflow__int_connect_socket_multiply_72a.cpp,"    int data;
    vector<int> dataVector;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
2072,0,CWE415_Double_Free__new_delete_array_int_82_bad.cpp,"Label Definition File: CWE415_Double_Free__new_delete_array.label.xml
Template File: sources-sinks-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 415 Double Free
 * BadSource:  Allocate data using new and Deallocae data using delete
 * GoodSource: Allocate data using new
 * Sinks:
 *    GoodSink: do nothing
 *    BadSink : Deallocate data using delete
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE415_Double_Free__new_delete_array_int_82.h""

namespace CWE415_Double_Free__new_delete_array_int_82
{

void CWE415_Double_Free__new_delete_array_int_82_bad::action(int * data)
{
    
    delete [] data;
}

}
"
4323,0,CWE563_Unused_Variable__unused_value_int_22a.c,"    int data;
    
    data = 5;
    CWE563_Unused_Variable__unused_value_int_22_badGlobal = 1; 
"
6744,0,CWE190_Integer_Overflow__int_fscanf_square_41.c,"    int data;
    
    data = 0;
    
    fscanf(stdin, ""%d"", &data);
"
9953,0,CWE758_Undefined_Behavior__double_pointer_new_use_05.cpp,"    if(staticTrue)
    {
        {
            double * * pointer = new double *;
            double * data = *pointer; 
            delete pointer;
            printDoubleLine(*data);
        }
"
7581,0,CWE369_Divide_by_Zero__float_listenSocket_63a.c,"    float data;
    
    data = 0.0F;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = (float)atof(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
19541,1,CWE252_Unchecked_Return_Value__char_snprintf_13.c,"    if(GLOBAL_CONST_FIVE==5)
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            
            if (SNPRINTF(data,100-strlen(SRC)-1, ""%s\n"", SRC) < 0)
            {
                printLine(""snprintf failed!"");
            }
        }
"
15341,0,CWE197_Numeric_Truncation_Error__short_rand_83a.cpp,"    short data;
    
    data = -1;
"
6637,0,CWE401_Memory_Leak__new_array_int_68a.cpp,"    int * data;
    data = NULL;
    
    data = new int[100];
    
    data[0] = 5;
    printIntLine(data[0]);
    badData = data;
"
15507,0,CWE190_Integer_Overflow__int64_t_fscanf_add_18.c,"    int64_t data;
    data = 0LL;
    goto source;
source:
    
    fscanf (stdin, ""%"" SCNd64, &data);
    goto sink;
sink:
    {
        
        int64_t result = data + 1;
        printLongLongLine(result);
"
3255,0,CWE690_NULL_Deref_From_Return__char_malloc_62a.cpp,"    char * data;
    data = NULL; 
    badSource(data);
    
    strcpy(data, ""Initialize"");
    printLine(data);
"
7893,0,CWE190_Integer_Overflow__int64_t_max_preinc_06.c,"    int64_t data;
    data = 0LL;
    if(STATIC_CONST_FIVE==5)
    {
        
        data = LLONG_MAX;
    }
    if(STATIC_CONST_FIVE==5)
    {
        {
            
            ++data;
            int64_t result = data;
            printLongLongLine(result);
        }
"
18748,0,CWE78_OS_Command_Injection__char_environment_popen_67a.c,"    char * data;
    CWE78_OS_Command_Injection__char_environment_popen_67_structType myStruct;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
        
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        
        if (environment != NULL)
        {
            
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    myStruct.structFirst = data;
"
5759,0,CWE190_Integer_Overflow__int_fgets_square_54a.c,"    int data;
    
    data = 0;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
"
4298,0,CWE457_Use_of_Uninitialized_Variable__int_array_alloca_partial_init_64a.c,"    int * data;
    data = (int *)ALLOCA(10*sizeof(int));
    
    {
        int i;
        for(i=0; i<(10/2); i++)
        {
            data[i] = i;
        }
    }
"
5383,0,CWE401_Memory_Leak__new_int_82_bad.cpp,"Label Definition File: CWE401_Memory_Leak__new.label.xml
Template File: sources-sinks-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 401 Memory Leak
 * BadSource:  Allocate data using new
 * GoodSource: Allocate data on the stack
 * Sinks:
 *    GoodSink: call delete on data
 *    BadSink : no deallocation of data
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE401_Memory_Leak__new_int_82.h""

namespace CWE401_Memory_Leak__new_int_82
{

void CWE401_Memory_Leak__new_int_82_bad::action(int * data)
{
    
    ; 
}

}
"
10370,0,CWE190_Integer_Overflow__unsigned_int_rand_preinc_14.c,"    unsigned int data;
    data = 0;
    if(globalFive==5)
    {
        
        data = (unsigned int)RAND32();
    }
    if(globalFive==5)
    {
        {
            
            ++data;
            unsigned int result = data;
            printUnsignedLine(result);
        }
"
3822,1,CWE758_Undefined_Behavior__char_new_use_15.cpp,"    switch(6)
    {
    case 6:
    {
        char data;
        data = 5;
        char * pointer = new char;
        *pointer = data; 
        {
            char data = *pointer;
            printHexCharLine(data);
        }
        delete pointer;
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
9510,0,CWE590_Free_Memory_Not_on_Heap__free_long_declare_10.c,"    long * data;
    data = NULL; 
    if(globalTrue)
    {
        {
            
            long dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5L;
                }
            }
            data = dataBuffer;
        }
    }
    printLongLine(data[0]);
    
"
17426,0,CWE190_Integer_Overflow__char_max_postinc_07.c,"    char data;
    data = ' ';
    if(staticFive==5)
    {
        
        data = CHAR_MAX;
    }
    if(staticFive==5)
    {
        {
            
            data++;
            char result = data;
            printHexCharLine(result);
        }
"
4942,0,CWE590_Free_Memory_Not_on_Heap__delete_struct_static_16.cpp,"    twoIntsStruct * data;
    data = NULL; 
    while(1)
    {
        {
            
            static twoIntsStruct dataBuffer;
            dataBuffer.intOne = 1;
            dataBuffer.intTwo = 1;
            data = &dataBuffer;
        }
        break;
    }
    printStructLine(data);
    
"
1791,0,CWE401_Memory_Leak__struct_twoIntsStruct_malloc_13.c,"    struct _twoIntsStruct * data;
    data = NULL;
    if(GLOBAL_CONST_FIVE==5)
    {
        
        data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));
        if (data == NULL) {exit(-1);}
        
        data[0].intOne = 0;
        data[0].intTwo = 0;
        printStructLine((twoIntsStruct *)&data[0]);
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        
        ; 
"
5545,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_44.c,"    size_t data;
    
    void (*funcPtr) (size_t) = badSink;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = strtoul(inputBuffer, NULL, 0);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
"
9957,0,CWE197_Numeric_Truncation_Error__int_fgets_to_char_84_bad.cpp,"Label Definition File: CWE197_Numeric_Truncation_Error__int.label.xml
Template File: sources-sink-84_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 197 Numeric Truncation Error
 * BadSource: fgets Read data from the console using fgets()
 * GoodSource: Less than CHAR_MAX
 * Sinks: to_char
 *    BadSink : Convert data to a char
 * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE197_Numeric_Truncation_Error__int_fgets_to_char_84.h""

#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)

namespace CWE197_Numeric_Truncation_Error__int_fgets_to_char_84
{
CWE197_Numeric_Truncation_Error__int_fgets_to_char_84_bad::CWE197_Numeric_Truncation_Error__int_fgets_to_char_84_bad(int dataCopy)
{
    data = dataCopy;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
}

CWE197_Numeric_Truncation_Error__int_fgets_to_char_84_bad::~CWE197_Numeric_Truncation_Error__int_fgets_to_char_84_bad()
{
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
    }
}
}
"
13870,0,CWE789_Uncontrolled_Mem_Alloc__new_char_listen_socket_15.cpp,"    size_t data;
    
    data = 0;
    switch(6)
    {
    case 6:
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = strtoul(inputBuffer, NULL, 0);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
    {
        char * myString;
        /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
         * for the strcpy() function to not cause a buffer overflow */
        
        if (data > strlen(HELLO_STRING))
        {
            myString = new char[data];
            
            strcpy(myString, HELLO_STRING);
            printLine(myString);
            delete [] myString;
        }
        else
        {
            printLine(""Input is less than the length of the source string"");
        }
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
9594,0,CWE78_OS_Command_Injection__char_environment_system_06.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(STATIC_CONST_FIVE==5)
    {
        {
            
            size_t dataLen = strlen(data);
            char * environment = GETENV(ENV_VARIABLE);
            
            if (environment != NULL)
            {
                
                strncat(data+dataLen, environment, 100-dataLen-1);
            }
        }
    }
    
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
"
13569,0,CWE590_Free_Memory_Not_on_Heap__delete_char_alloca_10.cpp,"    char * data;
    data = NULL; 
    if(globalTrue)
    {
        {
            
            char * dataBuffer = (char *)ALLOCA(sizeof(char));
            *dataBuffer = 'A';
            data = dataBuffer;
        }
    }
    printHexCharLine(*data);
    
"
3726,0,CWE590_Free_Memory_Not_on_Heap__delete_int_static_41.cpp,"    int * data;
    data = NULL; 
    {
        
        static int dataBuffer;
        dataBuffer = 5;
        data = &dataBuffer;
    }
"
19339,0,CWE190_Integer_Overflow__unsigned_int_fscanf_add_18.c,"    unsigned int data;
    data = 0;
    goto source;
source:
    
    fscanf (stdin, ""%u"", &data);
    goto sink;
sink:
    {
        
        unsigned int result = data + 1;
        printUnsignedLine(result);
"
14576,0,CWE590_Free_Memory_Not_on_Heap__free_char_static_16.c,"    char * data;
    data = NULL; 
    while(1)
    {
        {
            
            static char dataBuffer[100];
            memset(dataBuffer, 'A', 100-1); 
            dataBuffer[100-1] = '\0'; 
            data = dataBuffer;
        }
        break;
    }
    printLine(data);
    
"
6834,0,CWE758_Undefined_Behavior__class_pointer_new_use_02.cpp,"    if(1)
    {
        {
            TwoIntsClass * * pointer = new TwoIntsClass *;
            TwoIntsClass * data = *pointer; 
            delete pointer;
            printIntLine(data->intOne);
            printIntLine(data->intTwo);
        }
"
3791,0,CWE190_Integer_Overflow__int64_t_rand_add_83_bad.cpp,"Label Definition File: CWE190_Integer_Overflow.label.xml
Template File: sources-sinks-83_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 190 Integer Overflow
 * BadSource: rand Set data to result of rand()
 * GoodSource: Set data to a small, non-zero number (two)
 * Sinks: add
 *    GoodSink: Ensure there will not be an overflow before adding 1 to data
 *    BadSink : Add 1 to data, which can cause an overflow
 * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE190_Integer_Overflow__int64_t_rand_add_83.h""

namespace CWE190_Integer_Overflow__int64_t_rand_add_83
{
CWE190_Integer_Overflow__int64_t_rand_add_83_bad::CWE190_Integer_Overflow__int64_t_rand_add_83_bad(int64_t dataCopy)
{
    data = dataCopy;
    
    data = (int64_t)RAND64();
}

CWE190_Integer_Overflow__int64_t_rand_add_83_bad::~CWE190_Integer_Overflow__int64_t_rand_add_83_bad()
{
    {
        
        int64_t result = data + 1;
        printLongLongLine(result);
    }
}
}
"
7796,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_66a.c,"    size_t data;
    size_t dataArray[5];
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = strtoul(inputBuffer, NULL, 0);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
    dataArray[2] = data;
"
13545,0,CWE190_Integer_Overflow__int_listen_socket_postinc_64a.c,"    int data;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
10137,0,CWE190_Integer_Overflow__int_connect_socket_postinc_05.c,"    int data;
    
    data = 0;
    if(staticTrue)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(staticTrue)
    {
        {
            
            data++;
            int result = data;
            printIntLine(result);
        }
"
11626,0,CWE758_Undefined_Behavior__int_malloc_use_06.c,"    if(STATIC_CONST_FIVE==5)
    {
        {
            int * pointer = (int *)malloc(sizeof(int));
            if (pointer == NULL) {exit(-1);}
            int data = *pointer; 
            free(pointer);
            printIntLine(data);
        }
"
8118,0,CWE690_NULL_Deref_From_Return__long_realloc_52a.c,"    long * data;
    data = NULL; 
    
    data = (long *)realloc(data, 1*sizeof(long));
"
11006,0,CWE197_Numeric_Truncation_Error__short_fgets_18.c,"    short data;
    
    data = -1;
    goto source;
source:
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = (short)atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
1643,0,CWE590_Free_Memory_Not_on_Heap__delete_array_int64_t_alloca_54a.cpp,"    int64_t * data;
    data = NULL; 
    {
        
        int64_t * dataBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5LL;
            }
        }
        data = dataBuffer;
    }
"
3238,0,CWE134_Uncontrolled_Format_String__char_connect_socket_printf_83_bad.cpp,"Label Definition File: CWE134_Uncontrolled_Format_String.label.xml
Template File: sources-sinks-83_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 134 Uncontrolled Format String
 * BadSource: connect_socket Read data using a connect socket (client side)
 * GoodSource: Copy a fixed string into data
 * Sinks: printf
 *    GoodSink: printf with ""%s"" as the first argument and data as the second
 *    BadSink : printf with only data as an argument
 * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE134_Uncontrolled_Format_String__char_connect_socket_printf_83.h""

#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif

#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""

namespace CWE134_Uncontrolled_Format_String__char_connect_socket_printf_83
{
CWE134_Uncontrolled_Format_String__char_connect_socket_printf_83_bad::CWE134_Uncontrolled_Format_String__char_connect_socket_printf_83_bad(char * dataCopy)
{
    data = dataCopy;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
}

CWE134_Uncontrolled_Format_String__char_connect_socket_printf_83_bad::~CWE134_Uncontrolled_Format_String__char_connect_socket_printf_83_bad()
{
    
    printf(data);
}
}
"
6787,0,CWE190_Integer_Overflow__int_rand_add_54a.c,"    int data;
    
    data = 0;
    
    data = RAND32();
"
14215,0,CWE78_OS_Command_Injection__char_environment_execlp_63a.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        
        if (environment != NULL)
        {
            
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
"
18056,0,CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_68a.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_68_badData = data;
"
4062,0,CWE590_Free_Memory_Not_on_Heap__delete_char_declare_12.cpp,"    char * data;
    data = NULL; 
    if(globalReturnsTrueOrFalse())
    {
        {
            
            char dataBuffer;
            dataBuffer = 'A';
            data = &dataBuffer;
        }
    }
    else
    {
        {
            
            char * dataBuffer = new char;
            *dataBuffer = 'A';
            data = dataBuffer;
        }
    }
    printHexCharLine(*data);
    
"
3619,0,CWE590_Free_Memory_Not_on_Heap__delete_array_int_alloca_73a.cpp,"    int * data;
    list<int *> dataList;
    data = NULL; 
    {
        
        int * dataBuffer = (int *)ALLOCA(100*sizeof(int));
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5;
            }
        }
        data = dataBuffer;
    }
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
11589,0,CWE415_Double_Free__malloc_free_struct_34.c,"    twoIntsStruct * data;
    CWE415_Double_Free__malloc_free_struct_34_unionType myUnion;
    
    data = NULL;
    data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
    if (data == NULL) {exit(-1);}
    
    free(data);
    myUnion.unionFirst = data;
    {
        twoIntsStruct * data = myUnion.unionSecond;
        
        free(data);
"
3445,0,CWE475_Undefined_Behavior_for_Input_to_API__char_13.c,"    if(GLOBAL_CONST_FIVE==5)
    {
        {
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            strcpy(data, ""abcdefghijklmnopqrstuvwxyz"");
            
            memcpy(data + 6, data + 4, 10*sizeof(char));
            printLine(data);
        }
"
13601,0,CWE197_Numeric_Truncation_Error__int_connect_socket_to_short_02.c,"    int data;
    
    data = -1;
    if(1)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    {
        
        short shortData = (short)data;
        printShortLine(shortData);
"
9257,0,CWE401_Memory_Leak__char_realloc_73a.cpp,"    char * data;
    list<char *> dataList;
    data = NULL;
    
    data = (char *)realloc(data, 100*sizeof(char));
    if (data == NULL) {exit(-1);}
    
    strcpy(data, ""A String"");
    printLine(data);
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
14826,0,CWE590_Free_Memory_Not_on_Heap__delete_char_alloca_73a.cpp,"    char * data;
    list<char *> dataList;
    data = NULL; 
    {
        
        char * dataBuffer = (char *)ALLOCA(sizeof(char));
        *dataBuffer = 'A';
        data = dataBuffer;
    }
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
14927,0,CWE78_OS_Command_Injection__char_file_execlp_32.c,"    char * data;
    char * *dataPtr1 = &data;
    char * *dataPtr2 = &data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        char * data = *dataPtr1;
        {
            
            size_t dataLen = strlen(data);
            FILE * pFile;
            
            if (100-dataLen > 1)
            {
                pFile = fopen(FILENAME, ""r"");
                if (pFile != NULL)
                {
                    
                    if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                    {
                        printLine(""fgets() failed"");
                        
                        data[dataLen] = '\0';
                    }
                    fclose(pFile);
                }
            }
        }
        *dataPtr1 = data;
    }
    {
        char * data = *dataPtr2;
        /* execlp - searches for the location of the command among
         * the directories specified by the PATH environment variable */
        
        EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
"
9556,0,CWE758_Undefined_Behavior__int_malloc_use_01.c,"    {
        int * pointer = (int *)malloc(sizeof(int));
        if (pointer == NULL) {exit(-1);}
        int data = *pointer; 
        free(pointer);
        printIntLine(data);
"
12330,0,CWE467_Use_of_sizeof_on_Pointer_Type__short_01.c,"    {
        short * badShort = NULL;
        
        badShort = (short *)malloc(sizeof(badShort));
        if (badShort == NULL) {exit(-1);}
        *badShort = 5;
        printShortLine(*badShort);
        free(badShort);
"
15690,1,CWE758_Undefined_Behavior__int64_t_new_use_07.cpp,"    if(staticFive!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            int64_t data;
            data = 5LL;
            int64_t * pointer = new int64_t;
            *pointer = data; 
            {
                int64_t data = *pointer;
                printLongLongLine(data);
            }
            delete pointer;
        }
"
2858,0,CWE190_Integer_Overflow__int_fgets_add_05.c,"    int data;
    
    data = 0;
    if(staticTrue)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    if(staticTrue)
    {
        {
            
            int result = data + 1;
            printIntLine(result);
        }
"
9908,0,CWE190_Integer_Overflow__char_rand_add_73a.cpp,"    char data;
    list<char> dataList;
    data = ' ';
    
    data = (char)RAND32();
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
7675,0,CWE197_Numeric_Truncation_Error__short_listen_socket_22a.c,"    short data;
    
    data = -1;
    CWE197_Numeric_Truncation_Error__short_listen_socket_22_badGlobal = 1; 
    data = CWE197_Numeric_Truncation_Error__short_listen_socket_22_badSource(data);
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
3965,0,CWE690_NULL_Deref_From_Return__fopen_83a.cpp,"    FILE * data;
    
    data = NULL;
"
6750,0,CWE78_OS_Command_Injection__char_console_execlp_31.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        
        if (100-dataLen > 1)
        {
            
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgets() */
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
"
11786,0,CWE190_Integer_Overflow__char_rand_add_54a.c,"    char data;
    data = ' ';
    
    data = (char)RAND32();
"
8457,0,CWE563_Unused_Variable__unused_init_variable_long_73a.cpp,"    long data;
    list<long> dataList;
    
    data = 5L;
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
9112,0,CWE590_Free_Memory_Not_on_Heap__delete_array_int_alloca_07.cpp,"    int * data;
    data = NULL; 
    if(staticFive==5)
    {
        {
            
            int * dataBuffer = (int *)ALLOCA(100*sizeof(int));
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5;
                }
            }
            data = dataBuffer;
        }
    }
    printIntLine(data[0]);
    
"
5975,0,CWE758_Undefined_Behavior__int_pointer_alloca_use_03.c,"    if(5==5)
    {
        {
            int * * pointer = (int * *)ALLOCA(sizeof(int *));
            int * data = *pointer; 
            printIntLine(*data);
        }
"
7191,0,CWE190_Integer_Overflow__short_max_postinc_42.c,"    short data;
    data = 0;
    data = badSource(data);
    {
        
        data++;
        short result = data;
        printIntLine(result);
"
11369,1,CWE252_Unchecked_Return_Value__char_fwrite_05.c,"    if(staticTrue)
    {
        
        if (fwrite((char *)""string"", sizeof(char), strlen(""string""), stdout) != strlen(""string""))
        {
            printLine(""fwrite failed!"");
        }
"
760,0,CWE401_Memory_Leak__int64_t_calloc_53a.c,"    int64_t * data;
    data = NULL;
    
    data = (int64_t *)calloc(100, sizeof(int64_t));
    if (data == NULL) {exit(-1);}
    
    data[0] = 5LL;
    printLongLongLine(data[0]);
"
10907,0,CWE475_Undefined_Behavior_for_Input_to_API__char_04.c,"    if(STATIC_CONST_TRUE)
    {
        {
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            strcpy(data, ""abcdefghijklmnopqrstuvwxyz"");
            
            memcpy(data + 6, data + 4, 10*sizeof(char));
            printLine(data);
        }
"
4044,0,CWE190_Integer_Overflow__short_rand_square_32.c,"    short data;
    short *dataPtr1 = &data;
    short *dataPtr2 = &data;
    data = 0;
    {
        short data = *dataPtr1;
        
        data = (short)RAND32();
        *dataPtr1 = data;
    }
    {
        short data = *dataPtr2;
        {
            
            short result = data * data;
            printIntLine(result);
        }
"
1148,0,CWE190_Integer_Overflow__int_rand_add_82_bad.cpp,"Label Definition File: CWE190_Integer_Overflow__int.label.xml
Template File: sources-sinks-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 190 Integer Overflow
 * BadSource: rand Set data to result of rand(), which may be zero
 * GoodSource: Set data to a small, non-zero number (two)
 * Sinks: add
 *    GoodSink: Ensure there will not be an overflow before adding 1 to data
 *    BadSink : Add 1 to data, which can cause an overflow
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE190_Integer_Overflow__int_rand_add_82.h""

namespace CWE190_Integer_Overflow__int_rand_add_82
{

void CWE190_Integer_Overflow__int_rand_add_82_bad::action(int data)
{
    {
        
        int result = data + 1;
        printIntLine(result);
    }
}

}
"
10294,0,CWE190_Integer_Overflow__int_connect_socket_add_33.cpp,"    int data;
    int &dataRef = data;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    {
        int data = dataRef;
        {
            
            int result = data + 1;
            printIntLine(result);
        }
"
5277,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_05.c,"    size_t data;
    
    data = 0;
    if(staticTrue)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                
                data = strtoul(inputBuffer, NULL, 0);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    if(staticTrue)
    {
        {
            char * myString;
            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
             * for the strcpy() function to not cause a buffer overflow */
            
            if (data > strlen(HELLO_STRING))
            {
                myString = (char *)malloc(data*sizeof(char));
                if (myString == NULL) {exit(-1);}
                
                strcpy(myString, HELLO_STRING);
                printLine(myString);
                free(myString);
            }
            else
            {
                printLine(""Input is less than the length of the source string"");
            }
        }
"
15676,0,CWE690_NULL_Deref_From_Return__struct_calloc_03.c,"    twoIntsStruct * data;
    data = NULL; 
    
    data = (twoIntsStruct *)calloc(1, sizeof(twoIntsStruct));
    if(5==5)
    {
        
        data[0].intOne = 1;
        data[0].intTwo = 1;
        printStructLine(&data[0]);
        free(data);
"
14395,1,CWE758_Undefined_Behavior__char_new_use_13.cpp,"    if(GLOBAL_CONST_FIVE!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            char data;
            data = 5;
            char * pointer = new char;
            *pointer = data; 
            {
                char data = *pointer;
                printHexCharLine(data);
            }
            delete pointer;
        }
"
16280,0,CWE457_Use_of_Uninitialized_Variable__new_struct_array_partial_init_06.cpp,"    twoIntsStruct * data;
    data = new twoIntsStruct[10];
    if(STATIC_CONST_FIVE==5)
    {
        
        {
            int i;
            for(i=0; i<(10/2); i++)
            {
                data[i].intOne = i;
                data[i].intTwo = i;
            }
        }
    }
    if(STATIC_CONST_FIVE==5)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i].intOne);
                printIntLine(data[i].intTwo);
            }
        }
        
        delete [] data;
"
10648,0,CWE563_Unused_Variable__unused_uninit_variable_long_22a.c,"    long data;
    
    ; 
    CWE563_Unused_Variable__unused_uninit_variable_long_22_badGlobal = 1; 
"
4223,0,CWE190_Integer_Overflow__unsigned_int_fscanf_square_11.c,"    unsigned int data;
    data = 0;
    if(globalReturnsTrue())
    {
        
        fscanf (stdin, ""%u"", &data);
    }
    if(globalReturnsTrue())
    {
        {
            
            unsigned int result = data * data;
            printUnsignedLine(result);
        }
"
3188,0,CWE190_Integer_Overflow__int_connect_socket_add_44.c,"    int data;
    
    void (*funcPtr) (int) = badSink;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
"
905,0,CWE190_Integer_Overflow__unsigned_int_rand_add_81_bad.cpp,"Label Definition File: CWE190_Integer_Overflow.label.xml
Template File: sources-sinks-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 190 Integer Overflow
 * BadSource: rand Set data to result of rand()
 * GoodSource: Set data to a small, non-zero number (two)
 * Sinks: add
 *    GoodSink: Ensure there will not be an overflow before adding 1 to data
 *    BadSink : Add 1 to data, which can cause an overflow
 * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE190_Integer_Overflow__unsigned_int_rand_add_81.h""

namespace CWE190_Integer_Overflow__unsigned_int_rand_add_81
{

void CWE190_Integer_Overflow__unsigned_int_rand_add_81_bad::action(unsigned int data) const
{
    {
        
        unsigned int result = data + 1;
        printUnsignedLine(result);
    }
}

}
"
8515,0,CWE190_Integer_Overflow__short_fscanf_add_31.c,"    short data;
    data = 0;
    
    fscanf (stdin, ""%hd"", &data);
    {
        short dataCopy = data;
        short data = dataCopy;
        {
            
            short result = data + 1;
            printIntLine(result);
        }
"
10190,0,CWE369_Divide_by_Zero__int_zero_divide_84_bad.cpp,"Label Definition File: CWE369_Divide_by_Zero__int.label.xml
Template File: sources-sinks-84_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 369 Divide by Zero
 * BadSource: zero Fixed value of zero
 * GoodSource: Non-zero
 * Sinks: divide
 *    GoodSink: Check for zero before dividing
 *    BadSink : Divide a constant by data
 * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE369_Divide_by_Zero__int_zero_divide_84.h""

namespace CWE369_Divide_by_Zero__int_zero_divide_84
{
CWE369_Divide_by_Zero__int_zero_divide_84_bad::CWE369_Divide_by_Zero__int_zero_divide_84_bad(int dataCopy)
{
    data = dataCopy;
    
    data = 0;
}

CWE369_Divide_by_Zero__int_zero_divide_84_bad::~CWE369_Divide_by_Zero__int_zero_divide_84_bad()
{
    
    printIntLine(100 / data);
}
}
"
552,0,CWE78_OS_Command_Injection__char_listen_socket_system_04.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(STATIC_CONST_TRUE)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                data[dataLen + recvResult / sizeof(char)] = '\0';
                
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
"
7240,0,CWE690_NULL_Deref_From_Return__long_calloc_16.c,"    long * data;
    data = NULL; 
    
    data = (long *)calloc(1, sizeof(long));
    while(1)
    {
        
        data[0] = 5L;
        printLongLine(data[0]);
        free(data);
        break;
"
3218,0,CWE690_NULL_Deref_From_Return__long_malloc_65a.c,"    long * data;
    
    void (*funcPtr) (long *) = CWE690_NULL_Deref_From_Return__long_malloc_65b_badSink;
    data = NULL; 
    
    data = (long *)malloc(1*sizeof(long));
    
"
5222,0,CWE78_OS_Command_Injection__char_connect_socket_popen_22a.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    CWE78_OS_Command_Injection__char_connect_socket_popen_22_badGlobal = 1; 
    data = CWE78_OS_Command_Injection__char_connect_socket_popen_22_badSource(data);
    {
        FILE *pipe;
        
        pipe = POPEN(data, ""w"");
        if (pipe != NULL)
        {
            PCLOSE(pipe);
        }
    }
}

#endif 
"
11103,0,CWE563_Unused_Variable__unused_init_variable_int_82a.cpp,"    int data;
    
    data = 5;
    CWE563_Unused_Variable__unused_init_variable_int_82_base* baseObject = new CWE563_Unused_Variable__unused_init_variable_int_82_bad;
    baseObject->action(data);
"
17913,0,CWE190_Integer_Overflow__int_connect_socket_add_09.c,"    int data;
    
    data = 0;
    if(GLOBAL_CONST_TRUE)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(GLOBAL_CONST_TRUE)
    {
        {
            
            int result = data + 1;
            printIntLine(result);
        }
"
13864,0,CWE190_Integer_Overflow__char_max_multiply_72a.cpp,"    char data;
    vector<char> dataVector;
    data = ' ';
    
    data = CHAR_MAX;
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
11816,0,CWE590_Free_Memory_Not_on_Heap__free_char_alloca_73a.cpp,"    char * data;
    list<char *> dataList;
    data = NULL; 
    {
        
        char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
        memset(dataBuffer, 'A', 100-1); 
        dataBuffer[100-1] = '\0'; 
        data = dataBuffer;
    }
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
16340,0,CWE190_Integer_Overflow__short_max_preinc_10.c,"    short data;
    data = 0;
    if(globalTrue)
    {
        
        data = SHRT_MAX;
    }
    if(globalTrue)
    {
        {
            
            ++data;
            short result = data;
            printIntLine(result);
        }
"
1325,0,CWE401_Memory_Leak__new_TwoIntsClass_53a.cpp,"    TwoIntsClass * data;
    data = NULL;
    
    data = new TwoIntsClass;
    
    data->intOne = 0;
    data->intTwo = 0;
    printIntLine(data->intOne);
    printIntLine(data->intTwo);
"
1454,1,CWE758_Undefined_Behavior__double_pointer_new_use_13.cpp,"    if(GLOBAL_CONST_FIVE==5)
    {
        {
            double * data;
            
            data = new double;
            *data = 5.0;
            double * * pointer = new double *;
            *pointer = data; 
            {
                double * data = *pointer;
                printDoubleLine(*data);
            }
            delete pointer;
        }
"
10312,0,CWE190_Integer_Overflow__short_fscanf_postinc_02.c,"    short data;
    data = 0;
    if(1)
    {
        
        fscanf (stdin, ""%hd"", &data);
    }
    if(1)
    {
        {
            
            data++;
            short result = data;
            printIntLine(result);
        }
"
16252,0,CWE190_Integer_Overflow__int_rand_multiply_05.c,"    int data;
    
    data = 0;
    if(staticTrue)
    {
        
        data = RAND32();
    }
    if(staticTrue)
    {
        if(data > 0) 
        {
            
            int result = data * 2;
            printIntLine(result);
        }
"
3045,0,CWE190_Integer_Overflow__char_max_add_17.c,"    int i,j;
    char data;
    data = ' ';
    for(i = 0; i < 1; i++)
    {
        
        data = CHAR_MAX;
    }
    for(j = 0; j < 1; j++)
    {
        {
            
            char result = data + 1;
            printHexCharLine(result);
        }
"
5992,0,CWE197_Numeric_Truncation_Error__int_large_to_char_66a.c,"    int data;
    int dataArray[5];
    
    data = -1;
    
    data = SHRT_MAX + 5;
    
    dataArray[2] = data;
"
13491,0,CWE190_Integer_Overflow__unsigned_int_max_multiply_31.c,"    unsigned int data;
    data = 0;
    
    data = UINT_MAX;
    {
        unsigned int dataCopy = data;
        unsigned int data = dataCopy;
        if(data > 0) 
        {
            
            unsigned int result = data * 2;
            printUnsignedLine(result);
        }
"
11105,0,CWE590_Free_Memory_Not_on_Heap__delete_array_struct_alloca_68a.cpp,"    twoIntsStruct * data;
    data = NULL; 
    {
        
        twoIntsStruct * dataBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i].intOne = 1;
                dataBuffer[i].intTwo = 1;
            }
        }
        data = dataBuffer;
    }
    CWE590_Free_Memory_Not_on_Heap__delete_array_struct_alloca_68_badData = data;
"
9028,0,CWE563_Unused_Variable__unused_uninit_variable_struct_16.c,"    twoIntsStruct data;
    
    ; 
    while(1)
    {
        
        
        ; 
        break;
"
17494,0,CWE457_Use_of_Uninitialized_Variable__double_array_alloca_partial_init_64a.c,"    double * data;
    data = (double *)ALLOCA(10*sizeof(double));
    
    {
        int i;
        for(i=0; i<(10/2); i++)
        {
            data[i] = (double)i;
        }
    }
"
16635,0,CWE758_Undefined_Behavior__struct_alloca_use_06.c,"    if(STATIC_CONST_FIVE==5)
    {
        {
            twoIntsStruct * pointer = (twoIntsStruct *)ALLOCA(sizeof(twoIntsStruct));
            twoIntsStruct data = *pointer; 
            printIntLine(data.intOne);
            printIntLine(data.intTwo);
        }
"
18649,0,CWE590_Free_Memory_Not_on_Heap__free_char_static_72a.cpp,"    char * data;
    vector<char *> dataVector;
    data = NULL; 
    {
        
        static char dataBuffer[100];
        memset(dataBuffer, 'A', 100-1); 
        dataBuffer[100-1] = '\0'; 
        data = dataBuffer;
    }
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
9488,0,CWE252_Unchecked_Return_Value__char_fputs_04.c,"    if(STATIC_CONST_TRUE)
    {
        
        fputs(""string"", stdout);
"
12052,0,CWE758_Undefined_Behavior__int64_t_alloca_use_02.c,"    if(1)
    {
        {
            int64_t * pointer = (int64_t *)ALLOCA(sizeof(int64_t));
            int64_t data = *pointer; 
            printLongLongLine(data);
        }
"
17852,0,CWE190_Integer_Overflow__int_fgets_postinc_04.c,"    int data;
    
    data = 0;
    if(STATIC_CONST_TRUE)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    if(STATIC_CONST_TRUE)
    {
        {
            
            data++;
            int result = data;
            printIntLine(result);
        }
"
4644,0,CWE190_Integer_Overflow__char_rand_square_62a.cpp,"    char data;
    data = ' ';
    badSource(data);
    {
        
        char result = data * data;
        printHexCharLine(result);
"
17546,0,CWE590_Free_Memory_Not_on_Heap__delete_class_static_08.cpp,"    TwoIntsClass * data;
    data = NULL; 
    if(staticReturnsTrue())
    {
        {
            
            static TwoIntsClass dataBuffer;
            dataBuffer.intOne = 1;
            dataBuffer.intTwo = 1;
            data = &dataBuffer;
        }
    }
    printIntLine(data->intOne);
    
"
1697,1,CWE252_Unchecked_Return_Value__char_fwrite_11.c,"    if(globalReturnsTrue())
    {
        
        if (fwrite((char *)""string"", sizeof(char), strlen(""string""), stdout) != strlen(""string""))
        {
            printLine(""fwrite failed!"");
        }
"
16940,0,CWE590_Free_Memory_Not_on_Heap__delete_array_long_static_15.cpp,"    long * data;
    data = NULL; 
    switch(6)
    {
    case 6:
    {
        
        static long dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5L;
            }
        }
        data = dataBuffer;
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    printLongLine(data[0]);
    
"
6393,0,CWE401_Memory_Leak__strdup_char_66a.c,"    char * data;
    char * dataArray[5];
    data = NULL;
    {
        char myString[] = ""myString"";
        
        data = strdup(myString);
        
        printLine(data);
    }
    
    dataArray[2] = data;
"
12732,0,CWE190_Integer_Overflow__int64_t_fscanf_postinc_65a.c,"    int64_t data;
    
    void (*funcPtr) (int64_t) = CWE190_Integer_Overflow__int64_t_fscanf_postinc_65b_badSink;
    data = 0LL;
    
    fscanf (stdin, ""%"" SCNd64, &data);
    
"
1203,0,CWE78_OS_Command_Injection__char_connect_socket_execlp_05.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(staticTrue)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET connectSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
"
10267,0,CWE369_Divide_by_Zero__float_fscanf_43.cpp,"    float data;
    
    data = 0.0F;
    badSource(data);
    {
        
        int result = (int)(100.0 / data);
        printIntLine(result);
"
13385,0,CWE190_Integer_Overflow__int64_t_max_multiply_12.c,"    int64_t data;
    data = 0LL;
    if(globalReturnsTrueOrFalse())
    {
        
        data = LLONG_MAX;
    }
    else
    {
        
        data = 2;
    }
    if(globalReturnsTrueOrFalse())
    {
        if(data > 0) 
        {
            
            int64_t result = data * 2;
            printLongLongLine(result);
        }
    }
    else
    {
        if(data > 0) 
        {
            
            if (data < (LLONG_MAX/2))
            {
                int64_t result = data * 2;
                printLongLongLine(result);
            }
            else
            {
                printLine(""data value is too large to perform arithmetic safely."");
            }
        }
"
4425,0,CWE690_NULL_Deref_From_Return__char_realloc_22a.c,"    char * data;
    data = NULL; 
    
    data = (char *)realloc(data, 20*sizeof(char));
    CWE690_NULL_Deref_From_Return__char_realloc_22_badGlobal = 1; 
"
18717,0,CWE190_Integer_Overflow__int64_t_rand_multiply_74a.cpp,"    int64_t data;
    map<int, int64_t> dataMap;
    data = 0LL;
    
    data = (int64_t)RAND64();
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
15900,0,CWE401_Memory_Leak__char_realloc_44.c,"    char * data;
    
    void (*funcPtr) (char *) = badSink;
    data = NULL;
    
    data = (char *)realloc(data, 100*sizeof(char));
    if (data == NULL) {exit(-1);}
    
    strcpy(data, ""A String"");
    printLine(data);
    
"
14828,0,CWE563_Unused_Variable__unused_value_char_05.c,"    char data;
    if(staticTrue)
    {
        
        data = 'C';
    }
    if(staticTrue)
    {
        
        data = 'Z';
        printHexCharLine(data);
"
13106,0,CWE563_Unused_Variable__unused_uninit_variable_char_10.c,"    char data;
    
    ; 
    if(globalTrue)
    {
        
        
        ; 
"
15168,0,CWE457_Use_of_Uninitialized_Variable__new_int_array_no_init_62a.cpp,"    int * data;
    data = new int[10];
    badSource(data);
    
    {
        int i;
        for(i=0; i<10; i++)
        {
            printIntLine(data[i]);
        }
    }
    
"
9921,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_72a.cpp,"    size_t data;
    vector<size_t> dataVector;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = strtoul(inputBuffer, NULL, 0);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
1823,1,CWE252_Unchecked_Return_Value__char_remove_10.c,"    if(globalFalse)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        
        if (REMOVE(""removemegood.txt"") != 0)
        {
            printLine(""remove failed!"");
        }
"
13027,0,CWE190_Integer_Overflow__int_fgets_multiply_15.c,"    int data;
    
    data = 0;
    switch(6)
    {
    case 6:
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
        if(data > 0) 
        {
            
            int result = data * 2;
            printIntLine(result);
        }
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
5062,0,CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_61a.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    data = CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_61b_badSource(data);
    
"
2569,0,CWE190_Integer_Overflow__unsigned_int_rand_square_01.c,"    unsigned int data;
    data = 0;
    
    data = (unsigned int)RAND32();
    {
        
        unsigned int result = data * data;
        printUnsignedLine(result);
"
17035,0,CWE78_OS_Command_Injection__char_console_execlp_12.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(globalReturnsTrueOrFalse())
    {
        {
            
            size_t dataLen = strlen(data);
            
            if (100-dataLen > 1)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
                {
                    /* The next few lines remove the carriage return from the string that is
                     * inserted by fgets() */
                    dataLen = strlen(data);
"
6800,0,CWE457_Use_of_Uninitialized_Variable__twointsclass_array_declare_no_init_16.cpp,"    TwoIntsClass * data;
    TwoIntsClass dataUninitArray[10];
    data = dataUninitArray;
    while(1)
    {
        
        ; 
        break;
    }
    while(1)
    {
        
        for(int i=0; i<10; i++)
        {
            printIntLine(data[i].intOne);
            printIntLine(data[i].intTwo);
        }
        break;
"
10728,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_54a.c,"    size_t data;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = strtoul(inputBuffer, NULL, 0);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
6205,0,CWE457_Use_of_Uninitialized_Variable__struct_array_declare_no_init_11.c,"    twoIntsStruct * data;
    twoIntsStruct dataUninitArray[10];
    data = dataUninitArray;
    if(globalReturnsTrue())
    {
        
        ; 
    }
    if(globalReturnsTrue())
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i].intOne);
                printIntLine(data[i].intTwo);
            }
        }
"
5579,0,CWE415_Double_Free__new_delete_array_int64_t_22a.cpp,"    int64_t * data;
    
    data = NULL;
    data = new int64_t[100];
    
    delete [] data;
    badGlobal = 1; 
"
7452,0,CWE78_OS_Command_Injection__char_connect_socket_execl_22a.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    CWE78_OS_Command_Injection__char_connect_socket_execl_22_badGlobal = 1; 
    data = CWE78_OS_Command_Injection__char_connect_socket_execl_22_badSource(data);
    
    
    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}

#endif 

#ifndef OMITGOOD


int CWE78_OS_Command_Injection__char_connect_socket_execl_22_goodG2B1Global = 0;
int CWE78_OS_Command_Injection__char_connect_socket_execl_22_goodG2B2Global = 0;
"
3662,0,CWE758_Undefined_Behavior__char_new_use_12.cpp,"    if(globalReturnsTrueOrFalse())
    {
        {
            char * pointer = new char;
            char data = *pointer; 
            delete pointer;
            printHexCharLine(data);
        }
    }
    else
    {
        {
            char data;
            data = 5;
            char * pointer = new char;
            *pointer = data; 
            {
                char data = *pointer;
                printHexCharLine(data);
            }
            delete pointer;
        }
"
19514,0,CWE457_Use_of_Uninitialized_Variable__int64_t_08.c,"    int64_t data;
    if(staticReturnsTrue())
    {
        
        ; 
    }
    if(staticReturnsTrue())
    {
        
        printLongLongLine(data);
"
2210,0,CWE369_Divide_by_Zero__float_rand_16.c,"    float data;
    
    data = 0.0F;
    while(1)
    {
        
        data = (float)RAND32();
        break;
    }
    while(1)
    {
        {
            
            int result = (int)(100.0 / data);
            printIntLine(result);
        }
        break;
"
11638,0,CWE78_OS_Command_Injection__char_environment_execlp_22a.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    CWE78_OS_Command_Injection__char_environment_execlp_22_badGlobal = 1; 
    data = CWE78_OS_Command_Injection__char_environment_execlp_22_badSource(data);
    /* execlp - searches for the location of the command among
     * the directories specified by the PATH environment variable */
    
"
12537,1,CWE401_Memory_Leak__malloc_realloc_char_09.c,"    if(GLOBAL_CONST_FALSE)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            char * data = (char *)malloc(100*sizeof(char));
            if (data == NULL) {exit(-1);}
            char * tmpData;
            
            strcpy(data, ""A String"");
            printLine(data);
            tmpData = (char *)realloc(data, (130000)*sizeof(char));
            /* FIX: Ensure realloc() was successful before assigning data to the memory block
            * allocated with realloc() */
            if (tmpData != NULL)
            {
                data = tmpData;
                
                strcpy(data, ""New String"");
                printLine(data);
            }
            free(data);
        }
"
14942,0,CWE369_Divide_by_Zero__int_fscanf_modulo_64a.c,"    int data;
    
    data = -1;
    
    fscanf(stdin, ""%d"", &data);
"
10163,1,CWE587_Assignment_of_Fixed_Address_to_Pointer__basic_08.c,"    if(staticReturnsTrue())
    {
        {
            
            char charStack = 'a';
            char *charPointer = &charStack;
            printHexCharLine(*charPointer);
        }
"
654,0,CWE197_Numeric_Truncation_Error__short_connect_socket_54a.c,"    short data;
    
    data = -1;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = (short)atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
2655,0,CWE197_Numeric_Truncation_Error__int_fscanf_to_char_02.c,"    int data;
    
    data = -1;
    if(1)
    {
        
        fscanf(stdin, ""%d"", &data);
    }
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
3349,0,CWE690_NULL_Deref_From_Return__long_malloc_45.c,"    long * data;
    data = NULL; 
    
    data = (long *)malloc(1*sizeof(long));
    CWE690_NULL_Deref_From_Return__long_malloc_45_badData = data;
"
14062,0,CWE190_Integer_Overflow__short_rand_multiply_65a.c,"    short data;
    
    void (*funcPtr) (short) = CWE190_Integer_Overflow__short_rand_multiply_65b_badSink;
    data = 0;
    
    data = (short)RAND32();
    
"
7298,1,CWE416_Use_After_Free__return_freed_ptr_13.c,"    if(GLOBAL_CONST_FIVE!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            
            char * reversedString = helperGood(""GoodSink"");
            printLine(reversedString);
            /* free(reversedString);
             * This call to free() was removed because we want the tool to detect the use after free,
             * but we don't want that function to be free(). Essentially we want to avoid a double free
             */
        }
"
4806,0,CWE476_NULL_Pointer_Dereference__class_82a.cpp,"    TwoIntsClass * data;
    
    data = NULL;
    CWE476_NULL_Pointer_Dereference__class_82_base* baseObject = new CWE476_NULL_Pointer_Dereference__class_82_bad;
    baseObject->action(data);
"
8384,0,CWE197_Numeric_Truncation_Error__int_connect_socket_to_short_53a.c,"    int data;
    
    data = -1;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
14213,0,CWE197_Numeric_Truncation_Error__int_rand_to_short_02.c,"    int data;
    
    data = -1;
    if(1)
    {
        
        data = RAND32();
    }
    {
        
        short shortData = (short)data;
        printShortLine(shortData);
"
1517,0,CWE758_Undefined_Behavior__class_new_use_07.cpp,"    if(staticFive==5)
    {
        {
            TwoIntsClass * pointer = new TwoIntsClass;
            TwoIntsClass data = *pointer; 
            delete pointer;
            printIntLine(data.intOne);
            printIntLine(data.intTwo);
        }
"
14444,0,CWE78_OS_Command_Injection__char_file_popen_06.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(STATIC_CONST_FIVE==5)
    {
        {
            
            size_t dataLen = strlen(data);
            FILE * pFile;
            
            if (100-dataLen > 1)
            {
                pFile = fopen(FILENAME, ""r"");
                if (pFile != NULL)
                {
                    
                    if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                    {
                        printLine(""fgets() failed"");
                        
                        data[dataLen] = '\0';
                    }
                    fclose(pFile);
                }
            }
        }
    }
    {
        FILE *pipe;
        
        pipe = POPEN(data, ""w"");
        if (pipe != NULL)
        {
            PCLOSE(pipe);
        }
"
5547,0,CWE134_Uncontrolled_Format_String__char_console_fprintf_82a.cpp,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        
        if (100-dataLen > 1)
        {
            
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgets() */
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
                    data[dataLen-1] = '\0';
                }
            }
            else
            {
                printLine(""fgets() failed"");
                
                data[dataLen] = '\0';
            }
        }
    }
    CWE134_Uncontrolled_Format_String__char_console_fprintf_82_base* baseObject = new CWE134_Uncontrolled_Format_String__char_console_fprintf_82_bad;
    baseObject->action(data);
"
5083,0,CWE190_Integer_Overflow__int64_t_rand_square_42.c,"    int64_t data;
    data = 0LL;
    data = badSource(data);
    {
        
        int64_t result = data * data;
        printLongLongLine(result);
"
9405,0,CWE190_Integer_Overflow__short_rand_preinc_05.c,"    short data;
    data = 0;
    if(staticTrue)
    {
        
        data = (short)RAND32();
    }
    if(staticTrue)
    {
        {
            
            ++data;
            short result = data;
            printIntLine(result);
        }
"
16313,0,CWE190_Integer_Overflow__short_max_add_84a.cpp,"    short data;
    data = 0;
    CWE190_Integer_Overflow__short_max_add_84_bad * badObject = new CWE190_Integer_Overflow__short_max_add_84_bad(data);
"
3287,0,CWE190_Integer_Overflow__char_rand_add_12.c,"    char data;
    data = ' ';
    if(globalReturnsTrueOrFalse())
    {
        
        data = (char)RAND32();
    }
    else
    {
        
        data = 2;
    }
    if(globalReturnsTrueOrFalse())
    {
        {
            
            char result = data + 1;
            printHexCharLine(result);
        }
    }
    else
    {
        
        if (data < CHAR_MAX)
        {
            char result = data + 1;
            printHexCharLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
"
12647,0,CWE401_Memory_Leak__twoIntsStruct_calloc_54a.c,"    twoIntsStruct * data;
    data = NULL;
    
    data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));
    if (data == NULL) {exit(-1);}
    
    data[0].intOne = 0;
    data[0].intTwo = 0;
    printStructLine(&data[0]);
"
7398,0,CWE197_Numeric_Truncation_Error__int_fgets_to_char_41.c,"    int data;
    
    data = -1;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
"
11570,0,CWE190_Integer_Overflow__int_fscanf_preinc_15.c,"    int data;
    
    data = 0;
    switch(6)
    {
    case 6:
        
        fscanf(stdin, ""%d"", &data);
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
    {
        
        ++data;
        int result = data;
        printIntLine(result);
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
19476,0,CWE401_Memory_Leak__struct_twoIntsStruct_realloc_17.c,"    int i,j;
    struct _twoIntsStruct * data;
    data = NULL;
    for(i = 0; i < 1; i++)
    {
        
        data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));
        if (data == NULL) {exit(-1);}
        
        data[0].intOne = 0;
        data[0].intTwo = 0;
        printStructLine((twoIntsStruct *)&data[0]);
    }
    for(j = 0; j < 1; j++)
    {
        
        ; 
"
14442,0,CWE789_Uncontrolled_Mem_Alloc__new_char_rand_73a.cpp,"    size_t data;
    list<size_t> dataList;
    
    data = 0;
    
    data = rand();
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
14327,0,CWE590_Free_Memory_Not_on_Heap__delete_array_long_static_02.cpp,"    long * data;
    data = NULL; 
    if(1)
    {
        {
            
            static long dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5L;
                }
            }
            data = dataBuffer;
        }
    }
    printLongLine(data[0]);
    
"
878,0,CWE134_Uncontrolled_Format_String__char_listen_socket_printf_11.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(globalReturnsTrue())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                data[dataLen + recvResult / sizeof(char)] = '\0';
                
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(globalReturnsTrue())
    {
        
        printf(data);
"
8134,0,CWE401_Memory_Leak__new_char_08.cpp,"    char * data;
    data = NULL;
    if(staticReturnsTrue())
    {
        
        data = new char;
        
        *data = 'A';
        printHexCharLine(*data);
    }
    if(staticReturnsTrue())
    {
        
        ; 
"
5977,0,CWE190_Integer_Overflow__char_rand_multiply_84_bad.cpp,"Label Definition File: CWE190_Integer_Overflow.label.xml
Template File: sources-sinks-84_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 190 Integer Overflow
 * BadSource: rand Set data to result of rand()
 * GoodSource: Set data to a small, non-zero number (two)
 * Sinks: multiply
 *    GoodSink: Ensure there will not be an overflow before multiplying data by 2
 *    BadSink : If data is positive, multiply by 2, which can cause an overflow
 * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE190_Integer_Overflow__char_rand_multiply_84.h""

namespace CWE190_Integer_Overflow__char_rand_multiply_84
{
CWE190_Integer_Overflow__char_rand_multiply_84_bad::CWE190_Integer_Overflow__char_rand_multiply_84_bad(char dataCopy)
{
    data = dataCopy;
    
    data = (char)RAND32();
}

CWE190_Integer_Overflow__char_rand_multiply_84_bad::~CWE190_Integer_Overflow__char_rand_multiply_84_bad()
{
    if(data > 0) 
    {
        
        char result = data * 2;
        printHexCharLine(result);
    }
}
}
"
17371,0,CWE690_NULL_Deref_From_Return__char_realloc_62a.cpp,"    char * data;
    data = NULL; 
    badSource(data);
    
    strcpy(data, ""Initialize"");
    printLine(data);
"
10034,0,CWE190_Integer_Overflow__int_fgets_postinc_05.c,"    int data;
    
    data = 0;
    if(staticTrue)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    if(staticTrue)
    {
        {
            
            data++;
            int result = data;
            printIntLine(result);
        }
"
5231,0,CWE590_Free_Memory_Not_on_Heap__delete_array_struct_alloca_06.cpp,"    twoIntsStruct * data;
    data = NULL; 
    if(STATIC_CONST_FIVE==5)
    {
        {
            
            twoIntsStruct * dataBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i].intOne = 1;
                    dataBuffer[i].intTwo = 1;
                }
            }
            data = dataBuffer;
        }
    }
    printStructLine(&data[0]);
    
"
13421,0,CWE190_Integer_Overflow__char_rand_square_73a.cpp,"    char data;
    list<char> dataList;
    data = ' ';
    
    data = (char)RAND32();
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
15919,0,CWE134_Uncontrolled_Format_String__char_file_printf_09.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(GLOBAL_CONST_TRUE)
    {
        {
            
            size_t dataLen = strlen(data);
            FILE * pFile;
            
            if (100-dataLen > 1)
            {
                pFile = fopen(FILENAME, ""r"");
                if (pFile != NULL)
                {
                    
                    if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                    {
                        printLine(""fgets() failed"");
                        
                        data[dataLen] = '\0';
                    }
                    fclose(pFile);
                }
            }
        }
    }
    if(GLOBAL_CONST_TRUE)
    {
        
        printf(data);
"
17509,0,CWE690_NULL_Deref_From_Return__long_malloc_61a.c,"    long * data;
    data = NULL; 
    data = CWE690_NULL_Deref_From_Return__long_malloc_61b_badSource(data);
    
    data[0] = 5L;
    printLongLine(data[0]);
"
13984,0,CWE690_NULL_Deref_From_Return__long_malloc_17.c,"    int j;
    long * data;
    data = NULL; 
    
    data = (long *)malloc(1*sizeof(long));
    for(j = 0; j < 1; j++)
    {
        
        data[0] = 5L;
        printLongLine(data[0]);
        free(data);
"
14076,0,CWE690_NULL_Deref_From_Return__int64_t_realloc_22a.c,"    int64_t * data;
    data = NULL; 
    
    data = (int64_t *)realloc(data, 1*sizeof(int64_t));
    CWE690_NULL_Deref_From_Return__int64_t_realloc_22_badGlobal = 1; 
"
3820,0,CWE190_Integer_Overflow__short_fscanf_postinc_01.c,"    short data;
    data = 0;
    
    fscanf (stdin, ""%hd"", &data);
    {
        
        data++;
        short result = data;
        printIntLine(result);
"
6233,0,CWE590_Free_Memory_Not_on_Heap__delete_array_int64_t_static_67a.cpp,"    int64_t * data;
    structType myStruct;
    data = NULL; 
    {
        
        static int64_t dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5LL;
            }
        }
        data = dataBuffer;
    }
    myStruct.structFirst = data;
"
17579,0,CWE457_Use_of_Uninitialized_Variable__struct_array_declare_partial_init_02.c,"    twoIntsStruct * data;
    twoIntsStruct dataUninitArray[10];
    data = dataUninitArray;
    if(1)
    {
        
        {
            int i;
            for(i=0; i<(10/2); i++)
            {
                data[i].intOne = i;
                data[i].intTwo = i;
            }
        }
    }
    if(1)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i].intOne);
                printIntLine(data[i].intTwo);
            }
        }
"
7874,0,CWE758_Undefined_Behavior__struct_pointer_alloca_use_10.c,"    if(globalTrue)
    {
        {
            twoIntsStruct * * pointer = (twoIntsStruct * *)ALLOCA(sizeof(twoIntsStruct *));
            twoIntsStruct * data = *pointer; 
            printIntLine(data->intOne);
            printIntLine(data->intTwo);
        }
"
11172,0,CWE134_Uncontrolled_Format_String__char_environment_fprintf_68a.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        
        if (environment != NULL)
        {
            
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    CWE134_Uncontrolled_Format_String__char_environment_fprintf_68_badData = data;
"
11963,0,CWE415_Double_Free__new_delete_array_struct_34.cpp,"    twoIntsStruct * data;
    unionType myUnion;
    
    data = NULL;
    data = new twoIntsStruct[100];
    
    delete [] data;
    myUnion.unionFirst = data;
    {
        twoIntsStruct * data = myUnion.unionSecond;
        
        delete [] data;
"
6139,0,CWE758_Undefined_Behavior__struct_new_use_06.cpp,"    if(STATIC_CONST_FIVE==5)
    {
        {
            twoIntsStruct * pointer = new twoIntsStruct;
            twoIntsStruct data = *pointer; 
            delete pointer;
            printIntLine(data.intOne);
            printIntLine(data.intTwo);
        }
"
8603,0,CWE758_Undefined_Behavior__struct_pointer_malloc_use_14.c,"    if(globalFive==5)
    {
        {
            twoIntsStruct * * pointer = (twoIntsStruct * *)malloc(sizeof(twoIntsStruct *));
            if (pointer == NULL) {exit(-1);}
            twoIntsStruct * data = *pointer; 
            free(pointer);
            printIntLine(data->intOne);
            printIntLine(data->intTwo);
        }
"
15010,0,CWE415_Double_Free__new_delete_char_64a.cpp,"    char * data;
    
    data = NULL;
    data = new char;
    
    delete data;
"
16890,0,CWE369_Divide_by_Zero__float_zero_42.c,"    float data;
    
    data = 0.0F;
    data = badSource(data);
    {
        
        int result = (int)(100.0 / data);
        printIntLine(result);
"
14301,0,CWE369_Divide_by_Zero__int_zero_divide_51a.c,"    int data;
    
    data = -1;
    
    data = 0;
"
5028,0,CWE590_Free_Memory_Not_on_Heap__delete_array_struct_static_52a.cpp,"    twoIntsStruct * data;
    data = NULL; 
    {
        
        static twoIntsStruct dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i].intOne = 1;
                dataBuffer[i].intTwo = 1;
            }
        }
        data = dataBuffer;
    }
"
5395,1,CWE469_Use_of_Pointer_Subtraction_to_Determine_Size__char_05.c,"    if(staticFalse)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            char string1[] = SOURCE_STRING;
            char * slashInString1;
            size_t indexOfSlashInString1;
            slashInString1 = strchr(string1, '/');
            if (slashInString1 == NULL)
            {
                exit(1);
            }
            
            indexOfSlashInString1 = (size_t)(slashInString1 - string1);
            
            printUnsignedLine(indexOfSlashInString1);
        }
"
16427,0,CWE401_Memory_Leak__int64_t_malloc_72a.cpp,"    int64_t * data;
    vector<int64_t *> dataVector;
    data = NULL;
    
    data = (int64_t *)malloc(100*sizeof(int64_t));
    if (data == NULL) {exit(-1);}
    
    data[0] = 5LL;
    printLongLongLine(data[0]);
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
17828,0,CWE401_Memory_Leak__struct_twoIntsStruct_calloc_64a.c,"    struct _twoIntsStruct * data;
    data = NULL;
    
    data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));
    if (data == NULL) {exit(-1);}
    
    data[0].intOne = 0;
    data[0].intTwo = 0;
    printStructLine((twoIntsStruct *)&data[0]);
"
4779,0,CWE457_Use_of_Uninitialized_Variable__twointsclass_array_declare_partial_init_63a.cpp,"    TwoIntsClass * data;
    TwoIntsClass dataUninitArray[10];
    data = dataUninitArray;
    
    for(int i=0; i<(10/2); i++)
    {
        data[i].intOne = i;
        data[i].intTwo = i;
    }
"
7858,0,CWE457_Use_of_Uninitialized_Variable__empty_constructor_01_bad.cpp," * 
 * */

#include ""std_testcase.h""

namespace CWE457_Use_of_Uninitialized_Variable__empty_constructor_01
{

#ifndef OMITBAD

class BadClass 
{
    public:
        BadClass() 
        { 
            
        } 
        
        int intOne;
};

void bad()
{
    
    BadClass * badClassObject = new BadClass;
    printIntLine(badClassObject->intOne);
}

#endif 

} 

/* Below is the main(). It is only used when building this testcase on 
 * its own for testing or for building a binary to use in testing binary 
 * analysis tools. It is not used when compiling all the testcases as one 
 * application, which is how source code analysis tools are tested. 
 */ 

#ifdef INCLUDEMAIN

using namespace CWE457_Use_of_Uninitialized_Variable__empty_constructor_01; 

int main(int argc, char * argv[])
{
    
    srand( (unsigned)time(NULL) );
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}

"
6451,0,CWE369_Divide_by_Zero__int_zero_modulo_81_bad.cpp,"Label Definition File: CWE369_Divide_by_Zero__int.label.xml
Template File: sources-sinks-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 369 Divide by Zero
 * BadSource: zero Fixed value of zero
 * GoodSource: Non-zero
 * Sinks: modulo
 *    GoodSink: Check for zero before modulo
 *    BadSink : Modulo a constant with data
 * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE369_Divide_by_Zero__int_zero_modulo_81.h""

namespace CWE369_Divide_by_Zero__int_zero_modulo_81
{

void CWE369_Divide_by_Zero__int_zero_modulo_81_bad::action(int data) const
{
    
    printIntLine(100 % data);
}

}
"
15423,1,CWE401_Memory_Leak__malloc_realloc_int64_t_10.c,"    if(globalFalse)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            int64_t * data = (int64_t *)malloc(100*sizeof(int64_t));
            if (data == NULL) {exit(-1);}
            int64_t * tmpData;
            
            data[0] = 5LL;
            printLongLongLine(data[0]);
            tmpData = (int64_t *)realloc(data, (130000)*sizeof(int64_t));
            /* FIX: Ensure realloc() was successful before assigning data to the memory block
            * allocated with realloc() */
            if (tmpData != NULL)
            {
                data = tmpData;
                
                data[0] = 10LL;
                printLongLongLine(data[0]);
            }
            free(data);
        }
"
7765,0,CWE789_Uncontrolled_Mem_Alloc__new_char_fgets_72a.cpp,"    size_t data;
    vector<size_t> dataVector;
    
    data = 0;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = strtoul(inputBuffer, NULL, 0);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
11953,0,CWE457_Use_of_Uninitialized_Variable__struct_pointer_03.c,"    twoIntsStruct * data;
    if(5==5)
    {
        
        ; 
    }
    if(5==5)
    {
        
        printIntLine(data->intOne);
        printIntLine(data->intTwo);
"
4029,1,CWE476_NULL_Pointer_Dereference__deref_after_check_08.c,"    if(staticReturnsTrue())
    {
        {
            
            int *intPointer = NULL;
            if (intPointer == NULL)
            {
                printLine(""pointer is NULL"");
            }
        }
"
8585,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_11.c,"    size_t data;
    
    data = 0;
    if(globalReturnsTrue())
    {
        
        fscanf(stdin, ""%zu"", &data);
    }
    if(globalReturnsTrue())
    {
        {
            char * myString;
            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
             * for the strcpy() function to not cause a buffer overflow */
            
            if (data > strlen(HELLO_STRING))
            {
                myString = (char *)malloc(data*sizeof(char));
                if (myString == NULL) {exit(-1);}
                
                strcpy(myString, HELLO_STRING);
                printLine(myString);
                free(myString);
            }
            else
            {
                printLine(""Input is less than the length of the source string"");
            }
        }
"
14113,0,CWE401_Memory_Leak__struct_twoIntsStruct_realloc_33.cpp,"    struct _twoIntsStruct * data;
    struct _twoIntsStruct * &dataRef = data;
    data = NULL;
    
    data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));
    if (data == NULL) {exit(-1);}
    
    data[0].intOne = 0;
    data[0].intTwo = 0;
    printStructLine((twoIntsStruct *)&data[0]);
    {
        struct _twoIntsStruct * data = dataRef;
        
        ; 
"
6377,0,CWE563_Unused_Variable__unused_init_variable_char_72a.cpp,"    char data;
    vector<char> dataVector;
    
    data = 'C';
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
8948,0,CWE401_Memory_Leak__new_TwoIntsClass_81_bad.cpp,"Label Definition File: CWE401_Memory_Leak__new.label.xml
Template File: sources-sinks-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 401 Memory Leak
 * BadSource:  Allocate data using new
 * GoodSource: Allocate data on the stack
 * Sinks:
 *    GoodSink: call delete on data
 *    BadSink : no deallocation of data
 * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE401_Memory_Leak__new_TwoIntsClass_81.h""

namespace CWE401_Memory_Leak__new_TwoIntsClass_81
{

void CWE401_Memory_Leak__new_TwoIntsClass_81_bad::action(TwoIntsClass * data) const
{
    
    ; 
}

}
"
4671,0,CWE190_Integer_Overflow__int_listen_socket_add_11.c,"    int data;
    
    data = 0;
    if(globalReturnsTrue())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(globalReturnsTrue())
    {
        {
            
            int result = data + 1;
            printIntLine(result);
        }
"
11067,0,CWE78_OS_Command_Injection__char_console_popen_68a.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
        
        size_t dataLen = strlen(data);
        
        if (100-dataLen > 1)
        {
            
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgets() */
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
                    data[dataLen-1] = '\0';
                }
            }
            else
            {
                printLine(""fgets() failed"");
                
                data[dataLen] = '\0';
            }
        }
    }
    CWE78_OS_Command_Injection__char_console_popen_68_badData = data;
"
2955,0,CWE416_Use_After_Free__malloc_free_int_17.c,"    int i,j;
    int * data;
    
    data = NULL;
    for(i = 0; i < 1; i++)
    {
        data = (int *)malloc(100*sizeof(int));
        if (data == NULL) {exit(-1);}
        {
            size_t i;
            for(i = 0; i < 100; i++)
            {
                data[i] = 5;
            }
        }
        
        free(data);
    }
    for(j = 0; j < 1; j++)
    {
        
        printIntLine(data[0]);
        
"
12619,0,CWE415_Double_Free__new_delete_int_74a.cpp,"    int * data;
    map<int, int *> dataMap;
    
    data = NULL;
    data = new int;
    
    delete data;
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
16959,0,CWE197_Numeric_Truncation_Error__int_large_to_short_06.c,"    int data;
    
    data = -1;
    if(STATIC_CONST_FIVE==5)
    {
        
        data = SHRT_MAX + 5;
    }
    {
        
        short shortData = (short)data;
        printShortLine(shortData);
"
17270,0,CWE190_Integer_Overflow__short_fscanf_postinc_14.c,"    short data;
    data = 0;
    if(globalFive==5)
    {
        
        fscanf (stdin, ""%hd"", &data);
    }
    if(globalFive==5)
    {
        {
            
            data++;
            short result = data;
            printIntLine(result);
        }
"
16885,0,CWE190_Integer_Overflow__int_rand_postinc_21.c,"    int data;
    
    data = 0;
    
    data = RAND32();
    badStatic = 1; 
"
1565,0,CWE78_OS_Command_Injection__char_listen_socket_popen_41.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
8208,0,CWE78_OS_Command_Injection__char_listen_socket_popen_61a.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    data = CWE78_OS_Command_Injection__char_listen_socket_popen_61b_badSource(data);
    {
        FILE *pipe;
        
        pipe = POPEN(data, ""w"");
        if (pipe != NULL)
        {
            PCLOSE(pipe);
        }
"
6115,0,CWE415_Double_Free__malloc_free_int_84_bad.cpp,"Label Definition File: CWE415_Double_Free__malloc_free.label.xml
Template File: sources-sinks-84_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 415 Double Free
 * BadSource:  Allocate data using malloc() and Deallocate data using free()
 * GoodSource: Allocate data using malloc()
 * Sinks:
 *    GoodSink: do nothing
 *    BadSink : Deallocate data using free()
 * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE415_Double_Free__malloc_free_int_84.h""

namespace CWE415_Double_Free__malloc_free_int_84
{
CWE415_Double_Free__malloc_free_int_84_bad::CWE415_Double_Free__malloc_free_int_84_bad(int * dataCopy)
{
    data = dataCopy;
    data = (int *)malloc(100*sizeof(int));
    if (data == NULL) {exit(-1);}
    
    free(data);
}

CWE415_Double_Free__malloc_free_int_84_bad::~CWE415_Double_Free__malloc_free_int_84_bad()
{
    
    free(data);
}
}
"
12704,0,CWE190_Integer_Overflow__int_rand_postinc_01.c,"    int data;
    
    data = 0;
    
    data = RAND32();
    {
        
        data++;
        int result = data;
        printIntLine(result);
"
18445,0,CWE415_Double_Free__malloc_free_int_84a.cpp,"    int * data;
    
    data = NULL;
    CWE415_Double_Free__malloc_free_int_84_bad * badObject = new CWE415_Double_Free__malloc_free_int_84_bad(data);
"
19337,0,CWE190_Integer_Overflow__char_rand_square_84a.cpp,"    char data;
    data = ' ';
    CWE190_Integer_Overflow__char_rand_square_84_bad * badObject = new CWE190_Integer_Overflow__char_rand_square_84_bad(data);
"
15300,0,CWE78_OS_Command_Injection__char_file_execl_10.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(globalTrue)
    {
        {
            
            size_t dataLen = strlen(data);
            FILE * pFile;
            
            if (100-dataLen > 1)
            {
                pFile = fopen(FILENAME, ""r"");
                if (pFile != NULL)
                {
                    
                    if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                    {
                        printLine(""fgets() failed"");
                        
                        data[dataLen] = '\0';
                    }
                    fclose(pFile);
                }
            }
        }
    }
    
    
"
9362,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_34.c,"    size_t data;
    CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_34_unionType myUnion;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = strtoul(inputBuffer, NULL, 0);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    myUnion.unionFirst = data;
    {
        size_t data = myUnion.unionSecond;
        {
            char * myString;
            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
             * for the strcpy() function to not cause a buffer overflow */
            
            if (data > strlen(HELLO_STRING))
            {
                myString = (char *)malloc(data*sizeof(char));
                if (myString == NULL) {exit(-1);}
                
                strcpy(myString, HELLO_STRING);
                printLine(myString);
                free(myString);
            }
            else
            {
                printLine(""Input is less than the length of the source string"");
            }
        }
"
12929,0,CWE134_Uncontrolled_Format_String__char_file_snprintf_72a.cpp,"    char * data;
    vector<char *> dataVector;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        FILE * pFile;
        
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
8840,0,CWE78_OS_Command_Injection__char_connect_socket_execlp_83_bad.cpp,"Label Definition File: CWE78_OS_Command_Injection.strings.label.xml
Template File: sources-sink-83_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 78 OS Command Injection
 * BadSource: connect_socket Read data using a connect socket (client side)
 * GoodSource: Fixed string
 * Sinks: execlp
 *    BadSink : execute command with execlp
 * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE78_OS_Command_Injection__char_connect_socket_execlp_83.h""
"
19005,0,CWE190_Integer_Overflow__int_fscanf_square_11.c,"    int data;
    
    data = 0;
    if(globalReturnsTrue())
    {
        
        fscanf(stdin, ""%d"", &data);
    }
    if(globalReturnsTrue())
    {
        {
            
            int result = data * data;
            printIntLine(result);
        }
"
17924,0,CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_84a.cpp,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_84_bad * badObject = new CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_84_bad(data);
"
13761,0,CWE369_Divide_by_Zero__int_fgets_divide_44.c,"    int data;
    
    void (*funcPtr) (int) = badSink;
    
    data = -1;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    
"
5938,0,CWE190_Integer_Overflow__unsigned_int_max_square_08.c,"    unsigned int data;
    data = 0;
    if(staticReturnsTrue())
    {
        
        data = UINT_MAX;
    }
    if(staticReturnsTrue())
    {
        {
            
            unsigned int result = data * data;
            printUnsignedLine(result);
        }
"
6773,0,CWE416_Use_After_Free__new_delete_int_11.cpp,"    int * data;
    
    data = NULL;
    if(globalReturnsTrue())
    {
        data = new int;
        *data = 5;
        
        delete data;
    }
    if(globalReturnsTrue())
    {
        
        printIntLine(*data);
        
"
8012,0,CWE78_OS_Command_Injection__char_listen_socket_popen_07.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(staticFive==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                data[dataLen + recvResult / sizeof(char)] = '\0';
                
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    {
        FILE *pipe;
        
        pipe = POPEN(data, ""w"");
        if (pipe != NULL)
        {
            PCLOSE(pipe);
        }
"
180,0,CWE134_Uncontrolled_Format_String__char_console_snprintf_32.c,"    char * data;
    char * *dataPtr1 = &data;
    char * *dataPtr2 = &data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        char * data = *dataPtr1;
        {
            
            size_t dataLen = strlen(data);
            
            if (100-dataLen > 1)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
                {
                    /* The next few lines remove the carriage return from the string that is
                     * inserted by fgets() */
                    dataLen = strlen(data);
                    if (dataLen > 0 && data[dataLen-1] == '\n')
                    {
                        data[dataLen-1] = '\0';
                    }
                }
                else
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
            }
        }
        *dataPtr1 = data;
    }
    {
        char * data = *dataPtr2;
        {
            char dest[100] = """";
            
            SNPRINTF(dest, 100-1, data);
            printLine(dest);
        }
"
10640,0,CWE190_Integer_Overflow__char_fscanf_add_81a.cpp,"    char data;
    data = ' ';
    
    fscanf (stdin, ""%c"", &data);
    const CWE190_Integer_Overflow__char_fscanf_add_81_base& baseObject = CWE190_Integer_Overflow__char_fscanf_add_81_bad();
"
9694,0,CWE369_Divide_by_Zero__int_fscanf_divide_12.c,"    int data;
    
    data = -1;
    if(globalReturnsTrueOrFalse())
    {
        
        fscanf(stdin, ""%d"", &data);
    }
    else
    {
        
        data = 7;
    }
    if(globalReturnsTrueOrFalse())
    {
        
        printIntLine(100 / data);
    }
    else
    {
        
        if( data != 0 )
        {
            printIntLine(100 / data);
        }
        else
        {
            printLine(""This would result in a divide by zero"");
        }
"
5535,0,CWE190_Integer_Overflow__int_fgets_multiply_81_bad.cpp,"Label Definition File: CWE190_Integer_Overflow__int.label.xml
Template File: sources-sinks-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 190 Integer Overflow
 * BadSource: fgets Read data from the console using fgets()
 * GoodSource: Set data to a small, non-zero number (two)
 * Sinks: multiply
 *    GoodSink: Ensure there will not be an overflow before multiplying data by 2
 *    BadSink : If data is positive, multiply by 2, which can cause an overflow
 * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE190_Integer_Overflow__int_fgets_multiply_81.h""

namespace CWE190_Integer_Overflow__int_fgets_multiply_81
{

void CWE190_Integer_Overflow__int_fgets_multiply_81_bad::action(int data) const
{
    if(data > 0) 
    {
        
        int result = data * 2;
        printIntLine(result);
    }
}

}
"
18204,0,CWE78_OS_Command_Injection__char_console_execlp_11.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(globalReturnsTrue())
    {
        {
            
            size_t dataLen = strlen(data);
            
            if (100-dataLen > 1)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
                {
                    /* The next few lines remove the carriage return from the string that is
                     * inserted by fgets() */
                    dataLen = strlen(data);
"
10817,0,CWE190_Integer_Overflow__int_max_preinc_21.c,"    int data;
    
    data = 0;
    
    data = INT_MAX;
    badStatic = 1; 
"
12822,0,CWE457_Use_of_Uninitialized_Variable__struct_array_malloc_no_init_63a.c,"    twoIntsStruct * data;
    data = (twoIntsStruct *)malloc(10*sizeof(twoIntsStruct));
    if (data == NULL) {exit(-1);}
    
    ; 
"
19096,0,CWE590_Free_Memory_Not_on_Heap__delete_array_long_static_67a.cpp,"    long * data;
    structType myStruct;
    data = NULL; 
    {
        
        static long dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5L;
            }
        }
        data = dataBuffer;
    }
    myStruct.structFirst = data;
"
16900,0,CWE416_Use_After_Free__new_delete_array_char_17.cpp,"    int i,j;
    char * data;
    
    data = NULL;
    for(i = 0; i < 1; i++)
    {
        data = new char[100];
        memset(data, 'A', 100-1);
        data[100-1] = '\0';
        
        delete [] data;
    }
    for(j = 0; j < 1; j++)
    {
        
        printLine(data);
        
"
18627,0,CWE563_Unused_Variable__unused_init_variable_long_08.c,"    long data;
    
    data = 5L;
    if(staticReturnsTrue())
    {
        
        
        ; 
"
5524,0,CWE415_Double_Free__malloc_free_struct_13.c,"    twoIntsStruct * data;
    
    data = NULL;
    if(GLOBAL_CONST_FIVE==5)
    {
        data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
        if (data == NULL) {exit(-1);}
        
        free(data);
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        
        free(data);
"
15954,0,CWE563_Unused_Variable__unused_value_int64_t_82a.cpp,"    int64_t data;
    
    data = 5LL;
    CWE563_Unused_Variable__unused_value_int64_t_82_base* baseObject = new CWE563_Unused_Variable__unused_value_int64_t_82_bad;
    baseObject->action(data);
"
10324,0,CWE134_Uncontrolled_Format_String__char_console_vprintf_74a.cpp,"    char * data;
    map<int, char *> dataMap;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        
        if (100-dataLen > 1)
        {
            
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgets() */
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
                    data[dataLen-1] = '\0';
                }
            }
            else
            {
                printLine(""fgets() failed"");
                
                data[dataLen] = '\0';
            }
        }
    }
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
699,0,CWE190_Integer_Overflow__char_max_preinc_18.c,"    char data;
    data = ' ';
    goto source;
source:
    
    data = CHAR_MAX;
    goto sink;
sink:
    {
        
        ++data;
        char result = data;
        printHexCharLine(result);
"
1849,0,CWE789_Uncontrolled_Mem_Alloc__new_char_fgets_65a.cpp,"    size_t data;
    
    void (*funcPtr) (size_t) = badSink;
    
    data = 0;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = strtoul(inputBuffer, NULL, 0);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    
"
12203,0,CWE134_Uncontrolled_Format_String__char_listen_socket_printf_82_bad.cpp,"Label Definition File: CWE134_Uncontrolled_Format_String.label.xml
Template File: sources-sinks-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 134 Uncontrolled Format String
 * BadSource: listen_socket Read data using a listen socket (server side)
 * GoodSource: Copy a fixed string into data
 * Sinks: printf
 *    GoodSink: printf with ""%s"" as the first argument and data as the second
 *    BadSink : printf with only data as an argument
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE134_Uncontrolled_Format_String__char_listen_socket_printf_82.h""

namespace CWE134_Uncontrolled_Format_String__char_listen_socket_printf_82
{

void CWE134_Uncontrolled_Format_String__char_listen_socket_printf_82_bad::action(char * data)
{
    
    printf(data);
}

}
"
12642,0,CWE590_Free_Memory_Not_on_Heap__free_int64_t_static_01.c,"    int64_t * data;
    data = NULL; 
    {
        
        static int64_t dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5LL;
            }
        }
        data = dataBuffer;
    }
    printLongLongLine(data[0]);
    
"
12395,1,CWE252_Unchecked_Return_Value__char_rename_08.c,"    if(staticReturnsTrue())
    {
        
        if (RENAME(OLD_GOOD_FILE_NAME, ""newgoodfilename.txt"") != 0)
        {
            printLine(""rename failed!"");
        }
"
12134,0,CWE590_Free_Memory_Not_on_Heap__delete_int64_t_placement_new_14.cpp,"    int64_t * data;
    data = NULL; 
    if(globalFive==5)
    {
        {
            
            char buffer[sizeof(int64_t)];
            int64_t * dataBuffer = new(buffer) int64_t;
            *dataBuffer = 5LL;
            data = dataBuffer;
        }
    }
    printLongLongLine(*data);
    
"
13983,0,CWE563_Unused_Variable__unused_value_int64_t_02.c,"    int64_t data;
    if(1)
    {
        
        data = 5LL;
    }
    if(1)
    {
        
        data = 10LL;
        printLongLongLine(data);
"
11814,0,CWE415_Double_Free__new_delete_array_int_53a.cpp,"    int * data;
    
    data = NULL;
    data = new int[100];
    
    delete [] data;
"
18512,0,CWE563_Unused_Variable__unused_value_int_73a.cpp,"    int data;
    list<int> dataList;
    
    data = 5;
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
10536,0,CWE690_NULL_Deref_From_Return__struct_malloc_01.c,"    twoIntsStruct * data;
    data = NULL; 
    
    data = (twoIntsStruct *)malloc(1*sizeof(twoIntsStruct));
    
    data[0].intOne = 1;
    data[0].intTwo = 1;
    printStructLine(&data[0]);
"
4746,0,CWE197_Numeric_Truncation_Error__short_rand_02.c,"    short data;
    
    data = -1;
    if(1)
    {
        
        data = (short)RAND32();
    }
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
4208,0,CWE190_Integer_Overflow__char_rand_multiply_22a.c,"    char data;
    data = ' ';
    
    data = (char)RAND32();
    CWE190_Integer_Overflow__char_rand_multiply_22_badGlobal = 1; 
"
12670,0,CWE415_Double_Free__new_delete_long_04.cpp,"    long * data;
    
    data = NULL;
    if(STATIC_CONST_TRUE)
    {
        data = new long;
        
        delete data;
    }
    if(STATIC_CONST_TRUE)
    {
        
        delete data;
"
1636,1,CWE476_NULL_Pointer_Dereference__deref_after_check_08.c,"    if(staticReturnsFalse())
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            
            int *intPointer = NULL;
            if (intPointer == NULL)
            {
                printLine(""pointer is NULL"");
            }
        }
"
18569,0,CWE190_Integer_Overflow__int_connect_socket_add_72a.cpp,"    int data;
    vector<int> dataVector;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
11169,0,CWE590_Free_Memory_Not_on_Heap__delete_class_static_13.cpp,"    TwoIntsClass * data;
    data = NULL; 
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            
            static TwoIntsClass dataBuffer;
            dataBuffer.intOne = 1;
            dataBuffer.intTwo = 1;
            data = &dataBuffer;
        }
    }
    printIntLine(data->intOne);
    
"
13078,0,CWE590_Free_Memory_Not_on_Heap__delete_array_int64_t_declare_31.cpp,"    int64_t * data;
    data = NULL; 
    {
        
        int64_t dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5LL;
            }
        }
        data = dataBuffer;
    }
    {
        int64_t * dataCopy = data;
        int64_t * data = dataCopy;
        printLongLongLine(data[0]);
        
        delete [] data;
"
2498,0,CWE252_Unchecked_Return_Value__char_putchar_12.c,"    if(globalReturnsTrueOrFalse())
    {
        
        putchar((int)'A');
    }
    else
    {
        
        if (putchar((int)'A') == EOF)
        {
            printLine(""putchar failed!"");
        }
"
16783,0,CWE590_Free_Memory_Not_on_Heap__delete_struct_declare_03.cpp,"    twoIntsStruct * data;
    data = NULL; 
    if(5==5)
    {
        {
            
            twoIntsStruct dataBuffer;
            dataBuffer.intOne = 1;
            dataBuffer.intTwo = 1;
            data = &dataBuffer;
        }
    }
    printStructLine(data);
    
"
8876,0,CWE190_Integer_Overflow__int64_t_rand_add_74a.cpp,"    int64_t data;
    map<int, int64_t> dataMap;
    data = 0LL;
    
    data = (int64_t)RAND64();
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
4651,0,CWE590_Free_Memory_Not_on_Heap__free_char_declare_51a.c,"    char * data;
    data = NULL; 
    {
        
        char dataBuffer[100];
        memset(dataBuffer, 'A', 100-1); 
        dataBuffer[100-1] = '\0'; 
        data = dataBuffer;
    }
"
8372,0,CWE78_OS_Command_Injection__char_console_popen_42.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    data = badSource(data);
    {
        FILE *pipe;
        
        pipe = POPEN(data, ""w"");
        if (pipe != NULL)
        {
            PCLOSE(pipe);
        }
    }
}

#endif 

"
17663,1,CWE758_Undefined_Behavior__int64_t_new_use_16.cpp,"    while(1)
    {
        {
            int64_t data;
            data = 5LL;
            int64_t * pointer = new int64_t;
            *pointer = data; 
            {
                int64_t data = *pointer;
                printLongLongLine(data);
            }
            delete pointer;
        }
        break;
"
13884,0,CWE401_Memory_Leak__new_TwoIntsClass_33.cpp,"    TwoIntsClass * data;
    TwoIntsClass * &dataRef = data;
    data = NULL;
    
    data = new TwoIntsClass;
    
    data->intOne = 0;
    data->intTwo = 0;
    printIntLine(data->intOne);
    printIntLine(data->intTwo);
    {
        TwoIntsClass * data = dataRef;
        
        ; 
"
14340,0,CWE590_Free_Memory_Not_on_Heap__delete_array_class_alloca_12.cpp,"    TwoIntsClass * data;
    data = NULL; 
    if(globalReturnsTrueOrFalse())
    {
        {
            
            TwoIntsClass * dataBuffer = (TwoIntsClass *)ALLOCA(100*sizeof(TwoIntsClass));
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i].intOne = 1;
                    dataBuffer[i].intTwo = 1;
                }
            }
            data = dataBuffer;
        }
    }
    else
    {
        {
            
            TwoIntsClass * dataBuffer = new TwoIntsClass[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i].intOne = 1;
                    dataBuffer[i].intTwo = 1;
                }
            }
            data = dataBuffer;
        }
    }
    printIntLine(data[0].intOne);
    
"
18101,0,CWE197_Numeric_Truncation_Error__int_rand_to_short_61a.c,"    int data;
    
    data = -1;
    data = CWE197_Numeric_Truncation_Error__int_rand_to_short_61b_badSource(data);
    {
        
        short shortData = (short)data;
        printShortLine(shortData);
"
18561,0,CWE369_Divide_by_Zero__int_fscanf_modulo_52a.c,"    int data;
    
    data = -1;
    
    fscanf(stdin, ""%d"", &data);
"
12886,0,CWE78_OS_Command_Injection__char_environment_popen_65a.c,"    char * data;
    
    void (*funcPtr) (char *) = CWE78_OS_Command_Injection__char_environment_popen_65b_badSink;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
        
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        
        if (environment != NULL)
        {
            
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    
"
16040,0,CWE665_Improper_Initialization__char_cat_12.c,"    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    if(globalReturnsTrueOrFalse())
    {
        
        ; 
    }
    else
    {
        
        data[0] = '\0'; 
    }
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        
        strcat(data, source);
        printLine(data);
"
15410,0,CWE590_Free_Memory_Not_on_Heap__delete_array_long_alloca_41.cpp,"    long * data;
    data = NULL; 
    {
        
        long * dataBuffer = (long *)ALLOCA(100*sizeof(long));
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5L;
            }
        }
        data = dataBuffer;
    }
"
10236,0,CWE590_Free_Memory_Not_on_Heap__delete_char_declare_10.cpp,"    char * data;
    data = NULL; 
    if(globalTrue)
    {
        {
            
            char dataBuffer;
            dataBuffer = 'A';
            data = &dataBuffer;
        }
    }
    printHexCharLine(*data);
    
"
4060,0,CWE690_NULL_Deref_From_Return__int64_t_realloc_84a.cpp,"    int64_t * data;
    data = NULL; 
    CWE690_NULL_Deref_From_Return__int64_t_realloc_84_bad * badObject = new CWE690_NULL_Deref_From_Return__int64_t_realloc_84_bad(data);
"
16393,0,CWE197_Numeric_Truncation_Error__int_listen_socket_to_char_73a.cpp,"    int data;
    list<int> dataList;
    
    data = -1;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
13082,0,CWE590_Free_Memory_Not_on_Heap__delete_array_class_declare_07.cpp,"    TwoIntsClass * data;
    data = NULL; 
    if(staticFive==5)
    {
        {
            
            TwoIntsClass dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i].intOne = 1;
                    dataBuffer[i].intTwo = 1;
                }
            }
            data = dataBuffer;
        }
    }
    printIntLine(data[0].intOne);
    
"
11860,0,CWE252_Unchecked_Return_Value__char_sscanf_14.c,"    if(globalFive==5)
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            
            sscanf(SRC, ""%99s\0"", data);
        }
"
19144,0,CWE197_Numeric_Truncation_Error__int_rand_to_short_65a.c,"    int data;
    
    void (*funcPtr) (int) = CWE197_Numeric_Truncation_Error__int_rand_to_short_65b_badSink;
    
    data = -1;
    
    data = RAND32();
    
"
19248,0,CWE190_Integer_Overflow__int64_t_rand_postinc_13.c,"    int64_t data;
    data = 0LL;
    if(GLOBAL_CONST_FIVE==5)
    {
        
        data = (int64_t)RAND64();
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            
            data++;
            int64_t result = data;
            printLongLongLine(result);
        }
"
13865,1,CWE476_NULL_Pointer_Dereference__binary_if_09.c,"    if(GLOBAL_CONST_TRUE)
    {
        {
            twoIntsStruct *twoIntsStructPointer = NULL;
            /* FIX: Use && in the if statement so that if the left side of the expression fails then
             * the right side will not be evaluated */
            if ((twoIntsStructPointer != NULL) && (twoIntsStructPointer->intOne == 5))
            {
                printLine(""intOne == 5"");
            }
        }
"
19438,0,CWE369_Divide_by_Zero__int_rand_modulo_08.c,"    int data;
    
    data = -1;
    if(staticReturnsTrue())
    {
        
        data = RAND32();
    }
    if(staticReturnsTrue())
    {
        
        printIntLine(100 % data);
"
9135,0,CWE590_Free_Memory_Not_on_Heap__delete_array_struct_declare_53a.cpp,"    twoIntsStruct * data;
    data = NULL; 
    {
        
        twoIntsStruct dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i].intOne = 1;
                dataBuffer[i].intTwo = 1;
            }
        }
        data = dataBuffer;
    }
"
17973,0,CWE401_Memory_Leak__new_array_TwoIntsClass_01.cpp,"    TwoIntsClass * data;
    data = NULL;
    
    data = new TwoIntsClass[100];
    
    data[0].intOne = 0;
    data[0].intTwo = 0;
    printIntLine(data[0].intOne);
    printIntLine(data[0].intTwo);
    
"
18834,0,CWE190_Integer_Overflow__unsigned_int_max_multiply_63a.c,"    unsigned int data;
    data = 0;
    
    data = UINT_MAX;
"
12355,0,CWE190_Integer_Overflow__int64_t_rand_postinc_52a.c,"    int64_t data;
    data = 0LL;
    
    data = (int64_t)RAND64();
"
11666,0,CWE78_OS_Command_Injection__char_environment_popen_21.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    badStatic = 1; 
    data = badSource(data);
    {
        FILE *pipe;
        
        pipe = POPEN(data, ""w"");
        if (pipe != NULL)
        {
            PCLOSE(pipe);
        }
"
2038,0,CWE590_Free_Memory_Not_on_Heap__delete_array_struct_static_66a.cpp,"    twoIntsStruct * data;
    twoIntsStruct * dataArray[5];
    data = NULL; 
    {
        
        static twoIntsStruct dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i].intOne = 1;
                dataBuffer[i].intTwo = 1;
            }
        }
        data = dataBuffer;
    }
    
    dataArray[2] = data;
"
17942,0,CWE590_Free_Memory_Not_on_Heap__delete_array_struct_alloca_52a.cpp,"    twoIntsStruct * data;
    data = NULL; 
    {
        
        twoIntsStruct * dataBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i].intOne = 1;
                dataBuffer[i].intTwo = 1;
            }
        }
        data = dataBuffer;
    }
"
8275,1,CWE758_Undefined_Behavior__int_pointer_new_use_13.cpp,"    if(GLOBAL_CONST_FIVE==5)
    {
        {
            int * data;
            
            data = new int;
            *data = 5;
            int * * pointer = new int *;
            *pointer = data; 
            {
                int * data = *pointer;
                printIntLine(*data);
            }
            delete pointer;
        }
"
2623,0,CWE758_Undefined_Behavior__int_new_use_06.cpp,"    if(STATIC_CONST_FIVE==5)
    {
        {
            int * pointer = new int;
            int data = *pointer; 
            delete pointer;
            printIntLine(data);
        }
"
5729,0,CWE401_Memory_Leak__char_realloc_11.c,"    char * data;
    data = NULL;
    if(globalReturnsTrue())
    {
        
        data = (char *)realloc(data, 100*sizeof(char));
        if (data == NULL) {exit(-1);}
        
        strcpy(data, ""A String"");
        printLine(data);
    }
    if(globalReturnsTrue())
    {
        
        ; 
"
5919,0,CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_31.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    {
        char * dataCopy = data;
        char * data = dataCopy;
        badVaSink(data, data);
"
7074,0,CWE415_Double_Free__malloc_free_struct_33.cpp,"    twoIntsStruct * data;
    twoIntsStruct * &dataRef = data;
    
    data = NULL;
    data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
    if (data == NULL) {exit(-1);}
    
    free(data);
    {
        twoIntsStruct * data = dataRef;
        
        free(data);
"
16437,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_21.c,"    size_t data;
    
    data = 0;
    
    fscanf(stdin, ""%zu"", &data);
    badStatic = 1; 
"
15629,0,CWE590_Free_Memory_Not_on_Heap__delete_char_declare_04.cpp,"    char * data;
    data = NULL; 
    if(STATIC_CONST_TRUE)
    {
        {
            
            char dataBuffer;
            dataBuffer = 'A';
            data = &dataBuffer;
        }
    }
    printHexCharLine(*data);
    
"
11005,1,CWE475_Undefined_Behavior_for_Input_to_API__char_04.c,"    if(STATIC_CONST_TRUE)
    {
        {
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            strcpy(data, ""abcdefghijklmnopqrstuvwxyz"");
            
            memmove(data + 6, data + 4, 10*sizeof(char));
            printLine(data);
        }
"
14829,1,CWE758_Undefined_Behavior__char_pointer_malloc_use_02.c,"    if(1)
    {
        {
            char * data;
            char * * pointer = (char * *)malloc(sizeof(char *));
            if (pointer == NULL) {exit(-1);}
            data = ""string"";
            *pointer = data; 
            {
                char * data = *pointer;
                printLine(data);
            }
            free(pointer);
        }
"
5043,0,CWE457_Use_of_Uninitialized_Variable__new_double_array_no_init_01.cpp,"    double * data;
    data = new double[10];
    
    ; 
    
    {
        int i;
        for(i=0; i<10; i++)
        {
            printDoubleLine(data[i]);
        }
    }
    
"
5209,0,CWE690_NULL_Deref_From_Return__int64_t_calloc_17.c,"    int j;
    int64_t * data;
    data = NULL; 
    
    data = (int64_t *)calloc(1, sizeof(int64_t));
    for(j = 0; j < 1; j++)
    {
        
        data[0] = 5LL;
        printLongLongLine(data[0]);
        free(data);
"
18533,0,CWE590_Free_Memory_Not_on_Heap__delete_long_placement_new_53a.cpp,"    long * data;
    data = NULL; 
    {
        
        char buffer[sizeof(long)];
        long * dataBuffer = new(buffer) long;
        *dataBuffer = 5L;
        data = dataBuffer;
    }
"
19239,0,CWE190_Integer_Overflow__unsigned_int_rand_preinc_53a.c,"    unsigned int data;
    data = 0;
    
    data = (unsigned int)RAND32();
"
3621,0,CWE401_Memory_Leak__new_array_struct_twoIntsStruct_16.cpp,"    struct _twoIntsStruct * data;
    data = NULL;
    while(1)
    {
        
        data = new struct _twoIntsStruct[100];
        
        data[0].intOne = 0;
        data[0].intTwo = 0;
        printStructLine((twoIntsStruct *)&data[0]);
        break;
    }
    while(1)
    {
        
        ; 
        break;
"
4123,0,CWE590_Free_Memory_Not_on_Heap__free_int_alloca_66a.c,"    int * data;
    int * dataArray[5];
    data = NULL; 
    {
        
        int * dataBuffer = (int *)ALLOCA(100*sizeof(int));
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5;
            }
        }
        data = dataBuffer;
    }
    
    dataArray[2] = data;
"
18323,0,CWE134_Uncontrolled_Format_String__char_environment_vprintf_53a.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        
        if (environment != NULL)
        {
            
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
"
5423,0,CWE415_Double_Free__new_delete_array_long_74a.cpp,"    long * data;
    map<int, long *> dataMap;
    
    data = NULL;
    data = new long[100];
    
    delete [] data;
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
6036,1,CWE401_Memory_Leak__malloc_realloc_twoIntsStruct_16.c,"    while(1)
    {
        {
            twoIntsStruct * data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
            if (data == NULL) {exit(-1);}
            twoIntsStruct * tmpData;
            
            data[0].intOne = 0;
            data[0].intTwo = 0;
            printStructLine(&data[0]);
            tmpData = (twoIntsStruct *)realloc(data, (130000)*sizeof(twoIntsStruct));
            /* FIX: Ensure realloc() was successful before assigning data to the memory block
            * allocated with realloc() */
            if (tmpData != NULL)
            {
                data = tmpData;
                
                data[0].intOne = 1;
                data[0].intTwo = 1;
                printStructLine(&data[0]);
            }
            free(data);
        }
        break;
"
6790,0,CWE197_Numeric_Truncation_Error__int_fgets_to_short_11.c,"    int data;
    
    data = -1;
    if(globalReturnsTrue())
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    {
        
        short shortData = (short)data;
        printShortLine(shortData);
"
19399,0,CWE190_Integer_Overflow__short_rand_multiply_15.c,"    short data;
    data = 0;
    switch(6)
    {
    case 6:
        
        data = (short)RAND32();
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
        if(data > 0) 
        {
            
            short result = data * 2;
            printIntLine(result);
        }
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
12038,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_02.c,"    size_t data;
    
    data = 0;
    if(1)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                
                data = strtoul(inputBuffer, NULL, 0);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    if(1)
    {
        {
            char * myString;
            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
             * for the strcpy() function to not cause a buffer overflow */
            
            if (data > strlen(HELLO_STRING))
            {
                myString = (char *)malloc(data*sizeof(char));
                if (myString == NULL) {exit(-1);}
                
                strcpy(myString, HELLO_STRING);
                printLine(myString);
                free(myString);
            }
            else
            {
                printLine(""Input is less than the length of the source string"");
            }
        }
"
8855,0,CWE369_Divide_by_Zero__int_zero_divide_03.c,"    int data;
    
    data = -1;
    if(5==5)
    {
        
        data = 0;
    }
    if(5==5)
    {
        
        printIntLine(100 / data);
"
15057,1,CWE758_Undefined_Behavior__struct_new_use_07.cpp,"    if(staticFive!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            twoIntsStruct data;
            data.intOne = 1;
            data.intTwo = 2;
            twoIntsStruct * pointer = new twoIntsStruct;
            *pointer = data; 
            {
                twoIntsStruct data = *pointer;
                printIntLine(data.intOne);
                printIntLine(data.intTwo);
            }
            delete pointer;
        }
"
3472,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_83a.cpp,"    size_t data;
    
    data = 0;
"
15140,0,CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_61a.c,"    unsigned int data;
    data = 0;
    data = CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_61b_badSource(data);
    {
        
        data++;
        unsigned int result = data;
        printUnsignedLine(result);
"
15632,0,CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_42.cpp,"    size_t data;
    
    data = 0;
    data = badSource(data);
    {
        char * myString;
        /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
         * for the strcpy() function to not cause a buffer overflow */
        
        if (data > strlen(HELLO_STRING))
        {
            myString = new char[data];
            
            strcpy(myString, HELLO_STRING);
            printLine(myString);
            delete [] myString;
        }
        else
        {
            printLine(""Input is less than the length of the source string"");
        }
"
13937,0,CWE563_Unused_Variable__unused_value_struct_81_bad.cpp,"Label Definition File: CWE563_Unused_Variable__unused_value.label.xml
Template File: sources-sinks-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 563 Unused Variable
 * BadSource:  Initialize data
 * GoodSource: Initialize and use data
 * Sinks:
 *    GoodSink: Use data
 *    BadSink : Initialize and use data
 * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE563_Unused_Variable__unused_value_struct_81.h""

namespace CWE563_Unused_Variable__unused_value_struct_81
{

void CWE563_Unused_Variable__unused_value_struct_81_bad::action(twoIntsStruct data) const
{
    
    data.intOne = 1;
    data.intTwo = 1;
    printStructLine(&data);
}

}
"
2939,0,CWE401_Memory_Leak__int_calloc_12.c,"    int * data;
    data = NULL;
    if(globalReturnsTrueOrFalse())
    {
        
        data = (int *)calloc(100, sizeof(int));
        if (data == NULL) {exit(-1);}
        
        data[0] = 5;
        printIntLine(data[0]);
    }
    else
    {
        
        data = (int *)ALLOCA(100*sizeof(int));
        
        data[0] = 5;
        printIntLine(data[0]);
    }
    if(globalReturnsTrueOrFalse())
    {
        
        ; 
    }
    else
    {
        
        free(data);
"
15677,0,CWE190_Integer_Overflow__char_max_add_45.c,"    char data;
    data = ' ';
    
    data = CHAR_MAX;
    CWE190_Integer_Overflow__char_max_add_45_badData = data;
"
4743,0,CWE590_Free_Memory_Not_on_Heap__free_int64_t_alloca_18.c,"    int64_t * data;
    data = NULL; 
    goto source;
source:
    {
        
        int64_t * dataBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5LL;
            }
        }
        data = dataBuffer;
    }
    printLongLongLine(data[0]);
    
"
14418,0,CWE197_Numeric_Truncation_Error__int_connect_socket_to_short_22a.c,"    int data;
    
    data = -1;
    CWE197_Numeric_Truncation_Error__int_connect_socket_to_short_22_badGlobal = 1; 
    data = CWE197_Numeric_Truncation_Error__int_connect_socket_to_short_22_badSource(data);
    {
        
        short shortData = (short)data;
        printShortLine(shortData);
"
9772,0,CWE789_Uncontrolled_Mem_Alloc__new_char_fgets_53a.cpp,"    size_t data;
    
    data = 0;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = strtoul(inputBuffer, NULL, 0);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
"
16914,0,CWE190_Integer_Overflow__unsigned_int_rand_add_84a.cpp,"    unsigned int data;
    data = 0;
    CWE190_Integer_Overflow__unsigned_int_rand_add_84_bad * badObject = new CWE190_Integer_Overflow__unsigned_int_rand_add_84_bad(data);
"
2759,0,CWE190_Integer_Overflow__int64_t_max_square_14.c,"    int64_t data;
    data = 0LL;
    if(globalFive==5)
    {
        
        data = LLONG_MAX;
    }
    if(globalFive==5)
    {
        {
            
            int64_t result = data * data;
            printLongLongLine(result);
        }
"
10526,0,CWE190_Integer_Overflow__short_fscanf_multiply_04.c,"    short data;
    data = 0;
    if(STATIC_CONST_TRUE)
    {
        
        fscanf (stdin, ""%hd"", &data);
    }
    if(STATIC_CONST_TRUE)
    {
        if(data > 0) 
        {
            
            short result = data * 2;
            printIntLine(result);
        }
"
12450,0,CWE476_NULL_Pointer_Dereference__binary_if_18.c,"    goto sink;
sink:
    {
        twoIntsStruct *twoIntsStructPointer = NULL;
        /* FLAW: Using a single & in the if statement will cause both sides of the expression to be evaluated
         * thus causing a NPD */
        if ((twoIntsStructPointer != NULL) & (twoIntsStructPointer->intOne == 5))
        {
            printLine(""intOne == 5"");
        }
"
12349,0,CWE190_Integer_Overflow__char_rand_multiply_41.c,"    char data;
    data = ' ';
    
    data = (char)RAND32();
"
13627,1,CWE758_Undefined_Behavior__int_pointer_malloc_use_04.c,"    if(STATIC_CONST_TRUE)
    {
        {
            int * data;
            int * * pointer = (int * *)malloc(sizeof(int *));
            if (pointer == NULL) {exit(-1);}
            
            data = (int *)malloc(sizeof(int));
            if (data == NULL) {exit(-1);}
            *data = 5;
            *pointer = data; 
            {
                int * data = *pointer;
                printIntLine(*data);
            }
            free(pointer);
        }
"
8725,1,CWE401_Memory_Leak__malloc_realloc_struct_twoIntsStruct_04.c,"    if(STATIC_CONST_FALSE)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            struct _twoIntsStruct * data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));
            if (data == NULL) {exit(-1);}
            struct _twoIntsStruct * tmpData;
            
            data[0].intOne = 0;
            data[0].intTwo = 0;
            printStructLine((twoIntsStruct *)&data[0]);
            tmpData = (struct _twoIntsStruct *)realloc(data, (130000)*sizeof(struct _twoIntsStruct));
            /* FIX: Ensure realloc() was successful before assigning data to the memory block
            * allocated with realloc() */
            if (tmpData != NULL)
            {
                data = tmpData;
                
                data[0].intOne = 1;
                data[0].intTwo = 1;
                printStructLine((twoIntsStruct *)&data[0]);
            }
            free(data);
        }
"
5580,0,CWE690_NULL_Deref_From_Return__long_calloc_65a.c,"    long * data;
    
    void (*funcPtr) (long *) = CWE690_NULL_Deref_From_Return__long_calloc_65b_badSink;
    data = NULL; 
    
    data = (long *)calloc(1, sizeof(long));
    
"
15727,0,CWE416_Use_After_Free__new_delete_long_64a.cpp,"    long * data;
    
    data = NULL;
    data = new long;
    *data = 5L;
    
    delete data;
"
12713,0,CWE190_Integer_Overflow__short_max_postinc_01.c,"    short data;
    data = 0;
    
    data = SHRT_MAX;
    {
        
        data++;
        short result = data;
        printIntLine(result);
"
1689,0,CWE252_Unchecked_Return_Value__char_fread_07.c,"    if(staticFive==5)
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            
            fread((char *)data, sizeof(char), (size_t)(100-1), stdin);
        }
"
11855,1,CWE476_NULL_Pointer_Dereference__null_check_after_deref_10.c,"    if(globalFalse)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            int *intPointer = NULL;
            intPointer = (int *)malloc(sizeof(int));
            *intPointer = 5;
            printIntLine(*intPointer);
            
            *intPointer = 10;
            printIntLine(*intPointer);
        }
"
949,0,CWE190_Integer_Overflow__unsigned_int_max_square_73a.cpp,"    unsigned int data;
    list<unsigned int> dataList;
    data = 0;
    
    data = UINT_MAX;
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
16128,1,CWE758_Undefined_Behavior__int_malloc_use_07.c,"    if(staticFive==5)
    {
        {
            int data;
            int * pointer = (int *)malloc(sizeof(int));
            if (pointer == NULL) {exit(-1);}
            data = 5;
            *pointer = data; 
            {
                int data = *pointer;
                printIntLine(data);
            }
            free(pointer);
        }
"
16256,0,CWE190_Integer_Overflow__short_rand_add_09.c,"    short data;
    data = 0;
    if(GLOBAL_CONST_TRUE)
    {
        
        data = (short)RAND32();
    }
    if(GLOBAL_CONST_TRUE)
    {
        {
            
            short result = data + 1;
            printIntLine(result);
        }
"
9466,0,CWE457_Use_of_Uninitialized_Variable__long_17.c,"    int i,j;
    long data;
    for(i = 0; i < 1; i++)
    {
        
        ; 
    }
    for(j = 0; j < 1; j++)
    {
        
        printLongLine(data);
"
9823,0,CWE190_Integer_Overflow__short_fscanf_add_51a.c,"    short data;
    data = 0;
    
    fscanf (stdin, ""%hd"", &data);
"
2853,0,CWE190_Integer_Overflow__unsigned_int_rand_multiply_65a.c,"    unsigned int data;
    
    void (*funcPtr) (unsigned int) = CWE190_Integer_Overflow__unsigned_int_rand_multiply_65b_badSink;
    data = 0;
    
    data = (unsigned int)RAND32();
    
"
2245,0,CWE587_Assignment_of_Fixed_Address_to_Pointer__basic_03.c,"    if(5==5)
    {
        {
            
            char *charPointer = (char*)0x400000;
            printHexCharLine(*charPointer);
        }
"
6942,0,CWE190_Integer_Overflow__int_connect_socket_square_63a.c,"    int data;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
9647,0,CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_72a.cpp,"    char * data;
    vector<char *> dataVector;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
9157,0,CWE415_Double_Free__new_delete_array_struct_16.cpp,"    twoIntsStruct * data;
    
    data = NULL;
    while(1)
    {
        data = new twoIntsStruct[100];
        
        delete [] data;
        break;
    }
    while(1)
    {
        
        delete [] data;
        break;
"
11445,0,CWE401_Memory_Leak__int64_t_calloc_83a.cpp,"    int64_t * data;
    data = NULL;
"
6505,0,CWE401_Memory_Leak__new_array_int_53a.cpp,"    int * data;
    data = NULL;
    
    data = new int[100];
    
    data[0] = 5;
    printIntLine(data[0]);
"
3064,0,CWE457_Use_of_Uninitialized_Variable__twointsclass_array_new_no_init_03.cpp,"    TwoIntsClass * data;
    data = new TwoIntsClass[10];
    if(5==5)
    {
        
        ; 
    }
    if(5==5)
    {
        
        for(int i=0; i<10; i++)
        {
            printIntLine(data[i].intOne);
            printIntLine(data[i].intTwo);
        }
"
343,0,CWE134_Uncontrolled_Format_String__char_console_fprintf_33.cpp,"    char * data;
    char * &dataRef = data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        
        if (100-dataLen > 1)
        {
            
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgets() */
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
                    data[dataLen-1] = '\0';
                }
            }
            else
            {
                printLine(""fgets() failed"");
                
                data[dataLen] = '\0';
            }
        }
    }
    {
        char * data = dataRef;
        
        fprintf(stdout, data);
"
4260,0,CWE590_Free_Memory_Not_on_Heap__free_long_static_08.c,"    long * data;
    data = NULL; 
    if(staticReturnsTrue())
    {
        {
            
            static long dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5L;
                }
            }
            data = dataBuffer;
        }
    }
    printLongLine(data[0]);
    
"
8992,0,CWE590_Free_Memory_Not_on_Heap__delete_char_declare_73a.cpp,"    char * data;
    list<char *> dataList;
    data = NULL; 
    {
        
        char dataBuffer;
        dataBuffer = 'A';
        data = &dataBuffer;
    }
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
18684,0,CWE563_Unused_Variable__unused_init_variable_int_05.c,"    int data;
    
    data = 5;
    if(staticTrue)
    {
        
        
        ; 
"
15939,0,CWE190_Integer_Overflow__int64_t_fscanf_square_33.cpp,"    int64_t data;
    int64_t &dataRef = data;
    data = 0LL;
    
    fscanf (stdin, ""%"" SCNd64, &data);
    {
        int64_t data = dataRef;
        {
            
            int64_t result = data * data;
            printLongLongLine(result);
        }
"
17809,0,CWE252_Unchecked_Return_Value__char_fgets_14.c,"    if(globalFive==5)
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            printLine(""Please enter a string: "");
            
            fgets(data, 100, stdin);
            printLine(data);
        }
"
16038,0,CWE369_Divide_by_Zero__int_fgets_divide_74a.cpp,"    int data;
    map<int, int> dataMap;
    
    data = -1;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
5588,0,CWE415_Double_Free__new_delete_array_char_22a.cpp,"    char * data;
    
    data = NULL;
    data = new char[100];
    
    delete [] data;
    badGlobal = 1; 
"
4387,0,CWE190_Integer_Overflow__int_fgets_postinc_09.c,"    int data;
    
    data = 0;
    if(GLOBAL_CONST_TRUE)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    if(GLOBAL_CONST_TRUE)
    {
        {
            
            data++;
            int result = data;
            printIntLine(result);
        }
"
18333,0,CWE190_Integer_Overflow__unsigned_int_rand_square_74a.cpp,"    unsigned int data;
    map<int, unsigned int> dataMap;
    data = 0;
    
    data = (unsigned int)RAND32();
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
19047,0,CWE416_Use_After_Free__new_delete_int64_t_15.cpp,"    int64_t * data;
    
    data = NULL;
    switch(6)
    {
    case 6:
        data = new int64_t;
        *data = 5LL;
        
        delete data;
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
        
        printLongLongLine(*data);
        
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
15439,0,CWE457_Use_of_Uninitialized_Variable__int_array_malloc_partial_init_13.c,"    int * data;
    data = (int *)malloc(10*sizeof(int));
    if (data == NULL) {exit(-1);}
    if(GLOBAL_CONST_FIVE==5)
    {
        
        {
            int i;
            for(i=0; i<(10/2); i++)
            {
                data[i] = i;
            }
        }
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i]);
            }
        }
"
8113,0,CWE590_Free_Memory_Not_on_Heap__delete_char_static_04.cpp,"    char * data;
    data = NULL; 
    if(STATIC_CONST_TRUE)
    {
        {
            
            static char dataBuffer;
            dataBuffer = 'A';
            data = &dataBuffer;
        }
    }
    printHexCharLine(*data);
    
"
3663,0,CWE190_Integer_Overflow__int64_t_fscanf_add_65a.c,"    int64_t data;
    
    void (*funcPtr) (int64_t) = CWE190_Integer_Overflow__int64_t_fscanf_add_65b_badSink;
    data = 0LL;
    
    fscanf (stdin, ""%"" SCNd64, &data);
    
"
19517,0,CWE190_Integer_Overflow__int_max_postinc_45.c,"    int data;
    
    data = 0;
    
    data = INT_MAX;
    CWE190_Integer_Overflow__int_max_postinc_45_badData = data;
"
2689,0,CWE758_Undefined_Behavior__struct_malloc_use_12.c,"    if(globalReturnsTrueOrFalse())
    {
        {
            twoIntsStruct * pointer = (twoIntsStruct *)malloc(sizeof(twoIntsStruct));
            if (pointer == NULL) {exit(-1);}
            twoIntsStruct data = *pointer; 
            free(pointer);
            printIntLine(data.intOne);
            printIntLine(data.intTwo);
        }
    }
    else
    {
        {
            twoIntsStruct data;
            twoIntsStruct * pointer = (twoIntsStruct *)malloc(sizeof(twoIntsStruct));
            if (pointer == NULL) {exit(-1);}
            data.intOne = 1;
            data.intTwo = 2;
            *pointer = data; 
            {
                twoIntsStruct data = *pointer;
                printIntLine(data.intOne);
                printIntLine(data.intTwo);
            }
            free(pointer);
        }
"
18963,0,CWE369_Divide_by_Zero__int_listen_socket_divide_52a.c,"    int data;
    
    data = -1;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
12586,0,CWE467_Use_of_sizeof_on_Pointer_Type__char_15.c,"    switch(6)
    {
    case 6:
    {
        char * badChar = NULL;
        
        badChar = (char *)malloc(sizeof(badChar));
        if (badChar == NULL) {exit(-1);}
        *badChar = 'B';
        printHexCharLine(*badChar);
        free(badChar);
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
7809,0,CWE369_Divide_by_Zero__int_fscanf_modulo_74a.cpp,"    int data;
    map<int, int> dataMap;
    
    data = -1;
    
    fscanf(stdin, ""%d"", &data);
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
10977,0,CWE590_Free_Memory_Not_on_Heap__delete_int64_t_alloca_17.cpp,"    int i;
    int64_t * data;
    data = NULL; 
    for(i = 0; i < 1; i++)
    {
        {
            
            int64_t * dataBuffer = (int64_t *)ALLOCA(sizeof(int64_t));
            *dataBuffer = 5LL;
            data = dataBuffer;
        }
    }
    printLongLongLine(*data);
    
"
16837,0,CWE190_Integer_Overflow__short_fscanf_add_02.c,"    short data;
    data = 0;
    if(1)
    {
        
        fscanf (stdin, ""%hd"", &data);
    }
    if(1)
    {
        {
            
            short result = data + 1;
            printIntLine(result);
        }
"
12587,0,CWE590_Free_Memory_Not_on_Heap__delete_array_int64_t_alloca_82a.cpp,"    int64_t * data;
    data = NULL; 
    {
        
        int64_t * dataBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5LL;
            }
        }
        data = dataBuffer;
    }
    CWE590_Free_Memory_Not_on_Heap__delete_array_int64_t_alloca_82_base* baseObject = new CWE590_Free_Memory_Not_on_Heap__delete_array_int64_t_alloca_82_bad;
    baseObject->action(data);
"
8572,0,CWE78_OS_Command_Injection__char_connect_socket_popen_14.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(globalFive==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET connectSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
"
11715,0,CWE590_Free_Memory_Not_on_Heap__free_char_declare_18.c,"    char * data;
    data = NULL; 
    goto source;
source:
    {
        
        char dataBuffer[100];
        memset(dataBuffer, 'A', 100-1); 
        dataBuffer[100-1] = '\0'; 
        data = dataBuffer;
    }
    printLine(data);
    
"
1078,0,CWE476_NULL_Pointer_Dereference__struct_74a.cpp,"    twoIntsStruct * data;
    map<int, twoIntsStruct *> dataMap;
    
    data = NULL;
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
12397,0,CWE190_Integer_Overflow__int_fscanf_square_43.cpp,"    int data;
    
    data = 0;
    badSource(data);
    {
        
        int result = data * data;
        printIntLine(result);
"
1500,0,CWE190_Integer_Overflow__int_fscanf_add_52a.c,"    int data;
    
    data = 0;
    
    fscanf(stdin, ""%d"", &data);
"
606,0,CWE190_Integer_Overflow__char_rand_postinc_02.c,"    char data;
    data = ' ';
    if(1)
    {
        
        data = (char)RAND32();
    }
    if(1)
    {
        {
            
            data++;
            char result = data;
            printHexCharLine(result);
        }
"
570,0,CWE190_Integer_Overflow__char_rand_square_09.c,"    char data;
    data = ' ';
    if(GLOBAL_CONST_TRUE)
    {
        
        data = (char)RAND32();
    }
    if(GLOBAL_CONST_TRUE)
    {
        {
            
            char result = data * data;
            printHexCharLine(result);
        }
"
12104,0,CWE590_Free_Memory_Not_on_Heap__free_struct_alloca_73a.cpp,"    twoIntsStruct * data;
    list<twoIntsStruct *> dataList;
    data = NULL; 
    {
        
        twoIntsStruct * dataBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i].intOne = 1;
                dataBuffer[i].intTwo = 1;
            }
        }
        data = dataBuffer;
    }
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
5274,0,CWE252_Unchecked_Return_Value__char_rename_13.c,"    if(GLOBAL_CONST_FIVE==5)
    {
        
        RENAME(OLD_BAD_FILE_NAME, ""newbadfilename.txt"");
"
3630,0,CWE415_Double_Free__malloc_free_int64_t_32.c,"    int64_t * data;
    int64_t * *dataPtr1 = &data;
    int64_t * *dataPtr2 = &data;
    
    data = NULL;
    {
        int64_t * data = *dataPtr1;
        data = (int64_t *)malloc(100*sizeof(int64_t));
        if (data == NULL) {exit(-1);}
        
        free(data);
        *dataPtr1 = data;
    }
    {
        int64_t * data = *dataPtr2;
        
        free(data);
"
15226,0,CWE134_Uncontrolled_Format_String__char_console_fprintf_81_bad.cpp,"Label Definition File: CWE134_Uncontrolled_Format_String.label.xml
Template File: sources-sinks-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 134 Uncontrolled Format String
 * BadSource: console Read input from the console
 * GoodSource: Copy a fixed string into data
 * Sinks: fprintf
 *    GoodSink: fprintf with ""%s"" as the second argument and data as the third
 *    BadSink : fprintf with data as the second argument
 * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE134_Uncontrolled_Format_String__char_console_fprintf_81.h""

namespace CWE134_Uncontrolled_Format_String__char_console_fprintf_81
{

void CWE134_Uncontrolled_Format_String__char_console_fprintf_81_bad::action(char * data) const
{
    
    fprintf(stdout, data);
}

}
"
17129,1,CWE467_Use_of_sizeof_on_Pointer_Type__short_05.c,"    if(staticTrue)
    {
        {
            short * goodShort = NULL;
            
            goodShort = (short *)malloc(sizeof(*goodShort));
            if (goodShort == NULL) {exit(-1);}
            *goodShort = 6;
            printShortLine(*goodShort);
            free(goodShort);
        }
"
2211,0,CWE134_Uncontrolled_Format_String__char_connect_socket_printf_18.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    goto source;
source:
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    goto sink;
sink:
    
"
17336,0,CWE190_Integer_Overflow__int64_t_rand_square_52a.c,"    int64_t data;
    data = 0LL;
    
    data = (int64_t)RAND64();
"
9706,0,CWE190_Integer_Overflow__short_rand_postinc_45.c,"    short data;
    data = 0;
    
    data = (short)RAND32();
    CWE190_Integer_Overflow__short_rand_postinc_45_badData = data;
"
5488,0,CWE690_NULL_Deref_From_Return__struct_realloc_82a.cpp,"    twoIntsStruct * data;
    data = NULL; 
    
    data = (twoIntsStruct *)realloc(data, 1*sizeof(twoIntsStruct));
    CWE690_NULL_Deref_From_Return__struct_realloc_82_base* baseObject = new CWE690_NULL_Deref_From_Return__struct_realloc_82_bad;
    baseObject->action(data);
"
4733,0,CWE457_Use_of_Uninitialized_Variable__double_07.c,"    double data;
    if(staticFive==5)
    {
        
        ; 
    }
    if(staticFive==5)
    {
        
        printDoubleLine(data);
"
3961,0,CWE590_Free_Memory_Not_on_Heap__free_struct_static_44.c,"    twoIntsStruct * data;
    
    void (*funcPtr) (twoIntsStruct *) = badSink;
    data = NULL; 
    {
        
        static twoIntsStruct dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i].intOne = 1;
                dataBuffer[i].intTwo = 1;
            }
        }
        data = dataBuffer;
    }
    
"
2647,0,CWE590_Free_Memory_Not_on_Heap__delete_array_struct_alloca_08.cpp,"    twoIntsStruct * data;
    data = NULL; 
    if(staticReturnsTrue())
    {
        {
            
            twoIntsStruct * dataBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i].intOne = 1;
                    dataBuffer[i].intTwo = 1;
                }
            }
            data = dataBuffer;
        }
    }
    printStructLine(&data[0]);
    
"
18909,0,CWE789_Uncontrolled_Mem_Alloc__new_char_listen_socket_73a.cpp,"    size_t data;
    list<size_t> dataList;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = strtoul(inputBuffer, NULL, 0);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
15819,1,CWE252_Unchecked_Return_Value__char_remove_02.c,"    if(1)
    {
        
        if (REMOVE(""removemegood.txt"") != 0)
        {
            printLine(""remove failed!"");
        }
"
14627,0,CWE690_NULL_Deref_From_Return__char_realloc_83_bad.cpp,"Label Definition File: CWE690_NULL_Deref_From_Return.free.label.xml
Template File: source-sinks-83_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 690 Unchecked Return Value To NULL Pointer
 * BadSource: realloc Allocate data using realloc()
 * Sinks:
 *    GoodSink: Check to see if the data allocation failed and if not, use data
 *    BadSink : Don't check for NULL and use data
 * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE690_NULL_Deref_From_Return__char_realloc_83.h""

namespace CWE690_NULL_Deref_From_Return__char_realloc_83
{
CWE690_NULL_Deref_From_Return__char_realloc_83_bad::CWE690_NULL_Deref_From_Return__char_realloc_83_bad(char * dataCopy)
{
    data = dataCopy;
    
    data = (char *)realloc(data, 20*sizeof(char));
}

CWE690_NULL_Deref_From_Return__char_realloc_83_bad::~CWE690_NULL_Deref_From_Return__char_realloc_83_bad()
{
    
    strcpy(data, ""Initialize"");
    printLine(data);
    free(data);
}
}
"
409,0,CWE190_Integer_Overflow__short_max_square_81_bad.cpp,"Label Definition File: CWE190_Integer_Overflow.label.xml
Template File: sources-sinks-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 190 Integer Overflow
 * BadSource: max Set data to the max value for short
 * GoodSource: Set data to a small, non-zero number (two)
 * Sinks: square
 *    GoodSink: Ensure there will not be an overflow before squaring data
 *    BadSink : Square data, which can lead to overflow
 * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE190_Integer_Overflow__short_max_square_81.h""

#include <math.h>

namespace CWE190_Integer_Overflow__short_max_square_81
{

void CWE190_Integer_Overflow__short_max_square_81_bad::action(short data) const
{
    {
        
        short result = data * data;
        printIntLine(result);
    }
}

}
"
9790,0,CWE134_Uncontrolled_Format_String__char_environment_fprintf_03.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(5==5)
    {
        {
            
            size_t dataLen = strlen(data);
            char * environment = GETENV(ENV_VARIABLE);
            
            if (environment != NULL)
            {
                
                strncat(data+dataLen, environment, 100-dataLen-1);
            }
        }
    }
    if(5==5)
    {
        
        fprintf(stdout, data);
"
13706,1,CWE252_Unchecked_Return_Value__char_fputc_12.c,"    if(globalReturnsTrueOrFalse())
    {
        
        if (fputc((int)'A', stdout) == EOF)
        {
            printLine(""fputc failed!"");
        }
    }
    else
    {
        
        if (fputc((int)'A', stdout) == EOF)
        {
            printLine(""fputc failed!"");
        }
"
19018,0,CWE415_Double_Free__new_delete_char_05.cpp,"    char * data;
    
    data = NULL;
    if(staticTrue)
    {
        data = new char;
        
        delete data;
    }
    if(staticTrue)
    {
        
        delete data;
"
9975,0,CWE190_Integer_Overflow__int_max_square_68a.c,"    int data;
    
    data = 0;
    
    data = INT_MAX;
    CWE190_Integer_Overflow__int_max_square_68_badData = data;
"
14246,1,CWE676_Use_of_Potentially_Dangerous_Function__basic_07.cpp,"    if(staticFive!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            char charBuffer[CHAR_BUFFER_SIZE];
            
            cin.width(CHAR_BUFFER_SIZE);
            cin >> charBuffer;
            charBuffer[CHAR_BUFFER_SIZE-1] = '\0';
            printLine(charBuffer);
        }
"
7602,0,CWE415_Double_Free__new_delete_array_struct_01.cpp,"    twoIntsStruct * data;
    
    data = NULL;
    data = new twoIntsStruct[100];
    
    delete [] data;
    
"
1560,1,CWE758_Undefined_Behavior__char_pointer_alloca_use_08.c,"    if(staticReturnsTrue())
    {
        {
            char * data;
            char * * pointer = (char * *)ALLOCA(sizeof(char *));
            data = ""string"";
            *pointer = data; 
            {
                char * data = *pointer;
                printLine(data);
            }
        }
"
9650,0,CWE190_Integer_Overflow__int_max_postinc_04.c,"    int data;
    
    data = 0;
    if(STATIC_CONST_TRUE)
    {
        
        data = INT_MAX;
    }
    if(STATIC_CONST_TRUE)
    {
        {
            
            data++;
            int result = data;
            printIntLine(result);
        }
"
5866,0,CWE676_Use_of_Potentially_Dangerous_Function__basic_10.cpp,"    if(globalTrue)
    {
        {
            char charBuffer[CHAR_BUFFER_SIZE];
            
            
            cin >> charBuffer;
            charBuffer[CHAR_BUFFER_SIZE-1] = '\0';
            printLine(charBuffer);
        }
"
1626,0,CWE197_Numeric_Truncation_Error__int_large_to_char_65a.c,"    int data;
    
    void (*funcPtr) (int) = CWE197_Numeric_Truncation_Error__int_large_to_char_65b_badSink;
    
    data = -1;
    
    data = SHRT_MAX + 5;
    
"
7833,0,CWE401_Memory_Leak__new_array_struct_twoIntsStruct_65a.cpp,"    struct _twoIntsStruct * data;
    
    void (*funcPtr) (struct _twoIntsStruct *) = badSink;
    data = NULL;
    
    data = new struct _twoIntsStruct[100];
    
    data[0].intOne = 0;
    data[0].intTwo = 0;
    printStructLine((twoIntsStruct *)&data[0]);
    
"
3011,0,CWE457_Use_of_Uninitialized_Variable__int_array_alloca_no_init_06.c,"    int * data;
    data = (int *)ALLOCA(10*sizeof(int));
    if(STATIC_CONST_FIVE==5)
    {
        
        ; 
    }
    if(STATIC_CONST_FIVE==5)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i]);
            }
        }
"
4589,0,CWE401_Memory_Leak__int_malloc_22a.c,"    int * data;
    data = NULL;
    
    data = (int *)malloc(100*sizeof(int));
    if (data == NULL) {exit(-1);}
    
    data[0] = 5;
    printIntLine(data[0]);
    CWE401_Memory_Leak__int_malloc_22_badGlobal = 1; 
"
14889,0,CWE190_Integer_Overflow__int_fscanf_preinc_07.c,"    int data;
    
    data = 0;
    if(staticFive==5)
    {
        
        fscanf(stdin, ""%d"", &data);
    }
    if(staticFive==5)
    {
        {
            
            ++data;
            int result = data;
            printIntLine(result);
        }
"
2108,0,CWE197_Numeric_Truncation_Error__int_connect_socket_to_short_07.c,"    int data;
    
    data = -1;
    if(staticFive==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    {
        
        short shortData = (short)data;
        printShortLine(shortData);
"
153,0,CWE590_Free_Memory_Not_on_Heap__delete_struct_placement_new_11.cpp,"    twoIntsStruct * data;
    data = NULL; 
    if(globalReturnsTrue())
    {
        {
            
            char buffer[sizeof(twoIntsStruct)];
            twoIntsStruct * dataBuffer = new(buffer) twoIntsStruct;
            dataBuffer->intOne = 1;
            dataBuffer->intTwo = 1;
            data = dataBuffer;
        }
    }
    printStructLine(data);
    
"
5565,0,CWE401_Memory_Leak__char_calloc_02.c,"    char * data;
    data = NULL;
    if(1)
    {
        
        data = (char *)calloc(100, sizeof(char));
        if (data == NULL) {exit(-1);}
        
        strcpy(data, ""A String"");
        printLine(data);
    }
    if(1)
    {
        
        ; 
"
1462,0,CWE190_Integer_Overflow__unsigned_int_max_add_34.c,"    unsigned int data;
    CWE190_Integer_Overflow__unsigned_int_max_add_34_unionType myUnion;
    data = 0;
    
    data = UINT_MAX;
    myUnion.unionFirst = data;
    {
        unsigned int data = myUnion.unionSecond;
        {
            
            unsigned int result = data + 1;
            printUnsignedLine(result);
        }
"
6193,0,CWE190_Integer_Overflow__char_fscanf_preinc_03.c,"    char data;
    data = ' ';
    if(5==5)
    {
        
        fscanf (stdin, ""%c"", &data);
    }
    if(5==5)
    {
        {
            
            ++data;
            char result = data;
            printHexCharLine(result);
        }
"
4776,0,CWE401_Memory_Leak__new_char_65a.cpp,"    char * data;
    
    void (*funcPtr) (char *) = badSink;
    data = NULL;
    
    data = new char;
    
    *data = 'A';
    printHexCharLine(*data);
    
"
14957,0,CWE190_Integer_Overflow__short_max_multiply_31.c,"    short data;
    data = 0;
    
    data = SHRT_MAX;
    {
        short dataCopy = data;
        short data = dataCopy;
        if(data > 0) 
        {
            
            short result = data * 2;
            printIntLine(result);
        }
"
16255,1,CWE758_Undefined_Behavior__char_pointer_malloc_use_03.c,"    if(5!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            char * data;
            char * * pointer = (char * *)malloc(sizeof(char *));
            if (pointer == NULL) {exit(-1);}
            data = ""string"";
            *pointer = data; 
            {
                char * data = *pointer;
                printLine(data);
            }
            free(pointer);
        }
"
16440,0,CWE590_Free_Memory_Not_on_Heap__delete_array_int_alloca_33.cpp,"    int * data;
    int * &dataRef = data;
    data = NULL; 
    {
        
        int * dataBuffer = (int *)ALLOCA(100*sizeof(int));
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5;
            }
        }
        data = dataBuffer;
    }
    {
        int * data = dataRef;
        printIntLine(data[0]);
        
        delete [] data;
"
17905,0,CWE78_OS_Command_Injection__char_file_execl_52a.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        FILE * pFile;
        
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
"
936,0,CWE190_Integer_Overflow__int_fscanf_postinc_31.c,"    int data;
    
    data = 0;
    
    fscanf(stdin, ""%d"", &data);
    {
        int dataCopy = data;
        int data = dataCopy;
        {
            
            data++;
            int result = data;
            printIntLine(result);
        }
"
8932,0,CWE476_NULL_Pointer_Dereference__class_06.cpp,"    TwoIntsClass * data;
    if(STATIC_CONST_FIVE==5)
    {
        
        data = NULL;
    }
    if(STATIC_CONST_FIVE==5)
    {
        
        printIntLine(data->intOne);
        
        delete data;
"
6468,0,CWE190_Integer_Overflow__unsigned_int_max_postinc_02.c,"    unsigned int data;
    data = 0;
    if(1)
    {
        
        data = UINT_MAX;
    }
    if(1)
    {
        {
            
            data++;
            unsigned int result = data;
            printUnsignedLine(result);
        }
"
15824,0,CWE190_Integer_Overflow__short_fscanf_postinc_65a.c,"    short data;
    
    void (*funcPtr) (short) = CWE190_Integer_Overflow__short_fscanf_postinc_65b_badSink;
    data = 0;
    
    fscanf (stdin, ""%hd"", &data);
    
"
7535,0,CWE190_Integer_Overflow__int64_t_max_preinc_09.c,"    int64_t data;
    data = 0LL;
    if(GLOBAL_CONST_TRUE)
    {
        
        data = LLONG_MAX;
    }
    if(GLOBAL_CONST_TRUE)
    {
        {
            
            ++data;
            int64_t result = data;
            printLongLongLine(result);
        }
"
5075,0,CWE401_Memory_Leak__struct_twoIntsStruct_realloc_84_bad.cpp,"Label Definition File: CWE401_Memory_Leak.c.label.xml
Template File: sources-sinks-84_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 401 Memory Leak
 * BadSource: realloc Allocate data using realloc()
 * GoodSource: Allocate data on the stack
 * Sinks:
 *    GoodSink: call free() on data
 *    BadSink : no deallocation of data
 * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE401_Memory_Leak__struct_twoIntsStruct_realloc_84.h""

namespace CWE401_Memory_Leak__struct_twoIntsStruct_realloc_84
{
CWE401_Memory_Leak__struct_twoIntsStruct_realloc_84_bad::CWE401_Memory_Leak__struct_twoIntsStruct_realloc_84_bad(struct _twoIntsStruct * dataCopy)
{
    data = dataCopy;
    
    data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));
    if (data == NULL) {exit(-1);}
    
    data[0].intOne = 0;
    data[0].intTwo = 0;
    printStructLine((twoIntsStruct *)&data[0]);
}

CWE401_Memory_Leak__struct_twoIntsStruct_realloc_84_bad::~CWE401_Memory_Leak__struct_twoIntsStruct_realloc_84_bad()
{
    
    ; 
}
}
"
5925,0,CWE416_Use_After_Free__new_delete_array_class_14.cpp,"    TwoIntsClass * data;
    
    data = NULL;
    if(globalFive==5)
    {
        data = new TwoIntsClass[100];
        {
            size_t i;
            for(i = 0; i < 100; i++)
            {
                data[i].intOne = 1;
                data[i].intTwo = 2;
            }
        }
        
        delete [] data;
    }
    if(globalFive==5)
    {
        
        printIntLine(data[0].intOne);
        
"
1128,0,CWE134_Uncontrolled_Format_String__char_console_vfprintf_84_bad.cpp,"Label Definition File: CWE134_Uncontrolled_Format_String.vasinks.label.xml
Template File: sources-vasinks-84_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 134 Uncontrolled Format String
 * BadSource: console Read input from the console
 * GoodSource: Copy a fixed string into data
 * Sinks: vfprintf
 *    GoodSink: vfprintf with a format string
 *    BadSink : vfprintf without a format string
 * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use
 *
 * */
#ifndef OMITBAD

#include <stdarg.h>
#include ""std_testcase.h""
#include ""CWE134_Uncontrolled_Format_String__char_console_vfprintf_84.h""

namespace CWE134_Uncontrolled_Format_String__char_console_vfprintf_84
{
CWE134_Uncontrolled_Format_String__char_console_vfprintf_84_bad::CWE134_Uncontrolled_Format_String__char_console_vfprintf_84_bad(char * dataCopy)
{
    data = dataCopy;
    {
        
        size_t dataLen = strlen(data);
        
        if (100-dataLen > 1)
        {
            
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgets() */
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
                    data[dataLen-1] = '\0';
                }
            }
            else
            {
                printLine(""fgets() failed"");
                
                data[dataLen] = '\0';
            }
        }
    }
}

static void badVaSink(char * data, ...)
{
    {
        va_list args;
        va_start(args, data);
        
        vfprintf(stdout, data, args);
        va_end(args);
    }
}

CWE134_Uncontrolled_Format_String__char_console_vfprintf_84_bad::~CWE134_Uncontrolled_Format_String__char_console_vfprintf_84_bad()
{
    badVaSink(data, data);
}
}
"
9015,0,CWE78_OS_Command_Injection__char_console_execl_41.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        
        if (100-dataLen > 1)
        {
            
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgets() */
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
"
14094,0,CWE401_Memory_Leak__new_twoIntsStruct_63a.cpp,"    twoIntsStruct * data;
    data = NULL;
    
    data = new twoIntsStruct;
    
    data->intOne = 0;
    data->intTwo = 0;
    printStructLine(data);
"
5887,0,CWE758_Undefined_Behavior__int_alloca_use_05.c,"    if(staticTrue)
    {
        {
            int * pointer = (int *)ALLOCA(sizeof(int));
            int data = *pointer; 
            printIntLine(data);
        }
"
4342,0,CWE190_Integer_Overflow__unsigned_int_max_square_03.c,"    unsigned int data;
    data = 0;
    if(5==5)
    {
        
        data = UINT_MAX;
    }
    if(5==5)
    {
        {
            
            unsigned int result = data * data;
            printUnsignedLine(result);
        }
"
2293,0,CWE401_Memory_Leak__new_array_int64_t_10.cpp,"    int64_t * data;
    data = NULL;
    if(globalTrue)
    {
        
        data = new int64_t[100];
        
        data[0] = 5LL;
        printLongLongLine(data[0]);
    }
    if(globalTrue)
    {
        
        ; 
"
17139,0,CWE401_Memory_Leak__int64_t_malloc_83_bad.cpp,"Label Definition File: CWE401_Memory_Leak.c.label.xml
Template File: sources-sinks-83_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 401 Memory Leak
 * BadSource: malloc Allocate data using malloc()
 * GoodSource: Allocate data on the stack
 * Sinks:
 *    GoodSink: call free() on data
 *    BadSink : no deallocation of data
 * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE401_Memory_Leak__int64_t_malloc_83.h""

namespace CWE401_Memory_Leak__int64_t_malloc_83
{
CWE401_Memory_Leak__int64_t_malloc_83_bad::CWE401_Memory_Leak__int64_t_malloc_83_bad(int64_t * dataCopy)
{
    data = dataCopy;
    
    data = (int64_t *)malloc(100*sizeof(int64_t));
    if (data == NULL) {exit(-1);}
    
    data[0] = 5LL;
    printLongLongLine(data[0]);
}

CWE401_Memory_Leak__int64_t_malloc_83_bad::~CWE401_Memory_Leak__int64_t_malloc_83_bad()
{
    
    ; 
}
}
"
7595,0,CWE415_Double_Free__malloc_free_int_81a.cpp,"    int * data;
    
    data = NULL;
    data = (int *)malloc(100*sizeof(int));
    if (data == NULL) {exit(-1);}
    
    free(data);
    const CWE415_Double_Free__malloc_free_int_81_base& baseObject = CWE415_Double_Free__malloc_free_int_81_bad();
"
3956,0,CWE78_OS_Command_Injection__char_connect_socket_system_74a.cpp,"    char * data;
    map<int, char *> dataMap;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
16676,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_73a.cpp,"    size_t data;
    list<size_t> dataList;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = strtoul(inputBuffer, NULL, 0);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
16595,0,CWE690_NULL_Deref_From_Return__long_calloc_51a.c,"    long * data;
    data = NULL; 
    
    data = (long *)calloc(1, sizeof(long));
"
18218,0,CWE590_Free_Memory_Not_on_Heap__free_char_declare_31.c,"    char * data;
    data = NULL; 
    {
        
        char dataBuffer[100];
        memset(dataBuffer, 'A', 100-1); 
        dataBuffer[100-1] = '\0'; 
        data = dataBuffer;
    }
    {
        char * dataCopy = data;
        char * data = dataCopy;
        printLine(data);
        
        free(data);
"
16803,0,CWE78_OS_Command_Injection__char_connect_socket_popen_61a.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    data = CWE78_OS_Command_Injection__char_connect_socket_popen_61b_badSource(data);
    {
        FILE *pipe;
        
        pipe = POPEN(data, ""w"");
        if (pipe != NULL)
        {
            PCLOSE(pipe);
        }
    }
}

#endif 

"
10744,0,CWE190_Integer_Overflow__int64_t_fscanf_preinc_67a.c,"    int64_t data;
    CWE190_Integer_Overflow__int64_t_fscanf_preinc_67_structType myStruct;
    data = 0LL;
    
    fscanf (stdin, ""%"" SCNd64, &data);
    myStruct.structFirst = data;
"
12329,0,CWE415_Double_Free__malloc_free_long_43.cpp,"    long * data;
    
    data = NULL;
    badSource(data);
    
"
15622,0,CWE401_Memory_Leak__struct_twoIntsStruct_malloc_01.c,"    struct _twoIntsStruct * data;
    data = NULL;
    
    data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));
    if (data == NULL) {exit(-1);}
    
    data[0].intOne = 0;
    data[0].intTwo = 0;
    printStructLine((twoIntsStruct *)&data[0]);
    
"
3874,0,CWE190_Integer_Overflow__short_max_postinc_66a.c,"    short data;
    short dataArray[5];
    data = 0;
    
    data = SHRT_MAX;
    
    dataArray[2] = data;
"
15904,0,CWE369_Divide_by_Zero__int_listen_socket_modulo_13.c,"    int data;
    
    data = -1;
    if(GLOBAL_CONST_FIVE==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        
        printIntLine(100 % data);
"
272,1,CWE252_Unchecked_Return_Value__char_fgets_06.c,"    if(STATIC_CONST_FIVE!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            printLine(""Please enter a string: "");
            
            if (fgets(data, 100, stdin) == NULL)
            {
                printLine(""fgets failed!"");
                exit(1);
            }
            printLine(data);
        }
"
1322,0,CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_06.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(STATIC_CONST_FIVE==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                data[dataLen + recvResult / sizeof(char)] = '\0';
                
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(STATIC_CONST_FIVE==5)
    {
        badVaSinkB(data, data);
"
3963,0,CWE369_Divide_by_Zero__float_rand_18.c,"    float data;
    
    data = 0.0F;
    goto source;
source:
    
    data = (float)RAND32();
    goto sink;
sink:
    {
        
        int result = (int)(100.0 / data);
        printIntLine(result);
"
12756,0,CWE197_Numeric_Truncation_Error__short_fgets_13.c,"    short data;
    
    data = -1;
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                
                data = (short)atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
5177,1,CWE758_Undefined_Behavior__struct_new_use_13.cpp,"    if(GLOBAL_CONST_FIVE==5)
    {
        {
            twoIntsStruct data;
            data.intOne = 1;
            data.intTwo = 2;
            twoIntsStruct * pointer = new twoIntsStruct;
            *pointer = data; 
            {
                twoIntsStruct data = *pointer;
                printIntLine(data.intOne);
                printIntLine(data.intTwo);
            }
            delete pointer;
        }
"
18987,0,CWE369_Divide_by_Zero__float_fgets_83_bad.cpp,"Label Definition File: CWE369_Divide_by_Zero__float.label.xml
Template File: sources-sinks-83_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 369 Divide by Zero
 * BadSource: fgets Read data from the console using fgets()
 * GoodSource: A hardcoded non-zero number (two)
 * Sinks:
 *    GoodSink: Check value of or near zero before dividing
 *    BadSink : Divide a constant by data
 * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE369_Divide_by_Zero__float_fgets_83.h""

#define CHAR_ARRAY_SIZE 20

namespace CWE369_Divide_by_Zero__float_fgets_83
{
CWE369_Divide_by_Zero__float_fgets_83_bad::CWE369_Divide_by_Zero__float_fgets_83_bad(float dataCopy)
{
    data = dataCopy;
    {
        char inputBuffer[CHAR_ARRAY_SIZE];
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = (float)atof(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
}

CWE369_Divide_by_Zero__float_fgets_83_bad::~CWE369_Divide_by_Zero__float_fgets_83_bad()
{
    {
        
        int result = (int)(100.0 / data);
        printIntLine(result);
    }
}
}
"
1084,0,CWE401_Memory_Leak__twoIntsStruct_malloc_05.c,"    twoIntsStruct * data;
    data = NULL;
    if(staticTrue)
    {
        
        data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
        if (data == NULL) {exit(-1);}
        
        data[0].intOne = 0;
        data[0].intTwo = 0;
        printStructLine(&data[0]);
    }
    if(staticTrue)
    {
        
        ; 
"
19032,0,CWE401_Memory_Leak__new_array_int64_t_07.cpp,"    int64_t * data;
    data = NULL;
    if(staticFive==5)
    {
        
        data = new int64_t[100];
        
        data[0] = 5LL;
        printLongLongLine(data[0]);
    }
    if(staticFive==5)
    {
        
        ; 
"
2544,1,CWE476_NULL_Pointer_Dereference__null_check_after_deref_04.c,"    if(STATIC_CONST_FALSE)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            int *intPointer = NULL;
            intPointer = (int *)malloc(sizeof(int));
            *intPointer = 5;
            printIntLine(*intPointer);
            
            *intPointer = 10;
            printIntLine(*intPointer);
        }
"
12636,0,CWE190_Integer_Overflow__int64_t_rand_postinc_01.c,"    int64_t data;
    data = 0LL;
    
    data = (int64_t)RAND64();
    {
        
        data++;
        int64_t result = data;
        printLongLongLine(result);
"
18048,0,CWE190_Integer_Overflow__int_rand_square_12.c,"    int data;
    
    data = 0;
    if(globalReturnsTrueOrFalse())
    {
        
        data = RAND32();
    }
    else
    {
        
        data = 2;
    }
    if(globalReturnsTrueOrFalse())
    {
        {
            
            int result = data * data;
            printIntLine(result);
        }
    }
    else
    {
        
        if (data > INT_MIN && abs(data) < (long)sqrt((double)INT_MAX))
        {
            int result = data * data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
"
13746,0,CWE415_Double_Free__new_delete_int64_t_13.cpp,"    int64_t * data;
    
    data = NULL;
    if(GLOBAL_CONST_FIVE==5)
    {
        data = new int64_t;
        
        delete data;
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        
        delete data;
"
12058,0,CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_31.c,"    unsigned int data;
    data = 0;
    
    fscanf (stdin, ""%u"", &data);
    {
        unsigned int dataCopy = data;
        unsigned int data = dataCopy;
        if(data > 0) 
        {
            
            unsigned int result = data * 2;
            printUnsignedLine(result);
        }
"
16006,0,CWE190_Integer_Overflow__int_connect_socket_multiply_13.c,"    int data;
    
    data = 0;
    if(GLOBAL_CONST_FIVE==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        if(data > 0) 
        {
            
            int result = data * 2;
            printIntLine(result);
        }
"
6485,0,CWE590_Free_Memory_Not_on_Heap__delete_long_alloca_12.cpp,"    long * data;
    data = NULL; 
    if(globalReturnsTrueOrFalse())
    {
        {
            
            long * dataBuffer = (long *)ALLOCA(sizeof(long));
            *dataBuffer = 5L;
            data = dataBuffer;
        }
    }
    else
    {
        {
            
            long * dataBuffer = new long;
            *dataBuffer = 5L;
            data = dataBuffer;
        }
    }
    printLongLine(*data);
    
"
17312,0,CWE78_OS_Command_Injection__char_connect_socket_execl_52a.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
11669,0,CWE190_Integer_Overflow__int64_t_max_preinc_10.c,"    int64_t data;
    data = 0LL;
    if(globalTrue)
    {
        
        data = LLONG_MAX;
    }
    if(globalTrue)
    {
        {
            
            ++data;
            int64_t result = data;
            printLongLongLine(result);
        }
"
15689,0,CWE590_Free_Memory_Not_on_Heap__delete_array_int64_t_alloca_18.cpp,"    int64_t * data;
    data = NULL; 
    goto source;
source:
    {
        
        int64_t * dataBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5LL;
            }
        }
        data = dataBuffer;
    }
    printLongLongLine(data[0]);
    
"
18960,0,CWE190_Integer_Overflow__char_fscanf_multiply_34.c,"    char data;
    CWE190_Integer_Overflow__char_fscanf_multiply_34_unionType myUnion;
    data = ' ';
    
    fscanf (stdin, ""%c"", &data);
    myUnion.unionFirst = data;
    {
        char data = myUnion.unionSecond;
        if(data > 0) 
        {
            
            char result = data * 2;
            printHexCharLine(result);
        }
"
13697,0,CWE197_Numeric_Truncation_Error__int_fgets_to_short_07.c,"    int data;
    
    data = -1;
    if(staticFive==5)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    {
        
        short shortData = (short)data;
        printShortLine(shortData);
"
6915,0,CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_82a.cpp,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_82_base* baseObject = new CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_82_bad;
    baseObject->action(data);
"
15510,0,CWE590_Free_Memory_Not_on_Heap__free_int_alloca_32.c,"    int * data;
    int * *dataPtr1 = &data;
    int * *dataPtr2 = &data;
    data = NULL; 
    {
        int * data = *dataPtr1;
        {
            
            int * dataBuffer = (int *)ALLOCA(100*sizeof(int));
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5;
                }
            }
            data = dataBuffer;
        }
        *dataPtr1 = data;
    }
    {
        int * data = *dataPtr2;
        printIntLine(data[0]);
        
        free(data);
"
4297,0,CWE457_Use_of_Uninitialized_Variable__double_array_malloc_no_init_08.c,"    double * data;
    data = (double *)malloc(10*sizeof(double));
    if (data == NULL) {exit(-1);}
    if(staticReturnsTrue())
    {
        
        ; 
    }
    if(staticReturnsTrue())
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printDoubleLine(data[i]);
            }
        }
"
9813,1,CWE758_Undefined_Behavior__int_pointer_malloc_use_15.c,"    switch(6)
    {
    case 6:
    {
        int * data;
        int * * pointer = (int * *)malloc(sizeof(int *));
        if (pointer == NULL) {exit(-1);}
        
        data = (int *)malloc(sizeof(int));
        if (data == NULL) {exit(-1);}
        *data = 5;
        *pointer = data; 
        {
            int * data = *pointer;
            printIntLine(*data);
        }
        free(pointer);
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
1271,0,CWE190_Integer_Overflow__short_fscanf_add_61a.c,"    short data;
    data = 0;
    data = CWE190_Integer_Overflow__short_fscanf_add_61b_badSource(data);
    {
        
        short result = data + 1;
        printIntLine(result);
"
11710,0,CWE190_Integer_Overflow__int_max_add_07.c,"    int data;
    
    data = 0;
    if(staticFive==5)
    {
        
        data = INT_MAX;
    }
    if(staticFive==5)
    {
        {
            
            int result = data + 1;
            printIntLine(result);
        }
"
14735,1,CWE252_Unchecked_Return_Value__char_fscanf_11.c,"    if(globalReturnsTrue())
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            
            if (fscanf(stdin, ""%99s\0"", data) == EOF)
            {
                printLine(""fscanf failed!"");
            }
        }
"
19236,0,CWE190_Integer_Overflow__short_max_preinc_13.c,"    short data;
    data = 0;
    if(GLOBAL_CONST_FIVE==5)
    {
        
        data = SHRT_MAX;
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            
            ++data;
            short result = data;
            printIntLine(result);
        }
"
4466,0,CWE190_Integer_Overflow__unsigned_int_max_square_83_bad.cpp,"Label Definition File: CWE190_Integer_Overflow.label.xml
Template File: sources-sinks-83_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 190 Integer Overflow
 * BadSource: max Set data to the max value for unsigned int
 * GoodSource: Set data to a small, non-zero number (two)
 * Sinks: square
 *    GoodSink: Ensure there will not be an overflow before squaring data
 *    BadSink : Square data, which can lead to overflow
 * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE190_Integer_Overflow__unsigned_int_max_square_83.h""

#include <math.h>

namespace CWE190_Integer_Overflow__unsigned_int_max_square_83
{
CWE190_Integer_Overflow__unsigned_int_max_square_83_bad::CWE190_Integer_Overflow__unsigned_int_max_square_83_bad(unsigned int dataCopy)
{
    data = dataCopy;
    
    data = UINT_MAX;
}

CWE190_Integer_Overflow__unsigned_int_max_square_83_bad::~CWE190_Integer_Overflow__unsigned_int_max_square_83_bad()
{
    {
        
        unsigned int result = data * data;
        printUnsignedLine(result);
    }
}
}
"
18740,0,CWE190_Integer_Overflow__int_rand_preinc_34.c,"    int data;
    CWE190_Integer_Overflow__int_rand_preinc_34_unionType myUnion;
    
    data = 0;
    
    data = RAND32();
    myUnion.unionFirst = data;
    {
        int data = myUnion.unionSecond;
        {
            
            ++data;
            int result = data;
            printIntLine(result);
        }
"
11099,0,CWE78_OS_Command_Injection__char_file_execl_42.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    data = badSource(data);
    
    
"
11612,0,CWE190_Integer_Overflow__short_fscanf_add_22a.c,"    short data;
    data = 0;
    
    fscanf (stdin, ""%hd"", &data);
    CWE190_Integer_Overflow__short_fscanf_add_22_badGlobal = 1; 
"
14080,0,CWE369_Divide_by_Zero__int_rand_divide_72a.cpp,"    int data;
    vector<int> dataVector;
    
    data = -1;
    
    data = RAND32();
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
6561,0,CWE415_Double_Free__malloc_free_long_82a.cpp,"    long * data;
    
    data = NULL;
    data = (long *)malloc(100*sizeof(long));
    if (data == NULL) {exit(-1);}
    
    free(data);
    CWE415_Double_Free__malloc_free_long_82_base* baseObject = new CWE415_Double_Free__malloc_free_long_82_bad;
    baseObject->action(data);
"
18151,0,CWE190_Integer_Overflow__short_max_preinc_08.c,"    short data;
    data = 0;
    if(staticReturnsTrue())
    {
        
        data = SHRT_MAX;
    }
    if(staticReturnsTrue())
    {
        {
            
            ++data;
            short result = data;
            printIntLine(result);
        }
"
2404,0,CWE415_Double_Free__malloc_free_int64_t_61a.c,"    int64_t * data;
    
    data = NULL;
    data = CWE415_Double_Free__malloc_free_int64_t_61b_badSource(data);
    
"
16531,0,CWE690_NULL_Deref_From_Return__int_malloc_52a.c,"    int * data;
    data = NULL; 
    
    data = (int *)malloc(1*sizeof(int));
"
14813,0,CWE190_Integer_Overflow__char_rand_postinc_09.c,"    char data;
    data = ' ';
    if(GLOBAL_CONST_TRUE)
    {
        
        data = (char)RAND32();
    }
    if(GLOBAL_CONST_TRUE)
    {
        {
            
            data++;
            char result = data;
            printHexCharLine(result);
        }
"
915,0,CWE197_Numeric_Truncation_Error__int_fgets_to_char_09.c,"    int data;
    
    data = -1;
    if(GLOBAL_CONST_TRUE)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
16561,0,CWE665_Improper_Initialization__char_ncat_12.c,"    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    if(globalReturnsTrueOrFalse())
    {
        
        ; 
    }
    else
    {
        
        data[0] = '\0'; 
    }
    {
        size_t sourceLen;
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        sourceLen = strlen(source);
        
        strncat(data, source, sourceLen);
        printLine(data);
"
796,0,CWE401_Memory_Leak__malloc_realloc_int64_t_16.c,"    while(1)
    {
        {
            int64_t * data = (int64_t *)malloc(100*sizeof(int64_t));
            if (data == NULL) {exit(-1);}
            
            data[0] = 5LL;
            printLongLongLine(data[0]);
            
            data = (int64_t *)realloc(data, (130000)*sizeof(int64_t));
            if (data != NULL)
            {
                
                data[0] = 10LL;
                printLongLongLine(data[0]);
                free(data);
            }
        }
        break;
"
8649,0,CWE476_NULL_Pointer_Dereference__binary_if_08.c,"    if(staticReturnsTrue())
    {
        {
            twoIntsStruct *twoIntsStructPointer = NULL;
            /* FLAW: Using a single & in the if statement will cause both sides of the expression to be evaluated
             * thus causing a NPD */
            if ((twoIntsStructPointer != NULL) & (twoIntsStructPointer->intOne == 5))
            {
                printLine(""intOne == 5"");
            }
        }
"
3579,0,CWE369_Divide_by_Zero__int_fscanf_modulo_03.c,"    int data;
    
    data = -1;
    if(5==5)
    {
        
        fscanf(stdin, ""%d"", &data);
    }
    if(5==5)
    {
        
        printIntLine(100 % data);
"
3305,1,CWE758_Undefined_Behavior__class_new_use_08.cpp,"    if(staticReturnsTrue())
    {
        {
            TwoIntsClass data;
            data.intOne = 1;
            data.intTwo = 2;
            TwoIntsClass * pointer = new TwoIntsClass;
            *pointer = data; 
            {
                TwoIntsClass data = *pointer;
                printIntLine(data.intOne);
                printIntLine(data.intTwo);
            }
            delete pointer;
        }
"
3755,0,CWE190_Integer_Overflow__char_rand_postinc_13.c,"    char data;
    data = ' ';
    if(GLOBAL_CONST_FIVE==5)
    {
        
        data = (char)RAND32();
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            
            data++;
            char result = data;
            printHexCharLine(result);
        }
"
8767,0,CWE369_Divide_by_Zero__float_rand_02.c,"    float data;
    
    data = 0.0F;
    if(1)
    {
        
        data = (float)RAND32();
    }
    if(1)
    {
        {
            
            int result = (int)(100.0 / data);
            printIntLine(result);
        }
"
7971,0,CWE758_Undefined_Behavior__int64_t_malloc_use_13.c,"    if(GLOBAL_CONST_FIVE==5)
    {
        {
            int64_t * pointer = (int64_t *)malloc(sizeof(int64_t));
            if (pointer == NULL) {exit(-1);}
            int64_t data = *pointer; 
            free(pointer);
            printLongLongLine(data);
        }
"
11095,0,CWE590_Free_Memory_Not_on_Heap__free_char_alloca_68a.c,"    char * data;
    data = NULL; 
    {
        
        char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
        memset(dataBuffer, 'A', 100-1); 
        dataBuffer[100-1] = '\0'; 
        data = dataBuffer;
    }
    CWE590_Free_Memory_Not_on_Heap__free_char_alloca_68_badData = data;
"
7700,0,CWE590_Free_Memory_Not_on_Heap__delete_long_placement_new_64a.cpp,"    long * data;
    data = NULL; 
    {
        
        char buffer[sizeof(long)];
        long * dataBuffer = new(buffer) long;
        *dataBuffer = 5L;
        data = dataBuffer;
    }
"
15458,1,CWE758_Undefined_Behavior__double_pointer_new_use_10.cpp,"    if(globalTrue)
    {
        {
            double * data;
            
            data = new double;
            *data = 5.0;
            double * * pointer = new double *;
            *pointer = data; 
            {
                double * data = *pointer;
                printDoubleLine(*data);
            }
            delete pointer;
        }
"
6493,0,CWE190_Integer_Overflow__char_max_multiply_84a.cpp,"    char data;
    data = ' ';
    CWE190_Integer_Overflow__char_max_multiply_84_bad * badObject = new CWE190_Integer_Overflow__char_max_multiply_84_bad(data);
"
7542,0,CWE415_Double_Free__new_delete_class_62a.cpp,"    TwoIntsClass * data;
    
    data = NULL;
    badSource(data);
    
"
9092,0,CWE401_Memory_Leak__new_int_34.cpp,"    int * data;
    unionType myUnion;
    data = NULL;
    
    data = new int;
    
    *data = 5;
    printIntLine(*data);
    myUnion.unionFirst = data;
    {
        int * data = myUnion.unionSecond;
        
        ; 
"
16977,0,CWE190_Integer_Overflow__unsigned_int_fscanf_add_84_bad.cpp,"Label Definition File: CWE190_Integer_Overflow.label.xml
Template File: sources-sinks-84_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 190 Integer Overflow
 * BadSource: fscanf Read data from the console using fscanf()
 * GoodSource: Set data to a small, non-zero number (two)
 * Sinks: add
 *    GoodSink: Ensure there will not be an overflow before adding 1 to data
 *    BadSink : Add 1 to data, which can cause an overflow
 * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE190_Integer_Overflow__unsigned_int_fscanf_add_84.h""

namespace CWE190_Integer_Overflow__unsigned_int_fscanf_add_84
{
CWE190_Integer_Overflow__unsigned_int_fscanf_add_84_bad::CWE190_Integer_Overflow__unsigned_int_fscanf_add_84_bad(unsigned int dataCopy)
{
    data = dataCopy;
    
    fscanf (stdin, ""%u"", &data);
}

CWE190_Integer_Overflow__unsigned_int_fscanf_add_84_bad::~CWE190_Integer_Overflow__unsigned_int_fscanf_add_84_bad()
{
    {
        
        unsigned int result = data + 1;
        printUnsignedLine(result);
    }
}
}
"
10200,0,CWE590_Free_Memory_Not_on_Heap__delete_int_static_82_bad.cpp,"Label Definition File: CWE590_Free_Memory_Not_on_Heap__delete.nonpointer.label.xml
Template File: sources-sink-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 590 Free Memory Not on Heap
 * BadSource: static Data buffer is declared static on the stack
 * GoodSource: Allocate memory on the heap
 * Sinks:
 *    BadSink : Print then free data
 * Flow Variant: 82 Data flow: data passed in a parameter to a virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE590_Free_Memory_Not_on_Heap__delete_int_static_82.h""

namespace CWE590_Free_Memory_Not_on_Heap__delete_int_static_82
{

void CWE590_Free_Memory_Not_on_Heap__delete_int_static_82_bad::action(int * data)
{
    printIntLine(*data);
    
    delete data;
}

}
"
5270,0,CWE190_Integer_Overflow__char_fscanf_postinc_13.c,"    char data;
    data = ' ';
    if(GLOBAL_CONST_FIVE==5)
    {
        
        fscanf (stdin, ""%c"", &data);
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            
            data++;
            char result = data;
            printHexCharLine(result);
        }
"
1556,1,CWE758_Undefined_Behavior__int64_t_malloc_use_14.c,"    if(globalFive!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            int64_t data;
            int64_t * pointer = (int64_t *)malloc(sizeof(int64_t));
            if (pointer == NULL) {exit(-1);}
            data = 5LL;
            *pointer = data; 
            {
                int64_t data = *pointer;
                printLongLongLine(data);
            }
            free(pointer);
        }
"
14082,0,CWE590_Free_Memory_Not_on_Heap__delete_class_alloca_16.cpp,"    TwoIntsClass * data;
    data = NULL; 
    while(1)
    {
        {
            
            TwoIntsClass * dataBuffer = (TwoIntsClass *)ALLOCA(sizeof(TwoIntsClass));
            dataBuffer->intOne = 2;
            dataBuffer->intTwo = 2;
            data = dataBuffer;
        }
        break;
    }
    printIntLine(data->intOne);
    
"
14034,0,CWE590_Free_Memory_Not_on_Heap__delete_long_static_06.cpp,"    long * data;
    data = NULL; 
    if(STATIC_CONST_FIVE==5)
    {
        {
            
            static long dataBuffer;
            dataBuffer = 5L;
            data = &dataBuffer;
        }
    }
    printLongLine(*data);
    
"
300,0,CWE134_Uncontrolled_Format_String__char_environment_vprintf_64a.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        
        if (environment != NULL)
        {
            
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
"
6087,0,CWE134_Uncontrolled_Format_String__char_console_vprintf_05.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(staticTrue)
    {
        {
            
            size_t dataLen = strlen(data);
            
            if (100-dataLen > 1)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
                {
                    /* The next few lines remove the carriage return from the string that is
                     * inserted by fgets() */
                    dataLen = strlen(data);
                    if (dataLen > 0 && data[dataLen-1] == '\n')
                    {
                        data[dataLen-1] = '\0';
                    }
                }
                else
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
            }
        }
    }
    if(staticTrue)
    {
        badVaSinkB(data, data);
"
169,0,CWE190_Integer_Overflow__int_rand_add_65a.c,"    int data;
    
    void (*funcPtr) (int) = CWE190_Integer_Overflow__int_rand_add_65b_badSink;
    
    data = 0;
    
    data = RAND32();
    
"
17491,0,CWE197_Numeric_Truncation_Error__int_rand_to_char_84_bad.cpp,"Label Definition File: CWE197_Numeric_Truncation_Error__int.label.xml
Template File: sources-sink-84_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 197 Numeric Truncation Error
 * BadSource: rand Set data to result of rand(), which may be zero
 * GoodSource: Less than CHAR_MAX
 * Sinks: to_char
 *    BadSink : Convert data to a char
 * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE197_Numeric_Truncation_Error__int_rand_to_char_84.h""

namespace CWE197_Numeric_Truncation_Error__int_rand_to_char_84
{
CWE197_Numeric_Truncation_Error__int_rand_to_char_84_bad::CWE197_Numeric_Truncation_Error__int_rand_to_char_84_bad(int dataCopy)
{
    data = dataCopy;
    
    data = RAND32();
}

CWE197_Numeric_Truncation_Error__int_rand_to_char_84_bad::~CWE197_Numeric_Truncation_Error__int_rand_to_char_84_bad()
{
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
    }
}
}
"
11552,0,CWE134_Uncontrolled_Format_String__char_file_fprintf_31.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        FILE * pFile;
        
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
    {
        char * dataCopy = data;
        char * data = dataCopy;
        
        fprintf(stdout, data);
"
485,0,CWE78_OS_Command_Injection__char_connect_socket_system_84a.cpp,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    CWE78_OS_Command_Injection__char_connect_socket_system_84_bad * badObject = new CWE78_OS_Command_Injection__char_connect_socket_system_84_bad(data);
"
19133,1,CWE252_Unchecked_Return_Value__char_fread_16.c,"    while(1)
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            
            if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) != 100-1)
            {
                printLine(""fread failed!"");
            }
        }
        break;
"
18566,0,CWE197_Numeric_Truncation_Error__int_fgets_to_short_44.c,"    int data;
    
    void (*funcPtr) (int) = badSink;
    
    data = -1;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    
"
13972,0,CWE415_Double_Free__malloc_free_int_43.cpp,"    int * data;
    
    data = NULL;
    badSource(data);
    
"
7852,0,CWE190_Integer_Overflow__char_fscanf_multiply_68a.c,"    char data;
    data = ' ';
    
    fscanf (stdin, ""%c"", &data);
    CWE190_Integer_Overflow__char_fscanf_multiply_68_badData = data;
"
18079,0,CWE190_Integer_Overflow__short_max_square_84a.cpp,"    short data;
    data = 0;
    CWE190_Integer_Overflow__short_max_square_84_bad * badObject = new CWE190_Integer_Overflow__short_max_square_84_bad(data);
"
4534,0,CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_41.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
3818,0,CWE665_Improper_Initialization__char_cat_04.c,"    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    if(STATIC_CONST_TRUE)
    {
        
        ; 
    }
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        
        strcat(data, source);
        printLine(data);
"
6879,0,CWE190_Integer_Overflow__int64_t_max_add_52a.c,"    int64_t data;
    data = 0LL;
    
    data = LLONG_MAX;
"
6446,0,CWE369_Divide_by_Zero__float_rand_52a.c,"    float data;
    
    data = 0.0F;
    
    data = (float)RAND32();
"
19294,1,CWE252_Unchecked_Return_Value__char_scanf_07.c,"    if(staticFive!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            
            if (scanf(""%99s\0"", data) == EOF)
            {
                printLine(""scanf failed!"");
            }
        }
"
5321,0,CWE190_Integer_Overflow__int_listen_socket_square_32.c,"    int data;
    int *dataPtr1 = &data;
    int *dataPtr2 = &data;
    
    data = 0;
    {
        int data = *dataPtr1;
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
        *dataPtr1 = data;
    }
    {
        int data = *dataPtr2;
        {
            
            int result = data * data;
            printIntLine(result);
        }
"
9904,0,CWE134_Uncontrolled_Format_String__char_console_vfprintf_02.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(1)
    {
        {
            
            size_t dataLen = strlen(data);
            
            if (100-dataLen > 1)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
                {
                    /* The next few lines remove the carriage return from the string that is
                     * inserted by fgets() */
                    dataLen = strlen(data);
                    if (dataLen > 0 && data[dataLen-1] == '\n')
                    {
                        data[dataLen-1] = '\0';
                    }
                }
                else
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
            }
        }
    }
    if(1)
    {
        badVaSinkB(data, data);
"
2575,0,CWE665_Improper_Initialization__char_cat_02.c,"    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    if(1)
    {
        
        ; 
    }
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        
        strcat(data, source);
        printLine(data);
"
522,0,CWE590_Free_Memory_Not_on_Heap__delete_long_alloca_17.cpp,"    int i;
    long * data;
    data = NULL; 
    for(i = 0; i < 1; i++)
    {
        {
            
            long * dataBuffer = (long *)ALLOCA(sizeof(long));
            *dataBuffer = 5L;
            data = dataBuffer;
        }
    }
    printLongLine(*data);
    
"
10553,0,CWE457_Use_of_Uninitialized_Variable__int64_t_13.c,"    int64_t data;
    if(GLOBAL_CONST_FIVE==5)
    {
        
        ; 
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        
        printLongLongLine(data);
"
12383,0,CWE190_Integer_Overflow__short_max_postinc_54a.c,"    short data;
    data = 0;
    
    data = SHRT_MAX;
"
2372,0,CWE190_Integer_Overflow__int64_t_rand_multiply_04.c,"    int64_t data;
    data = 0LL;
    if(STATIC_CONST_TRUE)
    {
        
        data = (int64_t)RAND64();
    }
    if(STATIC_CONST_TRUE)
    {
        if(data > 0) 
        {
            
            int64_t result = data * 2;
            printLongLongLine(result);
        }
"
9535,0,CWE415_Double_Free__new_delete_struct_66a.cpp,"    twoIntsStruct * data;
    twoIntsStruct * dataArray[5];
    
    data = NULL;
    data = new twoIntsStruct;
    
    delete data;
    
    dataArray[2] = data;
"
12292,0,CWE416_Use_After_Free__new_delete_struct_07.cpp,"    twoIntsStruct * data;
    
    data = NULL;
    if(staticFive==5)
    {
        data = new twoIntsStruct;
        data->intOne = 1;
        data->intTwo = 2;
        
        delete data;
    }
    if(staticFive==5)
    {
        
        printStructLine(data);
        
"
5226,0,CWE197_Numeric_Truncation_Error__short_fscanf_09.c,"    short data;
    
    data = -1;
    if(GLOBAL_CONST_TRUE)
    {
        
        fscanf (stdin, ""%hd"", &data);
    }
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
4250,0,CWE190_Integer_Overflow__int_listen_socket_square_81a.cpp,"    int data;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    const CWE190_Integer_Overflow__int_listen_socket_square_81_base& baseObject = CWE190_Integer_Overflow__int_listen_socket_square_81_bad();
"
4980,0,CWE590_Free_Memory_Not_on_Heap__free_int64_t_declare_12.c,"    int64_t * data;
    data = NULL; 
    if(globalReturnsTrueOrFalse())
    {
        {
            
            int64_t dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5LL;
                }
            }
            data = dataBuffer;
        }
    }
    else
    {
        {
            
            int64_t * dataBuffer = (int64_t *)malloc(100*sizeof(int64_t));
            if (dataBuffer == NULL)
            {
                printLine(""malloc() failed"");
                exit(1);
            }
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5LL;
                }
            }
            data = dataBuffer;
        }
    }
    printLongLongLine(data[0]);
    
"
18477,0,CWE590_Free_Memory_Not_on_Heap__delete_array_int64_t_alloca_73a.cpp,"    int64_t * data;
    list<int64_t *> dataList;
    data = NULL; 
    {
        
        int64_t * dataBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5LL;
            }
        }
        data = dataBuffer;
    }
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
2249,1,CWE401_Memory_Leak__malloc_realloc_char_02.c,"    if(1)
    {
        {
            char * data = (char *)malloc(100*sizeof(char));
            if (data == NULL) {exit(-1);}
            char * tmpData;
            
            strcpy(data, ""A String"");
            printLine(data);
            tmpData = (char *)realloc(data, (130000)*sizeof(char));
            /* FIX: Ensure realloc() was successful before assigning data to the memory block
            * allocated with realloc() */
            if (tmpData != NULL)
            {
                data = tmpData;
                
                strcpy(data, ""New String"");
                printLine(data);
            }
            free(data);
        }
"
10646,0,CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_68a.c,"    unsigned int data;
    data = 0;
    
    fscanf (stdin, ""%u"", &data);
    CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_68_badData = data;
"
11685,0,CWE134_Uncontrolled_Format_String__char_console_vfprintf_62a.cpp,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    badSource(data);
"
16188,0,CWE190_Integer_Overflow__short_fscanf_multiply_67a.c,"    short data;
    CWE190_Integer_Overflow__short_fscanf_multiply_67_structType myStruct;
    data = 0;
    
    fscanf (stdin, ""%hd"", &data);
    myStruct.structFirst = data;
"
1235,0,CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_65a.c,"    char * data;
    
    void (*funcPtr) (char *) = CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_65b_badSink;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
"
17794,1,CWE758_Undefined_Behavior__char_pointer_alloca_use_11.c,"    if(globalReturnsFalse())
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            char * data;
            char * * pointer = (char * *)ALLOCA(sizeof(char *));
            data = ""string"";
            *pointer = data; 
            {
                char * data = *pointer;
                printLine(data);
            }
        }
"
11470,0,CWE789_Uncontrolled_Mem_Alloc__new_char_rand_06.cpp,"    size_t data;
    
    data = 0;
    if(STATIC_CONST_FIVE==5)
    {
        
        data = rand();
    }
    if(STATIC_CONST_FIVE==5)
    {
        {
            char * myString;
            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
             * for the strcpy() function to not cause a buffer overflow */
            
            if (data > strlen(HELLO_STRING))
            {
                myString = new char[data];
                
                strcpy(myString, HELLO_STRING);
                printLine(myString);
                delete [] myString;
            }
            else
            {
                printLine(""Input is less than the length of the source string"");
            }
        }
"
4911,0,CWE758_Undefined_Behavior__long_new_use_15.cpp,"    switch(6)
    {
    case 6:
    {
        long * pointer = new long;
        long data = *pointer; 
        delete pointer;
        printLongLine(data);
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
5982,0,CWE190_Integer_Overflow__unsigned_int_rand_square_14.c,"    unsigned int data;
    data = 0;
    if(globalFive==5)
    {
        
        data = (unsigned int)RAND32();
    }
    if(globalFive==5)
    {
        {
            
            unsigned int result = data * data;
            printUnsignedLine(result);
        }
"
5686,0,CWE401_Memory_Leak__int64_t_calloc_03.c,"    int64_t * data;
    data = NULL;
    if(5==5)
    {
        
        data = (int64_t *)calloc(100, sizeof(int64_t));
        if (data == NULL) {exit(-1);}
        
        data[0] = 5LL;
        printLongLongLine(data[0]);
    }
    if(5==5)
    {
        
        ; 
"
10003,0,CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_09.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(GLOBAL_CONST_TRUE)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                data[dataLen + recvResult / sizeof(char)] = '\0';
                
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(GLOBAL_CONST_TRUE)
    {
        
        fprintf(stdout, data);
"
13798,0,CWE190_Integer_Overflow__int_fscanf_square_53a.c,"    int data;
    
    data = 0;
    
    fscanf(stdin, ""%d"", &data);
"
3099,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_82_bad.cpp,"Label Definition File: CWE789_Uncontrolled_Mem_Alloc__malloc.label.xml
Template File: sources-sinks-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: connect_socket Read data using a connect socket (client side)
 * GoodSource: Small number greater than zero
 * Sinks:
 *    GoodSink: Allocate memory with malloc() and check the size of the memory to be allocated
 *    BadSink : Allocate memory with malloc(), but incorrectly check the size of the memory to be allocated
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_82.h""

#define HELLO_STRING ""hello""

namespace CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_82
{

void CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_82_bad::action(size_t data)
{
    {
        char * myString;
        /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
         * for the strcpy() function to not cause a buffer overflow */
        
        if (data > strlen(HELLO_STRING))
        {
            myString = (char *)malloc(data*sizeof(char));
            if (myString == NULL) {exit(-1);}
            
            strcpy(myString, HELLO_STRING);
            printLine(myString);
            free(myString);
        }
        else
        {
            printLine(""Input is less than the length of the source string"");
        }
    }
}

}
"
16741,0,CWE197_Numeric_Truncation_Error__short_listen_socket_13.c,"    short data;
    
    data = -1;
    if(GLOBAL_CONST_FIVE==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = (short)atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
139,0,CWE457_Use_of_Uninitialized_Variable__struct_pointer_15.c,"    twoIntsStruct * data;
    switch(6)
    {
    case 6:
        
        ; 
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
        
        printIntLine(data->intOne);
        printIntLine(data->intTwo);
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
15987,0,CWE78_OS_Command_Injection__char_listen_socket_execlp_03.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(5==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                data[dataLen + recvResult / sizeof(char)] = '\0';
                
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    /* execlp - searches for the location of the command among
     * the directories specified by the PATH environment variable */
    
"
2752,0,CWE78_OS_Command_Injection__char_file_execlp_81_bad.cpp,"Label Definition File: CWE78_OS_Command_Injection.strings.label.xml
Template File: sources-sink-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 78 OS Command Injection
 * BadSource: file Read input from a file
 * GoodSource: Fixed string
 * Sinks: execlp
 *    BadSink : execute command with execlp
 * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE78_OS_Command_Injection__char_file_execlp_81.h""

#ifdef _WIN32
#include <process.h>
#define EXECLP _execlp
#else 
#define EXECLP execlp
#endif

namespace CWE78_OS_Command_Injection__char_file_execlp_81
{

void CWE78_OS_Command_Injection__char_file_execlp_81_bad::action(char * data) const
{
    /* execlp - searches for the location of the command among
     * the directories specified by the PATH environment variable */
    
    EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}

}
"
16778,0,CWE590_Free_Memory_Not_on_Heap__delete_array_long_static_08.cpp,"    long * data;
    data = NULL; 
    if(staticReturnsTrue())
    {
        {
            
            static long dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5L;
                }
            }
            data = dataBuffer;
        }
    }
    printLongLine(data[0]);
    
"
14311,0,CWE78_OS_Command_Injection__char_environment_popen_05.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(staticTrue)
    {
        {
            
            size_t dataLen = strlen(data);
            char * environment = GETENV(ENV_VARIABLE);
            
            if (environment != NULL)
            {
                
                strncat(data+dataLen, environment, 100-dataLen-1);
            }
        }
    }
    {
        FILE *pipe;
        
        pipe = POPEN(data, ""w"");
        if (pipe != NULL)
        {
            PCLOSE(pipe);
        }
"
12869,0,CWE401_Memory_Leak__malloc_realloc_char_15.c,"    switch(6)
    {
    case 6:
    {
        char * data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        
        strcpy(data, ""A String"");
        printLine(data);
        
        data = (char *)realloc(data, (130000)*sizeof(char));
        if (data != NULL)
        {
            
            strcpy(data, ""New String"");
            printLine(data);
            free(data);
        }
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
11051,0,CWE197_Numeric_Truncation_Error__int_large_to_char_84a.cpp,"    int data;
    
    data = -1;
    CWE197_Numeric_Truncation_Error__int_large_to_char_84_bad * badObject = new CWE197_Numeric_Truncation_Error__int_large_to_char_84_bad(data);
"
16925,0,CWE190_Integer_Overflow__short_rand_preinc_15.c,"    short data;
    data = 0;
    switch(6)
    {
    case 6:
        
        data = (short)RAND32();
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
    {
        
        ++data;
        short result = data;
        printIntLine(result);
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
9517,0,CWE563_Unused_Variable__unused_uninit_variable_struct_09.c,"    twoIntsStruct data;
    
    ; 
    if(GLOBAL_CONST_TRUE)
    {
        
        
        ; 
"
4772,0,CWE190_Integer_Overflow__int_rand_add_05.c,"    int data;
    
    data = 0;
    if(staticTrue)
    {
        
        data = RAND32();
    }
    if(staticTrue)
    {
        {
            
            int result = data + 1;
            printIntLine(result);
        }
"
13317,0,CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_03.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(5==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                data[dataLen + recvResult / sizeof(char)] = '\0';
                
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(5==5)
    {
        
        fprintf(stdout, data);
"
7116,0,CWE78_OS_Command_Injection__char_console_execlp_68a.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        
        if (100-dataLen > 1)
        {
            
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgets() */
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
                    data[dataLen-1] = '\0';
                }
            }
            else
            {
                printLine(""fgets() failed"");
                
                data[dataLen] = '\0';
            }
        }
    }
    CWE78_OS_Command_Injection__char_console_execlp_68_badData = data;
"
10875,0,CWE665_Improper_Initialization__char_cat_44.c,"    char * data;
    
    void (*funcPtr) (char *) = badSink;
    char dataBuffer[100];
    data = dataBuffer;
    
    ; 
    
"
8875,0,CWE690_NULL_Deref_From_Return__int64_t_malloc_15.c,"    int64_t * data;
    data = NULL; 
    
    data = (int64_t *)malloc(1*sizeof(int64_t));
    switch(6)
    {
    case 6:
        
        data[0] = 5LL;
        printLongLongLine(data[0]);
        free(data);
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
5257,0,CWE190_Integer_Overflow__int_max_square_81a.cpp,"    int data;
    
    data = 0;
    
    data = INT_MAX;
    const CWE190_Integer_Overflow__int_max_square_81_base& baseObject = CWE190_Integer_Overflow__int_max_square_81_bad();
"
6852,0,CWE134_Uncontrolled_Format_String__char_environment_vfprintf_42.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    data = badSource(data);
"
9273,1,CWE758_Undefined_Behavior__class_new_use_08.cpp,"    if(staticReturnsFalse())
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            TwoIntsClass data;
            data.intOne = 1;
            data.intTwo = 2;
            TwoIntsClass * pointer = new TwoIntsClass;
            *pointer = data; 
            {
                TwoIntsClass data = *pointer;
                printIntLine(data.intOne);
                printIntLine(data.intTwo);
            }
            delete pointer;
        }
"
17748,0,CWE563_Unused_Variable__unused_value_struct_05.c,"    twoIntsStruct data;
    if(staticTrue)
    {
        
        data.intOne = 0;
        data.intTwo = 0;
    }
    if(staticTrue)
    {
        
        data.intOne = 1;
        data.intTwo = 1;
        printStructLine(&data);
"
3940,0,CWE476_NULL_Pointer_Dereference__char_65a.c,"    char * data;
    
    void (*funcPtr) (char *) = CWE476_NULL_Pointer_Dereference__char_65b_badSink;
    
    data = NULL;
    
"
19030,0,CWE190_Integer_Overflow__unsigned_int_max_postinc_65a.c,"    unsigned int data;
    
    void (*funcPtr) (unsigned int) = CWE190_Integer_Overflow__unsigned_int_max_postinc_65b_badSink;
    data = 0;
    
    data = UINT_MAX;
    
"
9018,0,CWE590_Free_Memory_Not_on_Heap__delete_array_long_static_81_bad.cpp,"Label Definition File: CWE590_Free_Memory_Not_on_Heap__delete_array.label.xml
Template File: sources-sink-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 590 Free Memory Not on Heap
 * BadSource: static Data buffer is declared static on the stack
 * GoodSource: Allocate memory on the heap
 * Sinks:
 *    BadSink : Print then free data
 * Flow Variant: 81 Data flow: data passed in a parameter to a virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE590_Free_Memory_Not_on_Heap__delete_array_long_static_81.h""

namespace CWE590_Free_Memory_Not_on_Heap__delete_array_long_static_81
{

void CWE590_Free_Memory_Not_on_Heap__delete_array_long_static_81_bad::action(long * data) const
{
    printLongLine(data[0]);
    
    delete [] data;
}

}
"
17802,0,CWE401_Memory_Leak__new_TwoIntsClass_07.cpp,"    TwoIntsClass * data;
    data = NULL;
    if(staticFive==5)
    {
        
        data = new TwoIntsClass;
        
        data->intOne = 0;
        data->intTwo = 0;
        printIntLine(data->intOne);
        printIntLine(data->intTwo);
    }
    if(staticFive==5)
    {
        
        ; 
"
12271,0,CWE690_NULL_Deref_From_Return__long_calloc_62a.cpp,"    long * data;
    data = NULL; 
    badSource(data);
    
    data[0] = 5L;
    printLongLine(data[0]);
"
13396,0,CWE401_Memory_Leak__new_array_struct_twoIntsStruct_13.cpp,"    struct _twoIntsStruct * data;
    data = NULL;
    if(GLOBAL_CONST_FIVE==5)
    {
        
        data = new struct _twoIntsStruct[100];
        
        data[0].intOne = 0;
        data[0].intTwo = 0;
        printStructLine((twoIntsStruct *)&data[0]);
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        
        ; 
"
10696,0,CWE415_Double_Free__malloc_free_int64_t_05.c,"    int64_t * data;
    
    data = NULL;
    if(staticTrue)
    {
        data = (int64_t *)malloc(100*sizeof(int64_t));
        if (data == NULL) {exit(-1);}
        
        free(data);
    }
    if(staticTrue)
    {
        
        free(data);
"
19472,0,CWE590_Free_Memory_Not_on_Heap__delete_array_long_alloca_11.cpp,"    long * data;
    data = NULL; 
    if(globalReturnsTrue())
    {
        {
            
            long * dataBuffer = (long *)ALLOCA(100*sizeof(long));
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5L;
                }
            }
            data = dataBuffer;
        }
    }
    printLongLine(data[0]);
    
"
3891,1,CWE252_Unchecked_Return_Value__char_fwrite_08.c,"    if(staticReturnsFalse())
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        
        if (fwrite((char *)""string"", sizeof(char), strlen(""string""), stdout) != strlen(""string""))
        {
            printLine(""fwrite failed!"");
        }
"
18288,0,CWE401_Memory_Leak__int_malloc_81a.cpp,"    int * data;
    data = NULL;
    
    data = (int *)malloc(100*sizeof(int));
    if (data == NULL) {exit(-1);}
    
    data[0] = 5;
    printIntLine(data[0]);
    const CWE401_Memory_Leak__int_malloc_81_base& baseObject = CWE401_Memory_Leak__int_malloc_81_bad();
"
3841,0,CWE197_Numeric_Truncation_Error__int_listen_socket_to_char_45.c,"    int data;
    
    data = -1;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    CWE197_Numeric_Truncation_Error__int_listen_socket_to_char_45_badData = data;
"
10141,0,CWE476_NULL_Pointer_Dereference__long_16.c,"    long * data;
    while(1)
    {
        
        data = NULL;
        break;
    }
    while(1)
    {
        
        printLongLine(*data);
        break;
"
15952,0,CWE190_Integer_Overflow__int64_t_fscanf_multiply_01.c,"    int64_t data;
    data = 0LL;
    
    fscanf (stdin, ""%"" SCNd64, &data);
    if(data > 0) 
    {
        
        int64_t result = data * 2;
        printLongLongLine(result);
"
17021,0,CWE590_Free_Memory_Not_on_Heap__delete_char_placement_new_68a.cpp,"    char * data;
    data = NULL; 
    {
        
        char buffer[sizeof(char)];
        char * dataBuffer = new(buffer) char;
        *dataBuffer = 'A';
        data = dataBuffer;
    }
    CWE590_Free_Memory_Not_on_Heap__delete_char_placement_new_68_badData = data;
"
12726,0,CWE401_Memory_Leak__new_array_struct_twoIntsStruct_04.cpp,"    struct _twoIntsStruct * data;
    data = NULL;
    if(STATIC_CONST_TRUE)
    {
        
        data = new struct _twoIntsStruct[100];
        
        data[0].intOne = 0;
        data[0].intTwo = 0;
        printStructLine((twoIntsStruct *)&data[0]);
    }
    if(STATIC_CONST_TRUE)
    {
        
        ; 
"
5989,0,CWE415_Double_Free__new_delete_array_class_15.cpp,"    TwoIntsClass * data;
    
    data = NULL;
    switch(6)
    {
    case 6:
        data = new TwoIntsClass[100];
        
        delete [] data;
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
        
        delete [] data;
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
16640,0,CWE590_Free_Memory_Not_on_Heap__delete_array_int_declare_67a.cpp,"    int * data;
    structType myStruct;
    data = NULL; 
    {
        
        int dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5;
            }
        }
        data = dataBuffer;
    }
    myStruct.structFirst = data;
"
6817,0,CWE190_Integer_Overflow__char_rand_multiply_16.c,"    char data;
    data = ' ';
    while(1)
    {
        
        data = (char)RAND32();
        break;
    }
    while(1)
    {
        if(data > 0) 
        {
            
            char result = data * 2;
            printHexCharLine(result);
        }
        break;
"
3302,0,CWE758_Undefined_Behavior__char_new_use_08.cpp,"    if(staticReturnsTrue())
    {
        {
            char * pointer = new char;
            char data = *pointer; 
            delete pointer;
            printHexCharLine(data);
        }
"
9584,0,CWE457_Use_of_Uninitialized_Variable__int_array_alloca_partial_init_09.c,"    int * data;
    data = (int *)ALLOCA(10*sizeof(int));
    if(GLOBAL_CONST_TRUE)
    {
        
        {
            int i;
            for(i=0; i<(10/2); i++)
            {
                data[i] = i;
            }
        }
    }
    if(GLOBAL_CONST_TRUE)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i]);
            }
        }
"
4135,0,CWE190_Integer_Overflow__unsigned_int_rand_postinc_54a.c,"    unsigned int data;
    data = 0;
    
    data = (unsigned int)RAND32();
"
17005,0,CWE590_Free_Memory_Not_on_Heap__delete_array_int_alloca_67a.cpp,"    int * data;
    structType myStruct;
    data = NULL; 
    {
        
        int * dataBuffer = (int *)ALLOCA(100*sizeof(int));
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5;
            }
        }
        data = dataBuffer;
    }
    myStruct.structFirst = data;
"
11863,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_07.c,"    size_t data;
    
    data = 0;
    if(staticFive==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = strtoul(inputBuffer, NULL, 0);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(staticFive==5)
    {
        {
            char * myString;
            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
             * for the strcpy() function to not cause a buffer overflow */
            
            if (data > strlen(HELLO_STRING))
            {
                myString = (char *)malloc(data*sizeof(char));
                if (myString == NULL) {exit(-1);}
                
                strcpy(myString, HELLO_STRING);
                printLine(myString);
                free(myString);
            }
            else
            {
                printLine(""Input is less than the length of the source string"");
            }
        }
"
13044,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_62a.cpp,"    size_t data;
    
    data = 0;
    badSource(data);
    {
        char * myString;
        /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
         * for the strcpy() function to not cause a buffer overflow */
        
        if (data > strlen(HELLO_STRING))
        {
            myString = (char *)malloc(data*sizeof(char));
            if (myString == NULL) {exit(-1);}
            
            strcpy(myString, HELLO_STRING);
            printLine(myString);
            free(myString);
        }
        else
        {
            printLine(""Input is less than the length of the source string"");
        }
"
9599,0,CWE590_Free_Memory_Not_on_Heap__delete_int_alloca_12.cpp,"    int * data;
    data = NULL; 
    if(globalReturnsTrueOrFalse())
    {
        {
            
            int * dataBuffer = (int *)ALLOCA(sizeof(int));
            *dataBuffer = 5;
            data = dataBuffer;
        }
    }
    else
    {
        {
            
            int * dataBuffer = new int;
            *dataBuffer = 5;
            data = dataBuffer;
        }
    }
    printIntLine(*data);
    
"
19168,0,CWE590_Free_Memory_Not_on_Heap__delete_array_int64_t_alloca_52a.cpp,"    int64_t * data;
    data = NULL; 
    {
        
        int64_t * dataBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5LL;
            }
        }
        data = dataBuffer;
    }
"
16546,0,CWE190_Integer_Overflow__short_rand_square_02.c,"    short data;
    data = 0;
    if(1)
    {
        
        data = (short)RAND32();
    }
    if(1)
    {
        {
            
            short result = data * data;
            printIntLine(result);
        }
"
16756,1,CWE676_Use_of_Potentially_Dangerous_Function__basic_11.cpp,"    if(globalReturnsTrue())
    {
        {
            char charBuffer[CHAR_BUFFER_SIZE];
            
            cin.width(CHAR_BUFFER_SIZE);
            cin >> charBuffer;
            charBuffer[CHAR_BUFFER_SIZE-1] = '\0';
            printLine(charBuffer);
        }
"
13201,0,CWE476_NULL_Pointer_Dereference__struct_41.c,"    twoIntsStruct * data;
    
    data = NULL;
"
14114,0,CWE369_Divide_by_Zero__int_listen_socket_divide_12.c,"    int data;
    
    data = -1;
    if(globalReturnsTrueOrFalse())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    else
    {
        
        data = 7;
    }
    if(globalReturnsTrueOrFalse())
    {
        
        printIntLine(100 / data);
    }
    else
    {
        
        if( data != 0 )
        {
            printIntLine(100 / data);
        }
        else
        {
            printLine(""This would result in a divide by zero"");
        }
"
15117,0,CWE457_Use_of_Uninitialized_Variable__double_array_declare_partial_init_63a.c,"    double * data;
    double dataUninitArray[10];
    data = dataUninitArray;
    
    {
        int i;
        for(i=0; i<(10/2); i++)
        {
            data[i] = (double)i;
        }
    }
"
13684,1,CWE476_NULL_Pointer_Dereference__null_check_after_deref_12.c,"    if(globalReturnsTrueOrFalse())
    {
        {
            int *intPointer = NULL;
            intPointer = (int *)malloc(sizeof(int));
            *intPointer = 5;
            printIntLine(*intPointer);
            
            *intPointer = 10;
            printIntLine(*intPointer);
        }
    }
    else
    {
        {
            int *intPointer = NULL;
            intPointer = (int *)malloc(sizeof(int));
            *intPointer = 5;
            printIntLine(*intPointer);
            
            *intPointer = 10;
            printIntLine(*intPointer);
        }
"
16669,1,CWE758_Undefined_Behavior__struct_pointer_new_use_01.cpp,"    {
        twoIntsStruct * data;
        
        data = new twoIntsStruct;
        data->intOne = 5;
        data->intTwo = 6;
        twoIntsStruct * * pointer = new twoIntsStruct *;
        *pointer = data; 
        {
            twoIntsStruct * data = *pointer;
            printIntLine(data->intOne);
            printIntLine(data->intTwo);
        }
        delete pointer;
"
18626,0,CWE401_Memory_Leak__new_array_struct_twoIntsStruct_06.cpp,"    struct _twoIntsStruct * data;
    data = NULL;
    if(STATIC_CONST_FIVE==5)
    {
        
        data = new struct _twoIntsStruct[100];
        
        data[0].intOne = 0;
        data[0].intTwo = 0;
        printStructLine((twoIntsStruct *)&data[0]);
    }
    if(STATIC_CONST_FIVE==5)
    {
        
        ; 
"
18272,0,CWE78_OS_Command_Injection__char_environment_execlp_81a.cpp,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        
        if (environment != NULL)
        {
            
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    const CWE78_OS_Command_Injection__char_environment_execlp_81_base& baseObject = CWE78_OS_Command_Injection__char_environment_execlp_81_bad();
"
13033,0,CWE252_Unchecked_Return_Value__char_putchar_02.c,"    if(1)
    {
        
        putchar((int)'A');
"
656,0,CWE78_OS_Command_Injection__char_file_execl_03.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(5==5)
    {
        {
            
            size_t dataLen = strlen(data);
            FILE * pFile;
            
            if (100-dataLen > 1)
            {
                pFile = fopen(FILENAME, ""r"");
                if (pFile != NULL)
                {
                    
                    if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                    {
                        printLine(""fgets() failed"");
                        
                        data[dataLen] = '\0';
                    }
                    fclose(pFile);
                }
            }
        }
    }
    
    
"
1400,0,CWE590_Free_Memory_Not_on_Heap__delete_class_alloca_09.cpp,"    TwoIntsClass * data;
    data = NULL; 
    if(GLOBAL_CONST_TRUE)
    {
        {
            
            TwoIntsClass * dataBuffer = (TwoIntsClass *)ALLOCA(sizeof(TwoIntsClass));
            dataBuffer->intOne = 2;
            dataBuffer->intTwo = 2;
            data = dataBuffer;
        }
    }
    printIntLine(data->intOne);
    
"
638,0,CWE369_Divide_by_Zero__int_zero_modulo_16.c,"    int data;
    
    data = -1;
    while(1)
    {
        
        data = 0;
        break;
    }
    while(1)
    {
        
        printIntLine(100 % data);
        break;
"
8520,0,CWE416_Use_After_Free__new_delete_array_struct_11.cpp,"    twoIntsStruct * data;
    
    data = NULL;
    if(globalReturnsTrue())
    {
        data = new twoIntsStruct[100];
        {
            size_t i;
            for(i = 0; i < 100; i++)
            {
                data[i].intOne = 1;
                data[i].intTwo = 2;
            }
        }
        
        delete [] data;
    }
    if(globalReturnsTrue())
    {
        
        printStructLine(&data[0]);
        
"
12307,0,CWE590_Free_Memory_Not_on_Heap__free_char_static_33.cpp,"    char * data;
    char * &dataRef = data;
    data = NULL; 
    {
        
        static char dataBuffer[100];
        memset(dataBuffer, 'A', 100-1); 
        dataBuffer[100-1] = '\0'; 
        data = dataBuffer;
    }
    {
        char * data = dataRef;
        printLine(data);
        
        free(data);
"
7795,0,CWE190_Integer_Overflow__unsigned_int_max_multiply_05.c,"    unsigned int data;
    data = 0;
    if(staticTrue)
    {
        
        data = UINT_MAX;
    }
    if(staticTrue)
    {
        if(data > 0) 
        {
            
            unsigned int result = data * 2;
            printUnsignedLine(result);
        }
"
18483,0,CWE690_NULL_Deref_From_Return__long_calloc_83_bad.cpp,"Label Definition File: CWE690_NULL_Deref_From_Return.free.label.xml
Template File: source-sinks-83_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 690 Unchecked Return Value To NULL Pointer
 * BadSource: calloc Allocate data using calloc()
 * Sinks:
 *    GoodSink: Check to see if the data allocation failed and if not, use data
 *    BadSink : Don't check for NULL and use data
 * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE690_NULL_Deref_From_Return__long_calloc_83.h""

namespace CWE690_NULL_Deref_From_Return__long_calloc_83
{
CWE690_NULL_Deref_From_Return__long_calloc_83_bad::CWE690_NULL_Deref_From_Return__long_calloc_83_bad(long * dataCopy)
{
    data = dataCopy;
    
    data = (long *)calloc(1, sizeof(long));
}

CWE690_NULL_Deref_From_Return__long_calloc_83_bad::~CWE690_NULL_Deref_From_Return__long_calloc_83_bad()
{
    
    data[0] = 5L;
    printLongLine(data[0]);
    free(data);
}
}
"
9807,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_61a.c,"    size_t data;
    
    data = 0;
    data = CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_61b_badSource(data);
    {
        char * myString;
        /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
         * for the strcpy() function to not cause a buffer overflow */
        
        if (data > strlen(HELLO_STRING))
        {
            myString = (char *)malloc(data*sizeof(char));
            if (myString == NULL) {exit(-1);}
            
            strcpy(myString, HELLO_STRING);
            printLine(myString);
            free(myString);
        }
        else
        {
            printLine(""Input is less than the length of the source string"");
        }
"
5785,0,CWE190_Integer_Overflow__char_fscanf_add_83a.cpp,"    char data;
    data = ' ';
"
8498,0,CWE590_Free_Memory_Not_on_Heap__delete_array_class_alloca_01.cpp,"    TwoIntsClass * data;
    data = NULL; 
    {
        
        TwoIntsClass * dataBuffer = (TwoIntsClass *)ALLOCA(100*sizeof(TwoIntsClass));
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i].intOne = 1;
                dataBuffer[i].intTwo = 1;
            }
        }
        data = dataBuffer;
    }
    printIntLine(data[0].intOne);
    
"
12531,0,CWE758_Undefined_Behavior__int_new_use_17.cpp,"    int j;
    for(j = 0; j < 1; j++)
    {
        {
            int * pointer = new int;
            int data = *pointer; 
            delete pointer;
            printIntLine(data);
        }
"
9021,0,CWE690_NULL_Deref_From_Return__struct_realloc_74a.cpp,"    twoIntsStruct * data;
    map<int, twoIntsStruct *> dataMap;
    data = NULL; 
    
    data = (twoIntsStruct *)realloc(data, 1*sizeof(twoIntsStruct));
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
11794,0,CWE78_OS_Command_Injection__char_environment_execlp_11.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(globalReturnsTrue())
    {
        {
            
            size_t dataLen = strlen(data);
            char * environment = GETENV(ENV_VARIABLE);
            
            if (environment != NULL)
            {
                
                strncat(data+dataLen, environment, 100-dataLen-1);
            }
        }
    }
    /* execlp - searches for the location of the command among
     * the directories specified by the PATH environment variable */
    
"
5267,0,CWE690_NULL_Deref_From_Return__long_realloc_64a.c,"    long * data;
    data = NULL; 
    
    data = (long *)realloc(data, 1*sizeof(long));
"
9572,0,CWE197_Numeric_Truncation_Error__int_fgets_to_short_01.c,"    int data;
    
    data = -1;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    {
        
        short shortData = (short)data;
        printShortLine(shortData);
"
12140,0,CWE590_Free_Memory_Not_on_Heap__delete_int64_t_static_65a.cpp,"    int64_t * data;
    
    void (*funcPtr) (int64_t *) = badSink;
    data = NULL; 
    {
        
        static int64_t dataBuffer;
        dataBuffer = 5LL;
        data = &dataBuffer;
    }
    
"
18951,0,CWE590_Free_Memory_Not_on_Heap__delete_int64_t_placement_new_33.cpp,"    int64_t * data;
    int64_t * &dataRef = data;
    data = NULL; 
    {
        
        char buffer[sizeof(int64_t)];
        int64_t * dataBuffer = new(buffer) int64_t;
        *dataBuffer = 5LL;
        data = dataBuffer;
    }
    {
        int64_t * data = dataRef;
        printLongLongLine(*data);
        
        delete data;
"
3322,0,CWE252_Unchecked_Return_Value__char_fread_13.c,"    if(GLOBAL_CONST_FIVE==5)
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            
            fread((char *)data, sizeof(char), (size_t)(100-1), stdin);
        }
"
9480,0,CWE190_Integer_Overflow__int64_t_fscanf_preinc_68a.c,"    int64_t data;
    data = 0LL;
    
    fscanf (stdin, ""%"" SCNd64, &data);
    CWE190_Integer_Overflow__int64_t_fscanf_preinc_68_badData = data;
"
7372,0,CWE590_Free_Memory_Not_on_Heap__delete_long_declare_02.cpp,"    long * data;
    data = NULL; 
    if(1)
    {
        {
            
            long dataBuffer;
            dataBuffer = 5L;
            data = &dataBuffer;
        }
    }
    printLongLine(*data);
    
"
3704,1,CWE758_Undefined_Behavior__int_malloc_use_15.c,"    switch(5)
    {
    case 6:
        
        printLine(""Benign, fixed string"");
        break;
    default:
    {
        int data;
        int * pointer = (int *)malloc(sizeof(int));
        if (pointer == NULL) {exit(-1);}
        data = 5;
        *pointer = data; 
        {
            int data = *pointer;
            printIntLine(data);
        }
        free(pointer);
    }
    break;
"
4526,0,CWE416_Use_After_Free__new_delete_long_63a.cpp,"    long * data;
    
    data = NULL;
    data = new long;
    *data = 5L;
    
    delete data;
"
17535,0,CWE190_Integer_Overflow__char_fscanf_postinc_51a.c,"    char data;
    data = ' ';
    
    fscanf (stdin, ""%c"", &data);
"
17065,1,CWE587_Assignment_of_Fixed_Address_to_Pointer__basic_16.c,"    while(1)
    {
        {
            
            char charStack = 'a';
            char *charPointer = &charStack;
            printHexCharLine(*charPointer);
        }
        break;
"
10371,0,CWE401_Memory_Leak__new_TwoIntsClass_82a.cpp,"    TwoIntsClass * data;
    data = NULL;
    
    data = new TwoIntsClass;
    
    data->intOne = 0;
    data->intTwo = 0;
    printIntLine(data->intOne);
    printIntLine(data->intTwo);
    CWE401_Memory_Leak__new_TwoIntsClass_82_base* baseObject = new CWE401_Memory_Leak__new_TwoIntsClass_82_bad;
    baseObject->action(data);
"
17685,0,CWE197_Numeric_Truncation_Error__int_connect_socket_to_short_34.c,"    int data;
    CWE197_Numeric_Truncation_Error__int_connect_socket_to_short_34_unionType myUnion;
    
    data = -1;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    myUnion.unionFirst = data;
    {
        int data = myUnion.unionSecond;
        {
            
            short shortData = (short)data;
            printShortLine(shortData);
        }
"
8166,0,CWE134_Uncontrolled_Format_String__char_listen_socket_printf_31.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    {
        char * dataCopy = data;
        char * data = dataCopy;
        
        printf(data);
"
15931,0,CWE590_Free_Memory_Not_on_Heap__delete_class_declare_16.cpp,"    TwoIntsClass * data;
    data = NULL; 
    while(1)
    {
        {
            
            TwoIntsClass dataBuffer;
            dataBuffer.intOne = 1;
            dataBuffer.intTwo = 1;
            data = &dataBuffer;
        }
        break;
    }
    printIntLine(data->intOne);
    
"
3476,0,CWE252_Unchecked_Return_Value__char_sscanf_06.c,"    if(STATIC_CONST_FIVE==5)
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            
            sscanf(SRC, ""%99s\0"", data);
        }
"
15053,0,CWE369_Divide_by_Zero__int_rand_modulo_33.cpp,"    int data;
    int &dataRef = data;
    
    data = -1;
    
    data = RAND32();
    {
        int data = dataRef;
        
        printIntLine(100 % data);
"
4494,0,CWE190_Integer_Overflow__short_rand_multiply_31.c,"    short data;
    data = 0;
    
    data = (short)RAND32();
    {
        short dataCopy = data;
        short data = dataCopy;
        if(data > 0) 
        {
            
            short result = data * 2;
            printIntLine(result);
        }
"
16719,0,CWE590_Free_Memory_Not_on_Heap__delete_array_long_alloca_17.cpp,"    int i;
    long * data;
    data = NULL; 
    for(i = 0; i < 1; i++)
    {
        {
            
            long * dataBuffer = (long *)ALLOCA(100*sizeof(long));
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5L;
                }
            }
            data = dataBuffer;
        }
    }
    printLongLine(data[0]);
    
"
10881,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_14.c,"    size_t data;
    
    data = 0;
    if(globalFive==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = strtoul(inputBuffer, NULL, 0);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(globalFive==5)
    {
        {
            char * myString;
            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
             * for the strcpy() function to not cause a buffer overflow */
            
            if (data > strlen(HELLO_STRING))
            {
                myString = (char *)malloc(data*sizeof(char));
                if (myString == NULL) {exit(-1);}
                
                strcpy(myString, HELLO_STRING);
                printLine(myString);
                free(myString);
            }
            else
            {
                printLine(""Input is less than the length of the source string"");
            }
        }
"
16169,0,CWE134_Uncontrolled_Format_String__char_file_vfprintf_09.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(GLOBAL_CONST_TRUE)
    {
        {
            
            size_t dataLen = strlen(data);
            FILE * pFile;
            
            if (100-dataLen > 1)
            {
                pFile = fopen(FILENAME, ""r"");
                if (pFile != NULL)
                {
                    
                    if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                    {
                        printLine(""fgets() failed"");
                        
                        data[dataLen] = '\0';
                    }
                    fclose(pFile);
                }
            }
        }
    }
    if(GLOBAL_CONST_TRUE)
    {
        badVaSinkB(data, data);
"
5868,0,CWE590_Free_Memory_Not_on_Heap__delete_int64_t_declare_52a.cpp,"    int64_t * data;
    data = NULL; 
    {
        
        int64_t dataBuffer;
        dataBuffer = 5LL;
        data = &dataBuffer;
    }
"
4777,0,CWE563_Unused_Variable__unused_value_int64_t_01.c,"    int64_t data;
    
    data = 5LL;
    
    data = 10LL;
"
15480,0,CWE590_Free_Memory_Not_on_Heap__delete_array_long_declare_74a.cpp,"    long * data;
    map<int, long *> dataMap;
    data = NULL; 
    {
        
        long dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5L;
            }
        }
        data = dataBuffer;
    }
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
4653,0,CWE401_Memory_Leak__new_array_TwoIntsClass_21.cpp,"    TwoIntsClass * data;
    data = NULL;
    
    data = new TwoIntsClass[100];
    
    data[0].intOne = 0;
    data[0].intTwo = 0;
    printIntLine(data[0].intOne);
    printIntLine(data[0].intTwo);
    badStatic = 1; 
"
10630,0,CWE690_NULL_Deref_From_Return__fopen_52a.c,"    FILE * data;
    
    data = NULL;
    
    data = fopen(""file.txt"", ""w+"");
"
14730,0,CWE369_Divide_by_Zero__int_fscanf_modulo_17.c,"    int i,j;
    int data;
    
    data = -1;
    for(i = 0; i < 1; i++)
    {
        
        fscanf(stdin, ""%d"", &data);
    }
    for(j = 0; j < 1; j++)
    {
        
        printIntLine(100 % data);
"
18714,0,CWE415_Double_Free__new_delete_int_44.cpp,"    int * data;
    
    void (*funcPtr) (int *) = badSink;
    
    data = NULL;
    data = new int;
    
    delete data;
    
"
2678,1,CWE587_Assignment_of_Fixed_Address_to_Pointer__basic_01.c,"    {
        
        char charStack = 'a';
        char *charPointer = &charStack;
        printHexCharLine(*charPointer);
"
16689,0,CWE563_Unused_Variable__unused_init_variable_char_83_bad.cpp,"Label Definition File: CWE563_Unused_Variable__unused_init_variable.label.xml
Template File: source-sinks-83_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 563 Unused Variable
 * BadSource:  Initialize data
 * Sinks:
 *    GoodSink: Use data
 *    BadSink : do nothing
 * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE563_Unused_Variable__unused_init_variable_char_83.h""

namespace CWE563_Unused_Variable__unused_init_variable_char_83
{
CWE563_Unused_Variable__unused_init_variable_char_83_bad::CWE563_Unused_Variable__unused_init_variable_char_83_bad(char dataCopy)
{
    data = dataCopy;
    
    data = 'C';
}

CWE563_Unused_Variable__unused_init_variable_char_83_bad::~CWE563_Unused_Variable__unused_init_variable_char_83_bad()
{
    
    
    ; 
}
}
"
16278,0,CWE190_Integer_Overflow__int_rand_square_81a.cpp,"    int data;
    
    data = 0;
    
    data = RAND32();
    const CWE190_Integer_Overflow__int_rand_square_81_base& baseObject = CWE190_Integer_Overflow__int_rand_square_81_bad();
"
19330,0,CWE590_Free_Memory_Not_on_Heap__delete_array_class_static_10.cpp,"    TwoIntsClass * data;
    data = NULL; 
    if(globalTrue)
    {
        {
            
            static TwoIntsClass dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i].intOne = 1;
                    dataBuffer[i].intTwo = 1;
                }
            }
            data = dataBuffer;
        }
    }
    printIntLine(data[0].intOne);
    
"
8631,0,CWE190_Integer_Overflow__int_connect_socket_preinc_45.c,"    int data;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    CWE190_Integer_Overflow__int_connect_socket_preinc_45_badData = data;
"
5044,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_18.c,"    size_t data;
    
    data = 0;
    goto source;
source:
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = strtoul(inputBuffer, NULL, 0);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    goto sink;
sink:
    {
        char * myString;
        /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
         * for the strcpy() function to not cause a buffer overflow */
        
        if (data > strlen(HELLO_STRING))
        {
            myString = (char *)malloc(data*sizeof(char));
            if (myString == NULL) {exit(-1);}
            
            strcpy(myString, HELLO_STRING);
            printLine(myString);
            free(myString);
        }
        else
        {
            printLine(""Input is less than the length of the source string"");
        }
"
12225,0,CWE665_Improper_Initialization__char_ncat_67a.c,"    char * data;
    CWE665_Improper_Initialization__char_ncat_67_structType myStruct;
    char dataBuffer[100];
    data = dataBuffer;
    
    ; 
    myStruct.structFirst = data;
"
6119,0,CWE190_Integer_Overflow__int64_t_fscanf_postinc_44.c,"    int64_t data;
    
    void (*funcPtr) (int64_t) = badSink;
    data = 0LL;
    
    fscanf (stdin, ""%"" SCNd64, &data);
    
"
1694,0,CWE563_Unused_Variable__unused_value_int_74a.cpp,"    int data;
    map<int, int> dataMap;
    
    data = 5;
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
10260,0,CWE78_OS_Command_Injection__char_listen_socket_execl_84_bad.cpp,"Label Definition File: CWE78_OS_Command_Injection.strings.label.xml
Template File: sources-sink-84_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 78 OS Command Injection
 * BadSource: listen_socket Read data using a listen socket (server side)
 * GoodSource: Fixed string
 * Sinks: execl
 *    BadSink : execute command with execl
 * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE78_OS_Command_Injection__char_listen_socket_execl_84.h""

#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif

#define TCP_PORT 27015
#define LISTEN_BACKLOG 5

#ifdef _WIN32
#include <process.h>
#define EXECL _execl
#else 
#define EXECL execl
#endif

namespace CWE78_OS_Command_Injection__char_listen_socket_execl_84
{
CWE78_OS_Command_Injection__char_listen_socket_execl_84_bad::CWE78_OS_Command_Injection__char_listen_socket_execl_84_bad(char * dataCopy)
{
    data = dataCopy;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
}

CWE78_OS_Command_Injection__char_listen_socket_execl_84_bad::~CWE78_OS_Command_Injection__char_listen_socket_execl_84_bad()
{
    
    
    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
}
"
7886,1,CWE758_Undefined_Behavior__char_new_use_05.cpp,"    if(staticTrue)
    {
        {
            char data;
            data = 5;
            char * pointer = new char;
            *pointer = data; 
            {
                char data = *pointer;
                printHexCharLine(data);
            }
            delete pointer;
        }
"
17872,0,CWE190_Integer_Overflow__int_connect_socket_square_41.c,"    int data;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
7802,0,CWE190_Integer_Overflow__short_rand_square_83a.cpp,"    short data;
    data = 0;
"
8214,0,CWE190_Integer_Overflow__int64_t_fscanf_multiply_14.c,"    int64_t data;
    data = 0LL;
    if(globalFive==5)
    {
        
        fscanf (stdin, ""%"" SCNd64, &data);
    }
    if(globalFive==5)
    {
        if(data > 0) 
        {
            
            int64_t result = data * 2;
            printLongLongLine(result);
        }
"
16620,0,CWE190_Integer_Overflow__int_connect_socket_add_05.c,"    int data;
    
    data = 0;
    if(staticTrue)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(staticTrue)
    {
        {
            
            int result = data + 1;
            printIntLine(result);
        }
"
7525,0,CWE590_Free_Memory_Not_on_Heap__delete_class_declare_05.cpp,"    TwoIntsClass * data;
    data = NULL; 
    if(staticTrue)
    {
        {
            
            TwoIntsClass dataBuffer;
            dataBuffer.intOne = 1;
            dataBuffer.intTwo = 1;
            data = &dataBuffer;
        }
    }
    printIntLine(data->intOne);
    
"
18932,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_08.c,"    size_t data;
    
    data = 0;
    if(staticReturnsTrue())
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                
                data = strtoul(inputBuffer, NULL, 0);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    if(staticReturnsTrue())
    {
        {
            char * myString;
            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
             * for the strcpy() function to not cause a buffer overflow */
            
            if (data > strlen(HELLO_STRING))
            {
                myString = (char *)malloc(data*sizeof(char));
                if (myString == NULL) {exit(-1);}
                
                strcpy(myString, HELLO_STRING);
                printLine(myString);
                free(myString);
            }
            else
            {
                printLine(""Input is less than the length of the source string"");
            }
        }
"
1794,0,CWE590_Free_Memory_Not_on_Heap__free_int64_t_static_07.c,"    int64_t * data;
    data = NULL; 
    if(staticFive==5)
    {
        {
            
            static int64_t dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5LL;
                }
            }
            data = dataBuffer;
        }
    }
    printLongLongLine(data[0]);
    
"
10791,0,CWE416_Use_After_Free__new_delete_array_int64_t_02.cpp,"    int64_t * data;
    
    data = NULL;
    if(1)
    {
        data = new int64_t[100];
        {
            size_t i;
            for(i = 0; i < 100; i++)
            {
                data[i] = 5LL;
            }
        }
        
        delete [] data;
    }
    if(1)
    {
        
        printLongLongLine(data[0]);
        
"
3549,0,CWE401_Memory_Leak__char_realloc_51a.c,"    char * data;
    data = NULL;
    
    data = (char *)realloc(data, 100*sizeof(char));
    if (data == NULL) {exit(-1);}
    
    strcpy(data, ""A String"");
    printLine(data);
"
18337,0,CWE78_OS_Command_Injection__char_file_popen_04.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(STATIC_CONST_TRUE)
    {
        {
            
            size_t dataLen = strlen(data);
            FILE * pFile;
            
            if (100-dataLen > 1)
            {
                pFile = fopen(FILENAME, ""r"");
                if (pFile != NULL)
                {
                    
                    if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                    {
                        printLine(""fgets() failed"");
                        
                        data[dataLen] = '\0';
                    }
                    fclose(pFile);
                }
            }
        }
    }
    {
        FILE *pipe;
        
        pipe = POPEN(data, ""w"");
        if (pipe != NULL)
        {
            PCLOSE(pipe);
        }
"
8040,0,CWE401_Memory_Leak__twoIntsStruct_calloc_08.c,"    twoIntsStruct * data;
    data = NULL;
    if(staticReturnsTrue())
    {
        
        data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));
        if (data == NULL) {exit(-1);}
        
        data[0].intOne = 0;
        data[0].intTwo = 0;
        printStructLine(&data[0]);
    }
    if(staticReturnsTrue())
    {
        
        ; 
"
13852,0,CWE457_Use_of_Uninitialized_Variable__struct_array_malloc_partial_init_43.cpp,"    twoIntsStruct * data;
    data = (twoIntsStruct *)malloc(10*sizeof(twoIntsStruct));
    if (data == NULL) {exit(-1);}
    badSource(data);
    
    {
        int i;
        for(i=0; i<10; i++)
        {
            printIntLine(data[i].intOne);
            printIntLine(data[i].intTwo);
        }
"
14657,0,CWE401_Memory_Leak__int_calloc_81a.cpp,"    int * data;
    data = NULL;
    
    data = (int *)calloc(100, sizeof(int));
    if (data == NULL) {exit(-1);}
    
    data[0] = 5;
    printIntLine(data[0]);
    const CWE401_Memory_Leak__int_calloc_81_base& baseObject = CWE401_Memory_Leak__int_calloc_81_bad();
"
5,0,CWE78_OS_Command_Injection__char_file_execl_65a.c,"    char * data;
    
    void (*funcPtr) (char *) = CWE78_OS_Command_Injection__char_file_execl_65b_badSink;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        FILE * pFile;
        
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
    
"
5894,0,CWE690_NULL_Deref_From_Return__int_malloc_63a.c,"    int * data;
    data = NULL; 
    
    data = (int *)malloc(1*sizeof(int));
"
19506,0,CWE401_Memory_Leak__int_realloc_65a.c,"    int * data;
    
    void (*funcPtr) (int *) = CWE401_Memory_Leak__int_realloc_65b_badSink;
    data = NULL;
    
    data = (int *)realloc(data, 100*sizeof(int));
    if (data == NULL) {exit(-1);}
    
    data[0] = 5;
    printIntLine(data[0]);
    
"
929,0,CWE590_Free_Memory_Not_on_Heap__delete_char_declare_45.cpp,"    char * data;
    data = NULL; 
    {
        
        char dataBuffer;
        dataBuffer = 'A';
        data = &dataBuffer;
    }
    badData = data;
"
6318,1,CWE563_Unused_Variable__unused_global_variable_01.c,"    
"
8167,0,CWE190_Integer_Overflow__int_listen_socket_multiply_68a.c,"    int data;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    CWE190_Integer_Overflow__int_listen_socket_multiply_68_badData = data;
"
4366,0,CWE78_OS_Command_Injection__char_listen_socket_execl_54a.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
5998,0,CWE476_NULL_Pointer_Dereference__long_54a.c,"    long * data;
    
    data = NULL;
"
5136,0,CWE190_Integer_Overflow__int64_t_rand_multiply_63a.c,"    int64_t data;
    data = 0LL;
    
    data = (int64_t)RAND64();
"
6883,0,CWE190_Integer_Overflow__int_fgets_multiply_02.c,"    int data;
    
    data = 0;
    if(1)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    if(1)
    {
        if(data > 0) 
        {
            
            int result = data * 2;
            printIntLine(result);
        }
"
2893,0,CWE401_Memory_Leak__new_struct_twoIntsStruct_16.cpp,"    struct _twoIntsStruct * data;
    data = NULL;
    while(1)
    {
        
        data = new struct _twoIntsStruct;
        
        data->intOne = 0;
        data->intTwo = 0;
        printStructLine((twoIntsStruct *)data);
        break;
    }
    while(1)
    {
        
        ; 
        break;
"
4115,0,CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_83a.cpp,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
"
10202,0,CWE457_Use_of_Uninitialized_Variable__double_array_malloc_partial_init_06.c,"    double * data;
    data = (double *)malloc(10*sizeof(double));
    if (data == NULL) {exit(-1);}
    if(STATIC_CONST_FIVE==5)
    {
        
        {
            int i;
            for(i=0; i<(10/2); i++)
            {
                data[i] = (double)i;
            }
        }
    }
    if(STATIC_CONST_FIVE==5)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printDoubleLine(data[i]);
            }
        }
"
15812,0,CWE134_Uncontrolled_Format_String__char_environment_printf_66a.c,"    char * data;
    char * dataArray[5];
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        
        if (environment != NULL)
        {
            
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    
    dataArray[2] = data;
"
11912,0,CWE78_OS_Command_Injection__char_file_popen_81_bad.cpp,"Label Definition File: CWE78_OS_Command_Injection.one_string.label.xml
Template File: sources-sink-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 78 OS Command Injection
 * BadSource: file Read input from a file
 * GoodSource: Fixed string
 * Sinks: popen
 *    BadSink : Execute command in data using popen()
 * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE78_OS_Command_Injection__char_file_popen_81.h""


#ifdef _WIN32
#define POPEN _popen
#define PCLOSE _pclose
#else 
#define POPEN popen
#define PCLOSE pclose
#endif

namespace CWE78_OS_Command_Injection__char_file_popen_81
{

void CWE78_OS_Command_Injection__char_file_popen_81_bad::action(char * data) const
{
    {
        FILE *pipe;
        
        pipe = POPEN(data, ""w"");
        if (pipe != NULL)
        {
            PCLOSE(pipe);
        }
    }
}

}
"
10027,0,CWE190_Integer_Overflow__short_rand_add_18.c,"    short data;
    data = 0;
    goto source;
source:
    
    data = (short)RAND32();
    goto sink;
sink:
    {
        
        short result = data + 1;
        printIntLine(result);
"
1915,0,CWE190_Integer_Overflow__unsigned_int_fscanf_add_06.c,"    unsigned int data;
    data = 0;
    if(STATIC_CONST_FIVE==5)
    {
        
        fscanf (stdin, ""%u"", &data);
    }
    if(STATIC_CONST_FIVE==5)
    {
        {
            
            unsigned int result = data + 1;
            printUnsignedLine(result);
        }
"
3382,0,CWE401_Memory_Leak__new_TwoIntsClass_44.cpp,"    TwoIntsClass * data;
    
    void (*funcPtr) (TwoIntsClass *) = badSink;
    data = NULL;
    
    data = new TwoIntsClass;
    
    data->intOne = 0;
    data->intTwo = 0;
    printIntLine(data->intOne);
    printIntLine(data->intTwo);
    
"
726,0,CWE190_Integer_Overflow__int64_t_max_add_44.c,"    int64_t data;
    
    void (*funcPtr) (int64_t) = badSink;
    data = 0LL;
    
    data = LLONG_MAX;
    
"
7588,0,CWE190_Integer_Overflow__char_max_preinc_42.c,"    char data;
    data = ' ';
    data = badSource(data);
    {
        
        ++data;
        char result = data;
        printHexCharLine(result);
"
7322,0,CWE416_Use_After_Free__new_delete_struct_08.cpp,"    twoIntsStruct * data;
    
    data = NULL;
    if(staticReturnsTrue())
    {
        data = new twoIntsStruct;
        data->intOne = 1;
        data->intTwo = 2;
        
        delete data;
    }
    if(staticReturnsTrue())
    {
        
        printStructLine(data);
        
"
7821,0,CWE758_Undefined_Behavior__class_pointer_new_use_17.cpp,"    int j;
    for(j = 0; j < 1; j++)
    {
        {
            TwoIntsClass * * pointer = new TwoIntsClass *;
            TwoIntsClass * data = *pointer; 
            delete pointer;
            printIntLine(data->intOne);
            printIntLine(data->intTwo);
        }
"
10142,0,CWE758_Undefined_Behavior__int_malloc_use_13.c,"    if(GLOBAL_CONST_FIVE==5)
    {
        {
            int * pointer = (int *)malloc(sizeof(int));
            if (pointer == NULL) {exit(-1);}
            int data = *pointer; 
            free(pointer);
            printIntLine(data);
        }
"
18676,0,CWE563_Unused_Variable__unused_init_variable_int64_t_06.c,"    int64_t data;
    
    data = 5LL;
    if(STATIC_CONST_FIVE==5)
    {
        
        
        ; 
"
6075,0,CWE590_Free_Memory_Not_on_Heap__delete_array_int64_t_declare_45.cpp,"    int64_t * data;
    data = NULL; 
    {
        
        int64_t dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5LL;
            }
        }
        data = dataBuffer;
    }
    badData = data;
"
6401,0,CWE190_Integer_Overflow__int64_t_rand_multiply_33.cpp,"    int64_t data;
    int64_t &dataRef = data;
    data = 0LL;
    
    data = (int64_t)RAND64();
    {
        int64_t data = dataRef;
        if(data > 0) 
        {
            
            int64_t result = data * 2;
            printLongLongLine(result);
        }
"
4960,0,CWE590_Free_Memory_Not_on_Heap__delete_struct_alloca_52a.cpp,"    twoIntsStruct * data;
    data = NULL; 
    {
        
        twoIntsStruct * dataBuffer = (twoIntsStruct *)ALLOCA(sizeof(twoIntsStruct));
        dataBuffer->intOne = 1;
        dataBuffer->intTwo = 1;
        data = dataBuffer;
    }
"
6229,0,CWE590_Free_Memory_Not_on_Heap__free_struct_static_68a.c,"    twoIntsStruct * data;
    data = NULL; 
    {
        
        static twoIntsStruct dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i].intOne = 1;
                dataBuffer[i].intTwo = 1;
            }
        }
        data = dataBuffer;
    }
    CWE590_Free_Memory_Not_on_Heap__free_struct_static_68_badData = data;
"
1137,0,CWE590_Free_Memory_Not_on_Heap__free_int64_t_static_12.c,"    int64_t * data;
    data = NULL; 
    if(globalReturnsTrueOrFalse())
    {
        {
            
            static int64_t dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5LL;
                }
            }
            data = dataBuffer;
        }
    }
    else
    {
        {
            
            int64_t * dataBuffer = (int64_t *)malloc(100*sizeof(int64_t));
            if (dataBuffer == NULL)
            {
                printLine(""malloc() failed"");
                exit(1);
            }
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5LL;
                }
            }
            data = dataBuffer;
        }
    }
    printLongLongLine(data[0]);
    
"
12734,0,CWE590_Free_Memory_Not_on_Heap__delete_array_char_static_66a.cpp,"    char * data;
    char * dataArray[5];
    data = NULL; 
    {
        
        static char dataBuffer[100];
        memset(dataBuffer, 'A', 100-1); 
        dataBuffer[100-1] = '\0'; 
        data = dataBuffer;
    }
    
    dataArray[2] = data;
"
15124,1,CWE758_Undefined_Behavior__struct_pointer_malloc_use_13.c,"    if(GLOBAL_CONST_FIVE==5)
    {
        {
            twoIntsStruct * data;
            twoIntsStruct * * pointer = (twoIntsStruct * *)malloc(sizeof(twoIntsStruct *));
            if (pointer == NULL) {exit(-1);}
            
            data = (twoIntsStruct *)malloc(sizeof(twoIntsStruct));
            if (data == NULL) {exit(-1);}
            data->intOne = 5;
            data->intTwo = 6;
            *pointer = data; 
            {
                twoIntsStruct * data = *pointer;
                printIntLine(data->intOne);
                printIntLine(data->intTwo);
            }
            free(pointer);
        }
"
6228,0,CWE590_Free_Memory_Not_on_Heap__delete_array_class_declare_73a.cpp,"    TwoIntsClass * data;
    list<TwoIntsClass *> dataList;
    data = NULL; 
    {
        
        TwoIntsClass dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i].intOne = 1;
                dataBuffer[i].intTwo = 1;
            }
        }
        data = dataBuffer;
    }
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
4314,1,CWE758_Undefined_Behavior__struct_pointer_new_use_11.cpp,"    if(globalReturnsTrue())
    {
        {
            twoIntsStruct * data;
            
            data = new twoIntsStruct;
            data->intOne = 5;
            data->intTwo = 6;
            twoIntsStruct * * pointer = new twoIntsStruct *;
            *pointer = data; 
            {
                twoIntsStruct * data = *pointer;
                printIntLine(data->intOne);
                printIntLine(data->intTwo);
            }
            delete pointer;
        }
"
1449,0,CWE401_Memory_Leak__strdup_char_03.c,"    char * data;
    data = NULL;
    if(5==5)
    {
        {
            char myString[] = ""myString"";
            
            data = strdup(myString);
            
            printLine(data);
        }
    }
    if(5==5)
    {
        
        
        ; 
"
16706,1,CWE476_NULL_Pointer_Dereference__null_check_after_deref_15.c,"    switch(5)
    {
    case 6:
        
        printLine(""Benign, fixed string"");
        break;
    default:
    {
        int *intPointer = NULL;
        intPointer = (int *)malloc(sizeof(int));
        *intPointer = 5;
        printIntLine(*intPointer);
        
        *intPointer = 10;
        printIntLine(*intPointer);
    }
    break;
"
6887,0,CWE190_Integer_Overflow__int_rand_multiply_12.c,"    int data;
    
    data = 0;
    if(globalReturnsTrueOrFalse())
    {
        
        data = RAND32();
    }
    else
    {
        
        data = 2;
    }
    if(globalReturnsTrueOrFalse())
    {
        if(data > 0) 
        {
            
            int result = data * 2;
            printIntLine(result);
        }
    }
    else
    {
        if(data > 0) 
        {
            
            if (data < (INT_MAX/2))
            {
                int result = data * 2;
                printIntLine(result);
            }
            else
            {
                printLine(""data value is too large to perform arithmetic safely."");
            }
        }
"
5538,0,CWE590_Free_Memory_Not_on_Heap__free_long_static_14.c,"    long * data;
    data = NULL; 
    if(globalFive==5)
    {
        {
            
            static long dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5L;
                }
            }
            data = dataBuffer;
        }
    }
    printLongLine(data[0]);
    
"
3827,0,CWE190_Integer_Overflow__char_fscanf_add_06.c,"    char data;
    data = ' ';
    if(STATIC_CONST_FIVE==5)
    {
        
        fscanf (stdin, ""%c"", &data);
    }
    if(STATIC_CONST_FIVE==5)
    {
        {
            
            char result = data + 1;
            printHexCharLine(result);
        }
"
8546,0,CWE590_Free_Memory_Not_on_Heap__free_long_declare_68a.c,"    long * data;
    data = NULL; 
    {
        
        long dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5L;
            }
        }
        data = dataBuffer;
    }
    CWE590_Free_Memory_Not_on_Heap__free_long_declare_68_badData = data;
"
16880,1,CWE758_Undefined_Behavior__double_pointer_new_use_11.cpp,"    if(globalReturnsTrue())
    {
        {
            double * data;
            
            data = new double;
            *data = 5.0;
            double * * pointer = new double *;
            *pointer = data; 
            {
                double * data = *pointer;
                printDoubleLine(*data);
            }
            delete pointer;
        }
"
14890,0,CWE416_Use_After_Free__malloc_free_char_16.c,"    char * data;
    
    data = NULL;
    while(1)
    {
        data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        memset(data, 'A', 100-1);
        data[100-1] = '\0';
        
        free(data);
        break;
    }
    while(1)
    {
        
        printLine(data);
        
        break;
"
8824,0,CWE590_Free_Memory_Not_on_Heap__delete_class_declare_11.cpp,"    TwoIntsClass * data;
    data = NULL; 
    if(globalReturnsTrue())
    {
        {
            
            TwoIntsClass dataBuffer;
            dataBuffer.intOne = 1;
            dataBuffer.intTwo = 1;
            data = &dataBuffer;
        }
    }
    printIntLine(data->intOne);
    
"
3783,0,CWE369_Divide_by_Zero__int_zero_divide_14.c,"    int data;
    
    data = -1;
    if(globalFive==5)
    {
        
        data = 0;
    }
    if(globalFive==5)
    {
        
        printIntLine(100 / data);
"
9001,0,CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_44.c,"    unsigned int data;
    
    void (*funcPtr) (unsigned int) = badSink;
    data = 0;
    
    fscanf (stdin, ""%u"", &data);
    
"
11115,0,CWE401_Memory_Leak__int_malloc_84a.cpp,"    int * data;
    data = NULL;
    CWE401_Memory_Leak__int_malloc_84_bad * badObject = new CWE401_Memory_Leak__int_malloc_84_bad(data);
"
5111,0,CWE190_Integer_Overflow__int_connect_socket_postinc_16.c,"    int data;
    
    data = 0;
    while(1)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
        break;
    }
    while(1)
    {
        {
            
            data++;
            int result = data;
            printIntLine(result);
        }
        break;
"
12658,0,CWE590_Free_Memory_Not_on_Heap__free_struct_static_02.c,"    twoIntsStruct * data;
    data = NULL; 
    if(1)
    {
        {
            
            static twoIntsStruct dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i].intOne = 1;
                    dataBuffer[i].intTwo = 1;
                }
            }
            data = dataBuffer;
        }
    }
    printStructLine(&data[0]);
    
"
18600,0,CWE190_Integer_Overflow__unsigned_int_rand_multiply_66a.c,"    unsigned int data;
    unsigned int dataArray[5];
    data = 0;
    
    data = (unsigned int)RAND32();
    
    dataArray[2] = data;
"
2322,0,CWE78_OS_Command_Injection__char_console_execl_52a.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        
        if (100-dataLen > 1)
        {
            
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgets() */
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
                    data[dataLen-1] = '\0';
                }
            }
            else
            {
                printLine(""fgets() failed"");
                
                data[dataLen] = '\0';
            }
        }
    }
"
2389,0,CWE401_Memory_Leak__struct_twoIntsStruct_calloc_11.c,"    struct _twoIntsStruct * data;
    data = NULL;
    if(globalReturnsTrue())
    {
        
        data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));
        if (data == NULL) {exit(-1);}
        
        data[0].intOne = 0;
        data[0].intTwo = 0;
        printStructLine((twoIntsStruct *)&data[0]);
    }
    if(globalReturnsTrue())
    {
        
        ; 
"
11562,0,CWE758_Undefined_Behavior__class_new_use_06.cpp,"    if(STATIC_CONST_FIVE==5)
    {
        {
            TwoIntsClass * pointer = new TwoIntsClass;
            TwoIntsClass data = *pointer; 
            delete pointer;
            printIntLine(data.intOne);
            printIntLine(data.intTwo);
        }
"
4202,0,CWE590_Free_Memory_Not_on_Heap__free_long_alloca_52a.c,"    long * data;
    data = NULL; 
    {
        
        long * dataBuffer = (long *)ALLOCA(100*sizeof(long));
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5L;
            }
        }
        data = dataBuffer;
    }
"
10795,0,CWE190_Integer_Overflow__int_max_square_10.c,"    int data;
    
    data = 0;
    if(globalTrue)
    {
        
        data = INT_MAX;
    }
    if(globalTrue)
    {
        {
            
            int result = data * data;
            printIntLine(result);
        }
"
1408,0,CWE134_Uncontrolled_Format_String__char_file_printf_01.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        FILE * pFile;
        
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
    
"
15750,0,CWE190_Integer_Overflow__short_fscanf_square_81_bad.cpp,"Label Definition File: CWE190_Integer_Overflow.label.xml
Template File: sources-sinks-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 190 Integer Overflow
 * BadSource: fscanf Read data from the console using fscanf()
 * GoodSource: Set data to a small, non-zero number (two)
 * Sinks: square
 *    GoodSink: Ensure there will not be an overflow before squaring data
 *    BadSink : Square data, which can lead to overflow
 * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE190_Integer_Overflow__short_fscanf_square_81.h""

#include <math.h>

namespace CWE190_Integer_Overflow__short_fscanf_square_81
{

void CWE190_Integer_Overflow__short_fscanf_square_81_bad::action(short data) const
{
    {
        
        short result = data * data;
        printIntLine(result);
    }
}

}
"
13915,0,CWE401_Memory_Leak__char_calloc_65a.c,"    char * data;
    
    void (*funcPtr) (char *) = CWE401_Memory_Leak__char_calloc_65b_badSink;
    data = NULL;
    
    data = (char *)calloc(100, sizeof(char));
    if (data == NULL) {exit(-1);}
    
    strcpy(data, ""A String"");
    printLine(data);
    
"
17484,0,CWE190_Integer_Overflow__unsigned_int_rand_multiply_09.c,"    unsigned int data;
    data = 0;
    if(GLOBAL_CONST_TRUE)
    {
        
        data = (unsigned int)RAND32();
    }
    if(GLOBAL_CONST_TRUE)
    {
        if(data > 0) 
        {
            
            unsigned int result = data * 2;
            printUnsignedLine(result);
        }
"
151,0,CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_07.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(staticFive==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                data[dataLen + recvResult / sizeof(char)] = '\0';
                
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(staticFive==5)
    {
        badVaSinkB(data, data);
"
6415,0,CWE690_NULL_Deref_From_Return__int64_t_calloc_67a.c,"    int64_t * data;
    CWE690_NULL_Deref_From_Return__int64_t_calloc_67_structType myStruct;
    data = NULL; 
    
    data = (int64_t *)calloc(1, sizeof(int64_t));
    myStruct.structFirst = data;
"
18421,0,CWE134_Uncontrolled_Format_String__char_file_vfprintf_33.cpp,"    char * data;
    char * &dataRef = data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        FILE * pFile;
        
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
    {
        char * data = dataRef;
        badVaSink(data, data);
"
288,0,CWE676_Use_of_Potentially_Dangerous_Function__basic_04.cpp,"    if(STATIC_CONST_TRUE)
    {
        {
            char charBuffer[CHAR_BUFFER_SIZE];
            
            
            cin >> charBuffer;
            charBuffer[CHAR_BUFFER_SIZE-1] = '\0';
            printLine(charBuffer);
        }
"
192,0,CWE190_Integer_Overflow__short_max_multiply_82a.cpp,"    short data;
    data = 0;
    
    data = SHRT_MAX;
    CWE190_Integer_Overflow__short_max_multiply_82_base* baseObject = new CWE190_Integer_Overflow__short_max_multiply_82_bad;
    baseObject->action(data);
"
14659,0,CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_45.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_45_badData = data;
"
10494,0,CWE590_Free_Memory_Not_on_Heap__delete_class_alloca_01.cpp,"    TwoIntsClass * data;
    data = NULL; 
    {
        
        TwoIntsClass * dataBuffer = (TwoIntsClass *)ALLOCA(sizeof(TwoIntsClass));
        dataBuffer->intOne = 2;
        dataBuffer->intTwo = 2;
        data = dataBuffer;
    }
    printIntLine(data->intOne);
    
"
6956,0,CWE690_NULL_Deref_From_Return__int_realloc_84_bad.cpp,"Label Definition File: CWE690_NULL_Deref_From_Return.free.label.xml
Template File: source-sinks-84_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 690 Unchecked Return Value To NULL Pointer
 * BadSource: realloc Allocate data using realloc()
 * Sinks:
 *    GoodSink: Check to see if the data allocation failed and if not, use data
 *    BadSink : Don't check for NULL and use data
 * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE690_NULL_Deref_From_Return__int_realloc_84.h""

namespace CWE690_NULL_Deref_From_Return__int_realloc_84
{
CWE690_NULL_Deref_From_Return__int_realloc_84_bad::CWE690_NULL_Deref_From_Return__int_realloc_84_bad(int * dataCopy)
{
    data = dataCopy;
    
    data = (int *)realloc(data, 1*sizeof(int));
}

CWE690_NULL_Deref_From_Return__int_realloc_84_bad::~CWE690_NULL_Deref_From_Return__int_realloc_84_bad()
{
    
    data[0] = 5;
    printIntLine(data[0]);
    free(data);
}
}
"
5219,0,CWE758_Undefined_Behavior__int64_t_new_use_04.cpp,"    if(STATIC_CONST_TRUE)
    {
        {
            int64_t * pointer = new int64_t;
            int64_t data = *pointer; 
            delete pointer;
            printLongLongLine(data);
        }
"
9095,1,CWE252_Unchecked_Return_Value__char_fprintf_04.c,"    if(STATIC_CONST_TRUE)
    {
        
        if (fprintf(stdout, ""%s\n"", ""string"") < 0)
        {
            printLine(""fprintf failed!"");
        }
"
4571,0,CWE190_Integer_Overflow__int_max_multiply_18.c,"    int data;
    
    data = 0;
    goto source;
source:
    
    data = INT_MAX;
    goto sink;
sink:
    if(data > 0) 
    {
        
        int result = data * 2;
        printIntLine(result);
"
12045,0,CWE590_Free_Memory_Not_on_Heap__delete_array_long_alloca_67a.cpp,"    long * data;
    structType myStruct;
    data = NULL; 
    {
        
        long * dataBuffer = (long *)ALLOCA(100*sizeof(long));
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5L;
            }
        }
        data = dataBuffer;
    }
    myStruct.structFirst = data;
"
10075,0,CWE476_NULL_Pointer_Dereference__class_31.cpp,"    TwoIntsClass * data;
    
    data = NULL;
    {
        TwoIntsClass * dataCopy = data;
        TwoIntsClass * data = dataCopy;
        
        printIntLine(data->intOne);
        
        delete data;
"
8405,0,CWE476_NULL_Pointer_Dereference__binary_if_16.c,"    while(1)
    {
        {
            twoIntsStruct *twoIntsStructPointer = NULL;
            /* FLAW: Using a single & in the if statement will cause both sides of the expression to be evaluated
             * thus causing a NPD */
            if ((twoIntsStructPointer != NULL) & (twoIntsStructPointer->intOne == 5))
            {
                printLine(""intOne == 5"");
            }
        }
        break;
"
14588,0,CWE690_NULL_Deref_From_Return__long_malloc_73a.cpp,"    long * data;
    list<long *> dataList;
    data = NULL; 
    
    data = (long *)malloc(1*sizeof(long));
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
9888,0,CWE563_Unused_Variable__unused_value_struct_07.c,"    twoIntsStruct data;
    if(staticFive==5)
    {
        
        data.intOne = 0;
        data.intTwo = 0;
    }
    if(staticFive==5)
    {
        
        data.intOne = 1;
        data.intTwo = 1;
        printStructLine(&data);
"
12458,0,CWE252_Unchecked_Return_Value__char_fprintf_14.c,"    if(globalFive==5)
    {
        
        fprintf(stdout, ""%s\n"", ""string"");
"
15705,0,CWE401_Memory_Leak__new_TwoIntsClass_82_bad.cpp,"Label Definition File: CWE401_Memory_Leak__new.label.xml
Template File: sources-sinks-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 401 Memory Leak
 * BadSource:  Allocate data using new
 * GoodSource: Allocate data on the stack
 * Sinks:
 *    GoodSink: call delete on data
 *    BadSink : no deallocation of data
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE401_Memory_Leak__new_TwoIntsClass_82.h""

namespace CWE401_Memory_Leak__new_TwoIntsClass_82
{

void CWE401_Memory_Leak__new_TwoIntsClass_82_bad::action(TwoIntsClass * data)
{
    
    ; 
}

}
"
7354,0,CWE369_Divide_by_Zero__int_connect_socket_modulo_32.c,"    int data;
    int *dataPtr1 = &data;
    int *dataPtr2 = &data;
    
    data = -1;
    {
        int data = *dataPtr1;
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
        *dataPtr1 = data;
    }
    {
        int data = *dataPtr2;
        
        printIntLine(100 % data);
"
6761,0,CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_65a.c,"    char * data;
    
    void (*funcPtr) (char *) = CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_65b_badSink;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
"
17994,0,CWE590_Free_Memory_Not_on_Heap__delete_array_long_declare_04.cpp,"    long * data;
    data = NULL; 
    if(STATIC_CONST_TRUE)
    {
        {
            
            long dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5L;
                }
            }
            data = dataBuffer;
        }
    }
    printLongLine(data[0]);
    
"
161,0,CWE415_Double_Free__new_delete_array_int_33.cpp,"    int * data;
    int * &dataRef = data;
    
    data = NULL;
    data = new int[100];
    
    delete [] data;
    {
        int * data = dataRef;
        
        delete [] data;
"
17432,0,CWE197_Numeric_Truncation_Error__int_listen_socket_to_short_33.cpp,"    int data;
    int &dataRef = data;
    
    data = -1;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    {
        int data = dataRef;
        {
            
            short shortData = (short)data;
            printShortLine(shortData);
        }
"
1659,0,CWE190_Integer_Overflow__int_rand_add_82a.cpp,"    int data;
    
    data = 0;
    
    data = RAND32();
    CWE190_Integer_Overflow__int_rand_add_82_base* baseObject = new CWE190_Integer_Overflow__int_rand_add_82_bad;
    baseObject->action(data);
"
7992,0,CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_65a.cpp,"    size_t data;
    
    void (*funcPtr) (size_t) = badSink;
    
    data = 0;
    
    fscanf(stdin, ""%zu"", &data);
    
"
6249,0,CWE590_Free_Memory_Not_on_Heap__free_long_static_17.c,"    int i;
    long * data;
    data = NULL; 
    for(i = 0; i < 1; i++)
    {
        {
            
            static long dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5L;
                }
            }
            data = dataBuffer;
        }
    }
    printLongLine(data[0]);
    
"
19475,0,CWE190_Integer_Overflow__char_fscanf_square_01.c,"    char data;
    data = ' ';
    
    fscanf (stdin, ""%c"", &data);
    {
        
        char result = data * data;
        printHexCharLine(result);
"
6297,0,CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_83_bad.cpp,"Label Definition File: CWE789_Uncontrolled_Mem_Alloc__new.label.xml
Template File: sources-sinks-83_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: fscanf Read data from the console using fscanf()
 * GoodSource: Small number greater than zero
 * Sinks:
 *    GoodSink: Allocate memory with new [] and check the size of the memory to be allocated
 *    BadSink : Allocate memory with new [], but incorrectly check the size of the memory to be allocated
 * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_83.h""

#define HELLO_STRING ""hello""

namespace CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_83
{
CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_83_bad::CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_83_bad(size_t dataCopy)
{
    data = dataCopy;
    
    fscanf(stdin, ""%zu"", &data);
}

CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_83_bad::~CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_83_bad()
{
    {
        char * myString;
        /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
         * for the strcpy() function to not cause a buffer overflow */
        
        if (data > strlen(HELLO_STRING))
        {
            myString = new char[data];
            
            strcpy(myString, HELLO_STRING);
            printLine(myString);
            delete [] myString;
        }
        else
        {
            printLine(""Input is less than the length of the source string"");
        }
    }
}
}
"
18868,0,CWE590_Free_Memory_Not_on_Heap__delete_array_long_declare_03.cpp,"    long * data;
    data = NULL; 
    if(5==5)
    {
        {
            
            long dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5L;
                }
            }
            data = dataBuffer;
        }
    }
    printLongLine(data[0]);
    
"
8262,0,CWE415_Double_Free__new_delete_array_int_15.cpp,"    int * data;
    
    data = NULL;
    switch(6)
    {
    case 6:
        data = new int[100];
        
        delete [] data;
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
        
        delete [] data;
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
8806,0,CWE690_NULL_Deref_From_Return__struct_realloc_17.c,"    int j;
    twoIntsStruct * data;
    data = NULL; 
    
    data = (twoIntsStruct *)realloc(data, 1*sizeof(twoIntsStruct));
    for(j = 0; j < 1; j++)
    {
        
        data[0].intOne = 1;
        data[0].intTwo = 1;
        printStructLine(&data[0]);
        free(data);
"
10758,0,CWE197_Numeric_Truncation_Error__int_connect_socket_to_short_65a.c,"    int data;
    
    void (*funcPtr) (int) = CWE197_Numeric_Truncation_Error__int_connect_socket_to_short_65b_badSink;
    
    data = -1;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
"
3384,0,CWE457_Use_of_Uninitialized_Variable__double_array_alloca_partial_init_09.c,"    double * data;
    data = (double *)ALLOCA(10*sizeof(double));
    if(GLOBAL_CONST_TRUE)
    {
        
        {
            int i;
            for(i=0; i<(10/2); i++)
            {
                data[i] = (double)i;
            }
        }
    }
    if(GLOBAL_CONST_TRUE)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printDoubleLine(data[i]);
            }
        }
"
13101,0,CWE401_Memory_Leak__int_calloc_65a.c,"    int * data;
    
    void (*funcPtr) (int *) = CWE401_Memory_Leak__int_calloc_65b_badSink;
    data = NULL;
    
    data = (int *)calloc(100, sizeof(int));
    if (data == NULL) {exit(-1);}
    
    data[0] = 5;
    printIntLine(data[0]);
    
"
4061,0,CWE197_Numeric_Truncation_Error__int_fscanf_to_short_05.c,"    int data;
    
    data = -1;
    if(staticTrue)
    {
        
        fscanf(stdin, ""%d"", &data);
    }
    {
        
        short shortData = (short)data;
        printShortLine(shortData);
"
3063,0,CWE758_Undefined_Behavior__char_pointer_alloca_use_12.c,"    if(globalReturnsTrueOrFalse())
    {
        {
            char * * pointer = (char * *)ALLOCA(sizeof(char *));
            char * data = *pointer; 
            printLine(data);
        }
    }
    else
    {
        {
            char * data;
            char * * pointer = (char * *)ALLOCA(sizeof(char *));
            data = ""string"";
            *pointer = data; 
            {
                char * data = *pointer;
                printLine(data);
            }
        }
"
15312,1,CWE676_Use_of_Potentially_Dangerous_Function__basic_18.cpp,"    goto sink;
sink:
    {
        char charBuffer[CHAR_BUFFER_SIZE];
        
        cin.width(CHAR_BUFFER_SIZE);
        cin >> charBuffer;
        charBuffer[CHAR_BUFFER_SIZE-1] = '\0';
        printLine(charBuffer);
"
10458,0,CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_05.c,"    unsigned int data;
    data = 0;
    if(staticTrue)
    {
        
        fscanf (stdin, ""%u"", &data);
    }
    if(staticTrue)
    {
        if(data > 0) 
        {
            
            unsigned int result = data * 2;
            printUnsignedLine(result);
        }
"
19139,0,CWE590_Free_Memory_Not_on_Heap__delete_char_alloca_51a.cpp,"    char * data;
    data = NULL; 
    {
        
        char * dataBuffer = (char *)ALLOCA(sizeof(char));
        *dataBuffer = 'A';
        data = dataBuffer;
    }
"
1789,0,CWE190_Integer_Overflow__int_fgets_multiply_10.c,"    int data;
    
    data = 0;
    if(globalTrue)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    if(globalTrue)
    {
        if(data > 0) 
        {
            
            int result = data * 2;
            printIntLine(result);
        }
"
17282,0,CWE563_Unused_Variable__unused_uninit_variable_long_04.c,"    long data;
    
    ; 
    if(STATIC_CONST_TRUE)
    {
        
        
        ; 
"
11279,0,CWE401_Memory_Leak__new_array_char_33.cpp,"    char * data;
    char * &dataRef = data;
    data = NULL;
    
    data = new char[100];
    
    strcpy(data, ""A String"");
    printLine(data);
    {
        char * data = dataRef;
        
        ; 
"
7575,0,CWE190_Integer_Overflow__int64_t_rand_preinc_51a.c,"    int64_t data;
    data = 0LL;
    
    data = (int64_t)RAND64();
"
9443,0,CWE190_Integer_Overflow__int64_t_fscanf_preinc_52a.c,"    int64_t data;
    data = 0LL;
    
    fscanf (stdin, ""%"" SCNd64, &data);
"
18071,1,CWE758_Undefined_Behavior__char_pointer_alloca_use_14.c,"    if(globalFive!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            char * data;
            char * * pointer = (char * *)ALLOCA(sizeof(char *));
            data = ""string"";
            *pointer = data; 
            {
                char * data = *pointer;
                printLine(data);
            }
        }
"
347,0,CWE476_NULL_Pointer_Dereference__int_17.c,"    int i,j;
    int * data;
    for(i = 0; i < 1; i++)
    {
        
        data = NULL;
    }
    for(j = 0; j < 1; j++)
    {
        
        printIntLine(*data);
"
14851,0,CWE590_Free_Memory_Not_on_Heap__free_int_declare_74a.cpp,"    int * data;
    map<int, int *> dataMap;
    data = NULL; 
    {
        
        int dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5;
            }
        }
        data = dataBuffer;
    }
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
13895,0,CWE416_Use_After_Free__new_delete_array_char_14.cpp,"    char * data;
    
    data = NULL;
    if(globalFive==5)
    {
        data = new char[100];
        memset(data, 'A', 100-1);
        data[100-1] = '\0';
        
        delete [] data;
    }
    if(globalFive==5)
    {
        
        printLine(data);
        
"
15392,0,CWE134_Uncontrolled_Format_String__char_file_snprintf_83_bad.cpp,"Label Definition File: CWE134_Uncontrolled_Format_String.label.xml
Template File: sources-sinks-83_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 134 Uncontrolled Format String
 * BadSource: file Read input from a file
 * GoodSource: Copy a fixed string into data
 * Sinks: snprintf
 *    GoodSink: snprintf with ""%s"" as the third argument and data as the fourth
 *    BadSink : snprintf with data as the third argument
 * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE134_Uncontrolled_Format_String__char_file_snprintf_83.h""

#ifdef _WIN32
#define FILENAME ""C:\\temp\\file.txt""
#else
#define FILENAME ""/tmp/file.txt""
#endif

#ifdef _WIN32
#define SNPRINTF _snprintf
#else
#define SNPRINTF snprintf
#endif

namespace CWE134_Uncontrolled_Format_String__char_file_snprintf_83
{
CWE134_Uncontrolled_Format_String__char_file_snprintf_83_bad::CWE134_Uncontrolled_Format_String__char_file_snprintf_83_bad(char * dataCopy)
{
    data = dataCopy;
    {
        
        size_t dataLen = strlen(data);
        FILE * pFile;
        
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
}

CWE134_Uncontrolled_Format_String__char_file_snprintf_83_bad::~CWE134_Uncontrolled_Format_String__char_file_snprintf_83_bad()
{
    {
        char dest[100] = """";
        
        SNPRINTF(dest, 100-1, data);
        printLine(dest);
    }
}
}
"
14636,0,CWE369_Divide_by_Zero__int_rand_divide_33.cpp,"    int data;
    int &dataRef = data;
    
    data = -1;
    
    data = RAND32();
    {
        int data = dataRef;
        
        printIntLine(100 / data);
"
9974,0,CWE415_Double_Free__new_delete_long_01.cpp,"    long * data;
    
    data = NULL;
    data = new long;
    
    delete data;
    
"
15419,0,CWE134_Uncontrolled_Format_String__char_file_printf_83_bad.cpp,"Label Definition File: CWE134_Uncontrolled_Format_String.label.xml
Template File: sources-sinks-83_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 134 Uncontrolled Format String
 * BadSource: file Read input from a file
 * GoodSource: Copy a fixed string into data
 * Sinks: printf
 *    GoodSink: printf with ""%s"" as the first argument and data as the second
 *    BadSink : printf with only data as an argument
 * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE134_Uncontrolled_Format_String__char_file_printf_83.h""

#ifdef _WIN32
#define FILENAME ""C:\\temp\\file.txt""
#else
#define FILENAME ""/tmp/file.txt""
#endif

namespace CWE134_Uncontrolled_Format_String__char_file_printf_83
{
CWE134_Uncontrolled_Format_String__char_file_printf_83_bad::CWE134_Uncontrolled_Format_String__char_file_printf_83_bad(char * dataCopy)
{
    data = dataCopy;
    {
        
        size_t dataLen = strlen(data);
        FILE * pFile;
        
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
}

CWE134_Uncontrolled_Format_String__char_file_printf_83_bad::~CWE134_Uncontrolled_Format_String__char_file_printf_83_bad()
{
    
    printf(data);
}
}
"
17962,0,CWE369_Divide_by_Zero__float_fgets_33.cpp,"    float data;
    float &dataRef = data;
    
    data = 0.0F;
    {
        char inputBuffer[CHAR_ARRAY_SIZE];
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = (float)atof(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    {
        float data = dataRef;
        {
            
            int result = (int)(100.0 / data);
            printIntLine(result);
        }
"
14629,1,CWE587_Assignment_of_Fixed_Address_to_Pointer__basic_09.c,"    if(GLOBAL_CONST_FALSE)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            
            char charStack = 'a';
            char *charPointer = &charStack;
            printHexCharLine(*charPointer);
        }
"
6775,0,CWE590_Free_Memory_Not_on_Heap__delete_array_char_alloca_09.cpp,"    char * data;
    data = NULL; 
    if(GLOBAL_CONST_TRUE)
    {
        {
            
            char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
            memset(dataBuffer, 'A', 100-1); 
            dataBuffer[100-1] = '\0'; 
            data = dataBuffer;
        }
    }
    printLine(data);
    
"
17375,0,CWE789_Uncontrolled_Mem_Alloc__new_char_connect_socket_73a.cpp,"    size_t data;
    list<size_t> dataList;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = strtoul(inputBuffer, NULL, 0);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
11580,0,CWE78_OS_Command_Injection__char_listen_socket_execlp_22a.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    CWE78_OS_Command_Injection__char_listen_socket_execlp_22_badGlobal = 1; 
    data = CWE78_OS_Command_Injection__char_listen_socket_execlp_22_badSource(data);
    /* execlp - searches for the location of the command among
     * the directories specified by the PATH environment variable */
    
"
11598,0,CWE190_Integer_Overflow__unsigned_int_rand_square_72a.cpp,"    unsigned int data;
    vector<unsigned int> dataVector;
    data = 0;
    
    data = (unsigned int)RAND32();
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
2597,0,CWE401_Memory_Leak__int64_t_calloc_04.c,"    int64_t * data;
    data = NULL;
    if(STATIC_CONST_TRUE)
    {
        
        data = (int64_t *)calloc(100, sizeof(int64_t));
        if (data == NULL) {exit(-1);}
        
        data[0] = 5LL;
        printLongLongLine(data[0]);
    }
    if(STATIC_CONST_TRUE)
    {
        
        ; 
"
14118,0,CWE590_Free_Memory_Not_on_Heap__delete_struct_static_66a.cpp,"    twoIntsStruct * data;
    twoIntsStruct * dataArray[5];
    data = NULL; 
    {
        
        static twoIntsStruct dataBuffer;
        dataBuffer.intOne = 1;
        dataBuffer.intTwo = 1;
        data = &dataBuffer;
    }
    
    dataArray[2] = data;
"
2520,0,CWE590_Free_Memory_Not_on_Heap__free_long_declare_33.cpp,"    long * data;
    long * &dataRef = data;
    data = NULL; 
    {
        
        long dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5L;
            }
        }
        data = dataBuffer;
    }
    {
        long * data = dataRef;
        printLongLine(data[0]);
        
        free(data);
"
16448,0,CWE401_Memory_Leak__new_int_44.cpp,"    int * data;
    
    void (*funcPtr) (int *) = badSink;
    data = NULL;
    
    data = new int;
    
    *data = 5;
    printIntLine(*data);
    
"
14379,0,CWE457_Use_of_Uninitialized_Variable__twointsclass_array_alloca_no_init_08.cpp,"    TwoIntsClass * data;
    data = reinterpret_cast<TwoIntsClass *>(ALLOCA(10*sizeof(TwoIntsClass)));
    if(staticReturnsTrue())
    {
        
        ; 
    }
    if(staticReturnsTrue())
    {
        
        for(int i=0; i<10; i++)
        {
            printIntLine(data[i].intOne);
            printIntLine(data[i].intTwo);
        }
"
6180,0,CWE78_OS_Command_Injection__char_environment_execl_53a.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        
        if (environment != NULL)
        {
            
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
"
14592,0,CWE590_Free_Memory_Not_on_Heap__free_long_declare_18.c,"    long * data;
    data = NULL; 
    goto source;
source:
    {
        
        long dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5L;
            }
        }
        data = dataBuffer;
    }
    printLongLine(data[0]);
    
"
15984,0,CWE197_Numeric_Truncation_Error__short_fscanf_62a.cpp,"    short data;
    
    data = -1;
    badSource(data);
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
9795,0,CWE190_Integer_Overflow__int_connect_socket_add_32.c,"    int data;
    int *dataPtr1 = &data;
    int *dataPtr2 = &data;
    
    data = 0;
    {
        int data = *dataPtr1;
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
        *dataPtr1 = data;
    }
    {
        int data = *dataPtr2;
        {
            
            int result = data + 1;
            printIntLine(result);
        }
"
1288,0,CWE190_Integer_Overflow__int_fscanf_preinc_66a.c,"    int data;
    int dataArray[5];
    
    data = 0;
    
    fscanf(stdin, ""%d"", &data);
    
    dataArray[2] = data;
"
12913,0,CWE590_Free_Memory_Not_on_Heap__delete_int64_t_static_52a.cpp,"    int64_t * data;
    data = NULL; 
    {
        
        static int64_t dataBuffer;
        dataBuffer = 5LL;
        data = &dataBuffer;
    }
"
18002,0,CWE563_Unused_Variable__unused_uninit_variable_struct_81_bad.cpp,"Label Definition File: CWE563_Unused_Variable__unused_uninit_variable.label.xml
Template File: source-sinks-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 563 Unused Variable
 * BadSource:  Initialize data
 * Sinks:
 *    GoodSink: Initialize, then use data
 *    BadSink : Do nothing
 * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE563_Unused_Variable__unused_uninit_variable_struct_81.h""

namespace CWE563_Unused_Variable__unused_uninit_variable_struct_81
{

void CWE563_Unused_Variable__unused_uninit_variable_struct_81_bad::action(twoIntsStruct data) const
{
    
    
    ; 
}

}
"
2244,0,CWE78_OS_Command_Injection__char_console_system_32.c,"    char * data;
    char * *dataPtr1 = &data;
    char * *dataPtr2 = &data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
        char * data = *dataPtr1;
        {
            
            size_t dataLen = strlen(data);
            
            if (100-dataLen > 1)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
                {
                    /* The next few lines remove the carriage return from the string that is
"
15656,0,CWE590_Free_Memory_Not_on_Heap__delete_array_class_declare_74a.cpp,"    TwoIntsClass * data;
    map<int, TwoIntsClass *> dataMap;
    data = NULL; 
    {
        
        TwoIntsClass dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i].intOne = 1;
                dataBuffer[i].intTwo = 1;
            }
        }
        data = dataBuffer;
    }
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
1075,0,CWE416_Use_After_Free__new_delete_array_int_06.cpp,"    int * data;
    
    data = NULL;
    if(STATIC_CONST_FIVE==5)
    {
        data = new int[100];
        {
            size_t i;
            for(i = 0; i < 100; i++)
            {
                data[i] = 5;
            }
        }
        
        delete [] data;
    }
    if(STATIC_CONST_FIVE==5)
    {
        
        printIntLine(data[0]);
        
"
17541,0,CWE190_Integer_Overflow__int64_t_max_multiply_08.c,"    int64_t data;
    data = 0LL;
    if(staticReturnsTrue())
    {
        
        data = LLONG_MAX;
    }
    if(staticReturnsTrue())
    {
        if(data > 0) 
        {
            
            int64_t result = data * 2;
            printLongLongLine(result);
        }
"
6670,0,CWE78_OS_Command_Injection__char_environment_popen_72a.cpp,"    char * data;
    vector<char *> dataVector;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
        
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        
        if (environment != NULL)
        {
            
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
12918,0,CWE190_Integer_Overflow__int_rand_preinc_06.c,"    int data;
    
    data = 0;
    if(STATIC_CONST_FIVE==5)
    {
        
        data = RAND32();
    }
    if(STATIC_CONST_FIVE==5)
    {
        {
            
            ++data;
            int result = data;
            printIntLine(result);
        }
"
12922,0,CWE401_Memory_Leak__new_int64_t_81_bad.cpp,"Label Definition File: CWE401_Memory_Leak__new.label.xml
Template File: sources-sinks-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 401 Memory Leak
 * BadSource:  Allocate data using new
 * GoodSource: Allocate data on the stack
 * Sinks:
 *    GoodSink: call delete on data
 *    BadSink : no deallocation of data
 * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE401_Memory_Leak__new_int64_t_81.h""

namespace CWE401_Memory_Leak__new_int64_t_81
{

void CWE401_Memory_Leak__new_int64_t_81_bad::action(int64_t * data) const
{
    
    ; 
}

}
"
12606,0,CWE457_Use_of_Uninitialized_Variable__int_array_declare_partial_init_03.c,"    int * data;
    int dataUninitArray[10];
    data = dataUninitArray;
    if(5==5)
    {
        
        {
            int i;
            for(i=0; i<(10/2); i++)
            {
                data[i] = i;
            }
        }
    }
    if(5==5)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i]);
            }
        }
"
7742,0,CWE563_Unused_Variable__unused_uninit_variable_char_82a.cpp,"    char data;
    
    ; 
    CWE563_Unused_Variable__unused_uninit_variable_char_82_base* baseObject = new CWE563_Unused_Variable__unused_uninit_variable_char_82_bad;
    baseObject->action(data);
"
9889,0,CWE190_Integer_Overflow__int_connect_socket_square_84_bad.cpp,"Label Definition File: CWE190_Integer_Overflow__int.label.xml
Template File: sources-sinks-84_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 190 Integer Overflow
 * BadSource: connect_socket Read data using a connect socket (client side)
 * GoodSource: Set data to a small, non-zero number (two)
 * Sinks: square
 *    GoodSink: Ensure there will not be an overflow before squaring data
 *    BadSink : Square data, which can lead to overflow
 * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE190_Integer_Overflow__int_connect_socket_square_84.h""

#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif

#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)

#include <math.h>

namespace CWE190_Integer_Overflow__int_connect_socket_square_84
{
CWE190_Integer_Overflow__int_connect_socket_square_84_bad::CWE190_Integer_Overflow__int_connect_socket_square_84_bad(int dataCopy)
{
    data = dataCopy;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
}

CWE190_Integer_Overflow__int_connect_socket_square_84_bad::~CWE190_Integer_Overflow__int_connect_socket_square_84_bad()
{
    {
        
        int result = data * data;
        printIntLine(result);
    }
}
}
"
7192,0,CWE416_Use_After_Free__new_delete_array_int_01.cpp,"    int * data;
    
    data = NULL;
    data = new int[100];
    {
        size_t i;
        for(i = 0; i < 100; i++)
        {
            data[i] = 5;
        }
    }
    
    delete [] data;
    
    printIntLine(data[0]);
"
18148,1,CWE252_Unchecked_Return_Value__char_puts_06.c,"    if(STATIC_CONST_FIVE==5)
    {
        
        if (PUTS(""string"") == EOF)
        {
            printLine(""puts failed!"");
        }
"
16784,0,CWE415_Double_Free__malloc_free_long_21.c,"    long * data;
    
    data = NULL;
    data = (long *)malloc(100*sizeof(long));
    if (data == NULL) {exit(-1);}
    
    free(data);
    badStatic = 1; 
"
14429,0,CWE590_Free_Memory_Not_on_Heap__delete_struct_static_06.cpp,"    twoIntsStruct * data;
    data = NULL; 
    if(STATIC_CONST_FIVE==5)
    {
        {
            
            static twoIntsStruct dataBuffer;
            dataBuffer.intOne = 1;
            dataBuffer.intTwo = 1;
            data = &dataBuffer;
        }
    }
    printStructLine(data);
    
"
15782,0,CWE457_Use_of_Uninitialized_Variable__int_14.c,"    int data;
    if(globalFive==5)
    {
        
        ; 
    }
    if(globalFive==5)
    {
        
        printIntLine(data);
"
173,0,CWE415_Double_Free__new_delete_struct_62a.cpp,"    twoIntsStruct * data;
    
    data = NULL;
    badSource(data);
    
"
3374,0,CWE78_OS_Command_Injection__char_file_execl_84a.cpp,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    CWE78_OS_Command_Injection__char_file_execl_84_bad * badObject = new CWE78_OS_Command_Injection__char_file_execl_84_bad(data);
"
12105,0,CWE190_Integer_Overflow__char_rand_preinc_34.c,"    char data;
    CWE190_Integer_Overflow__char_rand_preinc_34_unionType myUnion;
    data = ' ';
    
    data = (char)RAND32();
    myUnion.unionFirst = data;
    {
        char data = myUnion.unionSecond;
        {
            
            ++data;
            char result = data;
            printHexCharLine(result);
        }
"
14579,0,CWE78_OS_Command_Injection__char_console_execlp_82a.cpp,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        
        if (100-dataLen > 1)
        {
            
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgets() */
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
                    data[dataLen-1] = '\0';
                }
            }
            else
            {
                printLine(""fgets() failed"");
                
                data[dataLen] = '\0';
            }
        }
    }
    CWE78_OS_Command_Injection__char_console_execlp_82_base* baseObject = new CWE78_OS_Command_Injection__char_console_execlp_82_bad;
    baseObject->action(data);
"
8221,0,CWE78_OS_Command_Injection__char_console_system_04.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(STATIC_CONST_TRUE)
    {
        {
            
            size_t dataLen = strlen(data);
            
            if (100-dataLen > 1)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
                {
                    /* The next few lines remove the carriage return from the string that is
                     * inserted by fgets() */
                    dataLen = strlen(data);
"
17105,0,CWE690_NULL_Deref_From_Return__struct_calloc_17.c,"    int j;
    twoIntsStruct * data;
    data = NULL; 
    
    data = (twoIntsStruct *)calloc(1, sizeof(twoIntsStruct));
    for(j = 0; j < 1; j++)
    {
        
        data[0].intOne = 1;
        data[0].intTwo = 1;
        printStructLine(&data[0]);
        free(data);
"
13058,0,CWE590_Free_Memory_Not_on_Heap__delete_struct_declare_11.cpp,"    twoIntsStruct * data;
    data = NULL; 
    if(globalReturnsTrue())
    {
        {
            
            twoIntsStruct dataBuffer;
            dataBuffer.intOne = 1;
            dataBuffer.intTwo = 1;
            data = &dataBuffer;
        }
    }
    printStructLine(data);
    
"
604,0,CWE190_Integer_Overflow__int_rand_multiply_45.c,"    int data;
    
    data = 0;
    
    data = RAND32();
    CWE190_Integer_Overflow__int_rand_multiply_45_badData = data;
"
2270,0,CWE457_Use_of_Uninitialized_Variable__struct_array_alloca_no_init_15.c,"    twoIntsStruct * data;
    data = (twoIntsStruct *)ALLOCA(10*sizeof(twoIntsStruct));
    switch(6)
    {
    case 6:
        
        ; 
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
        
    {
        int i;
        for(i=0; i<10; i++)
        {
            printIntLine(data[i].intOne);
            printIntLine(data[i].intTwo);
        }
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
9988,0,CWE587_Assignment_of_Fixed_Address_to_Pointer__basic_01.c,"    {
        
        char *charPointer = (char*)0x400000;
        printHexCharLine(*charPointer);
"
1250,1,CWE758_Undefined_Behavior__int_pointer_malloc_use_08.c,"    if(staticReturnsFalse())
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            int * data;
            int * * pointer = (int * *)malloc(sizeof(int *));
            if (pointer == NULL) {exit(-1);}
            
            data = (int *)malloc(sizeof(int));
            if (data == NULL) {exit(-1);}
            *data = 5;
            *pointer = data; 
            {
                int * data = *pointer;
                printIntLine(*data);
            }
            free(pointer);
        }
"
13971,0,CWE190_Integer_Overflow__short_fscanf_square_51a.c,"    short data;
    data = 0;
    
    fscanf (stdin, ""%hd"", &data);
"
13398,0,CWE190_Integer_Overflow__short_max_preinc_68a.c,"    short data;
    data = 0;
    
    data = SHRT_MAX;
    CWE190_Integer_Overflow__short_max_preinc_68_badData = data;
"
19237,0,CWE590_Free_Memory_Not_on_Heap__delete_int64_t_static_51a.cpp,"    int64_t * data;
    data = NULL; 
    {
        
        static int64_t dataBuffer;
        dataBuffer = 5LL;
        data = &dataBuffer;
    }
"
15481,0,CWE457_Use_of_Uninitialized_Variable__struct_array_declare_no_init_64a.c,"    twoIntsStruct * data;
    twoIntsStruct dataUninitArray[10];
    data = dataUninitArray;
    
    ; 
"
19115,0,CWE197_Numeric_Truncation_Error__short_connect_socket_53a.c,"    short data;
    
    data = -1;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = (short)atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
14528,0,CWE190_Integer_Overflow__int_fscanf_square_08.c,"    int data;
    
    data = 0;
    if(staticReturnsTrue())
    {
        
        fscanf(stdin, ""%d"", &data);
    }
    if(staticReturnsTrue())
    {
        {
            
            int result = data * data;
            printIntLine(result);
        }
"
14438,0,CWE415_Double_Free__new_delete_array_long_31.cpp,"    long * data;
    
    data = NULL;
    data = new long[100];
    
    delete [] data;
    {
        long * dataCopy = data;
        long * data = dataCopy;
        
        delete [] data;
"
16009,1,CWE401_Memory_Leak__malloc_realloc_int_18.c,"    goto sink;
sink:
    {
        int * data = (int *)malloc(100*sizeof(int));
        if (data == NULL) {exit(-1);}
        int * tmpData;
        
        data[0] = 5;
        printIntLine(data[0]);
        tmpData = (int *)realloc(data, (130000)*sizeof(int));
        /* FIX: Ensure realloc() was successful before assigning data to the memory block
        * allocated with realloc() */
        if (tmpData != NULL)
        {
            data = tmpData;
            
            data[0] = 10;
            printIntLine(data[0]);
        }
        free(data);
"
13193,0,CWE758_Undefined_Behavior__int_new_use_07.cpp,"    if(staticFive==5)
    {
        {
            int * pointer = new int;
            int data = *pointer; 
            delete pointer;
            printIntLine(data);
        }
"
4308,0,CWE401_Memory_Leak__twoIntsStruct_realloc_63a.c,"    twoIntsStruct * data;
    data = NULL;
    
    data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));
    if (data == NULL) {exit(-1);}
    
    data[0].intOne = 0;
    data[0].intTwo = 0;
    printStructLine(&data[0]);
"
19159,0,CWE758_Undefined_Behavior__struct_alloca_use_05.c,"    if(staticTrue)
    {
        {
            twoIntsStruct * pointer = (twoIntsStruct *)ALLOCA(sizeof(twoIntsStruct));
            twoIntsStruct data = *pointer; 
            printIntLine(data.intOne);
            printIntLine(data.intTwo);
        }
"
18447,0,CWE758_Undefined_Behavior__double_pointer_malloc_use_18.c,"    goto sink;
sink:
    {
        double * * pointer = (double * *)malloc(sizeof(double *));
        if (pointer == NULL) {exit(-1);}
        double * data = *pointer; 
        free(pointer);
        printDoubleLine(*data);
"
17027,0,CWE457_Use_of_Uninitialized_Variable__new_int_array_partial_init_15.cpp,"    int * data;
    data = new int[10];
    switch(6)
    {
    case 6:
        
    {
        int i;
        for(i=0; i<(10/2); i++)
        {
            data[i] = i;
        }
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
        
    {
        int i;
        for(i=0; i<10; i++)
        {
            printIntLine(data[i]);
        }
    }
    
    delete [] data;
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
17806,0,CWE590_Free_Memory_Not_on_Heap__delete_long_placement_new_02.cpp,"    long * data;
    data = NULL; 
    if(1)
    {
        {
            
            char buffer[sizeof(long)];
            long * dataBuffer = new(buffer) long;
            *dataBuffer = 5L;
            data = dataBuffer;
        }
    }
    printLongLine(*data);
    
"
13664,0,CWE590_Free_Memory_Not_on_Heap__free_long_declare_44.c,"    long * data;
    
    void (*funcPtr) (long *) = badSink;
    data = NULL; 
    {
        
        long dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5L;
            }
        }
        data = dataBuffer;
    }
    
"
15012,0,CWE590_Free_Memory_Not_on_Heap__delete_array_struct_declare_02.cpp,"    twoIntsStruct * data;
    data = NULL; 
    if(1)
    {
        {
            
            twoIntsStruct dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i].intOne = 1;
                    dataBuffer[i].intTwo = 1;
                }
            }
            data = dataBuffer;
        }
    }
    printStructLine(&data[0]);
    
"
15370,0,CWE190_Integer_Overflow__char_fscanf_square_32.c,"    char data;
    char *dataPtr1 = &data;
    char *dataPtr2 = &data;
    data = ' ';
    {
        char data = *dataPtr1;
        
        fscanf (stdin, ""%c"", &data);
        *dataPtr1 = data;
    }
    {
        char data = *dataPtr2;
        {
            
            char result = data * data;
            printHexCharLine(result);
        }
"
15272,0,CWE190_Integer_Overflow__short_max_add_44.c,"    short data;
    
    void (*funcPtr) (short) = badSink;
    data = 0;
    
    data = SHRT_MAX;
    
"
6722,0,CWE690_NULL_Deref_From_Return__int64_t_realloc_83_bad.cpp,"Label Definition File: CWE690_NULL_Deref_From_Return.free.label.xml
Template File: source-sinks-83_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 690 Unchecked Return Value To NULL Pointer
 * BadSource: realloc Allocate data using realloc()
 * Sinks:
 *    GoodSink: Check to see if the data allocation failed and if not, use data
 *    BadSink : Don't check for NULL and use data
 * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE690_NULL_Deref_From_Return__int64_t_realloc_83.h""

namespace CWE690_NULL_Deref_From_Return__int64_t_realloc_83
{
CWE690_NULL_Deref_From_Return__int64_t_realloc_83_bad::CWE690_NULL_Deref_From_Return__int64_t_realloc_83_bad(int64_t * dataCopy)
{
    data = dataCopy;
    
    data = (int64_t *)realloc(data, 1*sizeof(int64_t));
}

CWE690_NULL_Deref_From_Return__int64_t_realloc_83_bad::~CWE690_NULL_Deref_From_Return__int64_t_realloc_83_bad()
{
    
    data[0] = 5LL;
    printLongLongLine(data[0]);
    free(data);
}
}
"
2348,0,CWE190_Integer_Overflow__unsigned_int_rand_square_68a.c,"    unsigned int data;
    data = 0;
    
    data = (unsigned int)RAND32();
    CWE190_Integer_Overflow__unsigned_int_rand_square_68_badData = data;
"
16193,0,CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_14.c,"    unsigned int data;
    data = 0;
    if(globalFive==5)
    {
        
        fscanf (stdin, ""%u"", &data);
    }
    if(globalFive==5)
    {
        if(data > 0) 
        {
            
            unsigned int result = data * 2;
            printUnsignedLine(result);
        }
"
4277,0,CWE190_Integer_Overflow__int_listen_socket_postinc_21.c,"    int data;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    badStatic = 1; 
"
8219,0,CWE590_Free_Memory_Not_on_Heap__delete_char_placement_new_31.cpp,"    char * data;
    data = NULL; 
    {
        
        char buffer[sizeof(char)];
        char * dataBuffer = new(buffer) char;
        *dataBuffer = 'A';
        data = dataBuffer;
    }
    {
        char * dataCopy = data;
        char * data = dataCopy;
        printHexCharLine(*data);
        
        delete data;
"
14002,0,CWE690_NULL_Deref_From_Return__struct_calloc_45.c,"    twoIntsStruct * data;
    data = NULL; 
    
    data = (twoIntsStruct *)calloc(1, sizeof(twoIntsStruct));
    CWE690_NULL_Deref_From_Return__struct_calloc_45_badData = data;
"
5916,0,CWE415_Double_Free__malloc_free_char_05.c,"    char * data;
    
    data = NULL;
    if(staticTrue)
    {
        data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        
        free(data);
    }
    if(staticTrue)
    {
        
        free(data);
"
11343,0,CWE590_Free_Memory_Not_on_Heap__delete_class_declare_67a.cpp,"    TwoIntsClass * data;
    structType myStruct;
    data = NULL; 
    {
        
        TwoIntsClass dataBuffer;
        dataBuffer.intOne = 1;
        dataBuffer.intTwo = 1;
        data = &dataBuffer;
    }
    myStruct.structFirst = data;
"
16183,0,CWE415_Double_Free__new_delete_char_18.cpp,"    char * data;
    
    data = NULL;
    goto source;
source:
    data = new char;
    
    delete data;
    goto sink;
sink:
    
"
1762,0,CWE401_Memory_Leak__twoIntsStruct_malloc_22a.c,"    twoIntsStruct * data;
    data = NULL;
    
    data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
    if (data == NULL) {exit(-1);}
    
    data[0].intOne = 0;
    data[0].intTwo = 0;
    printStructLine(&data[0]);
    CWE401_Memory_Leak__twoIntsStruct_malloc_22_badGlobal = 1; 
"
18827,0,CWE401_Memory_Leak__malloc_realloc_int64_t_02.c,"    if(1)
    {
        {
            int64_t * data = (int64_t *)malloc(100*sizeof(int64_t));
            if (data == NULL) {exit(-1);}
            
            data[0] = 5LL;
            printLongLongLine(data[0]);
            
            data = (int64_t *)realloc(data, (130000)*sizeof(int64_t));
            if (data != NULL)
            {
                
                data[0] = 10LL;
                printLongLongLine(data[0]);
                free(data);
            }
        }
"
10093,0,CWE369_Divide_by_Zero__int_zero_divide_01.c,"    int data;
    
    data = -1;
    
    data = 0;
    
"
12942,0,CWE190_Integer_Overflow__int64_t_max_square_05.c,"    int64_t data;
    data = 0LL;
    if(staticTrue)
    {
        
        data = LLONG_MAX;
    }
    if(staticTrue)
    {
        {
            
            int64_t result = data * data;
            printLongLongLine(result);
        }
"
5750,0,CWE78_OS_Command_Injection__char_file_execl_34.c,"    char * data;
    CWE78_OS_Command_Injection__char_file_execl_34_unionType myUnion;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        FILE * pFile;
        
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
    myUnion.unionFirst = data;
    {
        char * data = myUnion.unionSecond;
        
        
        EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
"
12618,0,CWE457_Use_of_Uninitialized_Variable__double_18.c,"    double data;
    goto source;
source:
    
    ; 
    goto sink;
sink:
    
"
3693,0,CWE467_Use_of_sizeof_on_Pointer_Type__char_17.c,"    int j;
    for(j = 0; j < 1; j++)
    {
        {
            char * badChar = NULL;
            
            badChar = (char *)malloc(sizeof(badChar));
            if (badChar == NULL) {exit(-1);}
            *badChar = 'B';
            printHexCharLine(*badChar);
            free(badChar);
        }
"
5361,0,CWE190_Integer_Overflow__char_max_square_54a.c,"    char data;
    data = ' ';
    
    data = CHAR_MAX;
"
11025,0,CWE78_OS_Command_Injection__char_connect_socket_system_17.c,"    int i;
    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    for(i = 0; i < 1; i++)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET connectSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
"
12923,0,CWE590_Free_Memory_Not_on_Heap__delete_int_placement_new_64a.cpp,"    int * data;
    data = NULL; 
    {
        
        char buffer[sizeof(int)];
        int * dataBuffer = new(buffer) int;
        *dataBuffer = 5;
        data = dataBuffer;
    }
"
16684,0,CWE190_Integer_Overflow__char_rand_square_68a.c,"    char data;
    data = ' ';
    
    data = (char)RAND32();
    CWE190_Integer_Overflow__char_rand_square_68_badData = data;
"
16207,0,CWE134_Uncontrolled_Format_String__char_environment_vprintf_81a.cpp,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        
        if (environment != NULL)
        {
            
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    const CWE134_Uncontrolled_Format_String__char_environment_vprintf_81_base& baseObject = CWE134_Uncontrolled_Format_String__char_environment_vprintf_81_bad();
"
7370,0,CWE415_Double_Free__new_delete_array_struct_83_bad.cpp,"Label Definition File: CWE415_Double_Free__new_delete_array.label.xml
Template File: sources-sinks-83_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 415 Double Free
 * BadSource:  Allocate data using new and Deallocae data using delete
 * GoodSource: Allocate data using new
 * Sinks:
 *    GoodSink: do nothing
 *    BadSink : Deallocate data using delete
 * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE415_Double_Free__new_delete_array_struct_83.h""

namespace CWE415_Double_Free__new_delete_array_struct_83
{
CWE415_Double_Free__new_delete_array_struct_83_bad::CWE415_Double_Free__new_delete_array_struct_83_bad(twoIntsStruct * dataCopy)
{
    data = dataCopy;
    data = new twoIntsStruct[100];
    
    delete [] data;
}

CWE415_Double_Free__new_delete_array_struct_83_bad::~CWE415_Double_Free__new_delete_array_struct_83_bad()
{
    
    delete [] data;
}
}
"
18642,1,CWE252_Unchecked_Return_Value__char_scanf_03.c,"    if(5!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            
            if (scanf(""%99s\0"", data) == EOF)
            {
                printLine(""scanf failed!"");
            }
        }
"
11299,1,CWE758_Undefined_Behavior__int_malloc_use_09.c,"    if(GLOBAL_CONST_FALSE)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            int data;
            int * pointer = (int *)malloc(sizeof(int));
            if (pointer == NULL) {exit(-1);}
            data = 5;
            *pointer = data; 
            {
                int data = *pointer;
                printIntLine(data);
            }
            free(pointer);
        }
"
11835,0,CWE369_Divide_by_Zero__int_connect_socket_modulo_72a.cpp,"    int data;
    vector<int> dataVector;
    
    data = -1;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
2781,1,CWE252_Unchecked_Return_Value__char_fgets_11.c,"    if(globalReturnsFalse())
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            printLine(""Please enter a string: "");
            
            if (fgets(data, 100, stdin) == NULL)
            {
                printLine(""fgets failed!"");
                exit(1);
            }
            printLine(data);
        }
"
13357,0,CWE190_Integer_Overflow__char_fscanf_square_63a.c,"    char data;
    data = ' ';
    
    fscanf (stdin, ""%c"", &data);
"
9156,0,CWE190_Integer_Overflow__int64_t_fscanf_preinc_01.c,"    int64_t data;
    data = 0LL;
    
    fscanf (stdin, ""%"" SCNd64, &data);
    {
        
        ++data;
        int64_t result = data;
        printLongLongLine(result);
"
7346,0,CWE134_Uncontrolled_Format_String__char_connect_socket_printf_64a.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
1219,1,CWE475_Undefined_Behavior_for_Input_to_API__char_02.c,"    if(1)
    {
        {
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            strcpy(data, ""abcdefghijklmnopqrstuvwxyz"");
            
            memmove(data + 6, data + 4, 10*sizeof(char));
            printLine(data);
        }
"
4600,0,CWE590_Free_Memory_Not_on_Heap__delete_int64_t_placement_new_73a.cpp,"    int64_t * data;
    list<int64_t *> dataList;
    data = NULL; 
    {
        
        char buffer[sizeof(int64_t)];
        int64_t * dataBuffer = new(buffer) int64_t;
        *dataBuffer = 5LL;
        data = dataBuffer;
    }
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
17066,0,CWE415_Double_Free__malloc_free_int_01.c,"    int * data;
    
    data = NULL;
    data = (int *)malloc(100*sizeof(int));
    if (data == NULL) {exit(-1);}
    
    free(data);
    
"
10192,0,CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_04.c,"    int data;
    
    data = -1;
    if(STATIC_CONST_TRUE)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
6786,0,CWE190_Integer_Overflow__int64_t_rand_square_31.c,"    int64_t data;
    data = 0LL;
    
    data = (int64_t)RAND64();
    {
        int64_t dataCopy = data;
        int64_t data = dataCopy;
        {
            
            int64_t result = data * data;
            printLongLongLine(result);
        }
"
2320,0,CWE369_Divide_by_Zero__float_fscanf_11.c,"    float data;
    
    data = 0.0F;
    if(globalReturnsTrue())
    {
        
        fscanf (stdin, ""%f"", &data);
    }
    if(globalReturnsTrue())
    {
        {
            
            int result = (int)(100.0 / data);
            printIntLine(result);
        }
"
18083,0,CWE190_Integer_Overflow__int64_t_fscanf_add_07.c,"    int64_t data;
    data = 0LL;
    if(staticFive==5)
    {
        
        fscanf (stdin, ""%"" SCNd64, &data);
    }
    if(staticFive==5)
    {
        {
            
            int64_t result = data + 1;
            printLongLongLine(result);
        }
"
4130,0,CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_83_bad.cpp,"Label Definition File: CWE134_Uncontrolled_Format_String.vasinks.label.xml
Template File: sources-vasinks-83_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 134 Uncontrolled Format String
 * BadSource: listen_socket Read data using a listen socket (server side)
 * GoodSource: Copy a fixed string into data
 * Sinks: vprintf
 *    GoodSink: vprintf with a format string
 *    BadSink : vprintf without a format string
 * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack
 *
 * */
#ifndef OMITBAD

#include <stdarg.h>
#include ""std_testcase.h""
#include ""CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_83.h""

#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif

#define TCP_PORT 27015
#define LISTEN_BACKLOG 5

namespace CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_83
{
CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_83_bad::CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_83_bad(char * dataCopy)
{
    data = dataCopy;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
}

static void badVaSink(char * data, ...)
{
    {
        va_list args;
        va_start(args, data);
        
        vprintf(data, args);
        va_end(args);
    }
}

CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_83_bad::~CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_83_bad()
{
    badVaSink(data, data);
}
}
"
4113,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_17.c,"    int i,j;
    size_t data;
    
    data = 0;
    for(i = 0; i < 1; i++)
    {
        
        fscanf(stdin, ""%zu"", &data);
    }
    for(j = 0; j < 1; j++)
    {
        {
            char * myString;
            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
             * for the strcpy() function to not cause a buffer overflow */
            
            if (data > strlen(HELLO_STRING))
            {
                myString = (char *)malloc(data*sizeof(char));
                if (myString == NULL) {exit(-1);}
                
                strcpy(myString, HELLO_STRING);
                printLine(myString);
                free(myString);
            }
            else
            {
                printLine(""Input is less than the length of the source string"");
            }
        }
"
8342,0,CWE476_NULL_Pointer_Dereference__char_16.c,"    char * data;
    while(1)
    {
        
        data = NULL;
        break;
    }
    while(1)
    {
        
        
        printHexCharLine(data[0]);
        break;
"
326,1,CWE688_Function_Call_With_Incorrect_Variable_or_Reference_as_Argument__basic_14.c,"    if(globalFive==5)
    {
        {
            char dest[DEST_SIZE];
            int intFive = 5;
            
            sprintf(dest, ""%d"", intFive);
            printLine(dest);
        }
"
7114,0,CWE401_Memory_Leak__char_realloc_81a.cpp,"    char * data;
    data = NULL;
    
    data = (char *)realloc(data, 100*sizeof(char));
    if (data == NULL) {exit(-1);}
    
    strcpy(data, ""A String"");
    printLine(data);
    const CWE401_Memory_Leak__char_realloc_81_base& baseObject = CWE401_Memory_Leak__char_realloc_81_bad();
"
117,0,CWE190_Integer_Overflow__short_max_postinc_21.c,"    short data;
    data = 0;
    
    data = SHRT_MAX;
    badStatic = 1; 
"
12077,0,CWE190_Integer_Overflow__int_connect_socket_postinc_42.c,"    int data;
    
    data = 0;
    data = badSource(data);
    {
        
        data++;
        int result = data;
        printIntLine(result);
"
1058,0,CWE190_Integer_Overflow__int_max_preinc_51a.c,"    int data;
    
    data = 0;
    
    data = INT_MAX;
"
18365,0,CWE190_Integer_Overflow__int_max_add_31.c,"    int data;
    
    data = 0;
    
    data = INT_MAX;
    {
        int dataCopy = data;
        int data = dataCopy;
        {
            
            int result = data + 1;
            printIntLine(result);
        }
"
15652,0,CWE789_Uncontrolled_Mem_Alloc__new_char_fgets_12.cpp,"    size_t data;
    
    data = 0;
    if(globalReturnsTrueOrFalse())
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                
                data = strtoul(inputBuffer, NULL, 0);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    else
    {
        
        data = 20;
    }
    if(globalReturnsTrueOrFalse())
    {
        {
            char * myString;
            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
             * for the strcpy() function to not cause a buffer overflow */
            
            if (data > strlen(HELLO_STRING))
            {
                myString = new char[data];
                
                strcpy(myString, HELLO_STRING);
                printLine(myString);
                delete [] myString;
            }
            else
            {
                printLine(""Input is less than the length of the source string"");
            }
        }
    }
    else
    {
        {
            char * myString;
            /* FIX: Include a MAXIMUM limitation for memory allocation and a check to ensure data is large enough
             * for the strcpy() function to not cause a buffer overflow */
            
            if (data > strlen(HELLO_STRING) && data < 100)
            {
                myString = new char[data];
                
                strcpy(myString, HELLO_STRING);
                printLine(myString);
                delete [] myString;
            }
            else
            {
                printLine(""Input is less than the length of the source string or too large"");
            }
        }
"
4035,0,CWE401_Memory_Leak__new_array_twointsStruct_82a.cpp,"    twoIntsStruct * data;
    data = NULL;
    
    data = new twoIntsStruct[100];
    
    data[0].intOne = 0;
    data[0].intTwo = 0;
    printStructLine(&data[0]);
    CWE401_Memory_Leak__new_array_twointsStruct_82_base* baseObject = new CWE401_Memory_Leak__new_array_twointsStruct_82_bad;
    baseObject->action(data);
"
18973,1,CWE758_Undefined_Behavior__struct_malloc_use_17.c,"    int k;
    for(k = 0; k < 1; k++)
    {
        {
            twoIntsStruct data;
            twoIntsStruct * pointer = (twoIntsStruct *)malloc(sizeof(twoIntsStruct));
            if (pointer == NULL) {exit(-1);}
            data.intOne = 1;
            data.intTwo = 2;
            *pointer = data; 
            {
                twoIntsStruct data = *pointer;
                printIntLine(data.intOne);
                printIntLine(data.intTwo);
            }
            free(pointer);
        }
"
16315,0,CWE78_OS_Command_Injection__char_connect_socket_execl_08.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(staticReturnsTrue())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET connectSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
"
8677,0,CWE416_Use_After_Free__malloc_free_char_02.c,"    char * data;
    
    data = NULL;
    if(1)
    {
        data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        memset(data, 'A', 100-1);
        data[100-1] = '\0';
        
        free(data);
    }
    if(1)
    {
        
        printLine(data);
        
"
2135,0,CWE401_Memory_Leak__char_calloc_42.c,"    char * data;
    data = NULL;
    data = badSource(data);
    
"
2280,0,CWE197_Numeric_Truncation_Error__short_rand_31.c,"    short data;
    
    data = -1;
    
    data = (short)RAND32();
    {
        short dataCopy = data;
        short data = dataCopy;
        {
            
            char charData = (char)data;
            printHexCharLine(charData);
        }
"
1391,0,CWE590_Free_Memory_Not_on_Heap__delete_int64_t_static_11.cpp,"    int64_t * data;
    data = NULL; 
    if(globalReturnsTrue())
    {
        {
            
            static int64_t dataBuffer;
            dataBuffer = 5LL;
            data = &dataBuffer;
        }
    }
    printLongLongLine(*data);
    
"
11651,0,CWE758_Undefined_Behavior__char_malloc_use_02.c,"    if(1)
    {
        {
            char * pointer = (char *)malloc(sizeof(char));
            if (pointer == NULL) {exit(-1);}
            char data = *pointer; 
            free(pointer);
            printHexCharLine(data);
        }
"
933,0,CWE590_Free_Memory_Not_on_Heap__free_long_alloca_06.c,"    long * data;
    data = NULL; 
    if(STATIC_CONST_FIVE==5)
    {
        {
            
            long * dataBuffer = (long *)ALLOCA(100*sizeof(long));
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5L;
                }
            }
            data = dataBuffer;
        }
    }
    printLongLine(data[0]);
    
"
17238,0,CWE457_Use_of_Uninitialized_Variable__struct_array_declare_partial_init_15.c,"    twoIntsStruct * data;
    twoIntsStruct dataUninitArray[10];
    data = dataUninitArray;
    switch(6)
    {
    case 6:
        
    {
        int i;
        for(i=0; i<(10/2); i++)
        {
            data[i].intOne = i;
            data[i].intTwo = i;
        }
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
        
    {
        int i;
        for(i=0; i<10; i++)
        {
            printIntLine(data[i].intOne);
            printIntLine(data[i].intTwo);
        }
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
11624,0,CWE758_Undefined_Behavior__double_pointer_alloca_use_16.c,"    while(1)
    {
        {
            double * * pointer = (double * *)ALLOCA(sizeof(double *));
            double * data = *pointer; 
            printDoubleLine(*data);
        }
        break;
"
1658,0,CWE457_Use_of_Uninitialized_Variable__struct_13.c,"    twoIntsStruct data;
    if(GLOBAL_CONST_FIVE==5)
    {
        
        ; 
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        
        printIntLine(data.intOne);
        printIntLine(data.intTwo);
"
14536,0,CWE401_Memory_Leak__new_array_TwoIntsClass_17.cpp,"    int i,j;
    TwoIntsClass * data;
    data = NULL;
    for(i = 0; i < 1; i++)
    {
        
        data = new TwoIntsClass[100];
        
        data[0].intOne = 0;
        data[0].intTwo = 0;
        printIntLine(data[0].intOne);
        printIntLine(data[0].intTwo);
    }
    for(j = 0; j < 1; j++)
    {
        
        ; 
"
3577,0,CWE415_Double_Free__malloc_free_struct_81_bad.cpp,"Label Definition File: CWE415_Double_Free__malloc_free.label.xml
Template File: sources-sinks-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 415 Double Free
 * BadSource:  Allocate data using malloc() and Deallocate data using free()
 * GoodSource: Allocate data using malloc()
 * Sinks:
 *    GoodSink: do nothing
 *    BadSink : Deallocate data using free()
 * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE415_Double_Free__malloc_free_struct_81.h""

namespace CWE415_Double_Free__malloc_free_struct_81
{

void CWE415_Double_Free__malloc_free_struct_81_bad::action(twoIntsStruct * data) const
{
    
    free(data);
}

}
"
13729,0,CWE415_Double_Free__malloc_free_struct_82_bad.cpp,"Label Definition File: CWE415_Double_Free__malloc_free.label.xml
Template File: sources-sinks-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 415 Double Free
 * BadSource:  Allocate data using malloc() and Deallocate data using free()
 * GoodSource: Allocate data using malloc()
 * Sinks:
 *    GoodSink: do nothing
 *    BadSink : Deallocate data using free()
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE415_Double_Free__malloc_free_struct_82.h""

namespace CWE415_Double_Free__malloc_free_struct_82
{

void CWE415_Double_Free__malloc_free_struct_82_bad::action(twoIntsStruct * data)
{
    
    free(data);
}

}
"
17424,0,CWE590_Free_Memory_Not_on_Heap__free_int_alloca_64a.c,"    int * data;
    data = NULL; 
    {
        
        int * dataBuffer = (int *)ALLOCA(100*sizeof(int));
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5;
            }
        }
        data = dataBuffer;
    }
"
4043,0,CWE190_Integer_Overflow__unsigned_int_max_square_81_bad.cpp,"Label Definition File: CWE190_Integer_Overflow.label.xml
Template File: sources-sinks-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 190 Integer Overflow
 * BadSource: max Set data to the max value for unsigned int
 * GoodSource: Set data to a small, non-zero number (two)
 * Sinks: square
 *    GoodSink: Ensure there will not be an overflow before squaring data
 *    BadSink : Square data, which can lead to overflow
 * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE190_Integer_Overflow__unsigned_int_max_square_81.h""

#include <math.h>

namespace CWE190_Integer_Overflow__unsigned_int_max_square_81
{

void CWE190_Integer_Overflow__unsigned_int_max_square_81_bad::action(unsigned int data) const
{
    {
        
        unsigned int result = data * data;
        printUnsignedLine(result);
    }
}

}
"
13739,0,CWE197_Numeric_Truncation_Error__int_rand_to_char_41.c,"    int data;
    
    data = -1;
    
    data = RAND32();
"
4331,0,CWE369_Divide_by_Zero__int_rand_divide_74a.cpp,"    int data;
    map<int, int> dataMap;
    
    data = -1;
    
    data = RAND32();
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
17686,0,CWE590_Free_Memory_Not_on_Heap__delete_array_int64_t_static_81_bad.cpp,"Label Definition File: CWE590_Free_Memory_Not_on_Heap__delete_array.label.xml
Template File: sources-sink-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 590 Free Memory Not on Heap
 * BadSource: static Data buffer is declared static on the stack
 * GoodSource: Allocate memory on the heap
 * Sinks:
 *    BadSink : Print then free data
 * Flow Variant: 81 Data flow: data passed in a parameter to a virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE590_Free_Memory_Not_on_Heap__delete_array_int64_t_static_81.h""

namespace CWE590_Free_Memory_Not_on_Heap__delete_array_int64_t_static_81
{

void CWE590_Free_Memory_Not_on_Heap__delete_array_int64_t_static_81_bad::action(int64_t * data) const
{
    printLongLongLine(data[0]);
    
    delete [] data;
}

}
"
11155,0,CWE190_Integer_Overflow__int_max_multiply_31.c,"    int data;
    
    data = 0;
    
    data = INT_MAX;
    {
        int dataCopy = data;
        int data = dataCopy;
        if(data > 0) 
        {
            
            int result = data * 2;
            printIntLine(result);
        }
"
19491,0,CWE197_Numeric_Truncation_Error__int_rand_to_char_73a.cpp,"    int data;
    list<int> dataList;
    
    data = -1;
    
    data = RAND32();
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
15540,0,CWE369_Divide_by_Zero__float_listenSocket_81a.cpp,"    float data;
    
    data = 0.0F;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = (float)atof(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    const CWE369_Divide_by_Zero__float_listenSocket_81_base& baseObject = CWE369_Divide_by_Zero__float_listenSocket_81_bad();
"
10440,0,CWE190_Integer_Overflow__int_connect_socket_postinc_14.c,"    int data;
    
    data = 0;
    if(globalFive==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(globalFive==5)
    {
        {
            
            data++;
            int result = data;
            printIntLine(result);
        }
"
6132,0,CWE676_Use_of_Potentially_Dangerous_Function__basic_12.cpp,"    if(globalReturnsTrueOrFalse())
    {
        {
            char charBuffer[CHAR_BUFFER_SIZE];
            
            
            cin >> charBuffer;
            charBuffer[CHAR_BUFFER_SIZE-1] = '\0';
            printLine(charBuffer);
        }
    }
    else
    {
        {
            char charBuffer[CHAR_BUFFER_SIZE];
            
            cin.width(CHAR_BUFFER_SIZE);
            cin >> charBuffer;
            charBuffer[CHAR_BUFFER_SIZE-1] = '\0';
            printLine(charBuffer);
        }
"
11593,0,CWE369_Divide_by_Zero__float_listenSocket_64a.c,"    float data;
    
    data = 0.0F;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = (float)atof(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
16727,0,CWE563_Unused_Variable__unused_init_variable_struct_11.c,"    twoIntsStruct data;
    
    data.intOne = 0;
    data.intTwo = 0;
    if(globalReturnsTrue())
    {
        
        
        ; 
"
12049,1,CWE252_Unchecked_Return_Value__char_sscanf_17.c,"    int k;
    for(k = 0; k < 1; k++)
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            
            if (sscanf(SRC, ""%99s\0"", data) == EOF)
            {
                printLine(""sscanf failed!"");
            }
        }
"
7840,0,CWE590_Free_Memory_Not_on_Heap__delete_array_int_alloca_45.cpp,"    int * data;
    data = NULL; 
    {
        
        int * dataBuffer = (int *)ALLOCA(100*sizeof(int));
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5;
            }
        }
        data = dataBuffer;
    }
    badData = data;
"
2086,0,CWE190_Integer_Overflow__int64_t_max_add_83a.cpp,"    int64_t data;
    data = 0LL;
"
4490,0,CWE190_Integer_Overflow__char_rand_add_13.c,"    char data;
    data = ' ';
    if(GLOBAL_CONST_FIVE==5)
    {
        
        data = (char)RAND32();
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            
            char result = data + 1;
            printHexCharLine(result);
        }
"
1153,0,CWE690_NULL_Deref_From_Return__char_realloc_63a.c,"    char * data;
    data = NULL; 
    
    data = (char *)realloc(data, 20*sizeof(char));
"
17172,0,CWE190_Integer_Overflow__int_rand_add_63a.c,"    int data;
    
    data = 0;
    
    data = RAND32();
"
16226,0,CWE369_Divide_by_Zero__int_listen_socket_modulo_84_bad.cpp,"Label Definition File: CWE369_Divide_by_Zero__int.label.xml
Template File: sources-sinks-84_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 369 Divide by Zero
 * BadSource: listen_socket Read data using a listen socket (server side)
 * GoodSource: Non-zero
 * Sinks: modulo
 *    GoodSink: Check for zero before modulo
 *    BadSink : Modulo a constant with data
 * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE369_Divide_by_Zero__int_listen_socket_modulo_84.h""

#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif

#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)

namespace CWE369_Divide_by_Zero__int_listen_socket_modulo_84
{
CWE369_Divide_by_Zero__int_listen_socket_modulo_84_bad::CWE369_Divide_by_Zero__int_listen_socket_modulo_84_bad(int dataCopy)
{
    data = dataCopy;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
}

CWE369_Divide_by_Zero__int_listen_socket_modulo_84_bad::~CWE369_Divide_by_Zero__int_listen_socket_modulo_84_bad()
{
    
    printIntLine(100 % data);
}
}
"
15639,0,CWE190_Integer_Overflow__char_max_postinc_51a.c,"    char data;
    data = ' ';
    
    data = CHAR_MAX;
"
2203,0,CWE590_Free_Memory_Not_on_Heap__free_int64_t_declare_73a.cpp,"    int64_t * data;
    list<int64_t *> dataList;
    data = NULL; 
    {
        
        int64_t dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5LL;
            }
        }
        data = dataBuffer;
    }
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
16016,0,CWE190_Integer_Overflow__int_fgets_multiply_82_bad.cpp,"Label Definition File: CWE190_Integer_Overflow__int.label.xml
Template File: sources-sinks-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 190 Integer Overflow
 * BadSource: fgets Read data from the console using fgets()
 * GoodSource: Set data to a small, non-zero number (two)
 * Sinks: multiply
 *    GoodSink: Ensure there will not be an overflow before multiplying data by 2
 *    BadSink : If data is positive, multiply by 2, which can cause an overflow
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE190_Integer_Overflow__int_fgets_multiply_82.h""

namespace CWE190_Integer_Overflow__int_fgets_multiply_82
{

void CWE190_Integer_Overflow__int_fgets_multiply_82_bad::action(int data)
{
    if(data > 0) 
    {
        
        int result = data * 2;
        printIntLine(result);
    }
}

}
"
2120,0,CWE190_Integer_Overflow__short_rand_preinc_10.c,"    short data;
    data = 0;
    if(globalTrue)
    {
        
        data = (short)RAND32();
    }
    if(globalTrue)
    {
        {
            
            ++data;
            short result = data;
            printIntLine(result);
        }
"
14759,1,CWE252_Unchecked_Return_Value__char_fputs_04.c,"    if(STATIC_CONST_FALSE)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        
        if (fputs(""string"", stdout) == EOF)
        {
            printLine(""fputs failed!"");
        }
"
15344,1,CWE758_Undefined_Behavior__int64_t_malloc_use_06.c,"    if(STATIC_CONST_FIVE!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            int64_t data;
            int64_t * pointer = (int64_t *)malloc(sizeof(int64_t));
            if (pointer == NULL) {exit(-1);}
            data = 5LL;
            *pointer = data; 
            {
                int64_t data = *pointer;
                printLongLongLine(data);
            }
            free(pointer);
        }
"
5371,1,CWE758_Undefined_Behavior__struct_alloca_use_06.c,"    if(STATIC_CONST_FIVE!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            twoIntsStruct data;
            twoIntsStruct * pointer = (twoIntsStruct *)ALLOCA(sizeof(twoIntsStruct));
            data.intOne = 1;
            data.intTwo = 2;
            *pointer = data; 
            {
                twoIntsStruct data = *pointer;
                printIntLine(data.intOne);
                printIntLine(data.intTwo);
            }
        }
"
707,0,CWE590_Free_Memory_Not_on_Heap__delete_int_alloca_67a.cpp,"    int * data;
    structType myStruct;
    data = NULL; 
    {
        
        int * dataBuffer = (int *)ALLOCA(sizeof(int));
        *dataBuffer = 5;
        data = dataBuffer;
    }
    myStruct.structFirst = data;
"
19368,0,CWE563_Unused_Variable__unused_value_int_10.c,"    int data;
    if(globalTrue)
    {
        
        data = 5;
    }
    if(globalTrue)
    {
        
        data = 10;
        printIntLine(data);
"
10498,0,CWE190_Integer_Overflow__unsigned_int_rand_add_21.c,"    unsigned int data;
    data = 0;
    
    data = (unsigned int)RAND32();
    badStatic = 1; 
"
11573,0,CWE369_Divide_by_Zero__int_connect_socket_modulo_01.c,"    int data;
    
    data = -1;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
"
3397,0,CWE78_OS_Command_Injection__char_listen_socket_system_51a.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
10453,0,CWE197_Numeric_Truncation_Error__int_fscanf_to_short_08.c,"    int data;
    
    data = -1;
    if(staticReturnsTrue())
    {
        
        fscanf(stdin, ""%d"", &data);
    }
    {
        
        short shortData = (short)data;
        printShortLine(shortData);
"
10685,0,CWE369_Divide_by_Zero__int_listen_socket_modulo_67a.c,"    int data;
    CWE369_Divide_by_Zero__int_listen_socket_modulo_67_structType myStruct;
    
    data = -1;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    myStruct.structFirst = data;
"
7775,0,CWE457_Use_of_Uninitialized_Variable__twointsclass_array_malloc_no_init_12.cpp,"    TwoIntsClass * data;
    data = reinterpret_cast<TwoIntsClass *>(malloc(10*sizeof(TwoIntsClass)));
    if (data == NULL) {exit(-1);}
    if(globalReturnsTrueOrFalse())
    {
        
        ; 
    }
    else
    {
        
        for(int i=0; i<10; i++)
        {
            data[i].intOne = i;
            data[i].intTwo = i;
        }
    }
    if(globalReturnsTrueOrFalse())
    {
        
        for(int i=0; i<10; i++)
        {
            printIntLine(data[i].intOne);
            printIntLine(data[i].intTwo);
        }
    }
    else
    {
        
        for(int i=0; i<10; i++)
        {
            data[i].intOne = i;
            data[i].intTwo = i;
        }
        for(int i=0; i<10; i++)
        {
            printIntLine(data[i].intOne);
            printIntLine(data[i].intTwo);
        }
"
1011,0,CWE134_Uncontrolled_Format_String__char_connect_socket_printf_68a.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    CWE134_Uncontrolled_Format_String__char_connect_socket_printf_68_badData = data;
"
17842,0,CWE590_Free_Memory_Not_on_Heap__delete_int64_t_static_17.cpp,"    int i;
    int64_t * data;
    data = NULL; 
    for(i = 0; i < 1; i++)
    {
        {
            
            static int64_t dataBuffer;
            dataBuffer = 5LL;
            data = &dataBuffer;
        }
    }
    printLongLongLine(*data);
    
"
2282,0,CWE190_Integer_Overflow__char_rand_square_01.c,"    char data;
    data = ' ';
    
    data = (char)RAND32();
    {
        
        char result = data * data;
        printHexCharLine(result);
"
6002,0,CWE415_Double_Free__new_delete_int64_t_82_bad.cpp,"Label Definition File: CWE415_Double_Free__new_delete.label.xml
Template File: sources-sinks-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 415 Double Free
 * BadSource:  Allocate data using new and Deallocae data using delete
 * GoodSource: Allocate data using new
 * Sinks:
 *    GoodSink: do nothing
 *    BadSink : Deallocate data using delete
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE415_Double_Free__new_delete_int64_t_82.h""

namespace CWE415_Double_Free__new_delete_int64_t_82
{

void CWE415_Double_Free__new_delete_int64_t_82_bad::action(int64_t * data)
{
    
    delete data;
}

}
"
10614,0,CWE590_Free_Memory_Not_on_Heap__free_int_static_07.c,"    int * data;
    data = NULL; 
    if(staticFive==5)
    {
        {
            
            static int dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5;
                }
            }
            data = dataBuffer;
        }
    }
    printIntLine(data[0]);
    
"
7081,0,CWE190_Integer_Overflow__int64_t_max_add_84a.cpp,"    int64_t data;
    data = 0LL;
    CWE190_Integer_Overflow__int64_t_max_add_84_bad * badObject = new CWE190_Integer_Overflow__int64_t_max_add_84_bad(data);
"
16432,0,CWE190_Integer_Overflow__char_rand_add_07.c,"    char data;
    data = ' ';
    if(staticFive==5)
    {
        
        data = (char)RAND32();
    }
    if(staticFive==5)
    {
        {
            
            char result = data + 1;
            printHexCharLine(result);
        }
"
18617,0,CWE590_Free_Memory_Not_on_Heap__delete_array_struct_alloca_54a.cpp,"    twoIntsStruct * data;
    data = NULL; 
    {
        
        twoIntsStruct * dataBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i].intOne = 1;
                dataBuffer[i].intTwo = 1;
            }
        }
        data = dataBuffer;
    }
"
13521,0,CWE690_NULL_Deref_From_Return__int64_t_calloc_84_bad.cpp,"Label Definition File: CWE690_NULL_Deref_From_Return.free.label.xml
Template File: source-sinks-84_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 690 Unchecked Return Value To NULL Pointer
 * BadSource: calloc Allocate data using calloc()
 * Sinks:
 *    GoodSink: Check to see if the data allocation failed and if not, use data
 *    BadSink : Don't check for NULL and use data
 * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE690_NULL_Deref_From_Return__int64_t_calloc_84.h""

namespace CWE690_NULL_Deref_From_Return__int64_t_calloc_84
{
CWE690_NULL_Deref_From_Return__int64_t_calloc_84_bad::CWE690_NULL_Deref_From_Return__int64_t_calloc_84_bad(int64_t * dataCopy)
{
    data = dataCopy;
    
    data = (int64_t *)calloc(1, sizeof(int64_t));
}

CWE690_NULL_Deref_From_Return__int64_t_calloc_84_bad::~CWE690_NULL_Deref_From_Return__int64_t_calloc_84_bad()
{
    
    data[0] = 5LL;
    printLongLongLine(data[0]);
    free(data);
}
}
"
5675,0,CWE590_Free_Memory_Not_on_Heap__delete_array_long_alloca_66a.cpp,"    long * data;
    long * dataArray[5];
    data = NULL; 
    {
        
        long * dataBuffer = (long *)ALLOCA(100*sizeof(long));
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5L;
            }
        }
        data = dataBuffer;
    }
    
    dataArray[2] = data;
"
9364,0,CWE197_Numeric_Truncation_Error__int_large_to_short_53a.c,"    int data;
    
    data = -1;
    
    data = SHRT_MAX + 5;
"
11940,0,CWE415_Double_Free__new_delete_int_82_bad.cpp,"Label Definition File: CWE415_Double_Free__new_delete.label.xml
Template File: sources-sinks-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 415 Double Free
 * BadSource:  Allocate data using new and Deallocae data using delete
 * GoodSource: Allocate data using new
 * Sinks:
 *    GoodSink: do nothing
 *    BadSink : Deallocate data using delete
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE415_Double_Free__new_delete_int_82.h""

namespace CWE415_Double_Free__new_delete_int_82
{

void CWE415_Double_Free__new_delete_int_82_bad::action(int * data)
{
    
    delete data;
}

}
"
5079,0,CWE590_Free_Memory_Not_on_Heap__free_struct_static_18.c,"    twoIntsStruct * data;
    data = NULL; 
    goto source;
source:
    {
        
        static twoIntsStruct dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i].intOne = 1;
                dataBuffer[i].intTwo = 1;
            }
        }
        data = dataBuffer;
    }
    printStructLine(&data[0]);
    
"
1044,0,CWE190_Integer_Overflow__short_fscanf_square_83_bad.cpp,"Label Definition File: CWE190_Integer_Overflow.label.xml
Template File: sources-sinks-83_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 190 Integer Overflow
 * BadSource: fscanf Read data from the console using fscanf()
 * GoodSource: Set data to a small, non-zero number (two)
 * Sinks: square
 *    GoodSink: Ensure there will not be an overflow before squaring data
 *    BadSink : Square data, which can lead to overflow
 * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE190_Integer_Overflow__short_fscanf_square_83.h""

#include <math.h>

namespace CWE190_Integer_Overflow__short_fscanf_square_83
{
CWE190_Integer_Overflow__short_fscanf_square_83_bad::CWE190_Integer_Overflow__short_fscanf_square_83_bad(short dataCopy)
{
    data = dataCopy;
    
    fscanf (stdin, ""%hd"", &data);
}

CWE190_Integer_Overflow__short_fscanf_square_83_bad::~CWE190_Integer_Overflow__short_fscanf_square_83_bad()
{
    {
        
        short result = data * data;
        printIntLine(result);
    }
}
}
"
799,0,CWE190_Integer_Overflow__char_fscanf_multiply_73a.cpp,"    char data;
    list<char> dataList;
    data = ' ';
    
    fscanf (stdin, ""%c"", &data);
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
845,0,CWE190_Integer_Overflow__int_listen_socket_postinc_66a.c,"    int data;
    int dataArray[5];
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
    dataArray[2] = data;
"
10601,0,CWE369_Divide_by_Zero__int_fscanf_divide_52a.c,"    int data;
    
    data = -1;
    
    fscanf(stdin, ""%d"", &data);
"
5723,0,CWE758_Undefined_Behavior__struct_malloc_use_09.c,"    if(GLOBAL_CONST_TRUE)
    {
        {
            twoIntsStruct * pointer = (twoIntsStruct *)malloc(sizeof(twoIntsStruct));
            if (pointer == NULL) {exit(-1);}
            twoIntsStruct data = *pointer; 
            free(pointer);
            printIntLine(data.intOne);
            printIntLine(data.intTwo);
        }
"
8351,0,CWE563_Unused_Variable__unused_init_variable_long_74a.cpp,"    long data;
    map<int, long> dataMap;
    
    data = 5L;
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
5988,1,CWE252_Unchecked_Return_Value__char_remove_07.c,"    if(staticFive!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        
        if (REMOVE(""removemegood.txt"") != 0)
        {
            printLine(""remove failed!"");
        }
"
4952,0,CWE590_Free_Memory_Not_on_Heap__delete_array_struct_static_07.cpp,"    twoIntsStruct * data;
    data = NULL; 
    if(staticFive==5)
    {
        {
            
            static twoIntsStruct dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i].intOne = 1;
                    dataBuffer[i].intTwo = 1;
                }
            }
            data = dataBuffer;
        }
    }
    printStructLine(&data[0]);
    
"
733,0,CWE190_Integer_Overflow__int_fgets_preinc_68a.c,"    int data;
    
    data = 0;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    CWE190_Integer_Overflow__int_fgets_preinc_68_badData = data;
"
11727,0,CWE197_Numeric_Truncation_Error__int_rand_to_char_05.c,"    int data;
    
    data = -1;
    if(staticTrue)
    {
        
        data = RAND32();
    }
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
18088,0,CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_51a.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
10456,0,CWE190_Integer_Overflow__short_fscanf_postinc_53a.c,"    short data;
    data = 0;
    
    fscanf (stdin, ""%hd"", &data);
"
18044,0,CWE457_Use_of_Uninitialized_Variable__int_pointer_12.c,"    int * data;
    if(globalReturnsTrueOrFalse())
    {
        
        ; 
    }
    else
    {
        
        
        data = (int *)malloc(sizeof(int));
        if (data == NULL) {exit(-1);}
        *data = 5;
    }
    if(globalReturnsTrueOrFalse())
    {
        
        printIntLine(*data);
    }
    else
    {
        
        
        data = (int *)malloc(sizeof(int));
        if (data == NULL) {exit(-1);}
        *data = 5;
        printIntLine(*data);
"
1938,1,CWE252_Unchecked_Return_Value__char_fread_13.c,"    if(GLOBAL_CONST_FIVE!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            
            if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) != 100-1)
            {
                printLine(""fread failed!"");
            }
        }
"
3268,0,CWE457_Use_of_Uninitialized_Variable__struct_array_declare_no_init_09.c,"    twoIntsStruct * data;
    twoIntsStruct dataUninitArray[10];
    data = dataUninitArray;
    if(GLOBAL_CONST_TRUE)
    {
        
        ; 
    }
    if(GLOBAL_CONST_TRUE)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i].intOne);
                printIntLine(data[i].intTwo);
            }
        }
"
12996,0,CWE190_Integer_Overflow__int_rand_multiply_03.c,"    int data;
    
    data = 0;
    if(5==5)
    {
        
        data = RAND32();
    }
    if(5==5)
    {
        if(data > 0) 
        {
            
            int result = data * 2;
            printIntLine(result);
        }
"
13016,0,CWE369_Divide_by_Zero__float_rand_72a.cpp,"    float data;
    vector<float> dataVector;
    
    data = 0.0F;
    
    data = (float)RAND32();
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
12814,0,CWE134_Uncontrolled_Format_String__char_environment_vprintf_83a.cpp,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
"
14830,0,CWE401_Memory_Leak__new_array_int_32.cpp,"    int * data;
    int * *dataPtr1 = &data;
    int * *dataPtr2 = &data;
    data = NULL;
    {
        int * data = *dataPtr1;
        
        data = new int[100];
        
        data[0] = 5;
        printIntLine(data[0]);
        *dataPtr1 = data;
    }
    {
        int * data = *dataPtr2;
        
        ; 
"
15649,0,CWE401_Memory_Leak__twoIntsStruct_calloc_06.c,"    twoIntsStruct * data;
    data = NULL;
    if(STATIC_CONST_FIVE==5)
    {
        
        data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));
        if (data == NULL) {exit(-1);}
        
        data[0].intOne = 0;
        data[0].intTwo = 0;
        printStructLine(&data[0]);
    }
    if(STATIC_CONST_FIVE==5)
    {
        
        ; 
"
5927,0,CWE457_Use_of_Uninitialized_Variable__twointsclass_01.cpp,"    TwoIntsClass data;
    
    ; 
    
    printIntLine(data.intOne);
"
7071,0,CWE563_Unused_Variable__unused_uninit_variable_char_43.cpp,"    char data;
    badSource(data);
    
    
"
6565,0,CWE369_Divide_by_Zero__int_zero_divide_09.c,"    int data;
    
    data = -1;
    if(GLOBAL_CONST_TRUE)
    {
        
        data = 0;
    }
    if(GLOBAL_CONST_TRUE)
    {
        
        printIntLine(100 / data);
"
13241,0,CWE563_Unused_Variable__unused_value_char_08.c,"    char data;
    if(staticReturnsTrue())
    {
        
        data = 'C';
    }
    if(staticReturnsTrue())
    {
        
        data = 'Z';
        printHexCharLine(data);
"
16411,0,CWE415_Double_Free__new_delete_char_74a.cpp,"    char * data;
    map<int, char *> dataMap;
    
    data = NULL;
    data = new char;
    
    delete data;
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
11194,0,CWE190_Integer_Overflow__int64_t_rand_square_74a.cpp,"    int64_t data;
    map<int, int64_t> dataMap;
    data = 0LL;
    
    data = (int64_t)RAND64();
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
17778,0,CWE563_Unused_Variable__unused_value_char_21.c,"    char data;
    
    data = 'C';
    badStatic = 1; 
"
1432,0,CWE665_Improper_Initialization__char_cat_14.c,"    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    if(globalFive==5)
    {
        
        ; 
    }
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        
        strcat(data, source);
        printLine(data);
"
14641,0,CWE789_Uncontrolled_Mem_Alloc__new_char_listen_socket_82a.cpp,"    size_t data;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = strtoul(inputBuffer, NULL, 0);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    CWE789_Uncontrolled_Mem_Alloc__new_char_listen_socket_82_base* baseObject = new CWE789_Uncontrolled_Mem_Alloc__new_char_listen_socket_82_bad;
    baseObject->action(data);
"
2363,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_51a.c,"    size_t data;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = strtoul(inputBuffer, NULL, 0);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
2024,0,CWE457_Use_of_Uninitialized_Variable__struct_array_declare_no_init_14.c,"    twoIntsStruct * data;
    twoIntsStruct dataUninitArray[10];
    data = dataUninitArray;
    if(globalFive==5)
    {
        
        ; 
    }
    if(globalFive==5)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i].intOne);
                printIntLine(data[i].intTwo);
            }
        }
"
19381,0,CWE190_Integer_Overflow__int_fscanf_add_45.c,"    int data;
    
    data = 0;
    
    fscanf(stdin, ""%d"", &data);
    CWE190_Integer_Overflow__int_fscanf_add_45_badData = data;
"
18959,0,CWE789_Uncontrolled_Mem_Alloc__new_char_listen_socket_02.cpp,"    size_t data;
    
    data = 0;
    if(1)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = strtoul(inputBuffer, NULL, 0);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(1)
    {
        {
            char * myString;
            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
             * for the strcpy() function to not cause a buffer overflow */
            
            if (data > strlen(HELLO_STRING))
            {
                myString = new char[data];
                
                strcpy(myString, HELLO_STRING);
                printLine(myString);
                delete [] myString;
            }
            else
            {
                printLine(""Input is less than the length of the source string"");
            }
        }
"
11408,0,CWE416_Use_After_Free__new_delete_long_12.cpp,"    long * data;
    
    data = NULL;
    if(globalReturnsTrueOrFalse())
    {
        data = new long;
        *data = 5L;
        
        delete data;
    }
    else
    {
        data = new long;
        *data = 5L;
        
    }
    if(globalReturnsTrueOrFalse())
    {
        
        printLongLine(*data);
        
    }
    else
    {
        
        
        
        ; 
"
6518,0,CWE789_Uncontrolled_Mem_Alloc__new_char_fgets_03.cpp,"    size_t data;
    
    data = 0;
    if(5==5)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                
                data = strtoul(inputBuffer, NULL, 0);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    if(5==5)
    {
        {
            char * myString;
            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
             * for the strcpy() function to not cause a buffer overflow */
            
            if (data > strlen(HELLO_STRING))
            {
                myString = new char[data];
                
                strcpy(myString, HELLO_STRING);
                printLine(myString);
                delete [] myString;
            }
            else
            {
                printLine(""Input is less than the length of the source string"");
            }
        }
"
3398,0,CWE78_OS_Command_Injection__char_file_execlp_33.cpp,"    char * data;
    char * &dataRef = data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        FILE * pFile;
        
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
    {
        char * data = dataRef;
        /* execlp - searches for the location of the command among
         * the directories specified by the PATH environment variable */
        
        EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
"
14349,0,CWE416_Use_After_Free__new_delete_class_04.cpp,"    TwoIntsClass * data;
    
    data = NULL;
    if(STATIC_CONST_TRUE)
    {
        data = new TwoIntsClass;
        data->intOne = 1;
        data->intTwo = 2;
        
        delete data;
    }
    if(STATIC_CONST_TRUE)
    {
        
        printIntLine(data->intOne);
        
"
18484,0,CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_16.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    while(1)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                data[dataLen + recvResult / sizeof(char)] = '\0';
                
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
        break;
    }
    while(1)
    {
        badVaSinkB(data, data);
        break;
"
9411,0,CWE78_OS_Command_Injection__char_file_system_61a.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    data = CWE78_OS_Command_Injection__char_file_system_61b_badSource(data);
    
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
"
1490,0,CWE190_Integer_Overflow__int_rand_square_67a.c,"    int data;
    CWE190_Integer_Overflow__int_rand_square_67_structType myStruct;
    
    data = 0;
    
    data = RAND32();
    myStruct.structFirst = data;
"
3117,0,CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_18.c,"    unsigned int data;
    data = 0;
    goto source;
source:
    
    fscanf (stdin, ""%u"", &data);
    goto sink;
sink:
    if(data > 0) 
    {
        
        unsigned int result = data * 2;
        printUnsignedLine(result);
"
2850,0,CWE134_Uncontrolled_Format_String__char_console_snprintf_16.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    while(1)
    {
        {
            
            size_t dataLen = strlen(data);
            
            if (100-dataLen > 1)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
                {
                    /* The next few lines remove the carriage return from the string that is
                     * inserted by fgets() */
                    dataLen = strlen(data);
                    if (dataLen > 0 && data[dataLen-1] == '\n')
                    {
                        data[dataLen-1] = '\0';
                    }
                }
                else
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
            }
        }
        break;
    }
    while(1)
    {
        {
            char dest[100] = """";
            
            SNPRINTF(dest, 100-1, data);
            printLine(dest);
        }
        break;
"
18255,0,CWE415_Double_Free__new_delete_array_struct_73a.cpp,"    twoIntsStruct * data;
    list<twoIntsStruct *> dataList;
    
    data = NULL;
    data = new twoIntsStruct[100];
    
    delete [] data;
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
15470,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_67a.c,"    size_t data;
    CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_67_structType myStruct;
    
    data = 0;
    
    fscanf(stdin, ""%zu"", &data);
    myStruct.structFirst = data;
"
18066,0,CWE457_Use_of_Uninitialized_Variable__char_pointer_04.c,"    char * data;
    if(STATIC_CONST_TRUE)
    {
        
        ; 
    }
    if(STATIC_CONST_TRUE)
    {
        
        printLine(data);
"
3149,0,CWE190_Integer_Overflow__int64_t_rand_add_82_bad.cpp,"Label Definition File: CWE190_Integer_Overflow.label.xml
Template File: sources-sinks-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 190 Integer Overflow
 * BadSource: rand Set data to result of rand()
 * GoodSource: Set data to a small, non-zero number (two)
 * Sinks: add
 *    GoodSink: Ensure there will not be an overflow before adding 1 to data
 *    BadSink : Add 1 to data, which can cause an overflow
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE190_Integer_Overflow__int64_t_rand_add_82.h""

namespace CWE190_Integer_Overflow__int64_t_rand_add_82
{

void CWE190_Integer_Overflow__int64_t_rand_add_82_bad::action(int64_t data)
{
    {
        
        int64_t result = data + 1;
        printLongLongLine(result);
    }
}

}
"
13513,1,CWE401_Memory_Leak__malloc_realloc_char_12.c,"    if(globalReturnsTrueOrFalse())
    {
        {
            char * data = (char *)malloc(100*sizeof(char));
            if (data == NULL) {exit(-1);}
            char * tmpData;
            
            strcpy(data, ""A String"");
            printLine(data);
            tmpData = (char *)realloc(data, (130000)*sizeof(char));
            /* FIX: Ensure realloc() was successful before assigning data to the memory block
            * allocated with realloc() */
            if (tmpData != NULL)
            {
                data = tmpData;
                
                strcpy(data, ""New String"");
                printLine(data);
            }
            free(data);
        }
    }
    else
    {
        {
            char * data = (char *)malloc(100*sizeof(char));
            if (data == NULL) {exit(-1);}
            char * tmpData;
            
            strcpy(data, ""A String"");
            printLine(data);
            tmpData = (char *)realloc(data, (130000)*sizeof(char));
            /* FIX: Ensure realloc() was successful before assigning data to the memory block
            * allocated with realloc() */
            if (tmpData != NULL)
            {
                data = tmpData;
                
                strcpy(data, ""New String"");
                printLine(data);
            }
            free(data);
        }
"
14941,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_04.c,"    size_t data;
    
    data = 0;
    if(STATIC_CONST_TRUE)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = strtoul(inputBuffer, NULL, 0);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(STATIC_CONST_TRUE)
    {
        {
            char * myString;
            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
             * for the strcpy() function to not cause a buffer overflow */
            
            if (data > strlen(HELLO_STRING))
            {
                myString = (char *)malloc(data*sizeof(char));
                if (myString == NULL) {exit(-1);}
                
                strcpy(myString, HELLO_STRING);
                printLine(myString);
                free(myString);
            }
            else
            {
                printLine(""Input is less than the length of the source string"");
            }
        }
"
7891,0,CWE190_Integer_Overflow__unsigned_int_rand_multiply_32.c,"    unsigned int data;
    unsigned int *dataPtr1 = &data;
    unsigned int *dataPtr2 = &data;
    data = 0;
    {
        unsigned int data = *dataPtr1;
        
        data = (unsigned int)RAND32();
        *dataPtr1 = data;
    }
    {
        unsigned int data = *dataPtr2;
        if(data > 0) 
        {
            
            unsigned int result = data * 2;
            printUnsignedLine(result);
        }
"
12156,0,CWE197_Numeric_Truncation_Error__short_large_67a.c,"    short data;
    CWE197_Numeric_Truncation_Error__short_large_67_structType myStruct;
    
    data = -1;
    
    data = CHAR_MAX + 1;
    myStruct.structFirst = data;
"
7895,1,CWE252_Unchecked_Return_Value__char_snprintf_11.c,"    if(globalReturnsTrue())
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            
            if (SNPRINTF(data,100-strlen(SRC)-1, ""%s\n"", SRC) < 0)
            {
                printLine(""snprintf failed!"");
            }
        }
"
8043,0,CWE134_Uncontrolled_Format_String__char_console_vfprintf_07.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(staticFive==5)
    {
        {
            
            size_t dataLen = strlen(data);
            
            if (100-dataLen > 1)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
                {
                    /* The next few lines remove the carriage return from the string that is
                     * inserted by fgets() */
                    dataLen = strlen(data);
                    if (dataLen > 0 && data[dataLen-1] == '\n')
                    {
                        data[dataLen-1] = '\0';
                    }
                }
                else
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
            }
        }
    }
    if(staticFive==5)
    {
        badVaSinkB(data, data);
"
107,0,CWE415_Double_Free__malloc_free_struct_45.c,"    twoIntsStruct * data;
    
    data = NULL;
    data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
    if (data == NULL) {exit(-1);}
    
    free(data);
    CWE415_Double_Free__malloc_free_struct_45_badData = data;
"
7508,1,CWE758_Undefined_Behavior__char_alloca_use_09.c,"    if(GLOBAL_CONST_TRUE)
    {
        {
            char data;
            char * pointer = (char *)ALLOCA(sizeof(char));
            data = 5;
            *pointer = data; 
            {
                char data = *pointer;
                printHexCharLine(data);
            }
        }
"
15774,0,CWE415_Double_Free__new_delete_array_class_72a.cpp,"    TwoIntsClass * data;
    vector<TwoIntsClass *> dataVector;
    
    data = NULL;
    data = new TwoIntsClass[100];
    
    delete [] data;
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
6964,0,CWE190_Integer_Overflow__int64_t_rand_square_63a.c,"    int64_t data;
    data = 0LL;
    
    data = (int64_t)RAND64();
"
1946,0,CWE590_Free_Memory_Not_on_Heap__delete_long_static_44.cpp,"    long * data;
    
    void (*funcPtr) (long *) = badSink;
    data = NULL; 
    {
        
        static long dataBuffer;
        dataBuffer = 5L;
        data = &dataBuffer;
    }
    
"
2895,0,CWE190_Integer_Overflow__int_connect_socket_postinc_08.c,"    int data;
    
    data = 0;
    if(staticReturnsTrue())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(staticReturnsTrue())
    {
        {
            
            data++;
            int result = data;
            printIntLine(result);
        }
"
8954,0,CWE190_Integer_Overflow__int_fscanf_add_81a.cpp,"    int data;
    
    data = 0;
    
    fscanf(stdin, ""%d"", &data);
    const CWE190_Integer_Overflow__int_fscanf_add_81_base& baseObject = CWE190_Integer_Overflow__int_fscanf_add_81_bad();
"
14788,0,CWE415_Double_Free__new_delete_long_16.cpp,"    long * data;
    
    data = NULL;
    while(1)
    {
        data = new long;
        
        delete data;
        break;
    }
    while(1)
    {
        
        delete data;
        break;
"
11556,0,CWE665_Improper_Initialization__char_cat_43.cpp,"    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    badSource(data);
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        
        strcat(data, source);
        printLine(data);
"
6723,0,CWE590_Free_Memory_Not_on_Heap__delete_char_alloca_08.cpp,"    char * data;
    data = NULL; 
    if(staticReturnsTrue())
    {
        {
            
            char * dataBuffer = (char *)ALLOCA(sizeof(char));
            *dataBuffer = 'A';
            data = dataBuffer;
        }
    }
    printHexCharLine(*data);
    
"
15183,0,CWE190_Integer_Overflow__int64_t_fscanf_postinc_13.c,"    int64_t data;
    data = 0LL;
    if(GLOBAL_CONST_FIVE==5)
    {
        
        fscanf (stdin, ""%"" SCNd64, &data);
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            
            data++;
            int64_t result = data;
            printLongLongLine(result);
        }
"
1886,0,CWE590_Free_Memory_Not_on_Heap__free_struct_alloca_64a.c,"    twoIntsStruct * data;
    data = NULL; 
    {
        
        twoIntsStruct * dataBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i].intOne = 1;
                dataBuffer[i].intTwo = 1;
            }
        }
        data = dataBuffer;
    }
"
6575,1,CWE252_Unchecked_Return_Value__char_snprintf_05.c,"    if(staticFalse)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            
            if (SNPRINTF(data,100-strlen(SRC)-1, ""%s\n"", SRC) < 0)
            {
                printLine(""snprintf failed!"");
            }
        }
"
7200,0,CWE190_Integer_Overflow__int_listen_socket_preinc_04.c,"    int data;
    
    data = 0;
    if(STATIC_CONST_TRUE)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(STATIC_CONST_TRUE)
    {
        {
            
            ++data;
            int result = data;
            printIntLine(result);
        }
"
6111,0,CWE590_Free_Memory_Not_on_Heap__free_int64_t_static_17.c,"    int i;
    int64_t * data;
    data = NULL; 
    for(i = 0; i < 1; i++)
    {
        {
            
            static int64_t dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5LL;
                }
            }
            data = dataBuffer;
        }
    }
    printLongLongLine(data[0]);
    
"
8413,0,CWE457_Use_of_Uninitialized_Variable__twointsclass_array_malloc_no_init_18.cpp,"    TwoIntsClass * data;
    data = reinterpret_cast<TwoIntsClass *>(malloc(10*sizeof(TwoIntsClass)));
    if (data == NULL) {exit(-1);}
    goto source;
source:
    
    ; 
    goto sink;
sink:
    
    for(int i=0; i<10; i++)
    {
        printIntLine(data[i].intOne);
        printIntLine(data[i].intTwo);
"
5700,0,CWE190_Integer_Overflow__char_max_postinc_22a.c,"    char data;
    data = ' ';
    
    data = CHAR_MAX;
    CWE190_Integer_Overflow__char_max_postinc_22_badGlobal = 1; 
"
5038,0,CWE590_Free_Memory_Not_on_Heap__delete_array_class_alloca_53a.cpp,"    TwoIntsClass * data;
    data = NULL; 
    {
        
        TwoIntsClass * dataBuffer = (TwoIntsClass *)ALLOCA(100*sizeof(TwoIntsClass));
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i].intOne = 1;
                dataBuffer[i].intTwo = 1;
            }
        }
        data = dataBuffer;
    }
"
879,0,CWE369_Divide_by_Zero__float_zero_67a.c,"    float data;
    CWE369_Divide_by_Zero__float_zero_67_structType myStruct;
    
    data = 0.0F;
    
    data = 0.0F;
    myStruct.structFirst = data;
"
3656,0,CWE190_Integer_Overflow__int_max_multiply_66a.c,"    int data;
    int dataArray[5];
    
    data = 0;
    
    data = INT_MAX;
    
    dataArray[2] = data;
"
2441,0,CWE467_Use_of_sizeof_on_Pointer_Type__short_07.c,"    if(staticFive==5)
    {
        {
            short * badShort = NULL;
            
            badShort = (short *)malloc(sizeof(badShort));
            if (badShort == NULL) {exit(-1);}
            *badShort = 5;
            printShortLine(*badShort);
            free(badShort);
        }
"
5393,1,CWE467_Use_of_sizeof_on_Pointer_Type__int_06.c,"    if(STATIC_CONST_FIVE==5)
    {
        {
            int * goodInt = NULL;
            
            goodInt = (int *)malloc(sizeof(*goodInt));
            if (goodInt == NULL) {exit(-1);}
            *goodInt = 6;
            printIntLine(*goodInt);
            free(goodInt);
        }
"
16654,0,CWE590_Free_Memory_Not_on_Heap__free_long_alloca_31.c,"    long * data;
    data = NULL; 
    {
        
        long * dataBuffer = (long *)ALLOCA(100*sizeof(long));
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5L;
            }
        }
        data = dataBuffer;
    }
    {
        long * dataCopy = data;
        long * data = dataCopy;
        printLongLine(data[0]);
        
        free(data);
"
4794,0,CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_17.c,"    int i,j;
    unsigned int data;
    data = 0;
    for(i = 0; i < 1; i++)
    {
        
        fscanf (stdin, ""%u"", &data);
    }
    for(j = 0; j < 1; j++)
    {
        {
            
            ++data;
            unsigned int result = data;
            printUnsignedLine(result);
        }
"
682,0,CWE758_Undefined_Behavior__struct_new_use_15.cpp,"    switch(6)
    {
    case 6:
    {
        twoIntsStruct * pointer = new twoIntsStruct;
        twoIntsStruct data = *pointer; 
        delete pointer;
        printIntLine(data.intOne);
        printIntLine(data.intTwo);
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
1790,0,CWE78_OS_Command_Injection__char_connect_socket_execl_45.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
"
14903,0,CWE457_Use_of_Uninitialized_Variable__struct_pointer_06.c,"    twoIntsStruct * data;
    if(STATIC_CONST_FIVE==5)
    {
        
        ; 
    }
    if(STATIC_CONST_FIVE==5)
    {
        
        printIntLine(data->intOne);
        printIntLine(data->intTwo);
"
10139,0,CWE590_Free_Memory_Not_on_Heap__delete_array_char_alloca_45.cpp,"    char * data;
    data = NULL; 
    {
        
        char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
        memset(dataBuffer, 'A', 100-1); 
        dataBuffer[100-1] = '\0'; 
        data = dataBuffer;
    }
    badData = data;
"
920,0,CWE563_Unused_Variable__unused_value_int64_t_72a.cpp,"    int64_t data;
    vector<int64_t> dataVector;
    
    data = 5LL;
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
2980,0,CWE401_Memory_Leak__malloc_realloc_char_05.c,"    if(staticTrue)
    {
        {
            char * data = (char *)malloc(100*sizeof(char));
            if (data == NULL) {exit(-1);}
            
            strcpy(data, ""A String"");
            printLine(data);
            
            data = (char *)realloc(data, (130000)*sizeof(char));
            if (data != NULL)
            {
                
                strcpy(data, ""New String"");
                printLine(data);
                free(data);
            }
        }
"
14329,0,CWE590_Free_Memory_Not_on_Heap__free_int_declare_66a.c,"    int * data;
    int * dataArray[5];
    data = NULL; 
    {
        
        int dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5;
            }
        }
        data = dataBuffer;
    }
    
    dataArray[2] = data;
"
7594,1,CWE252_Unchecked_Return_Value__char_fprintf_13.c,"    if(GLOBAL_CONST_FIVE==5)
    {
        
        if (fprintf(stdout, ""%s\n"", ""string"") < 0)
        {
            printLine(""fprintf failed!"");
        }
"
12374,1,CWE252_Unchecked_Return_Value__char_remove_16.c,"    while(1)
    {
        
        if (REMOVE(""removemegood.txt"") != 0)
        {
            printLine(""remove failed!"");
        }
        break;
"
11120,1,CWE758_Undefined_Behavior__double_pointer_alloca_use_01.c,"    {
        double * data;
        double * * pointer = (double * *)ALLOCA(sizeof(double *));
        
        data = (double *)malloc(sizeof(double));
        if (data == NULL) {exit(-1);}
        *data = 5.0;
        *pointer = data; 
        {
            double * data = *pointer;
            printDoubleLine(*data);
        }
"
17703,0,CWE590_Free_Memory_Not_on_Heap__delete_int64_t_alloca_34.cpp,"    int64_t * data;
    unionType myUnion;
    data = NULL; 
    {
        
        int64_t * dataBuffer = (int64_t *)ALLOCA(sizeof(int64_t));
        *dataBuffer = 5LL;
        data = dataBuffer;
    }
    myUnion.unionFirst = data;
    {
        int64_t * data = myUnion.unionSecond;
        printLongLongLine(*data);
        
        delete data;
"
6222,0,CWE190_Integer_Overflow__int_connect_socket_square_42.c,"    int data;
    
    data = 0;
    data = badSource(data);
    {
        
        int result = data * data;
        printIntLine(result);
"
12934,1,CWE758_Undefined_Behavior__char_pointer_new_use_11.cpp,"    if(globalReturnsTrue())
    {
        {
            char * data;
            data = ""string"";
            char * * pointer = new char *;
            *pointer = data; 
            {
                char * data = *pointer;
                printLine(data);
            }
            delete pointer;
        }
"
18884,0,CWE590_Free_Memory_Not_on_Heap__delete_class_alloca_74a.cpp,"    TwoIntsClass * data;
    map<int, TwoIntsClass *> dataMap;
    data = NULL; 
    {
        
        TwoIntsClass * dataBuffer = (TwoIntsClass *)ALLOCA(sizeof(TwoIntsClass));
        dataBuffer->intOne = 2;
        dataBuffer->intTwo = 2;
        data = dataBuffer;
    }
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
10320,0,CWE467_Use_of_sizeof_on_Pointer_Type__int_12.c,"    if(globalReturnsTrueOrFalse())
    {
        {
            int * badInt = NULL;
            
            badInt = (int *)malloc(sizeof(badInt));
            if (badInt == NULL) {exit(-1);}
            *badInt = 5;
            printIntLine(*badInt);
            free(badInt);
        }
    }
    else
    {
        {
            int * goodInt = NULL;
            
            goodInt = (int *)malloc(sizeof(*goodInt));
            if (goodInt == NULL) {exit(-1);}
            *goodInt = 6;
            printIntLine(*goodInt);
            free(goodInt);
        }
"
18427,0,CWE197_Numeric_Truncation_Error__int_fgets_to_char_02.c,"    int data;
    
    data = -1;
    if(1)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
2176,0,CWE415_Double_Free__new_delete_int_52a.cpp,"    int * data;
    
    data = NULL;
    data = new int;
    
    delete data;
"
16848,0,CWE369_Divide_by_Zero__int_fscanf_modulo_53a.c,"    int data;
    
    data = -1;
    
    fscanf(stdin, ""%d"", &data);
"
246,0,CWE415_Double_Free__new_delete_long_81_bad.cpp,"Label Definition File: CWE415_Double_Free__new_delete.label.xml
Template File: sources-sinks-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 415 Double Free
 * BadSource:  Allocate data using new and Deallocae data using delete
 * GoodSource: Allocate data using new
 * Sinks:
 *    GoodSink: do nothing
 *    BadSink : Deallocate data using delete
 * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE415_Double_Free__new_delete_long_81.h""

namespace CWE415_Double_Free__new_delete_long_81
{

void CWE415_Double_Free__new_delete_long_81_bad::action(long * data) const
{
    
    delete data;
}

}
"
13625,0,CWE190_Integer_Overflow__char_rand_multiply_62a.cpp,"    char data;
    data = ' ';
    badSource(data);
    if(data > 0) 
    {
        
        char result = data * 2;
        printHexCharLine(result);
"
5624,0,CWE563_Unused_Variable__unused_init_variable_int64_t_08.c,"    int64_t data;
    
    data = 5LL;
    if(staticReturnsTrue())
    {
        
        
        ; 
"
18700,0,CWE401_Memory_Leak__struct_twoIntsStruct_calloc_61a.c,"    struct _twoIntsStruct * data;
    data = NULL;
    data = CWE401_Memory_Leak__struct_twoIntsStruct_calloc_61b_badSource(data);
    
"
7197,0,CWE401_Memory_Leak__twoIntsStruct_malloc_11.c,"    twoIntsStruct * data;
    data = NULL;
    if(globalReturnsTrue())
    {
        
        data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
        if (data == NULL) {exit(-1);}
        
        data[0].intOne = 0;
        data[0].intTwo = 0;
        printStructLine(&data[0]);
    }
    if(globalReturnsTrue())
    {
        
        ; 
"
12828,0,CWE758_Undefined_Behavior__long_new_use_17.cpp,"    int j;
    for(j = 0; j < 1; j++)
    {
        {
            long * pointer = new long;
            long data = *pointer; 
            delete pointer;
            printLongLine(data);
        }
"
12646,1,CWE758_Undefined_Behavior__int_pointer_new_use_10.cpp,"    if(globalTrue)
    {
        {
            int * data;
            
            data = new int;
            *data = 5;
            int * * pointer = new int *;
            *pointer = data; 
            {
                int * data = *pointer;
                printIntLine(*data);
            }
            delete pointer;
        }
"
18743,0,CWE190_Integer_Overflow__short_fscanf_square_44.c,"    short data;
    
    void (*funcPtr) (short) = badSink;
    data = 0;
    
    fscanf (stdin, ""%hd"", &data);
    
"
13811,0,CWE252_Unchecked_Return_Value__char_fwrite_07.c,"    if(staticFive==5)
    {
        
        fwrite((char *)""string"", sizeof(char), strlen(""string""), stdout);
"
2189,0,CWE401_Memory_Leak__strdup_char_81a.cpp,"    char * data;
    data = NULL;
    {
        char myString[] = ""myString"";
        
        data = strdup(myString);
        
        printLine(data);
    }
    const CWE401_Memory_Leak__strdup_char_81_base& baseObject = CWE401_Memory_Leak__strdup_char_81_bad();
"
17633,0,CWE590_Free_Memory_Not_on_Heap__free_struct_declare_17.c,"    int i;
    twoIntsStruct * data;
    data = NULL; 
    for(i = 0; i < 1; i++)
    {
        {
            
            twoIntsStruct dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i].intOne = 1;
                    dataBuffer[i].intTwo = 1;
                }
            }
            data = dataBuffer;
        }
    }
    printStructLine(&data[0]);
    
"
6156,0,CWE197_Numeric_Truncation_Error__int_large_to_char_15.c,"    int data;
    
    data = -1;
    switch(6)
    {
    case 6:
        
        data = SHRT_MAX + 5;
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
13342,0,CWE563_Unused_Variable__unused_uninit_variable_int64_t_15.c,"    int64_t data;
    
    ; 
    switch(6)
    {
    case 6:
        
        
        ; 
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
12948,0,CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_33.cpp,"    char * data;
    char * &dataRef = data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    {
        char * data = dataRef;
        badVaSink(data, data);
"
6484,1,CWE665_Improper_Initialization__class_01_good1.cpp,"    GoodClass goodClassObject = GoodClass();

    cout << ""Initialized? "";
    if (goodClassObject.isInitialized())
    {
        cout << ""true"";
    }
    else
    {
        cout << ""false"";
    }
"
4681,0,CWE134_Uncontrolled_Format_String__char_listen_socket_printf_42.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    data = badSource(data);
    
"
16,0,CWE457_Use_of_Uninitialized_Variable__int64_t_15.c,"    int64_t data;
    switch(6)
    {
    case 6:
        
        ; 
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
        
        printLongLongLine(data);
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
11820,0,CWE190_Integer_Overflow__int_max_preinc_14.c,"    int data;
    
    data = 0;
    if(globalFive==5)
    {
        
        data = INT_MAX;
    }
    if(globalFive==5)
    {
        {
            
            ++data;
            int result = data;
            printIntLine(result);
        }
"
16596,0,CWE190_Integer_Overflow__char_fscanf_preinc_63a.c,"    char data;
    data = ' ';
    
    fscanf (stdin, ""%c"", &data);
"
5015,0,CWE590_Free_Memory_Not_on_Heap__delete_int64_t_alloca_82a.cpp,"    int64_t * data;
    data = NULL; 
    {
        
        int64_t * dataBuffer = (int64_t *)ALLOCA(sizeof(int64_t));
        *dataBuffer = 5LL;
        data = dataBuffer;
    }
    CWE590_Free_Memory_Not_on_Heap__delete_int64_t_alloca_82_base* baseObject = new CWE590_Free_Memory_Not_on_Heap__delete_int64_t_alloca_82_bad;
    baseObject->action(data);
"
8665,0,CWE789_Uncontrolled_Mem_Alloc__new_char_fgets_04.cpp,"    size_t data;
    
    data = 0;
    if(STATIC_CONST_TRUE)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                
                data = strtoul(inputBuffer, NULL, 0);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    if(STATIC_CONST_TRUE)
    {
        {
            char * myString;
            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
             * for the strcpy() function to not cause a buffer overflow */
            
            if (data > strlen(HELLO_STRING))
            {
                myString = new char[data];
                
                strcpy(myString, HELLO_STRING);
                printLine(myString);
                delete [] myString;
            }
            else
            {
                printLine(""Input is less than the length of the source string"");
            }
        }
"
12092,0,CWE190_Integer_Overflow__unsigned_int_rand_multiply_21.c,"    unsigned int data;
    data = 0;
    
    data = (unsigned int)RAND32();
    badStatic = 1; 
"
15535,0,CWE563_Unused_Variable__unused_uninit_variable_long_84a.cpp,"    long data;
    CWE563_Unused_Variable__unused_uninit_variable_long_84_bad * badObject = new CWE563_Unused_Variable__unused_uninit_variable_long_84_bad(data);
"
6706,0,CWE369_Divide_by_Zero__float_fscanf_52a.c,"    float data;
    
    data = 0.0F;
    
    fscanf (stdin, ""%f"", &data);
"
1434,0,CWE197_Numeric_Truncation_Error__short_listen_socket_43.cpp,"    short data;
    
    data = -1;
    badSource(data);
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
11248,0,CWE190_Integer_Overflow__int64_t_rand_add_18.c,"    int64_t data;
    data = 0LL;
    goto source;
source:
    
    data = (int64_t)RAND64();
    goto sink;
sink:
    {
        
        int64_t result = data + 1;
        printLongLongLine(result);
"
19521,0,CWE415_Double_Free__malloc_free_int_02.c,"    int * data;
    
    data = NULL;
    if(1)
    {
        data = (int *)malloc(100*sizeof(int));
        if (data == NULL) {exit(-1);}
        
        free(data);
    }
    if(1)
    {
        
        free(data);
"
9698,0,CWE190_Integer_Overflow__unsigned_int_max_multiply_06.c,"    unsigned int data;
    data = 0;
    if(STATIC_CONST_FIVE==5)
    {
        
        data = UINT_MAX;
    }
    if(STATIC_CONST_FIVE==5)
    {
        if(data > 0) 
        {
            
            unsigned int result = data * 2;
            printUnsignedLine(result);
        }
"
7732,0,CWE197_Numeric_Truncation_Error__short_rand_52a.c,"    short data;
    
    data = -1;
    
    data = (short)RAND32();
"
12627,0,CWE690_NULL_Deref_From_Return__int64_t_calloc_74a.cpp,"    int64_t * data;
    map<int, int64_t *> dataMap;
    data = NULL; 
    
    data = (int64_t *)calloc(1, sizeof(int64_t));
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
3573,1,CWE252_Unchecked_Return_Value__char_remove_06.c,"    if(STATIC_CONST_FIVE!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        
        if (REMOVE(""removemegood.txt"") != 0)
        {
            printLine(""remove failed!"");
        }
"
7737,0,CWE134_Uncontrolled_Format_String__char_environment_vprintf_16.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    while(1)
    {
        {
            
            size_t dataLen = strlen(data);
            char * environment = GETENV(ENV_VARIABLE);
            
            if (environment != NULL)
            {
                
                strncat(data+dataLen, environment, 100-dataLen-1);
            }
        }
        break;
    }
    while(1)
    {
        badVaSinkB(data, data);
        break;
"
1407,0,CWE134_Uncontrolled_Format_String__char_connect_socket_printf_15.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    switch(6)
    {
    case 6:
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
        
        printf(data);
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
11561,0,CWE401_Memory_Leak__int_realloc_84_bad.cpp,"Label Definition File: CWE401_Memory_Leak.c.label.xml
Template File: sources-sinks-84_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 401 Memory Leak
 * BadSource: realloc Allocate data using realloc()
 * GoodSource: Allocate data on the stack
 * Sinks:
 *    GoodSink: call free() on data
 *    BadSink : no deallocation of data
 * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE401_Memory_Leak__int_realloc_84.h""

namespace CWE401_Memory_Leak__int_realloc_84
{
CWE401_Memory_Leak__int_realloc_84_bad::CWE401_Memory_Leak__int_realloc_84_bad(int * dataCopy)
{
    data = dataCopy;
    
    data = (int *)realloc(data, 100*sizeof(int));
    if (data == NULL) {exit(-1);}
    
    data[0] = 5;
    printIntLine(data[0]);
}

CWE401_Memory_Leak__int_realloc_84_bad::~CWE401_Memory_Leak__int_realloc_84_bad()
{
    
    ; 
}
}
"
18689,0,CWE190_Integer_Overflow__unsigned_int_fscanf_square_82_bad.cpp,"Label Definition File: CWE190_Integer_Overflow.label.xml
Template File: sources-sinks-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 190 Integer Overflow
 * BadSource: fscanf Read data from the console using fscanf()
 * GoodSource: Set data to a small, non-zero number (two)
 * Sinks: square
 *    GoodSink: Ensure there will not be an overflow before squaring data
 *    BadSink : Square data, which can lead to overflow
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE190_Integer_Overflow__unsigned_int_fscanf_square_82.h""

#include <math.h>

namespace CWE190_Integer_Overflow__unsigned_int_fscanf_square_82
{

void CWE190_Integer_Overflow__unsigned_int_fscanf_square_82_bad::action(unsigned int data)
{
    {
        
        unsigned int result = data * data;
        printUnsignedLine(result);
    }
}

}
"
19426,0,CWE476_NULL_Pointer_Dereference__class_81_bad.cpp,"Label Definition File: CWE476_NULL_Pointer_Dereference__class.label.xml
Template File: sources-sinks-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 476 NULL Pointer Dereference
 * BadSource:  Set data to NULL
 * GoodSource: Initialize data
 * Sinks:
 *    GoodSink: Check data for NULL before attempting to print data->a
 *    BadSink : Print data->a
 * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE476_NULL_Pointer_Dereference__class_81.h""

namespace CWE476_NULL_Pointer_Dereference__class_81
{

void CWE476_NULL_Pointer_Dereference__class_81_bad::action(TwoIntsClass * data) const
{
    
    printIntLine(data->intOne);
    
    delete data;
}

}
"
15308,0,CWE78_OS_Command_Injection__char_file_execlp_82a.cpp,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        FILE * pFile;
        
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
    CWE78_OS_Command_Injection__char_file_execlp_82_base* baseObject = new CWE78_OS_Command_Injection__char_file_execlp_82_bad;
    baseObject->action(data);
"
16990,0,CWE758_Undefined_Behavior__int_pointer_malloc_use_12.c,"    if(globalReturnsTrueOrFalse())
    {
        {
            int * * pointer = (int * *)malloc(sizeof(int *));
            if (pointer == NULL) {exit(-1);}
            int * data = *pointer; 
            free(pointer);
            printIntLine(*data);
        }
    }
    else
    {
        {
            int * data;
            int * * pointer = (int * *)malloc(sizeof(int *));
            if (pointer == NULL) {exit(-1);}
            
            data = (int *)malloc(sizeof(int));
            if (data == NULL) {exit(-1);}
            *data = 5;
            *pointer = data; 
            {
                int * data = *pointer;
                printIntLine(*data);
            }
            free(pointer);
        }
"
4488,0,CWE590_Free_Memory_Not_on_Heap__delete_int_placement_new_15.cpp,"    int * data;
    data = NULL; 
    switch(6)
    {
    case 6:
    {
        
        char buffer[sizeof(int)];
        int * dataBuffer = new(buffer) int;
        *dataBuffer = 5;
        data = dataBuffer;
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    printIntLine(*data);
    
"
8268,0,CWE590_Free_Memory_Not_on_Heap__free_char_declare_07.c,"    char * data;
    data = NULL; 
    if(staticFive==5)
    {
        {
            
            char dataBuffer[100];
            memset(dataBuffer, 'A', 100-1); 
            dataBuffer[100-1] = '\0'; 
            data = dataBuffer;
        }
    }
    printLine(data);
    
"
1143,0,CWE134_Uncontrolled_Format_String__char_console_vfprintf_66a.c,"    char * data;
    char * dataArray[5];
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        
        if (100-dataLen > 1)
        {
            
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgets() */
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
                    data[dataLen-1] = '\0';
                }
            }
            else
            {
                printLine(""fgets() failed"");
                
                data[dataLen] = '\0';
            }
        }
    }
    
    dataArray[2] = data;
"
1394,0,CWE78_OS_Command_Injection__char_listen_socket_popen_14.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(globalFive==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                data[dataLen + recvResult / sizeof(char)] = '\0';
                
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    {
        FILE *pipe;
        
        pipe = POPEN(data, ""w"");
        if (pipe != NULL)
        {
            PCLOSE(pipe);
        }
"
7761,1,CWE758_Undefined_Behavior__long_new_use_05.cpp,"    if(staticTrue)
    {
        {
            long data;
            data = 5L;
            long * pointer = new long;
            *pointer = data; 
            {
                long data = *pointer;
                printLongLine(data);
            }
            delete pointer;
        }
"
9952,0,CWE190_Integer_Overflow__int_fscanf_multiply_61a.c,"    int data;
    
    data = 0;
    data = CWE190_Integer_Overflow__int_fscanf_multiply_61b_badSource(data);
    if(data > 0) 
    {
        
        int result = data * 2;
        printIntLine(result);
"
749,0,CWE78_OS_Command_Injection__char_connect_socket_execl_21.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    badStatic = 1; 
    data = badSource(data);
    
    
    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}

#endif 

#ifndef OMITGOOD


static int goodG2B1Static = 0;
static int goodG2B2Static = 0;
"
3380,0,CWE190_Integer_Overflow__short_fscanf_preinc_65a.c,"    short data;
    
    void (*funcPtr) (short) = CWE190_Integer_Overflow__short_fscanf_preinc_65b_badSink;
    data = 0;
    
    fscanf (stdin, ""%hd"", &data);
    
"
15595,0,CWE690_NULL_Deref_From_Return__fopen_53a.c,"    FILE * data;
    
    data = NULL;
    
    data = fopen(""file.txt"", ""w+"");
"
8399,0,CWE690_NULL_Deref_From_Return__char_calloc_04.c,"    char * data;
    data = NULL; 
    
    data = (char *)calloc(20, sizeof(char));
    if(STATIC_CONST_TRUE)
    {
        
        strcpy(data, ""Initialize"");
        printLine(data);
        free(data);
"
12777,0,CWE78_OS_Command_Injection__char_environment_execl_81_bad.cpp,"Label Definition File: CWE78_OS_Command_Injection.strings.label.xml
Template File: sources-sink-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 78 OS Command Injection
 * BadSource: environment Read input from an environment variable
 * GoodSource: Fixed string
 * Sinks: execl
 *    BadSink : execute command with execl
 * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE78_OS_Command_Injection__char_environment_execl_81.h""

#ifdef _WIN32
#include <process.h>
#define EXECL _execl
#else 
#define EXECL execl
#endif

namespace CWE78_OS_Command_Injection__char_environment_execl_81
{

void CWE78_OS_Command_Injection__char_environment_execl_81_bad::action(char * data) const
{
    
    
    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}

}
"
1008,0,CWE197_Numeric_Truncation_Error__int_rand_to_char_83_bad.cpp,"Label Definition File: CWE197_Numeric_Truncation_Error__int.label.xml
Template File: sources-sink-83_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 197 Numeric Truncation Error
 * BadSource: rand Set data to result of rand(), which may be zero
 * GoodSource: Less than CHAR_MAX
 * Sinks: to_char
 *    BadSink : Convert data to a char
 * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE197_Numeric_Truncation_Error__int_rand_to_char_83.h""

namespace CWE197_Numeric_Truncation_Error__int_rand_to_char_83
{
CWE197_Numeric_Truncation_Error__int_rand_to_char_83_bad::CWE197_Numeric_Truncation_Error__int_rand_to_char_83_bad(int dataCopy)
{
    data = dataCopy;
    
    data = RAND32();
}

CWE197_Numeric_Truncation_Error__int_rand_to_char_83_bad::~CWE197_Numeric_Truncation_Error__int_rand_to_char_83_bad()
{
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
    }
}
}
"
15816,1,CWE758_Undefined_Behavior__int_malloc_use_08.c,"    if(staticReturnsTrue())
    {
        {
            int data;
            int * pointer = (int *)malloc(sizeof(int));
            if (pointer == NULL) {exit(-1);}
            data = 5;
            *pointer = data; 
            {
                int data = *pointer;
                printIntLine(data);
            }
            free(pointer);
        }
"
6534,0,CWE563_Unused_Variable__unused_init_variable_char_07.c,"    char data;
    
    data = 'C';
    if(staticFive==5)
    {
        
        
        ; 
"
7878,1,CWE758_Undefined_Behavior__class_new_use_05.cpp,"    if(staticTrue)
    {
        {
            TwoIntsClass data;
            data.intOne = 1;
            data.intTwo = 2;
            TwoIntsClass * pointer = new TwoIntsClass;
            *pointer = data; 
            {
                TwoIntsClass data = *pointer;
                printIntLine(data.intOne);
                printIntLine(data.intTwo);
            }
            delete pointer;
        }
"
2621,0,CWE457_Use_of_Uninitialized_Variable__twointsclass_array_alloca_partial_init_62a.cpp,"    TwoIntsClass * data;
    data = reinterpret_cast<TwoIntsClass *>(ALLOCA(10*sizeof(TwoIntsClass)));
    badSource(data);
    
    for(int i=0; i<10; i++)
    {
        printIntLine(data[i].intOne);
        printIntLine(data[i].intTwo);
"
12568,0,CWE457_Use_of_Uninitialized_Variable__new_double_array_partial_init_10.cpp,"    double * data;
    data = new double[10];
    if(globalTrue)
    {
        
        {
            int i;
            for(i=0; i<(10/2); i++)
            {
                data[i] = (double)i;
            }
        }
    }
    if(globalTrue)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printDoubleLine(data[i]);
            }
        }
        
        delete [] data;
"
11832,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_63a.c,"    size_t data;
    
    data = 0;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = strtoul(inputBuffer, NULL, 0);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
"
1158,1,CWE758_Undefined_Behavior__int_pointer_new_use_09.cpp,"    if(GLOBAL_CONST_TRUE)
    {
        {
            int * data;
            
            data = new int;
            *data = 5;
            int * * pointer = new int *;
            *pointer = data; 
            {
                int * data = *pointer;
                printIntLine(*data);
            }
            delete pointer;
        }
"
13225,0,CWE190_Integer_Overflow__int_fscanf_square_04.c,"    int data;
    
    data = 0;
    if(STATIC_CONST_TRUE)
    {
        
        fscanf(stdin, ""%d"", &data);
    }
    if(STATIC_CONST_TRUE)
    {
        {
            
            int result = data * data;
            printIntLine(result);
        }
"
12838,0,CWE78_OS_Command_Injection__char_connect_socket_popen_21.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    badStatic = 1; 
    data = badSource(data);
    {
        FILE *pipe;
        
        pipe = POPEN(data, ""w"");
        if (pipe != NULL)
        {
            PCLOSE(pipe);
        }
    }
}

#endif 
"
18220,0,CWE401_Memory_Leak__new_array_TwoIntsClass_74a.cpp,"    TwoIntsClass * data;
    map<int, TwoIntsClass *> dataMap;
    data = NULL;
    
    data = new TwoIntsClass[100];
    
    data[0].intOne = 0;
    data[0].intTwo = 0;
    printIntLine(data[0].intOne);
    printIntLine(data[0].intTwo);
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
1169,0,CWE590_Free_Memory_Not_on_Heap__delete_long_alloca_34.cpp,"    long * data;
    unionType myUnion;
    data = NULL; 
    {
        
        long * dataBuffer = (long *)ALLOCA(sizeof(long));
        *dataBuffer = 5L;
        data = dataBuffer;
    }
    myUnion.unionFirst = data;
    {
        long * data = myUnion.unionSecond;
        printLongLine(*data);
        
        delete data;
"
3344,0,CWE590_Free_Memory_Not_on_Heap__delete_int_alloca_04.cpp,"    int * data;
    data = NULL; 
    if(STATIC_CONST_TRUE)
    {
        {
            
            int * dataBuffer = (int *)ALLOCA(sizeof(int));
            *dataBuffer = 5;
            data = dataBuffer;
        }
    }
    printIntLine(*data);
    
"
13313,0,CWE590_Free_Memory_Not_on_Heap__free_struct_alloca_03.c,"    twoIntsStruct * data;
    data = NULL; 
    if(5==5)
    {
        {
            
            twoIntsStruct * dataBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i].intOne = 1;
                    dataBuffer[i].intTwo = 1;
                }
            }
            data = dataBuffer;
        }
    }
    printStructLine(&data[0]);
    
"
200,1,CWE252_Unchecked_Return_Value__char_putc_17.c,"    int k;
    for(k = 0; k < 1; k++)
    {
        
        if (putc((int)'A', stdout) == EOF)
        {
            printLine(""putc failed!"");
        }
"
13592,1,CWE758_Undefined_Behavior__int64_t_alloca_use_05.c,"    if(staticFalse)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            int64_t data;
            int64_t * pointer = (int64_t *)ALLOCA(sizeof(int64_t));
            data = 5LL;
            *pointer = data; 
            {
                int64_t data = *pointer;
                printLongLongLine(data);
            }
        }
"
6742,0,CWE789_Uncontrolled_Mem_Alloc__new_char_rand_53a.cpp,"    size_t data;
    
    data = 0;
    
    data = rand();
"
5070,1,CWE758_Undefined_Behavior__char_alloca_use_02.c,"    if(1)
    {
        {
            char data;
            char * pointer = (char *)ALLOCA(sizeof(char));
            data = 5;
            *pointer = data; 
            {
                char data = *pointer;
                printHexCharLine(data);
            }
        }
"
1056,0,CWE401_Memory_Leak__int64_t_calloc_07.c,"    int64_t * data;
    data = NULL;
    if(staticFive==5)
    {
        
        data = (int64_t *)calloc(100, sizeof(int64_t));
        if (data == NULL) {exit(-1);}
        
        data[0] = 5LL;
        printLongLongLine(data[0]);
    }
    if(staticFive==5)
    {
        
        ; 
"
11964,0,CWE190_Integer_Overflow__int_connect_socket_add_61a.c,"    int data;
    
    data = 0;
    data = CWE190_Integer_Overflow__int_connect_socket_add_61b_badSource(data);
    {
        
        int result = data + 1;
        printIntLine(result);
"
11769,0,CWE415_Double_Free__new_delete_int_63a.cpp,"    int * data;
    
    data = NULL;
    data = new int;
    
    delete data;
"
12593,0,CWE190_Integer_Overflow__int_rand_add_83_bad.cpp,"Label Definition File: CWE190_Integer_Overflow__int.label.xml
Template File: sources-sinks-83_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 190 Integer Overflow
 * BadSource: rand Set data to result of rand(), which may be zero
 * GoodSource: Set data to a small, non-zero number (two)
 * Sinks: add
 *    GoodSink: Ensure there will not be an overflow before adding 1 to data
 *    BadSink : Add 1 to data, which can cause an overflow
 * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE190_Integer_Overflow__int_rand_add_83.h""

namespace CWE190_Integer_Overflow__int_rand_add_83
{
CWE190_Integer_Overflow__int_rand_add_83_bad::CWE190_Integer_Overflow__int_rand_add_83_bad(int dataCopy)
{
    data = dataCopy;
    
    data = RAND32();
}

CWE190_Integer_Overflow__int_rand_add_83_bad::~CWE190_Integer_Overflow__int_rand_add_83_bad()
{
    {
        
        int result = data + 1;
        printIntLine(result);
    }
}
}
"
3949,0,CWE190_Integer_Overflow__int_rand_preinc_01.c,"    int data;
    
    data = 0;
    
    data = RAND32();
    {
        
        ++data;
        int result = data;
        printIntLine(result);
"
591,0,CWE190_Integer_Overflow__char_rand_multiply_43.cpp,"    char data;
    data = ' ';
    badSource(data);
    if(data > 0) 
    {
        
        char result = data * 2;
        printHexCharLine(result);
"
14394,0,CWE590_Free_Memory_Not_on_Heap__delete_class_placement_new_82a.cpp,"    TwoIntsClass * data;
    data = NULL; 
    {
        
        char buffer[sizeof(TwoIntsClass)];
        TwoIntsClass * dataBuffer = new(buffer) TwoIntsClass;
        dataBuffer->intOne = 2;
        dataBuffer->intTwo = 2;
        data = dataBuffer;
    }
    CWE590_Free_Memory_Not_on_Heap__delete_class_placement_new_82_base* baseObject = new CWE590_Free_Memory_Not_on_Heap__delete_class_placement_new_82_bad;
    baseObject->action(data);
"
293,0,CWE590_Free_Memory_Not_on_Heap__delete_int64_t_alloca_06.cpp,"    int64_t * data;
    data = NULL; 
    if(STATIC_CONST_FIVE==5)
    {
        {
            
            int64_t * dataBuffer = (int64_t *)ALLOCA(sizeof(int64_t));
            *dataBuffer = 5LL;
            data = dataBuffer;
        }
    }
    printLongLongLine(*data);
    
"
2064,0,CWE252_Unchecked_Return_Value__char_puts_14.c,"    if(globalFive==5)
    {
        
        PUTS(""string"");
"
3452,0,CWE457_Use_of_Uninitialized_Variable__new_int_array_no_init_06.cpp,"    int * data;
    data = new int[10];
    if(STATIC_CONST_FIVE==5)
    {
        
        ; 
    }
    if(STATIC_CONST_FIVE==5)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i]);
            }
        }
        
        delete [] data;
"
8308,0,CWE78_OS_Command_Injection__char_listen_socket_system_44.c,"    char * data;
    
    void (*funcPtr) (char *) = badSink;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
"
5640,0,CWE563_Unused_Variable__unused_uninit_variable_long_06.c,"    long data;
    
    ; 
    if(STATIC_CONST_FIVE==5)
    {
        
        
        ; 
"
16901,0,CWE78_OS_Command_Injection__char_file_execl_33.cpp,"    char * data;
    char * &dataRef = data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        FILE * pFile;
        
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
    {
        char * data = dataRef;
        
        
        EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
"
14658,0,CWE563_Unused_Variable__unused_value_struct_72a.cpp,"    twoIntsStruct data;
    vector<twoIntsStruct> dataVector;
    
    data.intOne = 0;
    data.intTwo = 0;
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
17453,0,CWE476_NULL_Pointer_Dereference__struct_65a.c,"    twoIntsStruct * data;
    
    void (*funcPtr) (twoIntsStruct *) = CWE476_NULL_Pointer_Dereference__struct_65b_badSink;
    
    data = NULL;
    
"
5353,0,CWE690_NULL_Deref_From_Return__fopen_72a.cpp,"    FILE * data;
    vector<FILE *> dataVector;
    
    data = NULL;
    
    data = fopen(""file.txt"", ""w+"");
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
258,0,CWE590_Free_Memory_Not_on_Heap__delete_class_static_10.cpp,"    TwoIntsClass * data;
    data = NULL; 
    if(globalTrue)
    {
        {
            
            static TwoIntsClass dataBuffer;
            dataBuffer.intOne = 1;
            dataBuffer.intTwo = 1;
            data = &dataBuffer;
        }
    }
    printIntLine(data->intOne);
    
"
3532,0,CWE457_Use_of_Uninitialized_Variable__twointsclass_array_declare_partial_init_01.cpp,"    TwoIntsClass * data;
    TwoIntsClass dataUninitArray[10];
    data = dataUninitArray;
    
    for(int i=0; i<(10/2); i++)
    {
        data[i].intOne = i;
        data[i].intTwo = i;
    }
    
    for(int i=0; i<10; i++)
    {
        printIntLine(data[i].intOne);
        printIntLine(data[i].intTwo);
"
13149,0,CWE190_Integer_Overflow__unsigned_int_max_preinc_14.c,"    unsigned int data;
    data = 0;
    if(globalFive==5)
    {
        
        data = UINT_MAX;
    }
    if(globalFive==5)
    {
        {
            
            ++data;
            unsigned int result = data;
            printUnsignedLine(result);
        }
"
18624,0,CWE197_Numeric_Truncation_Error__int_large_to_char_33.cpp,"    int data;
    int &dataRef = data;
    
    data = -1;
    
    data = SHRT_MAX + 5;
    {
        int data = dataRef;
        {
            
            char charData = (char)data;
            printHexCharLine(charData);
        }
"
8282,0,CWE190_Integer_Overflow__char_max_multiply_63a.c,"    char data;
    data = ' ';
    
    data = CHAR_MAX;
"
1989,0,CWE476_NULL_Pointer_Dereference__int_44.c,"    int * data;
    
    void (*funcPtr) (int *) = badSink;
    
    data = NULL;
    
"
14702,0,CWE197_Numeric_Truncation_Error__int_fgets_to_char_15.c,"    int data;
    
    data = -1;
    switch(6)
    {
    case 6:
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
10369,0,CWE190_Integer_Overflow__char_max_add_08.c,"    char data;
    data = ' ';
    if(staticReturnsTrue())
    {
        
        data = CHAR_MAX;
    }
    if(staticReturnsTrue())
    {
        {
            
            char result = data + 1;
            printHexCharLine(result);
        }
"
18295,0,CWE457_Use_of_Uninitialized_Variable__new_int_array_partial_init_03.cpp,"    int * data;
    data = new int[10];
    if(5==5)
    {
        
        {
            int i;
            for(i=0; i<(10/2); i++)
            {
                data[i] = i;
            }
        }
    }
    if(5==5)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i]);
            }
        }
        
        delete [] data;
"
7128,0,CWE690_NULL_Deref_From_Return__fopen_10.c,"    FILE * data;
    
    data = NULL;
    
    data = fopen(""file.txt"", ""w+"");
    if(globalTrue)
    {
        
        fclose(data);
"
11119,0,CWE197_Numeric_Truncation_Error__int_listen_socket_to_short_61a.c,"    int data;
    
    data = -1;
    data = CWE197_Numeric_Truncation_Error__int_listen_socket_to_short_61b_badSource(data);
    {
        
        short shortData = (short)data;
        printShortLine(shortData);
"
18577,0,CWE401_Memory_Leak__new_array_struct_twoIntsStruct_12.cpp,"    struct _twoIntsStruct * data;
    data = NULL;
    if(globalReturnsTrueOrFalse())
    {
        
        data = new struct _twoIntsStruct[100];
        
        data[0].intOne = 0;
        data[0].intTwo = 0;
        printStructLine((twoIntsStruct *)&data[0]);
    }
    else
    {
        
        struct _twoIntsStruct dataGoodBuffer[100];
        data = dataGoodBuffer;
        
        data[0].intOne = 0;
        data[0].intTwo = 0;
        printStructLine((twoIntsStruct *)&data[0]);
    }
    if(globalReturnsTrueOrFalse())
    {
        
        ; 
    }
    else
    {
        
        delete[] data;
"
13975,0,CWE690_NULL_Deref_From_Return__int_realloc_08.c,"    int * data;
    data = NULL; 
    
    data = (int *)realloc(data, 1*sizeof(int));
    if(staticReturnsTrue())
    {
        
        data[0] = 5;
        printIntLine(data[0]);
        free(data);
"
18384,0,CWE758_Undefined_Behavior__char_pointer_alloca_use_15.c,"    switch(6)
    {
    case 6:
    {
        char * * pointer = (char * *)ALLOCA(sizeof(char *));
        char * data = *pointer; 
        printLine(data);
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
15499,0,CWE758_Undefined_Behavior__struct_alloca_use_10.c,"    if(globalTrue)
    {
        {
            twoIntsStruct * pointer = (twoIntsStruct *)ALLOCA(sizeof(twoIntsStruct));
            twoIntsStruct data = *pointer; 
            printIntLine(data.intOne);
            printIntLine(data.intTwo);
        }
"
14980,0,CWE416_Use_After_Free__new_delete_long_03.cpp,"    long * data;
    
    data = NULL;
    if(5==5)
    {
        data = new long;
        *data = 5L;
        
        delete data;
    }
    if(5==5)
    {
        
        printLongLine(*data);
        
"
10509,0,CWE401_Memory_Leak__struct_twoIntsStruct_malloc_18.c,"    struct _twoIntsStruct * data;
    data = NULL;
    goto source;
source:
    
    data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));
    if (data == NULL) {exit(-1);}
    
    data[0].intOne = 0;
    data[0].intTwo = 0;
    printStructLine((twoIntsStruct *)&data[0]);
    goto sink;
sink:
    
"
1245,0,CWE590_Free_Memory_Not_on_Heap__free_char_alloca_67a.c,"    char * data;
    CWE590_Free_Memory_Not_on_Heap__free_char_alloca_67_structType myStruct;
    data = NULL; 
    {
        
        char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
        memset(dataBuffer, 'A', 100-1); 
        dataBuffer[100-1] = '\0'; 
        data = dataBuffer;
    }
    myStruct.structFirst = data;
"
6573,0,CWE190_Integer_Overflow__char_max_multiply_11.c,"    char data;
    data = ' ';
    if(globalReturnsTrue())
    {
        
        data = CHAR_MAX;
    }
    if(globalReturnsTrue())
    {
        if(data > 0) 
        {
            
            char result = data * 2;
            printHexCharLine(result);
        }
"
4161,0,CWE690_NULL_Deref_From_Return__long_calloc_33.cpp,"    long * data;
    long * &dataRef = data;
    data = NULL; 
    
    data = (long *)calloc(1, sizeof(long));
    {
        long * data = dataRef;
        
        data[0] = 5L;
        printLongLine(data[0]);
        free(data);
"
13731,0,CWE690_NULL_Deref_From_Return__int64_t_malloc_18.c,"    int64_t * data;
    data = NULL; 
    
    data = (int64_t *)malloc(1*sizeof(int64_t));
    goto sink;
sink:
    
    data[0] = 5LL;
    printLongLongLine(data[0]);
"
18381,0,CWE78_OS_Command_Injection__char_file_system_74a.cpp,"    char * data;
    map<int, char *> dataMap;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
        
        size_t dataLen = strlen(data);
        FILE * pFile;
        
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
8822,0,CWE190_Integer_Overflow__int_connect_socket_preinc_17.c,"    int i,j;
    int data;
    
    data = 0;
    for(i = 0; i < 1; i++)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    for(j = 0; j < 1; j++)
    {
        {
            
            ++data;
            int result = data;
            printIntLine(result);
        }
"
11123,0,CWE590_Free_Memory_Not_on_Heap__delete_long_alloca_15.cpp,"    long * data;
    data = NULL; 
    switch(6)
    {
    case 6:
    {
        
        long * dataBuffer = (long *)ALLOCA(sizeof(long));
        *dataBuffer = 5L;
        data = dataBuffer;
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    printLongLine(*data);
    
"
17288,0,CWE134_Uncontrolled_Format_String__char_environment_printf_18.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    goto source;
source:
    {
        
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        
        if (environment != NULL)
        {
            
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    goto sink;
sink:
    
"
7248,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_07.c,"    size_t data;
    
    data = 0;
    if(staticFive==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = strtoul(inputBuffer, NULL, 0);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(staticFive==5)
    {
        {
            char * myString;
            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
             * for the strcpy() function to not cause a buffer overflow */
            
            if (data > strlen(HELLO_STRING))
            {
                myString = (char *)malloc(data*sizeof(char));
                if (myString == NULL) {exit(-1);}
                
                strcpy(myString, HELLO_STRING);
                printLine(myString);
                free(myString);
            }
            else
            {
                printLine(""Input is less than the length of the source string"");
            }
        }
"
4545,0,CWE467_Use_of_sizeof_on_Pointer_Type__int_11.c,"    if(globalReturnsTrue())
    {
        {
            int * badInt = NULL;
            
            badInt = (int *)malloc(sizeof(badInt));
            if (badInt == NULL) {exit(-1);}
            *badInt = 5;
            printIntLine(*badInt);
            free(badInt);
        }
"
16116,0,CWE369_Divide_by_Zero__int_connect_socket_divide_04.c,"    int data;
    
    data = -1;
    if(STATIC_CONST_TRUE)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(STATIC_CONST_TRUE)
    {
        
        printIntLine(100 / data);
"
10106,0,CWE590_Free_Memory_Not_on_Heap__delete_array_long_declare_34.cpp,"    long * data;
    unionType myUnion;
    data = NULL; 
    {
        
        long dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5L;
            }
        }
        data = dataBuffer;
    }
    myUnion.unionFirst = data;
    {
        long * data = myUnion.unionSecond;
        printLongLine(data[0]);
        
        delete [] data;
"
10555,0,CWE590_Free_Memory_Not_on_Heap__delete_int64_t_placement_new_10.cpp,"    int64_t * data;
    data = NULL; 
    if(globalTrue)
    {
        {
            
            char buffer[sizeof(int64_t)];
            int64_t * dataBuffer = new(buffer) int64_t;
            *dataBuffer = 5LL;
            data = dataBuffer;
        }
    }
    printLongLongLine(*data);
    
"
4362,0,CWE563_Unused_Variable__unused_init_variable_int64_t_04.c,"    int64_t data;
    
    data = 5LL;
    if(STATIC_CONST_TRUE)
    {
        
        
        ; 
"
13400,0,CWE401_Memory_Leak__new_array_TwoIntsClass_44.cpp,"    TwoIntsClass * data;
    
    void (*funcPtr) (TwoIntsClass *) = badSink;
    data = NULL;
    
    data = new TwoIntsClass[100];
    
    data[0].intOne = 0;
    data[0].intTwo = 0;
    printIntLine(data[0].intOne);
    printIntLine(data[0].intTwo);
    
"
5408,0,CWE676_Use_of_Potentially_Dangerous_Function__basic_05.cpp,"    if(staticTrue)
    {
        {
            char charBuffer[CHAR_BUFFER_SIZE];
            
            
            cin >> charBuffer;
            charBuffer[CHAR_BUFFER_SIZE-1] = '\0';
            printLine(charBuffer);
        }
"
1397,0,CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_01.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
8925,0,CWE457_Use_of_Uninitialized_Variable__int_array_malloc_partial_init_62a.cpp,"    int * data;
    data = (int *)malloc(10*sizeof(int));
    if (data == NULL) {exit(-1);}
    badSource(data);
    
    {
        int i;
        for(i=0; i<10; i++)
        {
            printIntLine(data[i]);
        }
"
5753,0,CWE134_Uncontrolled_Format_String__char_file_vprintf_51a.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        FILE * pFile;
        
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
"
6849,0,CWE78_OS_Command_Injection__char_console_system_17.c,"    int i;
    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    for(i = 0; i < 1; i++)
    {
        {
            
            size_t dataLen = strlen(data);
            
            if (100-dataLen > 1)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
                {
                    /* The next few lines remove the carriage return from the string that is
                     * inserted by fgets() */
"
6599,1,CWE252_Unchecked_Return_Value__char_scanf_11.c,"    if(globalReturnsTrue())
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            
            if (scanf(""%99s\0"", data) == EOF)
            {
                printLine(""scanf failed!"");
            }
        }
"
4605,0,CWE197_Numeric_Truncation_Error__short_connect_socket_81_bad.cpp,"Label Definition File: CWE197_Numeric_Truncation_Error__short.label.xml
Template File: sources-sink-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 197 Numeric Truncation Error
 * BadSource: connect_socket Read data using a connect socket (client side)
 * GoodSource: Less than CHAR_MAX
 * Sinks:
 *    BadSink : Convert data to a char
 * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE197_Numeric_Truncation_Error__short_connect_socket_81.h""

namespace CWE197_Numeric_Truncation_Error__short_connect_socket_81
{

void CWE197_Numeric_Truncation_Error__short_connect_socket_81_bad::action(short data) const
{
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
    }
}

}
"
3959,1,CWE758_Undefined_Behavior__struct_pointer_malloc_use_12.c,"    if(globalReturnsTrueOrFalse())
    {
        {
            twoIntsStruct * data;
            twoIntsStruct * * pointer = (twoIntsStruct * *)malloc(sizeof(twoIntsStruct *));
            if (pointer == NULL) {exit(-1);}
            
            data = (twoIntsStruct *)malloc(sizeof(twoIntsStruct));
            if (data == NULL) {exit(-1);}
            data->intOne = 5;
            data->intTwo = 6;
            *pointer = data; 
            {
                twoIntsStruct * data = *pointer;
                printIntLine(data->intOne);
                printIntLine(data->intTwo);
            }
            free(pointer);
        }
    }
    else
    {
        {
            twoIntsStruct * data;
            twoIntsStruct * * pointer = (twoIntsStruct * *)malloc(sizeof(twoIntsStruct *));
            if (pointer == NULL) {exit(-1);}
            
            data = (twoIntsStruct *)malloc(sizeof(twoIntsStruct));
            if (data == NULL) {exit(-1);}
            data->intOne = 5;
            data->intTwo = 6;
            *pointer = data; 
            {
                twoIntsStruct * data = *pointer;
                printIntLine(data->intOne);
                printIntLine(data->intTwo);
            }
            free(pointer);
        }
"
765,0,CWE415_Double_Free__new_delete_int64_t_12.cpp,"    int64_t * data;
    
    data = NULL;
    if(globalReturnsTrueOrFalse())
    {
        data = new int64_t;
        
        delete data;
    }
    else
    {
        data = new int64_t;
        
    }
    if(globalReturnsTrueOrFalse())
    {
        
        delete data;
    }
    else
    {
        
        
        ; 
"
2092,0,CWE415_Double_Free__new_delete_array_char_45.cpp,"    char * data;
    
    data = NULL;
    data = new char[100];
    
    delete [] data;
    badData = data;
"
9390,0,CWE590_Free_Memory_Not_on_Heap__delete_char_declare_66a.cpp,"    char * data;
    char * dataArray[5];
    data = NULL; 
    {
        
        char dataBuffer;
        dataBuffer = 'A';
        data = &dataBuffer;
    }
    
    dataArray[2] = data;
"
2506,0,CWE789_Uncontrolled_Mem_Alloc__new_char_rand_83a.cpp,"    size_t data;
    
    data = 0;
"
8364,0,CWE690_NULL_Deref_From_Return__char_realloc_04.c,"    char * data;
    data = NULL; 
    
    data = (char *)realloc(data, 20*sizeof(char));
    if(STATIC_CONST_TRUE)
    {
        
        strcpy(data, ""Initialize"");
        printLine(data);
        free(data);
"
12591,0,CWE190_Integer_Overflow__int64_t_max_square_18.c,"    int64_t data;
    data = 0LL;
    goto source;
source:
    
    data = LLONG_MAX;
    goto sink;
sink:
    {
        
        int64_t result = data * data;
        printLongLongLine(result);
"
7245,0,CWE457_Use_of_Uninitialized_Variable__struct_array_declare_no_init_06.c,"    twoIntsStruct * data;
    twoIntsStruct dataUninitArray[10];
    data = dataUninitArray;
    if(STATIC_CONST_FIVE==5)
    {
        
        ; 
    }
    if(STATIC_CONST_FIVE==5)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i].intOne);
                printIntLine(data[i].intTwo);
            }
        }
"
7275,0,CWE369_Divide_by_Zero__float_fscanf_66a.c,"    float data;
    float dataArray[5];
    
    data = 0.0F;
    
    fscanf (stdin, ""%f"", &data);
    
    dataArray[2] = data;
"
4404,0,CWE457_Use_of_Uninitialized_Variable__double_array_malloc_no_init_04.c,"    double * data;
    data = (double *)malloc(10*sizeof(double));
    if (data == NULL) {exit(-1);}
    if(STATIC_CONST_TRUE)
    {
        
        ; 
    }
    if(STATIC_CONST_TRUE)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printDoubleLine(data[i]);
            }
        }
"
3608,0,CWE190_Integer_Overflow__int_fgets_square_21.c,"    int data;
    
    data = 0;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    badStatic = 1; 
"
14512,0,CWE476_NULL_Pointer_Dereference__struct_52a.c,"    twoIntsStruct * data;
    
    data = NULL;
"
461,0,CWE197_Numeric_Truncation_Error__int_connect_socket_to_short_15.c,"    int data;
    
    data = -1;
    switch(6)
    {
    case 6:
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    {
        
        short shortData = (short)data;
        printShortLine(shortData);
"
13425,0,CWE134_Uncontrolled_Format_String__char_file_printf_68a.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        FILE * pFile;
        
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
    CWE134_Uncontrolled_Format_String__char_file_printf_68_badData = data;
"
8425,0,CWE190_Integer_Overflow__int_fscanf_square_51a.c,"    int data;
    
    data = 0;
    
    fscanf(stdin, ""%d"", &data);
"
615,0,CWE457_Use_of_Uninitialized_Variable__struct_62a.cpp,"    twoIntsStruct data;
    badSource(data);
    
    printIntLine(data.intOne);
"
6449,0,CWE369_Divide_by_Zero__int_fgets_modulo_03.c,"    int data;
    
    data = -1;
    if(5==5)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    if(5==5)
    {
        
        printIntLine(100 % data);
"
6727,0,CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_22a.c,"    int data;
    
    data = -1;
    CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_22_badGlobal = 1; 
    data = CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_22_badSource(data);
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
14216,0,CWE190_Integer_Overflow__unsigned_int_rand_square_06.c,"    unsigned int data;
    data = 0;
    if(STATIC_CONST_FIVE==5)
    {
        
        data = (unsigned int)RAND32();
    }
    if(STATIC_CONST_FIVE==5)
    {
        {
            
            unsigned int result = data * data;
            printUnsignedLine(result);
        }
"
3720,0,CWE690_NULL_Deref_From_Return__int_realloc_21.c,"    int * data;
    data = NULL; 
    
    data = (int *)realloc(data, 1*sizeof(int));
    badStatic = 1; 
"
7748,0,CWE190_Integer_Overflow__int_listen_socket_preinc_41.c,"    int data;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
2708,0,CWE590_Free_Memory_Not_on_Heap__delete_array_char_declare_74a.cpp,"    char * data;
    map<int, char *> dataMap;
    data = NULL; 
    {
        
        char dataBuffer[100];
        memset(dataBuffer, 'A', 100-1); 
        dataBuffer[100-1] = '\0'; 
        data = dataBuffer;
    }
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
3057,0,CWE563_Unused_Variable__unused_uninit_variable_long_83a.cpp,"    long data;
"
19346,0,CWE134_Uncontrolled_Format_String__char_environment_fprintf_45.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        
        if (environment != NULL)
        {
            
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    CWE134_Uncontrolled_Format_String__char_environment_fprintf_45_badData = data;
"
7832,0,CWE190_Integer_Overflow__short_max_square_11.c,"    short data;
    data = 0;
    if(globalReturnsTrue())
    {
        
        data = SHRT_MAX;
    }
    if(globalReturnsTrue())
    {
        {
            
            short result = data * data;
            printIntLine(result);
        }
"
3625,0,CWE197_Numeric_Truncation_Error__int_rand_to_char_18.c,"    int data;
    
    data = -1;
    goto source;
source:
    
    data = RAND32();
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
13629,1,CWE758_Undefined_Behavior__long_new_use_10.cpp,"    if(globalTrue)
    {
        {
            long data;
            data = 5L;
            long * pointer = new long;
            *pointer = data; 
            {
                long data = *pointer;
                printLongLine(data);
            }
            delete pointer;
        }
"
2663,0,CWE415_Double_Free__malloc_free_char_67a.c,"    char * data;
    CWE415_Double_Free__malloc_free_char_67_structType myStruct;
    
    data = NULL;
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    
    free(data);
    myStruct.structFirst = data;
"
8068,0,CWE78_OS_Command_Injection__char_file_execl_62a.cpp,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    badSource(data);
    
    
"
1545,0,CWE190_Integer_Overflow__int_rand_multiply_33.cpp,"    int data;
    int &dataRef = data;
    
    data = 0;
    
    data = RAND32();
    {
        int data = dataRef;
        if(data > 0) 
        {
            
            int result = data * 2;
            printIntLine(result);
        }
"
8634,0,CWE134_Uncontrolled_Format_String__char_console_vfprintf_83_bad.cpp,"Label Definition File: CWE134_Uncontrolled_Format_String.vasinks.label.xml
Template File: sources-vasinks-83_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 134 Uncontrolled Format String
 * BadSource: console Read input from the console
 * GoodSource: Copy a fixed string into data
 * Sinks: vfprintf
 *    GoodSink: vfprintf with a format string
 *    BadSink : vfprintf without a format string
 * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack
 *
 * */
#ifndef OMITBAD

#include <stdarg.h>
#include ""std_testcase.h""
#include ""CWE134_Uncontrolled_Format_String__char_console_vfprintf_83.h""

namespace CWE134_Uncontrolled_Format_String__char_console_vfprintf_83
{
CWE134_Uncontrolled_Format_String__char_console_vfprintf_83_bad::CWE134_Uncontrolled_Format_String__char_console_vfprintf_83_bad(char * dataCopy)
{
    data = dataCopy;
    {
        
        size_t dataLen = strlen(data);
        
        if (100-dataLen > 1)
        {
            
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgets() */
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
                    data[dataLen-1] = '\0';
                }
            }
            else
            {
                printLine(""fgets() failed"");
                
                data[dataLen] = '\0';
            }
        }
    }
}

static void badVaSink(char * data, ...)
{
    {
        va_list args;
        va_start(args, data);
        
        vfprintf(stdout, data, args);
        va_end(args);
    }
}

CWE134_Uncontrolled_Format_String__char_console_vfprintf_83_bad::~CWE134_Uncontrolled_Format_String__char_console_vfprintf_83_bad()
{
    badVaSink(data, data);
}
}
"
13345,0,CWE457_Use_of_Uninitialized_Variable__struct_array_alloca_partial_init_01.c,"    twoIntsStruct * data;
    data = (twoIntsStruct *)ALLOCA(10*sizeof(twoIntsStruct));
    
    {
        int i;
        for(i=0; i<(10/2); i++)
        {
            data[i].intOne = i;
            data[i].intTwo = i;
        }
    }
    
    {
        int i;
        for(i=0; i<10; i++)
        {
            printIntLine(data[i].intOne);
            printIntLine(data[i].intTwo);
        }
"
5765,0,CWE590_Free_Memory_Not_on_Heap__delete_struct_alloca_53a.cpp,"    twoIntsStruct * data;
    data = NULL; 
    {
        
        twoIntsStruct * dataBuffer = (twoIntsStruct *)ALLOCA(sizeof(twoIntsStruct));
        dataBuffer->intOne = 1;
        dataBuffer->intTwo = 1;
        data = dataBuffer;
    }
"
5233,0,CWE415_Double_Free__malloc_free_struct_10.c,"    twoIntsStruct * data;
    
    data = NULL;
    if(globalTrue)
    {
        data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
        if (data == NULL) {exit(-1);}
        
        free(data);
    }
    if(globalTrue)
    {
        
        free(data);
"
16302,0,CWE190_Integer_Overflow__int64_t_fscanf_square_08.c,"    int64_t data;
    data = 0LL;
    if(staticReturnsTrue())
    {
        
        fscanf (stdin, ""%"" SCNd64, &data);
    }
    if(staticReturnsTrue())
    {
        {
            
            int64_t result = data * data;
            printLongLongLine(result);
        }
"
4121,0,CWE190_Integer_Overflow__unsigned_int_rand_preinc_34.c,"    unsigned int data;
    CWE190_Integer_Overflow__unsigned_int_rand_preinc_34_unionType myUnion;
    data = 0;
    
    data = (unsigned int)RAND32();
    myUnion.unionFirst = data;
    {
        unsigned int data = myUnion.unionSecond;
        {
            
            ++data;
            unsigned int result = data;
            printUnsignedLine(result);
        }
"
9419,0,CWE190_Integer_Overflow__short_max_add_13.c,"    short data;
    data = 0;
    if(GLOBAL_CONST_FIVE==5)
    {
        
        data = SHRT_MAX;
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            
            short result = data + 1;
            printIntLine(result);
        }
"
2591,0,CWE758_Undefined_Behavior__double_pointer_alloca_use_10.c,"    if(globalTrue)
    {
        {
            double * * pointer = (double * *)ALLOCA(sizeof(double *));
            double * data = *pointer; 
            printDoubleLine(*data);
        }
"
10272,0,CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_07.c,"    int data;
    
    data = -1;
    if(staticFive==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
3592,0,CWE415_Double_Free__malloc_free_long_83a.cpp,"    long * data;
    
    data = NULL;
"
7611,0,CWE590_Free_Memory_Not_on_Heap__free_struct_static_15.c,"    twoIntsStruct * data;
    data = NULL; 
    switch(6)
    {
    case 6:
    {
        
        static twoIntsStruct dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i].intOne = 1;
                dataBuffer[i].intTwo = 1;
            }
        }
        data = dataBuffer;
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    printStructLine(&data[0]);
    
"
10174,1,CWE758_Undefined_Behavior__long_alloca_use_10.c,"    if(globalFalse)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            long data;
            long * pointer = (long *)ALLOCA(sizeof(long));
            data = 5L;
            *pointer = data; 
            {
                long data = *pointer;
                printLongLine(data);
            }
        }
"
8064,0,CWE78_OS_Command_Injection__char_environment_execl_41.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        
        if (environment != NULL)
        {
            
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
"
16517,0,CWE78_OS_Command_Injection__char_listen_socket_execl_21.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    badStatic = 1; 
    data = badSource(data);
    
    
"
7543,0,CWE78_OS_Command_Injection__char_environment_execl_22a.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    CWE78_OS_Command_Injection__char_environment_execl_22_badGlobal = 1; 
    data = CWE78_OS_Command_Injection__char_environment_execl_22_badSource(data);
    
    
"
9249,0,CWE190_Integer_Overflow__int_listen_socket_multiply_63a.c,"    int data;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
6438,0,CWE590_Free_Memory_Not_on_Heap__delete_array_char_declare_82a.cpp,"    char * data;
    data = NULL; 
    {
        
        char dataBuffer[100];
        memset(dataBuffer, 'A', 100-1); 
        dataBuffer[100-1] = '\0'; 
        data = dataBuffer;
    }
    CWE590_Free_Memory_Not_on_Heap__delete_array_char_declare_82_base* baseObject = new CWE590_Free_Memory_Not_on_Heap__delete_array_char_declare_82_bad;
    baseObject->action(data);
"
3842,0,CWE590_Free_Memory_Not_on_Heap__free_int_alloca_63a.c,"    int * data;
    data = NULL; 
    {
        
        int * dataBuffer = (int *)ALLOCA(100*sizeof(int));
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5;
            }
        }
        data = dataBuffer;
    }
"
2796,0,CWE252_Unchecked_Return_Value__char_remove_14.c,"    if(globalFive==5)
    {
        
        REMOVE(""removemebad.txt"");
"
13007,0,CWE457_Use_of_Uninitialized_Variable__struct_18.c,"    twoIntsStruct data;
    goto source;
source:
    
    ; 
    goto sink;
sink:
    
    printIntLine(data.intOne);
"
18041,0,CWE590_Free_Memory_Not_on_Heap__free_long_declare_54a.c,"    long * data;
    data = NULL; 
    {
        
        long dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5L;
            }
        }
        data = dataBuffer;
    }
"
17675,0,CWE590_Free_Memory_Not_on_Heap__delete_struct_static_15.cpp,"    twoIntsStruct * data;
    data = NULL; 
    switch(6)
    {
    case 6:
    {
        
        static twoIntsStruct dataBuffer;
        dataBuffer.intOne = 1;
        dataBuffer.intTwo = 1;
        data = &dataBuffer;
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    printStructLine(data);
    
"
16117,0,CWE457_Use_of_Uninitialized_Variable__int_array_malloc_no_init_16.c,"    int * data;
    data = (int *)malloc(10*sizeof(int));
    if (data == NULL) {exit(-1);}
    while(1)
    {
        
        ; 
        break;
    }
    while(1)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i]);
            }
        }
        break;
"
11010,1,CWE252_Unchecked_Return_Value__char_putc_15.c,"    switch(5)
    {
    case 6:
        
        printLine(""Benign, fixed string"");
        break;
    default:
        
        if (putc((int)'A', stdout) == EOF)
        {
            printLine(""putc failed!"");
        }
        break;
"
11696,0,CWE457_Use_of_Uninitialized_Variable__double_array_declare_no_init_07.c,"    double * data;
    double dataUninitArray[10];
    data = dataUninitArray;
    if(staticFive==5)
    {
        
        ; 
    }
    if(staticFive==5)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printDoubleLine(data[i]);
            }
        }
"
3700,0,CWE789_Uncontrolled_Mem_Alloc__new_char_connect_socket_66a.cpp,"    size_t data;
    size_t dataArray[5];
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = strtoul(inputBuffer, NULL, 0);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
    dataArray[2] = data;
"
19213,0,CWE416_Use_After_Free__new_delete_struct_10.cpp,"    twoIntsStruct * data;
    
    data = NULL;
    if(globalTrue)
    {
        data = new twoIntsStruct;
        data->intOne = 1;
        data->intTwo = 2;
        
        delete data;
    }
    if(globalTrue)
    {
        
        printStructLine(data);
        
"
9081,0,CWE457_Use_of_Uninitialized_Variable__struct_63a.c,"    twoIntsStruct data;
    
    ; 
"
14794,0,CWE190_Integer_Overflow__char_max_square_09.c,"    char data;
    data = ' ';
    if(GLOBAL_CONST_TRUE)
    {
        
        data = CHAR_MAX;
    }
    if(GLOBAL_CONST_TRUE)
    {
        {
            
            char result = data * data;
            printHexCharLine(result);
        }
"
5407,0,CWE78_OS_Command_Injection__char_console_execlp_15.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    switch(6)
    {
    case 6:
    {
        
        size_t dataLen = strlen(data);
        
        if (100-dataLen > 1)
        {
            
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgets() */
"
13644,0,CWE369_Divide_by_Zero__int_zero_modulo_84a.cpp,"    int data;
    
    data = -1;
    CWE369_Divide_by_Zero__int_zero_modulo_84_bad * badObject = new CWE369_Divide_by_Zero__int_zero_modulo_84_bad(data);
"
18979,0,CWE369_Divide_by_Zero__float_fscanf_02.c,"    float data;
    
    data = 0.0F;
    if(1)
    {
        
        fscanf (stdin, ""%f"", &data);
    }
    if(1)
    {
        {
            
            int result = (int)(100.0 / data);
            printIntLine(result);
        }
"
7596,0,CWE190_Integer_Overflow__int_fscanf_add_10.c,"    int data;
    
    data = 0;
    if(globalTrue)
    {
        
        fscanf(stdin, ""%d"", &data);
    }
    if(globalTrue)
    {
        {
            
            int result = data + 1;
            printIntLine(result);
        }
"
8138,0,CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_45.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_45_badData = data;
"
11064,0,CWE190_Integer_Overflow__short_max_multiply_73a.cpp,"    short data;
    list<short> dataList;
    data = 0;
    
    data = SHRT_MAX;
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
6627,0,CWE134_Uncontrolled_Format_String__char_console_snprintf_61a.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    data = CWE134_Uncontrolled_Format_String__char_console_snprintf_61b_badSource(data);
    {
        char dest[100] = """";
        
        SNPRINTF(dest, 100-1, data);
        printLine(dest);
"
10451,0,CWE78_OS_Command_Injection__char_listen_socket_system_41.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
18257,1,CWE758_Undefined_Behavior__long_new_use_07.cpp,"    if(staticFive==5)
    {
        {
            long data;
            data = 5L;
            long * pointer = new long;
            *pointer = data; 
            {
                long data = *pointer;
                printLongLine(data);
            }
            delete pointer;
        }
"
567,0,CWE369_Divide_by_Zero__int_zero_modulo_08.c,"    int data;
    
    data = -1;
    if(staticReturnsTrue())
    {
        
        data = 0;
    }
    if(staticReturnsTrue())
    {
        
        printIntLine(100 % data);
"
17293,0,CWE590_Free_Memory_Not_on_Heap__free_long_static_06.c,"    long * data;
    data = NULL; 
    if(STATIC_CONST_FIVE==5)
    {
        {
            
            static long dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5L;
                }
            }
            data = dataBuffer;
        }
    }
    printLongLine(data[0]);
    
"
3318,0,CWE401_Memory_Leak__char_malloc_82_bad.cpp,"Label Definition File: CWE401_Memory_Leak.c.label.xml
Template File: sources-sinks-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 401 Memory Leak
 * BadSource: malloc Allocate data using malloc()
 * GoodSource: Allocate data on the stack
 * Sinks:
 *    GoodSink: call free() on data
 *    BadSink : no deallocation of data
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE401_Memory_Leak__char_malloc_82.h""

namespace CWE401_Memory_Leak__char_malloc_82
{

void CWE401_Memory_Leak__char_malloc_82_bad::action(char * data)
{
    
    ; 
}

}
"
14545,0,CWE197_Numeric_Truncation_Error__short_fscanf_31.c,"    short data;
    
    data = -1;
    
    fscanf (stdin, ""%hd"", &data);
    {
        short dataCopy = data;
        short data = dataCopy;
        {
            
            char charData = (char)data;
            printHexCharLine(charData);
        }
"
9048,1,CWE252_Unchecked_Return_Value__char_fgets_02.c,"    if(0)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            printLine(""Please enter a string: "");
            
            if (fgets(data, 100, stdin) == NULL)
            {
                printLine(""fgets failed!"");
                exit(1);
            }
            printLine(data);
        }
"
18203,1,CWE758_Undefined_Behavior__char_pointer_new_use_05.cpp,"    if(staticTrue)
    {
        {
            char * data;
            data = ""string"";
            char * * pointer = new char *;
            *pointer = data; 
            {
                char * data = *pointer;
                printLine(data);
            }
            delete pointer;
        }
"
14792,0,CWE590_Free_Memory_Not_on_Heap__free_int_alloca_11.c,"    int * data;
    data = NULL; 
    if(globalReturnsTrue())
    {
        {
            
            int * dataBuffer = (int *)ALLOCA(100*sizeof(int));
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5;
                }
            }
            data = dataBuffer;
        }
    }
    printIntLine(data[0]);
    
"
2402,0,CWE190_Integer_Overflow__int64_t_fscanf_multiply_03.c,"    int64_t data;
    data = 0LL;
    if(5==5)
    {
        
        fscanf (stdin, ""%"" SCNd64, &data);
    }
    if(5==5)
    {
        if(data > 0) 
        {
            
            int64_t result = data * 2;
            printLongLongLine(result);
        }
"
14426,0,CWE457_Use_of_Uninitialized_Variable__int_array_malloc_partial_init_12.c,"    int * data;
    data = (int *)malloc(10*sizeof(int));
    if (data == NULL) {exit(-1);}
    if(globalReturnsTrueOrFalse())
    {
        
        {
            int i;
            for(i=0; i<(10/2); i++)
            {
                data[i] = i;
            }
        }
    }
    else
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                data[i] = i;
            }
        }
    }
    if(globalReturnsTrueOrFalse())
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i]);
            }
        }
    }
    else
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                data[i] = i;
            }
        }
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i]);
            }
        }
"
17823,0,CWE690_NULL_Deref_From_Return__int64_t_calloc_05.c,"    int64_t * data;
    data = NULL; 
    
    data = (int64_t *)calloc(1, sizeof(int64_t));
    if(staticTrue)
    {
        
        data[0] = 5LL;
        printLongLongLine(data[0]);
        free(data);
"
3191,1,CWE467_Use_of_sizeof_on_Pointer_Type__int_13.c,"    if(GLOBAL_CONST_FIVE==5)
    {
        {
            int * goodInt = NULL;
            
            goodInt = (int *)malloc(sizeof(*goodInt));
            if (goodInt == NULL) {exit(-1);}
            *goodInt = 6;
            printIntLine(*goodInt);
            free(goodInt);
        }
"
12502,0,CWE401_Memory_Leak__new_array_struct_twoIntsStruct_22a.cpp,"    struct _twoIntsStruct * data;
    data = NULL;
    
    data = new struct _twoIntsStruct[100];
    
    data[0].intOne = 0;
    data[0].intTwo = 0;
    printStructLine((twoIntsStruct *)&data[0]);
    badGlobal = 1; 
"
1089,0,CWE690_NULL_Deref_From_Return__long_realloc_45.c,"    long * data;
    data = NULL; 
    
    data = (long *)realloc(data, 1*sizeof(long));
    CWE690_NULL_Deref_From_Return__long_realloc_45_badData = data;
"
16413,0,CWE401_Memory_Leak__int64_t_malloc_45.c,"    int64_t * data;
    data = NULL;
    
    data = (int64_t *)malloc(100*sizeof(int64_t));
    if (data == NULL) {exit(-1);}
    
    data[0] = 5LL;
    printLongLongLine(data[0]);
    CWE401_Memory_Leak__int64_t_malloc_45_badData = data;
"
12246,0,CWE789_Uncontrolled_Mem_Alloc__new_char_rand_02.cpp,"    size_t data;
    
    data = 0;
    if(1)
    {
        
        data = rand();
    }
    if(1)
    {
        {
            char * myString;
            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
             * for the strcpy() function to not cause a buffer overflow */
            
            if (data > strlen(HELLO_STRING))
            {
                myString = new char[data];
                
                strcpy(myString, HELLO_STRING);
                printLine(myString);
                delete [] myString;
            }
            else
            {
                printLine(""Input is less than the length of the source string"");
            }
        }
"
4996,0,CWE190_Integer_Overflow__short_fscanf_square_67a.c,"    short data;
    CWE190_Integer_Overflow__short_fscanf_square_67_structType myStruct;
    data = 0;
    
    fscanf (stdin, ""%hd"", &data);
    myStruct.structFirst = data;
"
16383,0,CWE758_Undefined_Behavior__char_malloc_use_03.c,"    if(5==5)
    {
        {
            char * pointer = (char *)malloc(sizeof(char));
            if (pointer == NULL) {exit(-1);}
            char data = *pointer; 
            free(pointer);
            printHexCharLine(data);
        }
"
11965,0,CWE457_Use_of_Uninitialized_Variable__int_pointer_43.cpp,"    int * data;
    badSource(data);
    
"
5129,0,CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_31.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    {
        char * dataCopy = data;
        char * data = dataCopy;
        {
            char dest[100] = """";
            
            SNPRINTF(dest, 100-1, data);
            printLine(dest);
        }
"
3644,1,CWE252_Unchecked_Return_Value__char_putchar_07.c,"    if(staticFive!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        
        if (putchar((int)'A') == EOF)
        {
            printLine(""putchar failed!"");
        }
"
875,0,CWE190_Integer_Overflow__short_fscanf_square_82_bad.cpp,"Label Definition File: CWE190_Integer_Overflow.label.xml
Template File: sources-sinks-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 190 Integer Overflow
 * BadSource: fscanf Read data from the console using fscanf()
 * GoodSource: Set data to a small, non-zero number (two)
 * Sinks: square
 *    GoodSink: Ensure there will not be an overflow before squaring data
 *    BadSink : Square data, which can lead to overflow
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE190_Integer_Overflow__short_fscanf_square_82.h""

#include <math.h>

namespace CWE190_Integer_Overflow__short_fscanf_square_82
{

void CWE190_Integer_Overflow__short_fscanf_square_82_bad::action(short data)
{
    {
        
        short result = data * data;
        printIntLine(result);
    }
}

}
"
12571,0,CWE369_Divide_by_Zero__float_fgets_82_bad.cpp,"Label Definition File: CWE369_Divide_by_Zero__float.label.xml
Template File: sources-sinks-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 369 Divide by Zero
 * BadSource: fgets Read data from the console using fgets()
 * GoodSource: A hardcoded non-zero number (two)
 * Sinks:
 *    GoodSink: Check value of or near zero before dividing
 *    BadSink : Divide a constant by data
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE369_Divide_by_Zero__float_fgets_82.h""

namespace CWE369_Divide_by_Zero__float_fgets_82
{

void CWE369_Divide_by_Zero__float_fgets_82_bad::action(float data)
{
    {
        
        int result = (int)(100.0 / data);
        printIntLine(result);
    }
}

}
"
10280,0,CWE401_Memory_Leak__strdup_char_84a.cpp,"    char * data;
    data = NULL;
    CWE401_Memory_Leak__strdup_char_84_bad * badObject = new CWE401_Memory_Leak__strdup_char_84_bad(data);
"
8389,0,CWE78_OS_Command_Injection__char_file_execl_02.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(1)
    {
        {
            
            size_t dataLen = strlen(data);
            FILE * pFile;
            
            if (100-dataLen > 1)
            {
                pFile = fopen(FILENAME, ""r"");
                if (pFile != NULL)
                {
                    
                    if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                    {
                        printLine(""fgets() failed"");
                        
                        data[dataLen] = '\0';
                    }
                    fclose(pFile);
                }
            }
        }
    }
    
    
"
10069,1,CWE758_Undefined_Behavior__int64_t_malloc_use_05.c,"    if(staticTrue)
    {
        {
            int64_t data;
            int64_t * pointer = (int64_t *)malloc(sizeof(int64_t));
            if (pointer == NULL) {exit(-1);}
            data = 5LL;
            *pointer = data; 
            {
                int64_t data = *pointer;
                printLongLongLine(data);
            }
            free(pointer);
        }
"
18787,0,CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_08.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(staticReturnsTrue())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET connectSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                
                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                data[dataLen + recvResult / sizeof(char)] = '\0';
                
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(staticReturnsTrue())
    {
        {
            char dest[100] = """";
            
            SNPRINTF(dest, 100-1, data);
            printLine(dest);
        }
"
1256,0,CWE401_Memory_Leak__new_array_int64_t_53a.cpp,"    int64_t * data;
    data = NULL;
    
    data = new int64_t[100];
    
    data[0] = 5LL;
    printLongLongLine(data[0]);
"
9131,1,CWE252_Unchecked_Return_Value__char_fgets_15.c,"    switch(6)
    {
    case 6:
    {
        /* By initializing dataBuffer, we ensure this will not be the
         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
        char dataBuffer[100] = """";
        char * data = dataBuffer;
        printLine(""Please enter a string: "");
        
        if (fgets(data, 100, stdin) == NULL)
        {
            printLine(""fgets failed!"");
            exit(1);
        }
        printLine(data);
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
14678,1,CWE401_Memory_Leak__malloc_realloc_int64_t_05.c,"    if(staticFalse)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            int64_t * data = (int64_t *)malloc(100*sizeof(int64_t));
            if (data == NULL) {exit(-1);}
            int64_t * tmpData;
            
            data[0] = 5LL;
            printLongLongLine(data[0]);
            tmpData = (int64_t *)realloc(data, (130000)*sizeof(int64_t));
            /* FIX: Ensure realloc() was successful before assigning data to the memory block
            * allocated with realloc() */
            if (tmpData != NULL)
            {
                data = tmpData;
                
                data[0] = 10LL;
                printLongLongLine(data[0]);
            }
            free(data);
        }
"
4187,1,CWE401_Memory_Leak__malloc_realloc_int64_t_01.c,"    {
        int64_t * data = (int64_t *)malloc(100*sizeof(int64_t));
        if (data == NULL) {exit(-1);}
        int64_t * tmpData;
        
        data[0] = 5LL;
        printLongLongLine(data[0]);
        tmpData = (int64_t *)realloc(data, (130000)*sizeof(int64_t));
        /* FIX: Ensure realloc() was successful before assigning data to the memory block
        * allocated with realloc() */
        if (tmpData != NULL)
        {
            data = tmpData;
            
            data[0] = 10LL;
            printLongLongLine(data[0]);
        }
        free(data);
"
3657,0,CWE415_Double_Free__new_delete_array_class_81a.cpp,"    TwoIntsClass * data;
    
    data = NULL;
    data = new TwoIntsClass[100];
    
    delete [] data;
    const CWE415_Double_Free__new_delete_array_class_81_base& o = CWE415_Double_Free__new_delete_array_class_81_bad();
"
8311,0,CWE590_Free_Memory_Not_on_Heap__delete_array_int_static_63a.cpp,"    int * data;
    data = NULL; 
    {
        
        static int dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5;
            }
        }
        data = dataBuffer;
    }
"
11755,0,CWE369_Divide_by_Zero__float_zero_45.c,"    float data;
    
    data = 0.0F;
    
    data = 0.0F;
    CWE369_Divide_by_Zero__float_zero_45_badData = data;
"
7636,1,CWE476_NULL_Pointer_Dereference__null_check_after_deref_07.c,"    if(staticFive!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            int *intPointer = NULL;
            intPointer = (int *)malloc(sizeof(int));
            *intPointer = 5;
            printIntLine(*intPointer);
            
            *intPointer = 10;
            printIntLine(*intPointer);
        }
"
1160,0,CWE690_NULL_Deref_From_Return__long_calloc_32.c,"    long * data;
    long * *dataPtr1 = &data;
    long * *dataPtr2 = &data;
    data = NULL; 
    {
        long * data = *dataPtr1;
        
        data = (long *)calloc(1, sizeof(long));
        *dataPtr1 = data;
    }
    {
        long * data = *dataPtr2;
        
        data[0] = 5L;
        printLongLine(data[0]);
        free(data);
"
12690,0,CWE457_Use_of_Uninitialized_Variable__twointsclass_array_alloca_partial_init_18.cpp,"    TwoIntsClass * data;
    data = reinterpret_cast<TwoIntsClass *>(ALLOCA(10*sizeof(TwoIntsClass)));
    goto source;
source:
    
    for(int i=0; i<(10/2); i++)
    {
        data[i].intOne = i;
        data[i].intTwo = i;
    }
    goto sink;
sink:
    
    for(int i=0; i<10; i++)
    {
        printIntLine(data[i].intOne);
        printIntLine(data[i].intTwo);
"
6696,0,CWE78_OS_Command_Injection__char_environment_execl_08.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(staticReturnsTrue())
    {
        {
            
            size_t dataLen = strlen(data);
            char * environment = GETENV(ENV_VARIABLE);
            
            if (environment != NULL)
            {
                
                strncat(data+dataLen, environment, 100-dataLen-1);
            }
        }
    }
    
    
"
3346,0,CWE190_Integer_Overflow__unsigned_int_rand_square_63a.c,"    unsigned int data;
    data = 0;
    
    data = (unsigned int)RAND32();
"
13266,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_14.c,"    size_t data;
    
    data = 0;
    if(globalFive==5)
    {
        
        fscanf(stdin, ""%zu"", &data);
    }
    if(globalFive==5)
    {
        {
            char * myString;
            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
             * for the strcpy() function to not cause a buffer overflow */
            
            if (data > strlen(HELLO_STRING))
            {
                myString = (char *)malloc(data*sizeof(char));
                if (myString == NULL) {exit(-1);}
                
                strcpy(myString, HELLO_STRING);
                printLine(myString);
                free(myString);
            }
            else
            {
                printLine(""Input is less than the length of the source string"");
            }
        }
"
15935,0,CWE457_Use_of_Uninitialized_Variable__struct_pointer_17.c,"    int i,j;
    twoIntsStruct * data;
    for(i = 0; i < 1; i++)
    {
        
        ; 
    }
    for(j = 0; j < 1; j++)
    {
        
        printIntLine(data->intOne);
        printIntLine(data->intTwo);
"
2368,0,CWE690_NULL_Deref_From_Return__struct_calloc_54a.c,"    twoIntsStruct * data;
    data = NULL; 
    
    data = (twoIntsStruct *)calloc(1, sizeof(twoIntsStruct));
"
7482,0,CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_13.c,"    int data;
    
    data = -1;
    if(GLOBAL_CONST_FIVE==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
6131,0,CWE457_Use_of_Uninitialized_Variable__int64_t_63a.c,"    int64_t data;
    
    ; 
"
15387,0,CWE457_Use_of_Uninitialized_Variable__double_array_malloc_no_init_13.c,"    double * data;
    data = (double *)malloc(10*sizeof(double));
    if (data == NULL) {exit(-1);}
    if(GLOBAL_CONST_FIVE==5)
    {
        
        ; 
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printDoubleLine(data[i]);
            }
        }
"
8200,0,CWE690_NULL_Deref_From_Return__long_malloc_03.c,"    long * data;
    data = NULL; 
    
    data = (long *)malloc(1*sizeof(long));
    if(5==5)
    {
        
        data[0] = 5L;
        printLongLine(data[0]);
        free(data);
"
8586,0,CWE401_Memory_Leak__twoIntsStruct_calloc_64a.c,"    twoIntsStruct * data;
    data = NULL;
    
    data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));
    if (data == NULL) {exit(-1);}
    
    data[0].intOne = 0;
    data[0].intTwo = 0;
    printStructLine(&data[0]);
"
6234,0,CWE590_Free_Memory_Not_on_Heap__delete_int64_t_static_04.cpp,"    int64_t * data;
    data = NULL; 
    if(STATIC_CONST_TRUE)
    {
        {
            
            static int64_t dataBuffer;
            dataBuffer = 5LL;
            data = &dataBuffer;
        }
    }
    printLongLongLine(*data);
    
"
650,0,CWE590_Free_Memory_Not_on_Heap__free_long_static_82_bad.cpp,"Label Definition File: CWE590_Free_Memory_Not_on_Heap__free.label.xml
Template File: sources-sink-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 590 Free Memory Not on Heap
 * BadSource: static Data buffer is declared static on the stack
 * GoodSource: Allocate memory on the heap
 * Sinks:
 *    BadSink : Print then free data
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE590_Free_Memory_Not_on_Heap__free_long_static_82.h""

namespace CWE590_Free_Memory_Not_on_Heap__free_long_static_82
{

void CWE590_Free_Memory_Not_on_Heap__free_long_static_82_bad::action(long * data)
{
    printLongLine(data[0]);
    
    free(data);
}

}
"
12416,0,CWE416_Use_After_Free__malloc_free_long_03.c,"    long * data;
    
    data = NULL;
    if(5==5)
    {
        data = (long *)malloc(100*sizeof(long));
        if (data == NULL) {exit(-1);}
        {
            size_t i;
            for(i = 0; i < 100; i++)
            {
                data[i] = 5L;
            }
        }
        
        free(data);
    }
    if(5==5)
    {
        
        printLongLine(data[0]);
        
"
12373,0,CWE758_Undefined_Behavior__int_pointer_new_use_13.cpp,"    if(GLOBAL_CONST_FIVE==5)
    {
        {
            int * * pointer = new int *;
            int * data = *pointer; 
            delete pointer;
            printIntLine(*data);
        }
"
16805,1,CWE758_Undefined_Behavior__int_pointer_malloc_use_02.c,"    if(0)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            int * data;
            int * * pointer = (int * *)malloc(sizeof(int *));
            if (pointer == NULL) {exit(-1);}
            
            data = (int *)malloc(sizeof(int));
            if (data == NULL) {exit(-1);}
            *data = 5;
            *pointer = data; 
            {
                int * data = *pointer;
                printIntLine(*data);
            }
            free(pointer);
        }
"
5951,0,CWE758_Undefined_Behavior__struct_pointer_alloca_use_16.c,"    while(1)
    {
        {
            twoIntsStruct * * pointer = (twoIntsStruct * *)ALLOCA(sizeof(twoIntsStruct *));
            twoIntsStruct * data = *pointer; 
            printIntLine(data->intOne);
            printIntLine(data->intTwo);
        }
        break;
"
1675,0,CWE758_Undefined_Behavior__class_new_use_02.cpp,"    if(1)
    {
        {
            TwoIntsClass * pointer = new TwoIntsClass;
            TwoIntsClass data = *pointer; 
            delete pointer;
            printIntLine(data.intOne);
            printIntLine(data.intTwo);
        }
"
2325,0,CWE415_Double_Free__new_delete_array_long_01.cpp,"    long * data;
    
    data = NULL;
    data = new long[100];
    
    delete [] data;
    
"
10305,0,CWE457_Use_of_Uninitialized_Variable__int64_t_03.c,"    int64_t data;
    if(5==5)
    {
        
        ; 
    }
    if(5==5)
    {
        
        printLongLongLine(data);
"
1076,0,CWE197_Numeric_Truncation_Error__int_large_to_char_82a.cpp,"    int data;
    
    data = -1;
    
    data = SHRT_MAX + 5;
    CWE197_Numeric_Truncation_Error__int_large_to_char_82_base* baseObject = new CWE197_Numeric_Truncation_Error__int_large_to_char_82_bad;
    baseObject->action(data);
"
11196,0,CWE369_Divide_by_Zero__int_fscanf_modulo_10.c,"    int data;
    
    data = -1;
    if(globalTrue)
    {
        
        fscanf(stdin, ""%d"", &data);
    }
    if(globalTrue)
    {
        
        printIntLine(100 % data);
"
18764,0,CWE78_OS_Command_Injection__char_file_system_66a.c,"    char * data;
    char * dataArray[5];
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
        
        size_t dataLen = strlen(data);
        FILE * pFile;
        
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
    
    dataArray[2] = data;
"
7451,0,CWE78_OS_Command_Injection__char_environment_execlp_14.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(globalFive==5)
    {
        {
            
            size_t dataLen = strlen(data);
            char * environment = GETENV(ENV_VARIABLE);
            
            if (environment != NULL)
            {
                
                strncat(data+dataLen, environment, 100-dataLen-1);
            }
        }
    }
    /* execlp - searches for the location of the command among
     * the directories specified by the PATH environment variable */
    
"
4900,0,CWE665_Improper_Initialization__char_ncat_52a.c,"    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    
    ; 
"
2916,0,CWE190_Integer_Overflow__int_listen_socket_multiply_67a.c,"    int data;
    CWE190_Integer_Overflow__int_listen_socket_multiply_67_structType myStruct;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    myStruct.structFirst = data;
"
13896,0,CWE369_Divide_by_Zero__int_listen_socket_divide_05.c,"    int data;
    
    data = -1;
    if(staticTrue)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(staticTrue)
    {
        
        printIntLine(100 / data);
"
207,0,CWE190_Integer_Overflow__char_rand_multiply_34.c,"    char data;
    CWE190_Integer_Overflow__char_rand_multiply_34_unionType myUnion;
    data = ' ';
    
    data = (char)RAND32();
    myUnion.unionFirst = data;
    {
        char data = myUnion.unionSecond;
        if(data > 0) 
        {
            
            char result = data * 2;
            printHexCharLine(result);
        }
"
7282,0,CWE190_Integer_Overflow__char_rand_multiply_18.c,"    char data;
    data = ' ';
    goto source;
source:
    
    data = (char)RAND32();
    goto sink;
sink:
    if(data > 0) 
    {
        
        char result = data * 2;
        printHexCharLine(result);
"
18671,0,CWE690_NULL_Deref_From_Return__int_malloc_13.c,"    int * data;
    data = NULL; 
    
    data = (int *)malloc(1*sizeof(int));
    if(GLOBAL_CONST_FIVE==5)
    {
        
        data[0] = 5;
        printIntLine(data[0]);
        free(data);
"
9566,0,CWE401_Memory_Leak__struct_twoIntsStruct_calloc_72a.cpp,"    struct _twoIntsStruct * data;
    vector<struct _twoIntsStruct *> dataVector;
    data = NULL;
    
    data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));
    if (data == NULL) {exit(-1);}
    
    data[0].intOne = 0;
    data[0].intTwo = 0;
    printStructLine((twoIntsStruct *)&data[0]);
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
1682,0,CWE563_Unused_Variable__unused_uninit_variable_char_14.c,"    char data;
    
    ; 
    if(globalFive==5)
    {
        
        
        ; 
"
12902,0,CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_14.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(globalFive==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET connectSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                
                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                data[dataLen + recvResult / sizeof(char)] = '\0';
                
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(globalFive==5)
    {
        badVaSinkB(data, data);
"
5752,0,CWE415_Double_Free__new_delete_array_char_05.cpp,"    char * data;
    
    data = NULL;
    if(staticTrue)
    {
        data = new char[100];
        
        delete [] data;
    }
    if(staticTrue)
    {
        
        delete [] data;
"
2095,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_31.c,"    size_t data;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = strtoul(inputBuffer, NULL, 0);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    {
        size_t dataCopy = data;
        size_t data = dataCopy;
        {
            char * myString;
            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
             * for the strcpy() function to not cause a buffer overflow */
            
            if (data > strlen(HELLO_STRING))
            {
                myString = (char *)malloc(data*sizeof(char));
                if (myString == NULL) {exit(-1);}
                
                strcpy(myString, HELLO_STRING);
                printLine(myString);
                free(myString);
            }
            else
            {
                printLine(""Input is less than the length of the source string"");
            }
        }
"
1409,0,CWE401_Memory_Leak__new_int64_t_15.cpp,"    int64_t * data;
    data = NULL;
    switch(6)
    {
    case 6:
        
        data = new int64_t;
        
        *data = 5LL;
        printLongLongLine(*data);
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
        
        ; 
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
1287,0,CWE590_Free_Memory_Not_on_Heap__delete_array_class_static_17.cpp,"    int i;
    TwoIntsClass * data;
    data = NULL; 
    for(i = 0; i < 1; i++)
    {
        {
            
            static TwoIntsClass dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i].intOne = 1;
                    dataBuffer[i].intTwo = 1;
                }
            }
            data = dataBuffer;
        }
    }
    printIntLine(data[0].intOne);
    
"
2820,0,CWE401_Memory_Leak__int_malloc_18.c,"    int * data;
    data = NULL;
    goto source;
source:
    
    data = (int *)malloc(100*sizeof(int));
    if (data == NULL) {exit(-1);}
    
    data[0] = 5;
    printIntLine(data[0]);
    goto sink;
sink:
    
"
9490,0,CWE401_Memory_Leak__malloc_realloc_int_16.c,"    while(1)
    {
        {
            int * data = (int *)malloc(100*sizeof(int));
            if (data == NULL) {exit(-1);}
            
            data[0] = 5;
            printIntLine(data[0]);
            
            data = (int *)realloc(data, (130000)*sizeof(int));
            if (data != NULL)
            {
                
                data[0] = 10;
                printIntLine(data[0]);
                free(data);
            }
        }
        break;
"
3937,1,CWE476_NULL_Pointer_Dereference__null_check_after_deref_02.c,"    if(0)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            int *intPointer = NULL;
            intPointer = (int *)malloc(sizeof(int));
            *intPointer = 5;
            printIntLine(*intPointer);
            
            *intPointer = 10;
            printIntLine(*intPointer);
        }
"
16189,0,CWE690_NULL_Deref_From_Return__struct_malloc_62a.cpp,"    twoIntsStruct * data;
    data = NULL; 
    badSource(data);
    
    data[0].intOne = 1;
    data[0].intTwo = 1;
    printStructLine(&data[0]);
"
13968,0,CWE190_Integer_Overflow__char_fscanf_multiply_61a.c,"    char data;
    data = ' ';
    data = CWE190_Integer_Overflow__char_fscanf_multiply_61b_badSource(data);
    if(data > 0) 
    {
        
        char result = data * 2;
        printHexCharLine(result);
"
5214,0,CWE476_NULL_Pointer_Dereference__binary_if_01.c,"    {
        twoIntsStruct *twoIntsStructPointer = NULL;
        /* FLAW: Using a single & in the if statement will cause both sides of the expression to be evaluated
         * thus causing a NPD */
        if ((twoIntsStructPointer != NULL) & (twoIntsStructPointer->intOne == 5))
        {
            printLine(""intOne == 5"");
        }
"
8607,0,CWE134_Uncontrolled_Format_String__char_console_snprintf_82_bad.cpp,"Label Definition File: CWE134_Uncontrolled_Format_String.label.xml
Template File: sources-sinks-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 134 Uncontrolled Format String
 * BadSource: console Read input from the console
 * GoodSource: Copy a fixed string into data
 * Sinks: snprintf
 *    GoodSink: snprintf with ""%s"" as the third argument and data as the fourth
 *    BadSink : snprintf with data as the third argument
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE134_Uncontrolled_Format_String__char_console_snprintf_82.h""

#ifdef _WIN32
#define SNPRINTF _snprintf
#else
#define SNPRINTF snprintf
#endif

namespace CWE134_Uncontrolled_Format_String__char_console_snprintf_82
{

void CWE134_Uncontrolled_Format_String__char_console_snprintf_82_bad::action(char * data)
{
    {
        char dest[100] = """";
        
        SNPRINTF(dest, 100-1, data);
        printLine(dest);
    }
}

}
"
5929,0,CWE758_Undefined_Behavior__char_malloc_use_17.c,"    int j;
    for(j = 0; j < 1; j++)
    {
        {
            char * pointer = (char *)malloc(sizeof(char));
            if (pointer == NULL) {exit(-1);}
            char data = *pointer; 
            free(pointer);
            printHexCharLine(data);
        }
"
14692,0,CWE190_Integer_Overflow__int_max_preinc_53a.c,"    int data;
    
    data = 0;
    
    data = INT_MAX;
"
3448,0,CWE416_Use_After_Free__new_delete_class_12.cpp,"    TwoIntsClass * data;
    
    data = NULL;
    if(globalReturnsTrueOrFalse())
    {
        data = new TwoIntsClass;
        data->intOne = 1;
        data->intTwo = 2;
        
        delete data;
    }
    else
    {
        data = new TwoIntsClass;
        data->intOne = 1;
        data->intTwo = 2;
        
    }
    if(globalReturnsTrueOrFalse())
    {
        
        printIntLine(data->intOne);
        
    }
    else
    {
        
        
        
        ; 
"
4471,1,CWE758_Undefined_Behavior__long_new_use_04.cpp,"    if(STATIC_CONST_TRUE)
    {
        {
            long data;
            data = 5L;
            long * pointer = new long;
            *pointer = data; 
            {
                long data = *pointer;
                printLongLine(data);
            }
            delete pointer;
        }
"
1668,0,CWE78_OS_Command_Injection__char_environment_execl_31.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        
        if (environment != NULL)
        {
            
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    {
        char * dataCopy = data;
        char * data = dataCopy;
        
        
        EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
"
3567,0,CWE190_Integer_Overflow__short_rand_square_11.c,"    short data;
    data = 0;
    if(globalReturnsTrue())
    {
        
        data = (short)RAND32();
    }
    if(globalReturnsTrue())
    {
        {
            
            short result = data * data;
            printIntLine(result);
        }
"
7917,0,CWE134_Uncontrolled_Format_String__char_listen_socket_printf_16.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    while(1)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                data[dataLen + recvResult / sizeof(char)] = '\0';
                
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
        break;
    }
    while(1)
    {
        
        printf(data);
        break;
"
1330,0,CWE590_Free_Memory_Not_on_Heap__delete_long_placement_new_41.cpp,"    long * data;
    data = NULL; 
    {
        
        char buffer[sizeof(long)];
        long * dataBuffer = new(buffer) long;
        *dataBuffer = 5L;
        data = dataBuffer;
    }
"
798,0,CWE415_Double_Free__new_delete_class_14.cpp,"    TwoIntsClass * data;
    
    data = NULL;
    if(globalFive==5)
    {
        data = new TwoIntsClass;
        
        delete data;
    }
    if(globalFive==5)
    {
        
        delete data;
"
17194,0,CWE190_Integer_Overflow__int_listen_socket_add_73a.cpp,"    int data;
    list<int> dataList;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
8310,0,CWE590_Free_Memory_Not_on_Heap__free_int64_t_declare_74a.cpp,"    int64_t * data;
    map<int, int64_t *> dataMap;
    data = NULL; 
    {
        
        int64_t dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5LL;
            }
        }
        data = dataBuffer;
    }
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
4431,0,CWE563_Unused_Variable__unused_init_variable_char_08.c,"    char data;
    
    data = 'C';
    if(staticReturnsTrue())
    {
        
        
        ; 
"
15747,0,CWE190_Integer_Overflow__int_connect_socket_postinc_61a.c,"    int data;
    
    data = 0;
    data = CWE190_Integer_Overflow__int_connect_socket_postinc_61b_badSource(data);
    {
        
        data++;
        int result = data;
        printIntLine(result);
"
14916,0,CWE134_Uncontrolled_Format_String__char_file_vfprintf_41.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        FILE * pFile;
        
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
"
3026,0,CWE416_Use_After_Free__new_delete_array_struct_15.cpp,"    twoIntsStruct * data;
    
    data = NULL;
    switch(6)
    {
    case 6:
        data = new twoIntsStruct[100];
        {
            size_t i;
            for(i = 0; i < 100; i++)
            {
                data[i].intOne = 1;
                data[i].intTwo = 2;
            }
        }
        
        delete [] data;
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
        
        printStructLine(&data[0]);
        
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
19041,0,CWE369_Divide_by_Zero__int_zero_modulo_53a.c,"    int data;
    
    data = -1;
    
    data = 0;
"
13986,0,CWE190_Integer_Overflow__char_max_square_67a.c,"    char data;
    CWE190_Integer_Overflow__char_max_square_67_structType myStruct;
    data = ' ';
    
    data = CHAR_MAX;
    myStruct.structFirst = data;
"
17668,0,CWE401_Memory_Leak__malloc_realloc_int_06.c,"    if(STATIC_CONST_FIVE==5)
    {
        {
            int * data = (int *)malloc(100*sizeof(int));
            if (data == NULL) {exit(-1);}
            
            data[0] = 5;
            printIntLine(data[0]);
            
            data = (int *)realloc(data, (130000)*sizeof(int));
            if (data != NULL)
            {
                
                data[0] = 10;
                printIntLine(data[0]);
                free(data);
            }
        }
"
15036,0,CWE415_Double_Free__new_delete_array_char_34.cpp,"    char * data;
    unionType myUnion;
    
    data = NULL;
    data = new char[100];
    
    delete [] data;
    myUnion.unionFirst = data;
    {
        char * data = myUnion.unionSecond;
        
        delete [] data;
"
8434,0,CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_53a.c,"    int data;
    
    data = -1;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
14802,0,CWE789_Uncontrolled_Mem_Alloc__new_char_rand_22a.cpp,"    size_t data;
    
    data = 0;
    
    data = rand();
    badGlobal = 1; 
"
14406,0,CWE78_OS_Command_Injection__char_listen_socket_execlp_43.cpp,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    badSource(data);
    /* execlp - searches for the location of the command among
     * the directories specified by the PATH environment variable */
    
"
19478,0,CWE590_Free_Memory_Not_on_Heap__delete_array_long_static_74a.cpp,"    long * data;
    map<int, long *> dataMap;
    data = NULL; 
    {
        
        static long dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5L;
            }
        }
        data = dataBuffer;
    }
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
6818,0,CWE190_Integer_Overflow__char_fscanf_postinc_11.c,"    char data;
    data = ' ';
    if(globalReturnsTrue())
    {
        
        fscanf (stdin, ""%c"", &data);
    }
    if(globalReturnsTrue())
    {
        {
            
            data++;
            char result = data;
            printHexCharLine(result);
        }
"
3224,0,CWE457_Use_of_Uninitialized_Variable__int_array_malloc_partial_init_11.c,"    int * data;
    data = (int *)malloc(10*sizeof(int));
    if (data == NULL) {exit(-1);}
    if(globalReturnsTrue())
    {
        
        {
            int i;
            for(i=0; i<(10/2); i++)
            {
                data[i] = i;
            }
        }
    }
    if(globalReturnsTrue())
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i]);
            }
        }
"
13068,0,CWE590_Free_Memory_Not_on_Heap__free_int64_t_static_82_bad.cpp,"Label Definition File: CWE590_Free_Memory_Not_on_Heap__free.label.xml
Template File: sources-sink-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 590 Free Memory Not on Heap
 * BadSource: static Data buffer is declared static on the stack
 * GoodSource: Allocate memory on the heap
 * Sinks:
 *    BadSink : Print then free data
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE590_Free_Memory_Not_on_Heap__free_int64_t_static_82.h""

namespace CWE590_Free_Memory_Not_on_Heap__free_int64_t_static_82
{

void CWE590_Free_Memory_Not_on_Heap__free_int64_t_static_82_bad::action(int64_t * data)
{
    printLongLongLine(data[0]);
    
    free(data);
}

}
"
10437,0,CWE590_Free_Memory_Not_on_Heap__free_int64_t_static_51a.c,"    int64_t * data;
    data = NULL; 
    {
        
        static int64_t dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5LL;
            }
        }
        data = dataBuffer;
    }
"
15598,0,CWE190_Integer_Overflow__unsigned_int_rand_add_33.cpp,"    unsigned int data;
    unsigned int &dataRef = data;
    data = 0;
    
    data = (unsigned int)RAND32();
    {
        unsigned int data = dataRef;
        {
            
            unsigned int result = data + 1;
            printUnsignedLine(result);
        }
"
9948,0,CWE590_Free_Memory_Not_on_Heap__free_int64_t_static_18.c,"    int64_t * data;
    data = NULL; 
    goto source;
source:
    {
        
        static int64_t dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5LL;
            }
        }
        data = dataBuffer;
    }
    printLongLongLine(data[0]);
    
"
14446,0,CWE369_Divide_by_Zero__int_rand_modulo_62a.cpp,"    int data;
    
    data = -1;
    badSource(data);
    
"
18776,0,CWE134_Uncontrolled_Format_String__char_file_printf_73a.cpp,"    char * data;
    list<char *> dataList;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        FILE * pFile;
        
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
1582,0,CWE590_Free_Memory_Not_on_Heap__delete_class_alloca_34.cpp,"    TwoIntsClass * data;
    unionType myUnion;
    data = NULL; 
    {
        
        TwoIntsClass * dataBuffer = (TwoIntsClass *)ALLOCA(sizeof(TwoIntsClass));
        dataBuffer->intOne = 2;
        dataBuffer->intTwo = 2;
        data = dataBuffer;
    }
    myUnion.unionFirst = data;
    {
        TwoIntsClass * data = myUnion.unionSecond;
        printIntLine(data->intOne);
        
        delete data;
"
2267,0,CWE190_Integer_Overflow__int64_t_rand_multiply_82a.cpp,"    int64_t data;
    data = 0LL;
    
    data = (int64_t)RAND64();
    CWE190_Integer_Overflow__int64_t_rand_multiply_82_base* baseObject = new CWE190_Integer_Overflow__int64_t_rand_multiply_82_bad;
    baseObject->action(data);
"
15289,0,CWE190_Integer_Overflow__short_rand_preinc_53a.c,"    short data;
    data = 0;
    
    data = (short)RAND32();
"
13350,0,CWE190_Integer_Overflow__char_max_multiply_01.c,"    char data;
    data = ' ';
    
    data = CHAR_MAX;
    if(data > 0) 
    {
        
        char result = data * 2;
        printHexCharLine(result);
"
9198,0,CWE78_OS_Command_Injection__char_environment_popen_84a.cpp,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    CWE78_OS_Command_Injection__char_environment_popen_84_bad * badObject = new CWE78_OS_Command_Injection__char_environment_popen_84_bad(data);
"
479,0,CWE197_Numeric_Truncation_Error__short_connect_socket_61a.c,"    short data;
    
    data = -1;
    data = CWE197_Numeric_Truncation_Error__short_connect_socket_61b_badSource(data);
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
3271,0,CWE369_Divide_by_Zero__int_rand_modulo_11.c,"    int data;
    
    data = -1;
    if(globalReturnsTrue())
    {
        
        data = RAND32();
    }
    if(globalReturnsTrue())
    {
        
        printIntLine(100 % data);
"
16084,0,CWE190_Integer_Overflow__char_fscanf_postinc_41.c,"    char data;
    data = ' ';
    
    fscanf (stdin, ""%c"", &data);
"
12277,0,CWE190_Integer_Overflow__int_max_square_09.c,"    int data;
    
    data = 0;
    if(GLOBAL_CONST_TRUE)
    {
        
        data = INT_MAX;
    }
    if(GLOBAL_CONST_TRUE)
    {
        {
            
            int result = data * data;
            printIntLine(result);
        }
"
1535,0,CWE190_Integer_Overflow__int_fscanf_add_21.c,"    int data;
    
    data = 0;
    
    fscanf(stdin, ""%d"", &data);
    badStatic = 1; 
"
13957,0,CWE369_Divide_by_Zero__int_connect_socket_divide_07.c,"    int data;
    
    data = -1;
    if(staticFive==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(staticFive==5)
    {
        
        printIntLine(100 / data);
"
4179,0,CWE401_Memory_Leak__twoIntsStruct_calloc_17.c,"    int i,j;
    twoIntsStruct * data;
    data = NULL;
    for(i = 0; i < 1; i++)
    {
        
        data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));
        if (data == NULL) {exit(-1);}
        
        data[0].intOne = 0;
        data[0].intTwo = 0;
        printStructLine(&data[0]);
    }
    for(j = 0; j < 1; j++)
    {
        
        ; 
"
15903,0,CWE78_OS_Command_Injection__char_file_system_65a.c,"    char * data;
    
    void (*funcPtr) (char *) = CWE78_OS_Command_Injection__char_file_system_65b_badSink;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
        
        size_t dataLen = strlen(data);
        FILE * pFile;
        
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
    
"
483,0,CWE190_Integer_Overflow__int_listen_socket_preinc_02.c,"    int data;
    
    data = 0;
    if(1)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(1)
    {
        {
            
            ++data;
            int result = data;
            printIntLine(result);
        }
"
16351,0,CWE401_Memory_Leak__char_realloc_22a.c,"    char * data;
    data = NULL;
    
    data = (char *)realloc(data, 100*sizeof(char));
    if (data == NULL) {exit(-1);}
    
    strcpy(data, ""A String"");
    printLine(data);
    CWE401_Memory_Leak__char_realloc_22_badGlobal = 1; 
"
1336,1,CWE758_Undefined_Behavior__char_pointer_alloca_use_06.c,"    if(STATIC_CONST_FIVE==5)
    {
        {
            char * data;
            char * * pointer = (char * *)ALLOCA(sizeof(char *));
            data = ""string"";
            *pointer = data; 
            {
                char * data = *pointer;
                printLine(data);
            }
        }
"
7741,0,CWE190_Integer_Overflow__int64_t_max_multiply_03.c,"    int64_t data;
    data = 0LL;
    if(5==5)
    {
        
        data = LLONG_MAX;
    }
    if(5==5)
    {
        if(data > 0) 
        {
            
            int64_t result = data * 2;
            printLongLongLine(result);
        }
"
4898,0,CWE401_Memory_Leak__int_realloc_16.c,"    int * data;
    data = NULL;
    while(1)
    {
        
        data = (int *)realloc(data, 100*sizeof(int));
        if (data == NULL) {exit(-1);}
        
        data[0] = 5;
        printIntLine(data[0]);
        break;
    }
    while(1)
    {
        
        ; 
        break;
"
18924,0,CWE190_Integer_Overflow__short_rand_square_14.c,"    short data;
    data = 0;
    if(globalFive==5)
    {
        
        data = (short)RAND32();
    }
    if(globalFive==5)
    {
        {
            
            short result = data * data;
            printIntLine(result);
        }
"
3948,0,CWE401_Memory_Leak__new_int64_t_32.cpp,"    int64_t * data;
    int64_t * *dataPtr1 = &data;
    int64_t * *dataPtr2 = &data;
    data = NULL;
    {
        int64_t * data = *dataPtr1;
        
        data = new int64_t;
        
        *data = 5LL;
        printLongLongLine(*data);
        *dataPtr1 = data;
    }
    {
        int64_t * data = *dataPtr2;
        
        ; 
"
11252,0,CWE190_Integer_Overflow__unsigned_int_fscanf_square_72a.cpp,"    unsigned int data;
    vector<unsigned int> dataVector;
    data = 0;
    
    fscanf (stdin, ""%u"", &data);
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
5536,0,CWE190_Integer_Overflow__int_listen_socket_preinc_18.c,"    int data;
    
    data = 0;
    goto source;
source:
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    goto sink;
sink:
    {
        
        ++data;
        int result = data;
        printIntLine(result);
"
5376,0,CWE457_Use_of_Uninitialized_Variable__double_pointer_13.c,"    double * data;
    if(GLOBAL_CONST_FIVE==5)
    {
        
        ; 
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        
        printDoubleLine(*data);
"
14204,0,CWE590_Free_Memory_Not_on_Heap__delete_array_struct_alloca_16.cpp,"    twoIntsStruct * data;
    data = NULL; 
    while(1)
    {
        {
            
            twoIntsStruct * dataBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i].intOne = 1;
                    dataBuffer[i].intTwo = 1;
                }
            }
            data = dataBuffer;
        }
        break;
    }
    printStructLine(&data[0]);
    
"
1486,0,CWE369_Divide_by_Zero__float_connect_socket_81a.cpp,"    float data;
    
    data = 0.0F;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = (float)atof(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    const CWE369_Divide_by_Zero__float_connect_socket_81_base& baseObject = CWE369_Divide_by_Zero__float_connect_socket_81_bad();
"
9161,0,CWE590_Free_Memory_Not_on_Heap__free_int64_t_alloca_10.c,"    int64_t * data;
    data = NULL; 
    if(globalTrue)
    {
        {
            
            int64_t * dataBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5LL;
                }
            }
            data = dataBuffer;
        }
    }
    printLongLongLine(data[0]);
    
"
3464,0,CWE78_OS_Command_Injection__char_console_execl_17.c,"    int i;
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    for(i = 0; i < 1; i++)
    {
        {
            
            size_t dataLen = strlen(data);
            
            if (100-dataLen > 1)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
                {
                    /* The next few lines remove the carriage return from the string that is
                     * inserted by fgets() */
"
84,0,CWE690_NULL_Deref_From_Return__struct_malloc_16.c,"    twoIntsStruct * data;
    data = NULL; 
    
    data = (twoIntsStruct *)malloc(1*sizeof(twoIntsStruct));
    while(1)
    {
        
        data[0].intOne = 1;
        data[0].intTwo = 1;
        printStructLine(&data[0]);
        free(data);
        break;
"
9289,0,CWE476_NULL_Pointer_Dereference__struct_16.c,"    twoIntsStruct * data;
    while(1)
    {
        
        data = NULL;
        break;
    }
    while(1)
    {
        
        printIntLine(data->intOne);
        break;
"
4374,0,CWE190_Integer_Overflow__int_fscanf_preinc_65a.c,"    int data;
    
    void (*funcPtr) (int) = CWE190_Integer_Overflow__int_fscanf_preinc_65b_badSink;
    
    data = 0;
    
    fscanf(stdin, ""%d"", &data);
    
"
16972,0,CWE415_Double_Free__new_delete_array_struct_43.cpp,"    twoIntsStruct * data;
    
    data = NULL;
    badSource(data);
    
"
4690,0,CWE590_Free_Memory_Not_on_Heap__free_int_alloca_74a.cpp,"    int * data;
    map<int, int *> dataMap;
    data = NULL; 
    {
        
        int * dataBuffer = (int *)ALLOCA(100*sizeof(int));
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5;
            }
        }
        data = dataBuffer;
    }
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
17378,0,CWE590_Free_Memory_Not_on_Heap__delete_class_declare_53a.cpp,"    TwoIntsClass * data;
    data = NULL; 
    {
        
        TwoIntsClass dataBuffer;
        dataBuffer.intOne = 1;
        dataBuffer.intTwo = 1;
        data = &dataBuffer;
    }
"
17617,0,CWE78_OS_Command_Injection__char_file_popen_66a.c,"    char * data;
    char * dataArray[5];
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
        
        size_t dataLen = strlen(data);
        FILE * pFile;
        
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
    
    dataArray[2] = data;
"
7285,1,CWE758_Undefined_Behavior__char_new_use_03.cpp,"    if(5==5)
    {
        {
            char data;
            data = 5;
            char * pointer = new char;
            *pointer = data; 
            {
                char data = *pointer;
                printHexCharLine(data);
            }
            delete pointer;
        }
"
13579,0,CWE190_Integer_Overflow__unsigned_int_max_multiply_81a.cpp,"    unsigned int data;
    data = 0;
    
    data = UINT_MAX;
    const CWE190_Integer_Overflow__unsigned_int_max_multiply_81_base& baseObject = CWE190_Integer_Overflow__unsigned_int_max_multiply_81_bad();
"
17461,1,CWE758_Undefined_Behavior__int_alloca_use_06.c,"    if(STATIC_CONST_FIVE==5)
    {
        {
            int data;
            int * pointer = (int *)ALLOCA(sizeof(int));
            data = 5;
            *pointer = data; 
            {
                int data = *pointer;
                printIntLine(data);
            }
        }
"
10739,0,CWE197_Numeric_Truncation_Error__short_connect_socket_12.c,"    short data;
    
    data = -1;
    if(globalReturnsTrueOrFalse())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = (short)atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    else
    {
        
        data = CHAR_MAX-5;
    }
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
2798,0,CWE590_Free_Memory_Not_on_Heap__delete_array_struct_declare_11.cpp,"    twoIntsStruct * data;
    data = NULL; 
    if(globalReturnsTrue())
    {
        {
            
            twoIntsStruct dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i].intOne = 1;
                    dataBuffer[i].intTwo = 1;
                }
            }
            data = dataBuffer;
        }
    }
    printStructLine(&data[0]);
    
"
14587,0,CWE665_Improper_Initialization__char_ncat_11.c,"    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    if(globalReturnsTrue())
    {
        
        ; 
    }
    {
        size_t sourceLen;
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        sourceLen = strlen(source);
        
        strncat(data, source, sourceLen);
        printLine(data);
"
11144,0,CWE690_NULL_Deref_From_Return__int64_t_calloc_44.c,"    int64_t * data;
    
    void (*funcPtr) (int64_t *) = badSink;
    data = NULL; 
    
    data = (int64_t *)calloc(1, sizeof(int64_t));
    
"
9674,0,CWE134_Uncontrolled_Format_String__char_file_vprintf_06.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(STATIC_CONST_FIVE==5)
    {
        {
            
            size_t dataLen = strlen(data);
            FILE * pFile;
            
            if (100-dataLen > 1)
            {
                pFile = fopen(FILENAME, ""r"");
                if (pFile != NULL)
                {
                    
                    if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                    {
                        printLine(""fgets() failed"");
                        
                        data[dataLen] = '\0';
                    }
                    fclose(pFile);
                }
            }
        }
    }
    if(STATIC_CONST_FIVE==5)
    {
        badVaSinkB(data, data);
"
3172,0,CWE369_Divide_by_Zero__int_connect_socket_modulo_61a.c,"    int data;
    
    data = -1;
    data = CWE369_Divide_by_Zero__int_connect_socket_modulo_61b_badSource(data);
    
"
4055,0,CWE190_Integer_Overflow__int64_t_fscanf_postinc_03.c,"    int64_t data;
    data = 0LL;
    if(5==5)
    {
        
        fscanf (stdin, ""%"" SCNd64, &data);
    }
    if(5==5)
    {
        {
            
            data++;
            int64_t result = data;
            printLongLongLine(result);
        }
"
3320,0,CWE758_Undefined_Behavior__char_new_use_05.cpp,"    if(staticTrue)
    {
        {
            char * pointer = new char;
            char data = *pointer; 
            delete pointer;
            printHexCharLine(data);
        }
"
4643,0,CWE369_Divide_by_Zero__int_listen_socket_modulo_05.c,"    int data;
    
    data = -1;
    if(staticTrue)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(staticTrue)
    {
        
        printIntLine(100 % data);
"
3123,0,CWE190_Integer_Overflow__short_fscanf_multiply_34.c,"    short data;
    CWE190_Integer_Overflow__short_fscanf_multiply_34_unionType myUnion;
    data = 0;
    
    fscanf (stdin, ""%hd"", &data);
    myUnion.unionFirst = data;
    {
        short data = myUnion.unionSecond;
        if(data > 0) 
        {
            
            short result = data * 2;
            printIntLine(result);
        }
"
14731,0,CWE457_Use_of_Uninitialized_Variable__struct_array_declare_partial_init_05.c,"    twoIntsStruct * data;
    twoIntsStruct dataUninitArray[10];
    data = dataUninitArray;
    if(staticTrue)
    {
        
        {
            int i;
            for(i=0; i<(10/2); i++)
            {
                data[i].intOne = i;
                data[i].intTwo = i;
            }
        }
    }
    if(staticTrue)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i].intOne);
                printIntLine(data[i].intTwo);
            }
        }
"
9172,1,CWE401_Memory_Leak__malloc_realloc_int64_t_10.c,"    if(globalTrue)
    {
        {
            int64_t * data = (int64_t *)malloc(100*sizeof(int64_t));
            if (data == NULL) {exit(-1);}
            int64_t * tmpData;
            
            data[0] = 5LL;
            printLongLongLine(data[0]);
            tmpData = (int64_t *)realloc(data, (130000)*sizeof(int64_t));
            /* FIX: Ensure realloc() was successful before assigning data to the memory block
            * allocated with realloc() */
            if (tmpData != NULL)
            {
                data = tmpData;
                
                data[0] = 10LL;
                printLongLongLine(data[0]);
            }
            free(data);
        }
"
7135,0,CWE590_Free_Memory_Not_on_Heap__delete_array_long_alloca_81a.cpp,"    long * data;
    data = NULL; 
    {
        
        long * dataBuffer = (long *)ALLOCA(100*sizeof(long));
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5L;
            }
        }
        data = dataBuffer;
    }
    const CWE590_Free_Memory_Not_on_Heap__delete_array_long_alloca_81_base& baseObject = CWE590_Free_Memory_Not_on_Heap__delete_array_long_alloca_81_bad();
"
18744,0,CWE401_Memory_Leak__new_array_TwoIntsClass_15.cpp,"    TwoIntsClass * data;
    data = NULL;
    switch(6)
    {
    case 6:
        
        data = new TwoIntsClass[100];
        
        data[0].intOne = 0;
        data[0].intTwo = 0;
        printIntLine(data[0].intOne);
        printIntLine(data[0].intTwo);
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
        
        ; 
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
19494,0,CWE590_Free_Memory_Not_on_Heap__delete_array_int64_t_static_06.cpp,"    int64_t * data;
    data = NULL; 
    if(STATIC_CONST_FIVE==5)
    {
        {
            
            static int64_t dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5LL;
                }
            }
            data = dataBuffer;
        }
    }
    printLongLongLine(data[0]);
    
"
12946,0,CWE190_Integer_Overflow__int_connect_socket_add_11.c,"    int data;
    
    data = 0;
    if(globalReturnsTrue())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(globalReturnsTrue())
    {
        {
            
            int result = data + 1;
            printIntLine(result);
        }
"
14212,0,CWE416_Use_After_Free__new_delete_array_char_16.cpp,"    char * data;
    
    data = NULL;
    while(1)
    {
        data = new char[100];
        memset(data, 'A', 100-1);
        data[100-1] = '\0';
        
        delete [] data;
        break;
    }
    while(1)
    {
        
        printLine(data);
        
        break;
"
9980,0,CWE190_Integer_Overflow__int64_t_max_multiply_44.c,"    int64_t data;
    
    void (*funcPtr) (int64_t) = badSink;
    data = 0LL;
    
    data = LLONG_MAX;
    
"
19127,0,CWE190_Integer_Overflow__char_rand_preinc_63a.c,"    char data;
    data = ' ';
    
    data = (char)RAND32();
"
6035,0,CWE78_OS_Command_Injection__char_environment_system_09.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(GLOBAL_CONST_TRUE)
    {
        {
            
            size_t dataLen = strlen(data);
            char * environment = GETENV(ENV_VARIABLE);
            
            if (environment != NULL)
            {
                
                strncat(data+dataLen, environment, 100-dataLen-1);
            }
        }
    }
    
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
"
2225,0,CWE590_Free_Memory_Not_on_Heap__delete_class_declare_02.cpp,"    TwoIntsClass * data;
    data = NULL; 
    if(1)
    {
        {
            
            TwoIntsClass dataBuffer;
            dataBuffer.intOne = 1;
            dataBuffer.intTwo = 1;
            data = &dataBuffer;
        }
    }
    printIntLine(data->intOne);
    
"
2775,0,CWE401_Memory_Leak__malloc_realloc_struct_twoIntsStruct_08.c,"    if(staticReturnsTrue())
    {
        {
            struct _twoIntsStruct * data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));
            if (data == NULL) {exit(-1);}
            
            data[0].intOne = 0;
            data[0].intTwo = 0;
            printStructLine((twoIntsStruct *)&data[0]);
            
            data = (struct _twoIntsStruct *)realloc(data, (130000)*sizeof(struct _twoIntsStruct));
            if (data != NULL)
            {
                
                data[0].intOne = 1;
                data[0].intTwo = 1;
                printStructLine((twoIntsStruct *)&data[0]);
                free(data);
            }
        }
"
15554,0,CWE690_NULL_Deref_From_Return__int64_t_malloc_21.c,"    int64_t * data;
    data = NULL; 
    
    data = (int64_t *)malloc(1*sizeof(int64_t));
    badStatic = 1; 
"
3000,0,CWE190_Integer_Overflow__unsigned_int_rand_postinc_68a.c,"    unsigned int data;
    data = 0;
    
    data = (unsigned int)RAND32();
    CWE190_Integer_Overflow__unsigned_int_rand_postinc_68_badData = data;
"
18221,0,CWE190_Integer_Overflow__int64_t_max_square_12.c,"    int64_t data;
    data = 0LL;
    if(globalReturnsTrueOrFalse())
    {
        
        data = LLONG_MAX;
    }
    else
    {
        
        data = 2;
    }
    if(globalReturnsTrueOrFalse())
    {
        {
            
            int64_t result = data * data;
            printLongLongLine(result);
        }
    }
    else
    {
        
        if (imaxabs((intmax_t)data) <= sqrtl(LLONG_MAX))
        {
            int64_t result = data * data;
            printLongLongLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
"
18402,1,CWE467_Use_of_sizeof_on_Pointer_Type__int_08.c,"    if(staticReturnsFalse())
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            int * goodInt = NULL;
            
            goodInt = (int *)malloc(sizeof(*goodInt));
            if (goodInt == NULL) {exit(-1);}
            *goodInt = 6;
            printIntLine(*goodInt);
            free(goodInt);
        }
"
17743,0,CWE401_Memory_Leak__malloc_realloc_int64_t_13.c,"    if(GLOBAL_CONST_FIVE==5)
    {
        {
            int64_t * data = (int64_t *)malloc(100*sizeof(int64_t));
            if (data == NULL) {exit(-1);}
            
            data[0] = 5LL;
            printLongLongLine(data[0]);
            
            data = (int64_t *)realloc(data, (130000)*sizeof(int64_t));
            if (data != NULL)
            {
                
                data[0] = 10LL;
                printLongLongLine(data[0]);
                free(data);
            }
        }
"
9359,0,CWE758_Undefined_Behavior__struct_new_use_18.cpp,"    goto sink;
sink:
    {
        twoIntsStruct * pointer = new twoIntsStruct;
        twoIntsStruct data = *pointer; 
        delete pointer;
        printIntLine(data.intOne);
        printIntLine(data.intTwo);
"
18618,1,CWE467_Use_of_sizeof_on_Pointer_Type__int_09.c,"    if(GLOBAL_CONST_FALSE)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            int * goodInt = NULL;
            
            goodInt = (int *)malloc(sizeof(*goodInt));
            if (goodInt == NULL) {exit(-1);}
            *goodInt = 6;
            printIntLine(*goodInt);
            free(goodInt);
        }
"
12506,0,CWE190_Integer_Overflow__char_rand_preinc_31.c,"    char data;
    data = ' ';
    
    data = (char)RAND32();
    {
        char dataCopy = data;
        char data = dataCopy;
        {
            
            ++data;
            char result = data;
            printHexCharLine(result);
        }
"
17138,0,CWE690_NULL_Deref_From_Return__int64_t_realloc_82_bad.cpp,"Label Definition File: CWE690_NULL_Deref_From_Return.free.label.xml
Template File: source-sinks-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 690 Unchecked Return Value To NULL Pointer
 * BadSource: realloc Allocate data using realloc()
 * Sinks:
 *    GoodSink: Check to see if the data allocation failed and if not, use data
 *    BadSink : Don't check for NULL and use data
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE690_NULL_Deref_From_Return__int64_t_realloc_82.h""

namespace CWE690_NULL_Deref_From_Return__int64_t_realloc_82
{

void CWE690_NULL_Deref_From_Return__int64_t_realloc_82_bad::action(int64_t * data)
{
    
    data[0] = 5LL;
    printLongLongLine(data[0]);
    free(data);
}

}
"
11777,0,CWE415_Double_Free__new_delete_array_struct_17.cpp,"    int i,j;
    twoIntsStruct * data;
    
    data = NULL;
    for(i = 0; i < 1; i++)
    {
        data = new twoIntsStruct[100];
        
        delete [] data;
    }
    for(j = 0; j < 1; j++)
    {
        
        delete [] data;
"
6456,0,CWE457_Use_of_Uninitialized_Variable__twointsclass_array_alloca_partial_init_64a.cpp,"    TwoIntsClass * data;
    data = reinterpret_cast<TwoIntsClass *>(ALLOCA(10*sizeof(TwoIntsClass)));
    
    for(int i=0; i<(10/2); i++)
    {
        data[i].intOne = i;
        data[i].intTwo = i;
    }
"
12048,0,CWE369_Divide_by_Zero__int_rand_divide_54a.c,"    int data;
    
    data = -1;
    
    data = RAND32();
"
14831,0,CWE190_Integer_Overflow__int64_t_fscanf_square_64a.c,"    int64_t data;
    data = 0LL;
    
    fscanf (stdin, ""%"" SCNd64, &data);
"
10535,1,CWE758_Undefined_Behavior__double_pointer_malloc_use_05.c,"    if(staticFalse)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            double * data;
            double * * pointer = (double * *)malloc(sizeof(double *));
            if (pointer == NULL) {exit(-1);}
            
            data = (double *)malloc(sizeof(double));
            if (data == NULL) {exit(-1);}
            *data = 5.0;
            *pointer = data; 
            {
                double * data = *pointer;
                printDoubleLine(*data);
            }
            free(pointer);
        }
"
6895,0,CWE190_Integer_Overflow__int_connect_socket_square_68a.c,"    int data;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    CWE190_Integer_Overflow__int_connect_socket_square_68_badData = data;
"
2035,0,CWE190_Integer_Overflow__char_fscanf_square_14.c,"    char data;
    data = ' ';
    if(globalFive==5)
    {
        
        fscanf (stdin, ""%c"", &data);
    }
    if(globalFive==5)
    {
        {
            
            char result = data * data;
            printHexCharLine(result);
        }
"
4955,0,CWE190_Integer_Overflow__short_fscanf_multiply_81a.cpp,"    short data;
    data = 0;
    
    fscanf (stdin, ""%hd"", &data);
    const CWE190_Integer_Overflow__short_fscanf_multiply_81_base& baseObject = CWE190_Integer_Overflow__short_fscanf_multiply_81_bad();
"
12062,0,CWE190_Integer_Overflow__unsigned_int_max_square_44.c,"    unsigned int data;
    
    void (*funcPtr) (unsigned int) = badSink;
    data = 0;
    
    data = UINT_MAX;
    
"
18136,0,CWE590_Free_Memory_Not_on_Heap__delete_struct_placement_new_33.cpp,"    twoIntsStruct * data;
    twoIntsStruct * &dataRef = data;
    data = NULL; 
    {
        
        char buffer[sizeof(twoIntsStruct)];
        twoIntsStruct * dataBuffer = new(buffer) twoIntsStruct;
        dataBuffer->intOne = 1;
        dataBuffer->intTwo = 1;
        data = dataBuffer;
    }
    {
        twoIntsStruct * data = dataRef;
        printStructLine(data);
        
        delete data;
"
2618,0,CWE190_Integer_Overflow__int64_t_max_add_06.c,"    int64_t data;
    data = 0LL;
    if(STATIC_CONST_FIVE==5)
    {
        
        data = LLONG_MAX;
    }
    if(STATIC_CONST_FIVE==5)
    {
        {
            
            int64_t result = data + 1;
            printLongLongLine(result);
        }
"
1531,0,CWE590_Free_Memory_Not_on_Heap__free_int64_t_declare_16.c,"    int64_t * data;
    data = NULL; 
    while(1)
    {
        {
            
            int64_t dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5LL;
                }
            }
            data = dataBuffer;
        }
        break;
    }
    printLongLongLine(data[0]);
    
"
351,0,CWE190_Integer_Overflow__short_fscanf_add_05.c,"    short data;
    data = 0;
    if(staticTrue)
    {
        
        fscanf (stdin, ""%hd"", &data);
    }
    if(staticTrue)
    {
        {
            
            short result = data + 1;
            printIntLine(result);
        }
"
13354,0,CWE590_Free_Memory_Not_on_Heap__delete_int_alloca_41.cpp,"    int * data;
    data = NULL; 
    {
        
        int * dataBuffer = (int *)ALLOCA(sizeof(int));
        *dataBuffer = 5;
        data = dataBuffer;
    }
"
3765,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_17.c,"    int i,j;
    size_t data;
    
    data = 0;
    for(i = 0; i < 1; i++)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                
                data = strtoul(inputBuffer, NULL, 0);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    for(j = 0; j < 1; j++)
    {
        {
            char * myString;
            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
             * for the strcpy() function to not cause a buffer overflow */
            
            if (data > strlen(HELLO_STRING))
            {
                myString = (char *)malloc(data*sizeof(char));
                if (myString == NULL) {exit(-1);}
                
                strcpy(myString, HELLO_STRING);
                printLine(myString);
                free(myString);
            }
            else
            {
                printLine(""Input is less than the length of the source string"");
            }
        }
"
13497,0,CWE369_Divide_by_Zero__int_zero_modulo_61a.c,"    int data;
    
    data = -1;
    data = CWE369_Divide_by_Zero__int_zero_modulo_61b_badSource(data);
    
"
12335,0,CWE190_Integer_Overflow__int_fscanf_postinc_14.c,"    int data;
    
    data = 0;
    if(globalFive==5)
    {
        
        fscanf(stdin, ""%d"", &data);
    }
    if(globalFive==5)
    {
        {
            
            data++;
            int result = data;
            printIntLine(result);
        }
"
7289,0,CWE190_Integer_Overflow__char_fscanf_square_53a.c,"    char data;
    data = ' ';
    
    fscanf (stdin, ""%c"", &data);
"
7942,0,CWE590_Free_Memory_Not_on_Heap__free_long_declare_01.c,"    long * data;
    data = NULL; 
    {
        
        long dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5L;
            }
        }
        data = dataBuffer;
    }
    printLongLine(data[0]);
    
"
6028,0,CWE665_Improper_Initialization__char_cat_84_bad.cpp,"Label Definition File: CWE665_Improper_Initialization.label.xml
Template File: sources-sink-84_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 665 Improper Initialization
 * BadSource:  Do not initialize data properly
 * GoodSource: Initialize data
 * Sinks: cat
 *    BadSink : Copy string to data using strcat
 * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE665_Improper_Initialization__char_cat_84.h""

namespace CWE665_Improper_Initialization__char_cat_84
{
CWE665_Improper_Initialization__char_cat_84_bad::CWE665_Improper_Initialization__char_cat_84_bad(char * dataCopy)
{
    data = dataCopy;
    
    ; 
}

CWE665_Improper_Initialization__char_cat_84_bad::~CWE665_Improper_Initialization__char_cat_84_bad()
{
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        
        strcat(data, source);
        printLine(data);
    }
}
}
"
8796,0,CWE369_Divide_by_Zero__float_zero_53a.c,"    float data;
    
    data = 0.0F;
    
    data = 0.0F;
"
10436,1,CWE758_Undefined_Behavior__char_alloca_use_08.c,"    if(staticReturnsFalse())
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            char data;
            char * pointer = (char *)ALLOCA(sizeof(char));
            data = 5;
            *pointer = data; 
            {
                char data = *pointer;
                printHexCharLine(data);
            }
        }
"
10624,0,CWE415_Double_Free__new_delete_long_05.cpp,"    long * data;
    
    data = NULL;
    if(staticTrue)
    {
        data = new long;
        
        delete data;
    }
    if(staticTrue)
    {
        
        delete data;
"
13853,1,CWE252_Unchecked_Return_Value__char_rename_02.c,"    if(0)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        
        if (RENAME(OLD_GOOD_FILE_NAME, ""newgoodfilename.txt"") != 0)
        {
            printLine(""rename failed!"");
        }
"
10273,0,CWE197_Numeric_Truncation_Error__int_rand_to_short_32.c,"    int data;
    int *dataPtr1 = &data;
    int *dataPtr2 = &data;
    
    data = -1;
    {
        int data = *dataPtr1;
        
        data = RAND32();
        *dataPtr1 = data;
    }
    {
        int data = *dataPtr2;
        {
            
            short shortData = (short)data;
            printShortLine(shortData);
        }
"
967,1,CWE476_NULL_Pointer_Dereference__deref_after_check_01.c,"    {
        
        int *intPointer = NULL;
        if (intPointer == NULL)
        {
            printLine(""pointer is NULL"");
        }
"
5505,0,CWE416_Use_After_Free__malloc_free_int64_t_03.c,"    int64_t * data;
    
    data = NULL;
    if(5==5)
    {
        data = (int64_t *)malloc(100*sizeof(int64_t));
        if (data == NULL) {exit(-1);}
        {
            size_t i;
            for(i = 0; i < 100; i++)
            {
                data[i] = 5LL;
            }
        }
        
        free(data);
    }
    if(5==5)
    {
        
        printLongLongLine(data[0]);
        
"
19072,0,CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_33.cpp,"    char * data;
    char * &dataRef = data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    {
        char * data = dataRef;
        
        fprintf(stdout, data);
"
213,0,CWE590_Free_Memory_Not_on_Heap__delete_struct_alloca_15.cpp,"    twoIntsStruct * data;
    data = NULL; 
    switch(6)
    {
    case 6:
    {
        
        twoIntsStruct * dataBuffer = (twoIntsStruct *)ALLOCA(sizeof(twoIntsStruct));
        dataBuffer->intOne = 1;
        dataBuffer->intTwo = 1;
        data = dataBuffer;
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    printStructLine(data);
    
"
12698,0,CWE369_Divide_by_Zero__int_fgets_divide_07.c,"    int data;
    
    data = -1;
    if(staticFive==5)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    if(staticFive==5)
    {
        
        printIntLine(100 / data);
"
18281,1,CWE758_Undefined_Behavior__struct_pointer_malloc_use_07.c,"    if(staticFive!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            twoIntsStruct * data;
            twoIntsStruct * * pointer = (twoIntsStruct * *)malloc(sizeof(twoIntsStruct *));
            if (pointer == NULL) {exit(-1);}
            
            data = (twoIntsStruct *)malloc(sizeof(twoIntsStruct));
            if (data == NULL) {exit(-1);}
            data->intOne = 5;
            data->intTwo = 6;
            *pointer = data; 
            {
                twoIntsStruct * data = *pointer;
                printIntLine(data->intOne);
                printIntLine(data->intTwo);
            }
            free(pointer);
        }
"
4738,0,CWE563_Unused_Variable__unused_uninit_variable_int_01.c,"    int data;
    
    ; 
    
    
"
7099,0,CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_82a.cpp,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_82_base* baseObject = new CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_82_bad;
    baseObject->action(data);
"
18485,0,CWE690_NULL_Deref_From_Return__int_calloc_03.c,"    int * data;
    data = NULL; 
    
    data = (int *)calloc(1, sizeof(int));
    if(5==5)
    {
        
        data[0] = 5;
        printIntLine(data[0]);
        free(data);
"
6590,0,CWE369_Divide_by_Zero__float_fgets_53a.c,"    float data;
    
    data = 0.0F;
    {
        char inputBuffer[CHAR_ARRAY_SIZE];
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = (float)atof(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
"
9871,0,CWE690_NULL_Deref_From_Return__struct_realloc_03.c,"    twoIntsStruct * data;
    data = NULL; 
    
    data = (twoIntsStruct *)realloc(data, 1*sizeof(twoIntsStruct));
    if(5==5)
    {
        
        data[0].intOne = 1;
        data[0].intTwo = 1;
        printStructLine(&data[0]);
        free(data);
"
6158,0,CWE457_Use_of_Uninitialized_Variable__new_struct_array_partial_init_12.cpp,"    twoIntsStruct * data;
    data = new twoIntsStruct[10];
    if(globalReturnsTrueOrFalse())
    {
        
        {
            int i;
            for(i=0; i<(10/2); i++)
            {
                data[i].intOne = i;
                data[i].intTwo = i;
            }
        }
    }
    else
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                data[i].intOne = i;
                data[i].intTwo = i;
            }
        }
    }
    if(globalReturnsTrueOrFalse())
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i].intOne);
                printIntLine(data[i].intTwo);
            }
        }
        
        delete [] data;
    }
    else
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                data[i].intOne = i;
                data[i].intTwo = i;
            }
        }
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i].intOne);
                printIntLine(data[i].intTwo);
            }
        }
        
        delete [] data;
"
10638,0,CWE415_Double_Free__new_delete_class_81_bad.cpp,"Label Definition File: CWE415_Double_Free__new_delete.label.xml
Template File: sources-sinks-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 415 Double Free
 * BadSource:  Allocate data using new and Deallocae data using delete
 * GoodSource: Allocate data using new
 * Sinks:
 *    GoodSink: do nothing
 *    BadSink : Deallocate data using delete
 * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE415_Double_Free__new_delete_class_81.h""

namespace CWE415_Double_Free__new_delete_class_81
{

void CWE415_Double_Free__new_delete_class_81_bad::action(TwoIntsClass * data) const
{
    
    delete data;
}

}
"
118,0,CWE197_Numeric_Truncation_Error__int_fgets_to_short_68a.c,"    int data;
    
    data = -1;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    CWE197_Numeric_Truncation_Error__int_fgets_to_short_68_badData = data;
"
7975,0,CWE476_NULL_Pointer_Dereference__class_13.cpp,"    TwoIntsClass * data;
    if(GLOBAL_CONST_FIVE==5)
    {
        
        data = NULL;
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        
        printIntLine(data->intOne);
        
        delete data;
"
16089,0,CWE416_Use_After_Free__new_delete_array_long_03.cpp,"    long * data;
    
    data = NULL;
    if(5==5)
    {
        data = new long[100];
        {
            size_t i;
            for(i = 0; i < 100; i++)
            {
                data[i] = 5L;
            }
        }
        
        delete [] data;
    }
    if(5==5)
    {
        
        printLongLine(data[0]);
        
"
12266,0,CWE401_Memory_Leak__char_realloc_10.c,"    char * data;
    data = NULL;
    if(globalTrue)
    {
        
        data = (char *)realloc(data, 100*sizeof(char));
        if (data == NULL) {exit(-1);}
        
        strcpy(data, ""A String"");
        printLine(data);
    }
    if(globalTrue)
    {
        
        ; 
"
2952,0,CWE590_Free_Memory_Not_on_Heap__free_long_static_31.c,"    long * data;
    data = NULL; 
    {
        
        static long dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5L;
            }
        }
        data = dataBuffer;
    }
    {
        long * dataCopy = data;
        long * data = dataCopy;
        printLongLine(data[0]);
        
        free(data);
"
16551,1,CWE758_Undefined_Behavior__double_pointer_new_use_03.cpp,"    if(5!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            double * data;
            
            data = new double;
            *data = 5.0;
            double * * pointer = new double *;
            *pointer = data; 
            {
                double * data = *pointer;
                printDoubleLine(*data);
            }
            delete pointer;
        }
"
16591,0,CWE190_Integer_Overflow__int64_t_fscanf_square_83a.cpp,"    int64_t data;
    data = 0LL;
"
1042,0,CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_67a.c,"    unsigned int data;
    CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_67_structType myStruct;
    data = 0;
    
    fscanf (stdin, ""%u"", &data);
    myStruct.structFirst = data;
"
7819,0,CWE369_Divide_by_Zero__int_listen_socket_divide_44.c,"    int data;
    
    void (*funcPtr) (int) = badSink;
    
    data = -1;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
"
13138,0,CWE563_Unused_Variable__unused_value_int64_t_83a.cpp,"    int64_t data;
"
3821,0,CWE590_Free_Memory_Not_on_Heap__delete_array_class_alloca_11.cpp,"    TwoIntsClass * data;
    data = NULL; 
    if(globalReturnsTrue())
    {
        {
            
            TwoIntsClass * dataBuffer = (TwoIntsClass *)ALLOCA(100*sizeof(TwoIntsClass));
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i].intOne = 1;
                    dataBuffer[i].intTwo = 1;
                }
            }
            data = dataBuffer;
        }
    }
    printIntLine(data[0].intOne);
    
"
15871,0,CWE457_Use_of_Uninitialized_Variable__new_double_array_no_init_07.cpp,"    double * data;
    data = new double[10];
    if(staticFive==5)
    {
        
        ; 
    }
    if(staticFive==5)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printDoubleLine(data[i]);
            }
        }
        
        delete [] data;
"
10447,0,CWE416_Use_After_Free__new_delete_array_int_17.cpp,"    int i,j;
    int * data;
    
    data = NULL;
    for(i = 0; i < 1; i++)
    {
        data = new int[100];
        {
            size_t i;
            for(i = 0; i < 100; i++)
            {
                data[i] = 5;
            }
        }
        
        delete [] data;
    }
    for(j = 0; j < 1; j++)
    {
        
        printIntLine(data[0]);
        
"
17941,0,CWE190_Integer_Overflow__short_fscanf_preinc_54a.c,"    short data;
    data = 0;
    
    fscanf (stdin, ""%hd"", &data);
"
13672,0,CWE197_Numeric_Truncation_Error__int_large_to_char_42.c,"    int data;
    
    data = -1;
    data = badSource(data);
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
3967,0,CWE190_Integer_Overflow__unsigned_int_fscanf_square_34.c,"    unsigned int data;
    CWE190_Integer_Overflow__unsigned_int_fscanf_square_34_unionType myUnion;
    data = 0;
    
    fscanf (stdin, ""%u"", &data);
    myUnion.unionFirst = data;
    {
        unsigned int data = myUnion.unionSecond;
        {
            
            unsigned int result = data * data;
            printUnsignedLine(result);
        }
"
7643,0,CWE789_Uncontrolled_Mem_Alloc__new_char_fgets_10.cpp,"    size_t data;
    
    data = 0;
    if(globalTrue)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                
                data = strtoul(inputBuffer, NULL, 0);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    if(globalTrue)
    {
        {
            char * myString;
            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
             * for the strcpy() function to not cause a buffer overflow */
            
            if (data > strlen(HELLO_STRING))
            {
                myString = new char[data];
                
                strcpy(myString, HELLO_STRING);
                printLine(myString);
                delete [] myString;
            }
            else
            {
                printLine(""Input is less than the length of the source string"");
            }
        }
"
18418,0,CWE190_Integer_Overflow__char_max_postinc_67a.c,"    char data;
    CWE190_Integer_Overflow__char_max_postinc_67_structType myStruct;
    data = ' ';
    
    data = CHAR_MAX;
    myStruct.structFirst = data;
"
4106,0,CWE401_Memory_Leak__struct_twoIntsStruct_calloc_08.c,"    struct _twoIntsStruct * data;
    data = NULL;
    if(staticReturnsTrue())
    {
        
        data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));
        if (data == NULL) {exit(-1);}
        
        data[0].intOne = 0;
        data[0].intTwo = 0;
        printStructLine((twoIntsStruct *)&data[0]);
    }
    if(staticReturnsTrue())
    {
        
        ; 
"
2728,0,CWE190_Integer_Overflow__char_max_preinc_21.c,"    char data;
    data = ' ';
    
    data = CHAR_MAX;
    badStatic = 1; 
"
1941,1,CWE758_Undefined_Behavior__class_pointer_new_use_11.cpp,"    if(globalReturnsFalse())
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            TwoIntsClass * data;
            
            data = new TwoIntsClass;
            data->intOne = 5;
            data->intTwo = 6;
            TwoIntsClass * * pointer = new TwoIntsClass *;
            *pointer = data; 
            {
                TwoIntsClass * data = *pointer;
                printIntLine(data->intOne);
                printIntLine(data->intTwo);
            }
            delete pointer;
        }
"
9077,0,CWE476_NULL_Pointer_Dereference__long_31.c,"    long * data;
    
    data = NULL;
    {
        long * dataCopy = data;
        long * data = dataCopy;
        
        printLongLine(*data);
"
11083,0,CWE190_Integer_Overflow__short_rand_preinc_01.c,"    short data;
    data = 0;
    
    data = (short)RAND32();
    {
        
        ++data;
        short result = data;
        printIntLine(result);
"
16850,0,CWE590_Free_Memory_Not_on_Heap__delete_struct_declare_72a.cpp,"    twoIntsStruct * data;
    vector<twoIntsStruct *> dataVector;
    data = NULL; 
    {
        
        twoIntsStruct dataBuffer;
        dataBuffer.intOne = 1;
        dataBuffer.intTwo = 1;
        data = &dataBuffer;
    }
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
4854,0,CWE690_NULL_Deref_From_Return__int_calloc_05.c,"    int * data;
    data = NULL; 
    
    data = (int *)calloc(1, sizeof(int));
    if(staticTrue)
    {
        
        data[0] = 5;
        printIntLine(data[0]);
        free(data);
"
18641,0,CWE590_Free_Memory_Not_on_Heap__delete_char_declare_41.cpp,"    char * data;
    data = NULL; 
    {
        
        char dataBuffer;
        dataBuffer = 'A';
        data = &dataBuffer;
    }
"
14906,0,CWE190_Integer_Overflow__int64_t_fscanf_square_32.c,"    int64_t data;
    int64_t *dataPtr1 = &data;
    int64_t *dataPtr2 = &data;
    data = 0LL;
    {
        int64_t data = *dataPtr1;
        
        fscanf (stdin, ""%"" SCNd64, &data);
        *dataPtr1 = data;
    }
    {
        int64_t data = *dataPtr2;
        {
            
            int64_t result = data * data;
            printLongLongLine(result);
        }
"
10960,0,CWE190_Integer_Overflow__char_rand_postinc_05.c,"    char data;
    data = ' ';
    if(staticTrue)
    {
        
        data = (char)RAND32();
    }
    if(staticTrue)
    {
        {
            
            data++;
            char result = data;
            printHexCharLine(result);
        }
"
5026,0,CWE197_Numeric_Truncation_Error__short_connect_socket_83_bad.cpp,"Label Definition File: CWE197_Numeric_Truncation_Error__short.label.xml
Template File: sources-sink-83_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 197 Numeric Truncation Error
 * BadSource: connect_socket Read data using a connect socket (client side)
 * GoodSource: Less than CHAR_MAX
 * Sinks:
 *    BadSink : Convert data to a char
 * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE197_Numeric_Truncation_Error__short_connect_socket_83.h""

#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif

#define TCP_PORT 27015

#define CHAR_ARRAY_SIZE 8
#define IP_ADDRESS ""127.0.0.1""

namespace CWE197_Numeric_Truncation_Error__short_connect_socket_83
{
CWE197_Numeric_Truncation_Error__short_connect_socket_83_bad::CWE197_Numeric_Truncation_Error__short_connect_socket_83_bad(short dataCopy)
{
    data = dataCopy;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = (short)atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
}

CWE197_Numeric_Truncation_Error__short_connect_socket_83_bad::~CWE197_Numeric_Truncation_Error__short_connect_socket_83_bad()
{
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
    }
}
}
"
3793,0,CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_45.cpp,"    size_t data;
    
    data = 0;
    
    fscanf(stdin, ""%zu"", &data);
    badData = data;
"
7877,0,CWE457_Use_of_Uninitialized_Variable__twointsclass_array_declare_no_init_14.cpp,"    TwoIntsClass * data;
    TwoIntsClass dataUninitArray[10];
    data = dataUninitArray;
    if(globalFive==5)
    {
        
        ; 
    }
    if(globalFive==5)
    {
        
        for(int i=0; i<10; i++)
        {
            printIntLine(data[i].intOne);
            printIntLine(data[i].intTwo);
        }
"
7881,0,CWE78_OS_Command_Injection__char_connect_socket_popen_66a.c,"    char * data;
    char * dataArray[5];
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
    dataArray[2] = data;
"
11231,0,CWE190_Integer_Overflow__unsigned_int_max_add_01.c,"    unsigned int data;
    data = 0;
    
    data = UINT_MAX;
    {
        
        unsigned int result = data + 1;
        printUnsignedLine(result);
"
10826,0,CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_02.c,"    unsigned int data;
    data = 0;
    if(1)
    {
        
        fscanf (stdin, ""%u"", &data);
    }
    if(1)
    {
        {
            
            ++data;
            unsigned int result = data;
            printUnsignedLine(result);
        }
"
9105,0,CWE590_Free_Memory_Not_on_Heap__delete_array_char_static_10.cpp,"    char * data;
    data = NULL; 
    if(globalTrue)
    {
        {
            
            static char dataBuffer[100];
            memset(dataBuffer, 'A', 100-1); 
            dataBuffer[100-1] = '\0'; 
            data = dataBuffer;
        }
    }
    printLine(data);
    
"
9145,0,CWE134_Uncontrolled_Format_String__char_file_snprintf_11.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(globalReturnsTrue())
    {
        {
            
            size_t dataLen = strlen(data);
            FILE * pFile;
            
            if (100-dataLen > 1)
            {
                pFile = fopen(FILENAME, ""r"");
                if (pFile != NULL)
                {
                    
                    if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                    {
                        printLine(""fgets() failed"");
                        
                        data[dataLen] = '\0';
                    }
                    fclose(pFile);
                }
            }
        }
    }
    if(globalReturnsTrue())
    {
        {
            char dest[100] = """";
            
            SNPRINTF(dest, 100-1, data);
            printLine(dest);
        }
"
2070,0,CWE190_Integer_Overflow__int_fscanf_add_16.c,"    int data;
    
    data = 0;
    while(1)
    {
        
        fscanf(stdin, ""%d"", &data);
        break;
    }
    while(1)
    {
        {
            
            int result = data + 1;
            printIntLine(result);
        }
        break;
"
5457,0,CWE590_Free_Memory_Not_on_Heap__free_struct_alloca_54a.c,"    twoIntsStruct * data;
    data = NULL; 
    {
        
        twoIntsStruct * dataBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i].intOne = 1;
                dataBuffer[i].intTwo = 1;
            }
        }
        data = dataBuffer;
    }
"
17140,0,CWE590_Free_Memory_Not_on_Heap__free_char_static_65a.c,"    char * data;
    
    void (*funcPtr) (char *) = CWE590_Free_Memory_Not_on_Heap__free_char_static_65b_badSink;
    data = NULL; 
    {
        
        static char dataBuffer[100];
        memset(dataBuffer, 'A', 100-1); 
        dataBuffer[100-1] = '\0'; 
        data = dataBuffer;
    }
    
"
11084,0,CWE369_Divide_by_Zero__float_fgets_84a.cpp,"    float data;
    
    data = 0.0F;
    CWE369_Divide_by_Zero__float_fgets_84_bad * badObject = new CWE369_Divide_by_Zero__float_fgets_84_bad(data);
"
8098,0,CWE190_Integer_Overflow__short_rand_postinc_13.c,"    short data;
    data = 0;
    if(GLOBAL_CONST_FIVE==5)
    {
        
        data = (short)RAND32();
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            
            data++;
            short result = data;
            printIntLine(result);
        }
"
5697,0,CWE590_Free_Memory_Not_on_Heap__free_char_declare_65a.c,"    char * data;
    
    void (*funcPtr) (char *) = CWE590_Free_Memory_Not_on_Heap__free_char_declare_65b_badSink;
    data = NULL; 
    {
        
        char dataBuffer[100];
        memset(dataBuffer, 'A', 100-1); 
        dataBuffer[100-1] = '\0'; 
        data = dataBuffer;
    }
    
"
18729,0,CWE190_Integer_Overflow__char_max_square_18.c,"    char data;
    data = ' ';
    goto source;
source:
    
    data = CHAR_MAX;
    goto sink;
sink:
    {
        
        char result = data * data;
        printHexCharLine(result);
"
6136,0,CWE590_Free_Memory_Not_on_Heap__free_long_declare_06.c,"    long * data;
    data = NULL; 
    if(STATIC_CONST_FIVE==5)
    {
        {
            
            long dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5L;
                }
            }
            data = dataBuffer;
        }
    }
    printLongLine(data[0]);
    
"
1181,0,CWE190_Integer_Overflow__int_fscanf_add_83a.cpp,"    int data;
    
    data = 0;
"
17365,0,CWE252_Unchecked_Return_Value__char_snprintf_13.c,"    if(GLOBAL_CONST_FIVE==5)
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            
            SNPRINTF(data,100-strlen(SRC)-1, ""%s\n"", SRC);
        }
"
2253,0,CWE369_Divide_by_Zero__float_rand_42.c,"    float data;
    
    data = 0.0F;
    data = badSource(data);
    {
        
        int result = (int)(100.0 / data);
        printIntLine(result);
"
17590,0,CWE590_Free_Memory_Not_on_Heap__delete_array_int_static_51a.cpp,"    int * data;
    data = NULL; 
    {
        
        static int dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5;
            }
        }
        data = dataBuffer;
    }
"
7491,0,CWE190_Integer_Overflow__int64_t_max_postinc_44.c,"    int64_t data;
    
    void (*funcPtr) (int64_t) = badSink;
    data = 0LL;
    
    data = LLONG_MAX;
    
"
2445,0,CWE190_Integer_Overflow__short_rand_multiply_07.c,"    short data;
    data = 0;
    if(staticFive==5)
    {
        
        data = (short)RAND32();
    }
    if(staticFive==5)
    {
        if(data > 0) 
        {
            
            short result = data * 2;
            printIntLine(result);
        }
"
7726,0,CWE590_Free_Memory_Not_on_Heap__delete_int64_t_static_09.cpp,"    int64_t * data;
    data = NULL; 
    if(GLOBAL_CONST_TRUE)
    {
        {
            
            static int64_t dataBuffer;
            dataBuffer = 5LL;
            data = &dataBuffer;
        }
    }
    printLongLongLine(*data);
    
"
4445,0,CWE758_Undefined_Behavior__char_pointer_malloc_use_14.c,"    if(globalFive==5)
    {
        {
            char * * pointer = (char * *)malloc(sizeof(char *));
            if (pointer == NULL) {exit(-1);}
            char * data = *pointer; 
            free(pointer);
            printLine(data);
        }
"
11052,0,CWE563_Unused_Variable__unused_uninit_variable_int64_t_83_bad.cpp,"Label Definition File: CWE563_Unused_Variable__unused_uninit_variable.label.xml
Template File: source-sinks-83_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 563 Unused Variable
 * BadSource:  Initialize data
 * Sinks:
 *    GoodSink: Initialize, then use data
 *    BadSink : Do nothing
 * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE563_Unused_Variable__unused_uninit_variable_int64_t_83.h""

namespace CWE563_Unused_Variable__unused_uninit_variable_int64_t_83
{
CWE563_Unused_Variable__unused_uninit_variable_int64_t_83_bad::CWE563_Unused_Variable__unused_uninit_variable_int64_t_83_bad(int64_t dataCopy)
{
    data = dataCopy;
    
    ; 
}

CWE563_Unused_Variable__unused_uninit_variable_int64_t_83_bad::~CWE563_Unused_Variable__unused_uninit_variable_int64_t_83_bad()
{
    
    
    ; 
}
}
"
8144,0,CWE190_Integer_Overflow__int_fscanf_preinc_05.c,"    int data;
    
    data = 0;
    if(staticTrue)
    {
        
        fscanf(stdin, ""%d"", &data);
    }
    if(staticTrue)
    {
        {
            
            ++data;
            int result = data;
            printIntLine(result);
        }
"
19204,0,CWE190_Integer_Overflow__unsigned_int_rand_preinc_07.c,"    unsigned int data;
    data = 0;
    if(staticFive==5)
    {
        
        data = (unsigned int)RAND32();
    }
    if(staticFive==5)
    {
        {
            
            ++data;
            unsigned int result = data;
            printUnsignedLine(result);
        }
"
8538,0,CWE78_OS_Command_Injection__char_connect_socket_popen_03.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(5==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET connectSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
"
7946,1,CWE252_Unchecked_Return_Value__char_remove_10.c,"    if(globalTrue)
    {
        
        if (REMOVE(""removemegood.txt"") != 0)
        {
            printLine(""remove failed!"");
        }
"
7377,0,CWE190_Integer_Overflow__unsigned_int_rand_postinc_52a.c,"    unsigned int data;
    data = 0;
    
    data = (unsigned int)RAND32();
"
392,0,CWE476_NULL_Pointer_Dereference__int_03.c,"    int * data;
    if(5==5)
    {
        
        data = NULL;
    }
    if(5==5)
    {
        
        printIntLine(*data);
"
15920,0,CWE190_Integer_Overflow__unsigned_int_max_square_10.c,"    unsigned int data;
    data = 0;
    if(globalTrue)
    {
        
        data = UINT_MAX;
    }
    if(globalTrue)
    {
        {
            
            unsigned int result = data * data;
            printUnsignedLine(result);
        }
"
8827,1,CWE252_Unchecked_Return_Value__char_sscanf_07.c,"    if(staticFive==5)
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            
            if (sscanf(SRC, ""%99s\0"", data) == EOF)
            {
                printLine(""sscanf failed!"");
            }
        }
"
12719,0,CWE134_Uncontrolled_Format_String__char_environment_vprintf_45.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        
        if (environment != NULL)
        {
            
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    CWE134_Uncontrolled_Format_String__char_environment_vprintf_45_badData = data;
"
1185,0,CWE690_NULL_Deref_From_Return__int64_t_realloc_74a.cpp,"    int64_t * data;
    map<int, int64_t *> dataMap;
    data = NULL; 
    
    data = (int64_t *)realloc(data, 1*sizeof(int64_t));
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
9240,0,CWE457_Use_of_Uninitialized_Variable__new_int_array_partial_init_10.cpp,"    int * data;
    data = new int[10];
    if(globalTrue)
    {
        
        {
            int i;
            for(i=0; i<(10/2); i++)
            {
                data[i] = i;
            }
        }
    }
    if(globalTrue)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i]);
            }
        }
        
        delete [] data;
"
12130,0,CWE78_OS_Command_Injection__char_connect_socket_system_21.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    badStatic = 1; 
    data = badSource(data);
    
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
    }
}

#endif 

#ifndef OMITGOOD

"
1939,0,CWE590_Free_Memory_Not_on_Heap__free_struct_static_03.c,"    twoIntsStruct * data;
    data = NULL; 
    if(5==5)
    {
        {
            
            static twoIntsStruct dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i].intOne = 1;
                    dataBuffer[i].intTwo = 1;
                }
            }
            data = dataBuffer;
        }
    }
    printStructLine(&data[0]);
    
"
11781,0,CWE197_Numeric_Truncation_Error__int_fscanf_to_short_10.c,"    int data;
    
    data = -1;
    if(globalTrue)
    {
        
        fscanf(stdin, ""%d"", &data);
    }
    {
        
        short shortData = (short)data;
        printShortLine(shortData);
"
576,0,CWE252_Unchecked_Return_Value__char_fputc_12.c,"    if(globalReturnsTrueOrFalse())
    {
        
        fputc((int)'A', stdout);
    }
    else
    {
        
        if (fputc((int)'A', stdout) == EOF)
        {
            printLine(""fputc failed!"");
        }
"
17202,0,CWE190_Integer_Overflow__unsigned_int_rand_add_68a.c,"    unsigned int data;
    data = 0;
    
    data = (unsigned int)RAND32();
    CWE190_Integer_Overflow__unsigned_int_rand_add_68_badData = data;
"
7089,0,CWE190_Integer_Overflow__short_rand_preinc_14.c,"    short data;
    data = 0;
    if(globalFive==5)
    {
        
        data = (short)RAND32();
    }
    if(globalFive==5)
    {
        {
            
            ++data;
            short result = data;
            printIntLine(result);
        }
"
8303,0,CWE401_Memory_Leak__new_array_twointsStruct_45.cpp,"    twoIntsStruct * data;
    data = NULL;
    
    data = new twoIntsStruct[100];
    
    data[0].intOne = 0;
    data[0].intTwo = 0;
    printStructLine(&data[0]);
    badData = data;
"
8125,0,CWE190_Integer_Overflow__short_rand_square_62a.cpp,"    short data;
    data = 0;
    badSource(data);
    {
        
        short result = data * data;
        printIntLine(result);
"
15536,0,CWE457_Use_of_Uninitialized_Variable__int64_t_17.c,"    int i,j;
    int64_t data;
    for(i = 0; i < 1; i++)
    {
        
        ; 
    }
    for(j = 0; j < 1; j++)
    {
        
        printLongLongLine(data);
"
7783,0,CWE590_Free_Memory_Not_on_Heap__delete_array_char_declare_51a.cpp,"    char * data;
    data = NULL; 
    {
        
        char dataBuffer[100];
        memset(dataBuffer, 'A', 100-1); 
        dataBuffer[100-1] = '\0'; 
        data = dataBuffer;
    }
"
15630,0,CWE190_Integer_Overflow__short_max_preinc_18.c,"    short data;
    data = 0;
    goto source;
source:
    
    data = SHRT_MAX;
    goto sink;
sink:
    {
        
        ++data;
        short result = data;
        printIntLine(result);
"
13696,0,CWE415_Double_Free__new_delete_int64_t_81a.cpp,"    int64_t * data;
    
    data = NULL;
    data = new int64_t;
    
    delete data;
    const CWE415_Double_Free__new_delete_int64_t_81_base& o = CWE415_Double_Free__new_delete_int64_t_81_bad();
"
2812,0,CWE590_Free_Memory_Not_on_Heap__delete_int_declare_31.cpp,"    int * data;
    data = NULL; 
    {
        
        int dataBuffer;
        dataBuffer = 5;
        data = &dataBuffer;
    }
    {
        int * dataCopy = data;
        int * data = dataCopy;
        printIntLine(*data);
        
        delete data;
"
14041,0,CWE415_Double_Free__new_delete_int_21.cpp,"    int * data;
    
    data = NULL;
    data = new int;
    
    delete data;
    badStatic = 1; 
"
556,0,CWE416_Use_After_Free__malloc_free_int_07.c,"    int * data;
    
    data = NULL;
    if(staticFive==5)
    {
        data = (int *)malloc(100*sizeof(int));
        if (data == NULL) {exit(-1);}
        {
            size_t i;
            for(i = 0; i < 100; i++)
            {
                data[i] = 5;
            }
        }
        
        free(data);
    }
    if(staticFive==5)
    {
        
        printIntLine(data[0]);
        
"
11121,0,CWE197_Numeric_Truncation_Error__int_fgets_to_char_03.c,"    int data;
    
    data = -1;
    if(5==5)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
2583,0,CWE758_Undefined_Behavior__int_pointer_malloc_use_18.c,"    goto sink;
sink:
    {
        int * * pointer = (int * *)malloc(sizeof(int *));
        if (pointer == NULL) {exit(-1);}
        int * data = *pointer; 
        free(pointer);
        printIntLine(*data);
"
1826,0,CWE252_Unchecked_Return_Value__char_putchar_15.c,"    switch(6)
    {
    case 6:
        
        putchar((int)'A');
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
10425,0,CWE401_Memory_Leak__new_array_char_64a.cpp,"    char * data;
    data = NULL;
    
    data = new char[100];
    
    strcpy(data, ""A String"");
    printLine(data);
"
1475,0,CWE415_Double_Free__malloc_free_char_54a.c,"    char * data;
    
    data = NULL;
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    
    free(data);
"
10281,0,CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_04.c,"    unsigned int data;
    data = 0;
    if(STATIC_CONST_TRUE)
    {
        
        fscanf (stdin, ""%u"", &data);
    }
    if(STATIC_CONST_TRUE)
    {
        {
            
            ++data;
            unsigned int result = data;
            printUnsignedLine(result);
        }
"
19179,0,CWE415_Double_Free__new_delete_struct_08.cpp,"    twoIntsStruct * data;
    
    data = NULL;
    if(staticReturnsTrue())
    {
        data = new twoIntsStruct;
        
        delete data;
    }
    if(staticReturnsTrue())
    {
        
        delete data;
"
13429,0,CWE690_NULL_Deref_From_Return__long_malloc_67a.c,"    long * data;
    CWE690_NULL_Deref_From_Return__long_malloc_67_structType myStruct;
    data = NULL; 
    
    data = (long *)malloc(1*sizeof(long));
    myStruct.structFirst = data;
"
450,0,CWE190_Integer_Overflow__short_rand_multiply_11.c,"    short data;
    data = 0;
    if(globalReturnsTrue())
    {
        
        data = (short)RAND32();
    }
    if(globalReturnsTrue())
    {
        if(data > 0) 
        {
            
            short result = data * 2;
            printIntLine(result);
        }
"
16082,1,CWE758_Undefined_Behavior__int64_t_alloca_use_08.c,"    if(staticReturnsFalse())
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            int64_t data;
            int64_t * pointer = (int64_t *)ALLOCA(sizeof(int64_t));
            data = 5LL;
            *pointer = data; 
            {
                int64_t data = *pointer;
                printLongLongLine(data);
            }
        }
"
5336,0,CWE590_Free_Memory_Not_on_Heap__free_long_static_04.c,"    long * data;
    data = NULL; 
    if(STATIC_CONST_TRUE)
    {
        {
            
            static long dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5L;
                }
            }
            data = dataBuffer;
        }
    }
    printLongLine(data[0]);
    
"
3904,1,CWE758_Undefined_Behavior__double_pointer_malloc_use_14.c,"    if(globalFive!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            double * data;
            double * * pointer = (double * *)malloc(sizeof(double *));
            if (pointer == NULL) {exit(-1);}
            
            data = (double *)malloc(sizeof(double));
            if (data == NULL) {exit(-1);}
            *data = 5.0;
            *pointer = data; 
            {
                double * data = *pointer;
                printDoubleLine(*data);
            }
            free(pointer);
        }
"
12254,0,CWE134_Uncontrolled_Format_String__char_file_fprintf_83a.cpp,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
"
16663,0,CWE190_Integer_Overflow__int_fgets_square_83_bad.cpp,"Label Definition File: CWE190_Integer_Overflow__int.label.xml
Template File: sources-sinks-83_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 190 Integer Overflow
 * BadSource: fgets Read data from the console using fgets()
 * GoodSource: Set data to a small, non-zero number (two)
 * Sinks: square
 *    GoodSink: Ensure there will not be an overflow before squaring data
 *    BadSink : Square data, which can lead to overflow
 * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE190_Integer_Overflow__int_fgets_square_83.h""

#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)

#include <math.h>

namespace CWE190_Integer_Overflow__int_fgets_square_83
{
CWE190_Integer_Overflow__int_fgets_square_83_bad::CWE190_Integer_Overflow__int_fgets_square_83_bad(int dataCopy)
{
    data = dataCopy;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
}

CWE190_Integer_Overflow__int_fgets_square_83_bad::~CWE190_Integer_Overflow__int_fgets_square_83_bad()
{
    {
        
        int result = data * data;
        printIntLine(result);
    }
}
}
"
11914,1,CWE758_Undefined_Behavior__long_malloc_use_08.c,"    if(staticReturnsTrue())
    {
        {
            long data;
            long * pointer = (long *)malloc(sizeof(long));
            if (pointer == NULL) {exit(-1);}
            data = 5L;
            *pointer = data; 
            {
                long data = *pointer;
                printLongLine(data);
            }
            free(pointer);
        }
"
147,0,CWE401_Memory_Leak__new_array_char_06.cpp,"    char * data;
    data = NULL;
    if(STATIC_CONST_FIVE==5)
    {
        
        data = new char[100];
        
        strcpy(data, ""A String"");
        printLine(data);
    }
    if(STATIC_CONST_FIVE==5)
    {
        
        ; 
"
2966,0,CWE457_Use_of_Uninitialized_Variable__twointsclass_array_new_no_init_10.cpp,"    TwoIntsClass * data;
    data = new TwoIntsClass[10];
    if(globalTrue)
    {
        
        ; 
    }
    if(globalTrue)
    {
        
        for(int i=0; i<10; i++)
        {
            printIntLine(data[i].intOne);
            printIntLine(data[i].intTwo);
        }
"
4167,0,CWE590_Free_Memory_Not_on_Heap__delete_struct_static_07.cpp,"    twoIntsStruct * data;
    data = NULL; 
    if(staticFive==5)
    {
        {
            
            static twoIntsStruct dataBuffer;
            dataBuffer.intOne = 1;
            dataBuffer.intTwo = 1;
            data = &dataBuffer;
        }
    }
    printStructLine(data);
    
"
12540,0,CWE190_Integer_Overflow__int_connect_socket_multiply_32.c,"    int data;
    int *dataPtr1 = &data;
    int *dataPtr2 = &data;
    
    data = 0;
    {
        int data = *dataPtr1;
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
        *dataPtr1 = data;
    }
    {
        int data = *dataPtr2;
        if(data > 0) 
        {
            
            int result = data * 2;
            printIntLine(result);
        }
"
8247,0,CWE476_NULL_Pointer_Dereference__deref_after_check_14.c,"    if(globalFive==5)
    {
        {
            
            int *intPointer = NULL;
            if (intPointer == NULL)
            {
                printIntLine(*intPointer);
            }
        }
"
9244,0,CWE457_Use_of_Uninitialized_Variable__char_pointer_05.c,"    char * data;
    if(staticTrue)
    {
        
        ; 
    }
    if(staticTrue)
    {
        
        printLine(data);
"
7131,0,CWE190_Integer_Overflow__short_rand_preinc_07.c,"    short data;
    data = 0;
    if(staticFive==5)
    {
        
        data = (short)RAND32();
    }
    if(staticFive==5)
    {
        {
            
            ++data;
            short result = data;
            printIntLine(result);
        }
"
15573,0,CWE190_Integer_Overflow__int_max_multiply_83_bad.cpp,"Label Definition File: CWE190_Integer_Overflow__int.label.xml
Template File: sources-sinks-83_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 190 Integer Overflow
 * BadSource: max Set data to the max value for int
 * GoodSource: Set data to a small, non-zero number (two)
 * Sinks: multiply
 *    GoodSink: Ensure there will not be an overflow before multiplying data by 2
 *    BadSink : If data is positive, multiply by 2, which can cause an overflow
 * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE190_Integer_Overflow__int_max_multiply_83.h""

namespace CWE190_Integer_Overflow__int_max_multiply_83
{
CWE190_Integer_Overflow__int_max_multiply_83_bad::CWE190_Integer_Overflow__int_max_multiply_83_bad(int dataCopy)
{
    data = dataCopy;
    
    data = INT_MAX;
}

CWE190_Integer_Overflow__int_max_multiply_83_bad::~CWE190_Integer_Overflow__int_max_multiply_83_bad()
{
    if(data > 0) 
    {
        
        int result = data * 2;
        printIntLine(result);
    }
}
}
"
4465,0,CWE78_OS_Command_Injection__char_environment_execlp_84a.cpp,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    CWE78_OS_Command_Injection__char_environment_execlp_84_bad * badObject = new CWE78_OS_Command_Injection__char_environment_execlp_84_bad(data);
"
12218,0,CWE78_OS_Command_Injection__char_listen_socket_execl_32.c,"    char * data;
    char * *dataPtr1 = &data;
    char * *dataPtr2 = &data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        char * data = *dataPtr1;
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                data[dataLen + recvResult / sizeof(char)] = '\0';
                
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
        *dataPtr1 = data;
    }
    {
        char * data = *dataPtr2;
        
        
        EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
"
12890,0,CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_22a.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_22_badGlobal = 1; 
"
13737,0,CWE190_Integer_Overflow__int64_t_max_postinc_67a.c,"    int64_t data;
    CWE190_Integer_Overflow__int64_t_max_postinc_67_structType myStruct;
    data = 0LL;
    
    data = LLONG_MAX;
    myStruct.structFirst = data;
"
8346,0,CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_34.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    {
        char * dataCopy = data;
        char * data = dataCopy;
        badVaSink(data, data);
"
1532,0,CWE690_NULL_Deref_From_Return__fopen_43.cpp,"    FILE * data;
    
    data = NULL;
    badSource(data);
    
"
11300,0,CWE190_Integer_Overflow__int_fscanf_multiply_17.c,"    int i,j;
    int data;
    
    data = 0;
    for(i = 0; i < 1; i++)
    {
        
        fscanf(stdin, ""%d"", &data);
    }
    for(j = 0; j < 1; j++)
    {
        if(data > 0) 
        {
            
            int result = data * 2;
            printIntLine(result);
        }
"
7857,0,CWE190_Integer_Overflow__unsigned_int_fscanf_square_32.c,"    unsigned int data;
    unsigned int *dataPtr1 = &data;
    unsigned int *dataPtr2 = &data;
    data = 0;
    {
        unsigned int data = *dataPtr1;
        
        fscanf (stdin, ""%u"", &data);
        *dataPtr1 = data;
    }
    {
        unsigned int data = *dataPtr2;
        {
            
            unsigned int result = data * data;
            printUnsignedLine(result);
        }
"
16908,0,CWE134_Uncontrolled_Format_String__char_environment_vprintf_21.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        
        if (environment != NULL)
        {
            
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    badStatic = 1; 
"
7206,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_41.c,"    size_t data;
    
    data = 0;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = strtoul(inputBuffer, NULL, 0);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
"
7309,1,CWE688_Function_Call_With_Incorrect_Variable_or_Reference_as_Argument__basic_09.c,"    if(GLOBAL_CONST_FALSE)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            char dest[DEST_SIZE];
            int intFive = 5;
            
            sprintf(dest, ""%d"", intFive);
            printLine(dest);
        }
"
5840,1,CWE758_Undefined_Behavior__double_pointer_malloc_use_03.c,"    if(5==5)
    {
        {
            double * data;
            double * * pointer = (double * *)malloc(sizeof(double *));
            if (pointer == NULL) {exit(-1);}
            
            data = (double *)malloc(sizeof(double));
            if (data == NULL) {exit(-1);}
            *data = 5.0;
            *pointer = data; 
            {
                double * data = *pointer;
                printDoubleLine(*data);
            }
            free(pointer);
        }
"
202,0,CWE78_OS_Command_Injection__char_environment_execl_04.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(STATIC_CONST_TRUE)
    {
        {
            
            size_t dataLen = strlen(data);
            char * environment = GETENV(ENV_VARIABLE);
            
            if (environment != NULL)
            {
                
                strncat(data+dataLen, environment, 100-dataLen-1);
            }
        }
    }
    
    
"
216,0,CWE590_Free_Memory_Not_on_Heap__delete_struct_declare_52a.cpp,"    twoIntsStruct * data;
    data = NULL; 
    {
        
        twoIntsStruct dataBuffer;
        dataBuffer.intOne = 1;
        dataBuffer.intTwo = 1;
        data = &dataBuffer;
    }
"
12240,0,CWE401_Memory_Leak__new_TwoIntsClass_01.cpp,"    TwoIntsClass * data;
    data = NULL;
    
    data = new TwoIntsClass;
    
    data->intOne = 0;
    data->intTwo = 0;
    printIntLine(data->intOne);
    printIntLine(data->intTwo);
    
"
5402,0,CWE590_Free_Memory_Not_on_Heap__delete_long_alloca_14.cpp,"    long * data;
    data = NULL; 
    if(globalFive==5)
    {
        {
            
            long * dataBuffer = (long *)ALLOCA(sizeof(long));
            *dataBuffer = 5L;
            data = dataBuffer;
        }
    }
    printLongLine(*data);
    
"
11256,0,CWE590_Free_Memory_Not_on_Heap__free_struct_declare_82_bad.cpp,"Label Definition File: CWE590_Free_Memory_Not_on_Heap__free.label.xml
Template File: sources-sink-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 590 Free Memory Not on Heap
 * BadSource: declare Data buffer is declared on the stack
 * GoodSource: Allocate memory on the heap
 * Sinks:
 *    BadSink : Print then free data
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE590_Free_Memory_Not_on_Heap__free_struct_declare_82.h""

namespace CWE590_Free_Memory_Not_on_Heap__free_struct_declare_82
{

void CWE590_Free_Memory_Not_on_Heap__free_struct_declare_82_bad::action(twoIntsStruct * data)
{
    printStructLine(&data[0]);
    
    free(data);
}

}
"
2878,0,CWE369_Divide_by_Zero__int_fscanf_modulo_16.c,"    int data;
    
    data = -1;
    while(1)
    {
        
        fscanf(stdin, ""%d"", &data);
        break;
    }
    while(1)
    {
        
        printIntLine(100 % data);
        break;
"
2711,0,CWE690_NULL_Deref_From_Return__struct_calloc_31.c,"    twoIntsStruct * data;
    data = NULL; 
    
    data = (twoIntsStruct *)calloc(1, sizeof(twoIntsStruct));
    {
        twoIntsStruct * dataCopy = data;
        twoIntsStruct * data = dataCopy;
        
        data[0].intOne = 1;
        data[0].intTwo = 1;
        printStructLine(&data[0]);
        free(data);
"
2296,0,CWE134_Uncontrolled_Format_String__char_environment_vfprintf_68a.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        
        if (environment != NULL)
        {
            
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    CWE134_Uncontrolled_Format_String__char_environment_vfprintf_68_badData = data;
"
396,0,CWE190_Integer_Overflow__char_fscanf_preinc_31.c,"    char data;
    data = ' ';
    
    fscanf (stdin, ""%c"", &data);
    {
        char dataCopy = data;
        char data = dataCopy;
        {
            
            ++data;
            char result = data;
            printHexCharLine(result);
        }
"
11385,0,CWE415_Double_Free__malloc_free_char_44.c,"    char * data;
    
    void (*funcPtr) (char *) = badSink;
    
    data = NULL;
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    
    free(data);
    
"
3696,0,CWE134_Uncontrolled_Format_String__char_console_snprintf_84_bad.cpp,"Label Definition File: CWE134_Uncontrolled_Format_String.label.xml
Template File: sources-sinks-84_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 134 Uncontrolled Format String
 * BadSource: console Read input from the console
 * GoodSource: Copy a fixed string into data
 * Sinks: snprintf
 *    GoodSink: snprintf with ""%s"" as the third argument and data as the fourth
 *    BadSink : snprintf with data as the third argument
 * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE134_Uncontrolled_Format_String__char_console_snprintf_84.h""

#ifdef _WIN32
#define SNPRINTF _snprintf
#else
#define SNPRINTF snprintf
#endif

namespace CWE134_Uncontrolled_Format_String__char_console_snprintf_84
{
CWE134_Uncontrolled_Format_String__char_console_snprintf_84_bad::CWE134_Uncontrolled_Format_String__char_console_snprintf_84_bad(char * dataCopy)
{
    data = dataCopy;
    {
        
        size_t dataLen = strlen(data);
        
        if (100-dataLen > 1)
        {
            
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgets() */
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
                    data[dataLen-1] = '\0';
                }
            }
            else
            {
                printLine(""fgets() failed"");
                
                data[dataLen] = '\0';
            }
        }
    }
}

CWE134_Uncontrolled_Format_String__char_console_snprintf_84_bad::~CWE134_Uncontrolled_Format_String__char_console_snprintf_84_bad()
{
    {
        char dest[100] = """";
        
        SNPRINTF(dest, 100-1, data);
        printLine(dest);
    }
}
}
"
7606,1,CWE587_Assignment_of_Fixed_Address_to_Pointer__basic_06.c,"    if(STATIC_CONST_FIVE!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            
            char charStack = 'a';
            char *charPointer = &charStack;
            printHexCharLine(*charPointer);
        }
"
17654,0,CWE134_Uncontrolled_Format_String__char_listen_socket_printf_04.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(STATIC_CONST_TRUE)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                data[dataLen + recvResult / sizeof(char)] = '\0';
                
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(STATIC_CONST_TRUE)
    {
        
        printf(data);
"
11903,0,CWE590_Free_Memory_Not_on_Heap__delete_int_alloca_68a.cpp,"    int * data;
    data = NULL; 
    {
        
        int * dataBuffer = (int *)ALLOCA(sizeof(int));
        *dataBuffer = 5;
        data = dataBuffer;
    }
    CWE590_Free_Memory_Not_on_Heap__delete_int_alloca_68_badData = data;
"
6183,1,CWE758_Undefined_Behavior__char_new_use_11.cpp,"    if(globalReturnsTrue())
    {
        {
            char data;
            data = 5;
            char * pointer = new char;
            *pointer = data; 
            {
                char data = *pointer;
                printHexCharLine(data);
            }
            delete pointer;
        }
"
9707,0,CWE369_Divide_by_Zero__int_fgets_modulo_83a.cpp,"    int data;
    
    data = -1;
"
13252,0,CWE197_Numeric_Truncation_Error__int_large_to_char_10.c,"    int data;
    
    data = -1;
    if(globalTrue)
    {
        
        data = SHRT_MAX + 5;
    }
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
1358,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_53a.c,"    size_t data;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = strtoul(inputBuffer, NULL, 0);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
13722,0,CWE197_Numeric_Truncation_Error__int_fgets_to_short_03.c,"    int data;
    
    data = -1;
    if(5==5)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    {
        
        short shortData = (short)data;
        printShortLine(shortData);
"
18128,0,CWE197_Numeric_Truncation_Error__int_large_to_char_07.c,"    int data;
    
    data = -1;
    if(staticFive==5)
    {
        
        data = SHRT_MAX + 5;
    }
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
7476,0,CWE590_Free_Memory_Not_on_Heap__delete_char_declare_03.cpp,"    char * data;
    data = NULL; 
    if(5==5)
    {
        {
            
            char dataBuffer;
            dataBuffer = 'A';
            data = &dataBuffer;
        }
    }
    printHexCharLine(*data);
    
"
6490,0,CWE369_Divide_by_Zero__int_fgets_divide_32.c,"    int data;
    int *dataPtr1 = &data;
    int *dataPtr2 = &data;
    
    data = -1;
    {
        int data = *dataPtr1;
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
        *dataPtr1 = data;
    }
    {
        int data = *dataPtr2;
        
        printIntLine(100 / data);
"
2336,0,CWE401_Memory_Leak__new_char_81_bad.cpp,"Label Definition File: CWE401_Memory_Leak__new.label.xml
Template File: sources-sinks-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 401 Memory Leak
 * BadSource:  Allocate data using new
 * GoodSource: Allocate data on the stack
 * Sinks:
 *    GoodSink: call delete on data
 *    BadSink : no deallocation of data
 * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE401_Memory_Leak__new_char_81.h""

namespace CWE401_Memory_Leak__new_char_81
{

void CWE401_Memory_Leak__new_char_81_bad::action(char * data) const
{
    
    ; 
}

}
"
7437,0,CWE416_Use_After_Free__malloc_free_char_04.c,"    char * data;
    
    data = NULL;
    if(STATIC_CONST_TRUE)
    {
        data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        memset(data, 'A', 100-1);
        data[100-1] = '\0';
        
        free(data);
    }
    if(STATIC_CONST_TRUE)
    {
        
        printLine(data);
        
"
3340,0,CWE401_Memory_Leak__new_int64_t_34.cpp,"    int64_t * data;
    unionType myUnion;
    data = NULL;
    
    data = new int64_t;
    
    *data = 5LL;
    printLongLongLine(*data);
    myUnion.unionFirst = data;
    {
        int64_t * data = myUnion.unionSecond;
        
        ; 
"
3851,0,CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_02.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(1)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET connectSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                
                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                data[dataLen + recvResult / sizeof(char)] = '\0';
                
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(1)
    {
        badVaSinkB(data, data);
"
10511,0,CWE190_Integer_Overflow__int_connect_socket_multiply_33.cpp,"    int data;
    int &dataRef = data;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    {
        int data = dataRef;
        if(data > 0) 
        {
            
            int result = data * 2;
            printIntLine(result);
        }
"
10864,0,CWE190_Integer_Overflow__short_fscanf_square_22a.c,"    short data;
    data = 0;
    
    fscanf (stdin, ""%hd"", &data);
    CWE190_Integer_Overflow__short_fscanf_square_22_badGlobal = 1; 
"
5711,1,CWE758_Undefined_Behavior__class_new_use_14.cpp,"    if(globalFive==5)
    {
        {
            TwoIntsClass data;
            data.intOne = 1;
            data.intTwo = 2;
            TwoIntsClass * pointer = new TwoIntsClass;
            *pointer = data; 
            {
                TwoIntsClass data = *pointer;
                printIntLine(data.intOne);
                printIntLine(data.intTwo);
            }
            delete pointer;
        }
"
6934,0,CWE401_Memory_Leak__char_malloc_65a.c,"    char * data;
    
    void (*funcPtr) (char *) = CWE401_Memory_Leak__char_malloc_65b_badSink;
    data = NULL;
    
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    
    strcpy(data, ""A String"");
    printLine(data);
    
"
18451,0,CWE190_Integer_Overflow__unsigned_int_fscanf_add_17.c,"    int i,j;
    unsigned int data;
    data = 0;
    for(i = 0; i < 1; i++)
    {
        
        fscanf (stdin, ""%u"", &data);
    }
    for(j = 0; j < 1; j++)
    {
        {
            
            unsigned int result = data + 1;
            printUnsignedLine(result);
        }
"
18573,0,CWE416_Use_After_Free__new_delete_array_char_08.cpp,"    char * data;
    
    data = NULL;
    if(staticReturnsTrue())
    {
        data = new char[100];
        memset(data, 'A', 100-1);
        data[100-1] = '\0';
        
        delete [] data;
    }
    if(staticReturnsTrue())
    {
        
        printLine(data);
        
"
14946,0,CWE252_Unchecked_Return_Value__char_fprintf_13.c,"    if(GLOBAL_CONST_FIVE==5)
    {
        
        fprintf(stdout, ""%s\n"", ""string"");
"
17364,0,CWE401_Memory_Leak__malloc_realloc_struct_twoIntsStruct_04.c,"    if(STATIC_CONST_TRUE)
    {
        {
            struct _twoIntsStruct * data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));
            if (data == NULL) {exit(-1);}
            
            data[0].intOne = 0;
            data[0].intTwo = 0;
            printStructLine((twoIntsStruct *)&data[0]);
            
            data = (struct _twoIntsStruct *)realloc(data, (130000)*sizeof(struct _twoIntsStruct));
            if (data != NULL)
            {
                
                data[0].intOne = 1;
                data[0].intTwo = 1;
                printStructLine((twoIntsStruct *)&data[0]);
                free(data);
            }
        }
"
9969,0,CWE590_Free_Memory_Not_on_Heap__delete_int64_t_declare_13.cpp,"    int64_t * data;
    data = NULL; 
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            
            int64_t dataBuffer;
            dataBuffer = 5LL;
            data = &dataBuffer;
        }
    }
    printLongLongLine(*data);
    
"
11818,0,CWE134_Uncontrolled_Format_String__char_console_vprintf_04.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(STATIC_CONST_TRUE)
    {
        {
            
            size_t dataLen = strlen(data);
            
            if (100-dataLen > 1)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
                {
                    /* The next few lines remove the carriage return from the string that is
                     * inserted by fgets() */
                    dataLen = strlen(data);
                    if (dataLen > 0 && data[dataLen-1] == '\n')
                    {
                        data[dataLen-1] = '\0';
                    }
                }
                else
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
            }
        }
    }
    if(STATIC_CONST_TRUE)
    {
        badVaSinkB(data, data);
"
5589,0,CWE190_Integer_Overflow__int_fscanf_add_18.c,"    int data;
    
    data = 0;
    goto source;
source:
    
    fscanf(stdin, ""%d"", &data);
    goto sink;
sink:
    {
        
        int result = data + 1;
        printIntLine(result);
"
8035,0,CWE690_NULL_Deref_From_Return__int64_t_malloc_73a.cpp,"    int64_t * data;
    list<int64_t *> dataList;
    data = NULL; 
    
    data = (int64_t *)malloc(1*sizeof(int64_t));
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
3110,0,CWE416_Use_After_Free__new_delete_array_int64_t_10.cpp,"    int64_t * data;
    
    data = NULL;
    if(globalTrue)
    {
        data = new int64_t[100];
        {
            size_t i;
            for(i = 0; i < 100; i++)
            {
                data[i] = 5LL;
            }
        }
        
        delete [] data;
    }
    if(globalTrue)
    {
        
        printLongLongLine(data[0]);
        
"
3548,0,CWE190_Integer_Overflow__char_rand_square_08.c,"    char data;
    data = ' ';
    if(staticReturnsTrue())
    {
        
        data = (char)RAND32();
    }
    if(staticReturnsTrue())
    {
        {
            
            char result = data * data;
            printHexCharLine(result);
        }
"
10628,0,CWE190_Integer_Overflow__char_max_multiply_42.c,"    char data;
    data = ' ';
    data = badSource(data);
    if(data > 0) 
    {
        
        char result = data * 2;
        printHexCharLine(result);
"
11205,0,CWE134_Uncontrolled_Format_String__char_environment_printf_65a.c,"    char * data;
    
    void (*funcPtr) (char *) = CWE134_Uncontrolled_Format_String__char_environment_printf_65b_badSink;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        
        if (environment != NULL)
        {
            
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    
"
2844,0,CWE789_Uncontrolled_Mem_Alloc__new_char_rand_84a.cpp,"    size_t data;
    
    data = 0;
    CWE789_Uncontrolled_Mem_Alloc__new_char_rand_84_bad * badObject = new CWE789_Uncontrolled_Mem_Alloc__new_char_rand_84_bad(data);
"
2413,0,CWE457_Use_of_Uninitialized_Variable__struct_array_declare_partial_init_43.cpp,"    twoIntsStruct * data;
    twoIntsStruct dataUninitArray[10];
    data = dataUninitArray;
    badSource(data);
    
    {
        int i;
        for(i=0; i<10; i++)
        {
            printIntLine(data[i].intOne);
            printIntLine(data[i].intTwo);
        }
"
3078,0,CWE590_Free_Memory_Not_on_Heap__free_char_static_02.c,"    char * data;
    data = NULL; 
    if(1)
    {
        {
            
            static char dataBuffer[100];
            memset(dataBuffer, 'A', 100-1); 
            dataBuffer[100-1] = '\0'; 
            data = dataBuffer;
        }
    }
    printLine(data);
    
"
11517,0,CWE190_Integer_Overflow__char_max_square_43.cpp,"    char data;
    data = ' ';
    badSource(data);
    {
        
        char result = data * data;
        printHexCharLine(result);
"
6864,0,CWE190_Integer_Overflow__short_rand_multiply_81_bad.cpp,"Label Definition File: CWE190_Integer_Overflow.label.xml
Template File: sources-sinks-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 190 Integer Overflow
 * BadSource: rand Set data to result of rand()
 * GoodSource: Set data to a small, non-zero number (two)
 * Sinks: multiply
 *    GoodSink: Ensure there will not be an overflow before multiplying data by 2
 *    BadSink : If data is positive, multiply by 2, which can cause an overflow
 * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE190_Integer_Overflow__short_rand_multiply_81.h""

namespace CWE190_Integer_Overflow__short_rand_multiply_81
{

void CWE190_Integer_Overflow__short_rand_multiply_81_bad::action(short data) const
{
    if(data > 0) 
    {
        
        short result = data * 2;
        printIntLine(result);
    }
}

}
"
19154,0,CWE457_Use_of_Uninitialized_Variable__long_15.c,"    long data;
    switch(6)
    {
    case 6:
        
        ; 
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
        
        printLongLine(data);
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
9576,0,CWE590_Free_Memory_Not_on_Heap__delete_long_declare_64a.cpp,"    long * data;
    data = NULL; 
    {
        
        long dataBuffer;
        dataBuffer = 5L;
        data = &dataBuffer;
    }
"
17359,0,CWE590_Free_Memory_Not_on_Heap__free_char_static_07.c,"    char * data;
    data = NULL; 
    if(staticFive==5)
    {
        {
            
            static char dataBuffer[100];
            memset(dataBuffer, 'A', 100-1); 
            dataBuffer[100-1] = '\0'; 
            data = dataBuffer;
        }
    }
    printLine(data);
    
"
17115,0,CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_33.cpp,"    int data;
    int &dataRef = data;
    
    data = -1;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    {
        int data = dataRef;
        {
            
            char charData = (char)data;
            printHexCharLine(charData);
        }
"
5476,0,CWE190_Integer_Overflow__int_rand_add_74a.cpp,"    int data;
    map<int, int> dataMap;
    
    data = 0;
    
    data = RAND32();
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
943,0,CWE476_NULL_Pointer_Dereference__int_32.c,"    int * data;
    int * *dataPtr1 = &data;
    int * *dataPtr2 = &data;
    {
        int * data = *dataPtr1;
        
        data = NULL;
        *dataPtr1 = data;
    }
    {
        int * data = *dataPtr2;
        
        printIntLine(*data);
"
283,0,CWE590_Free_Memory_Not_on_Heap__delete_char_alloca_33.cpp,"    char * data;
    char * &dataRef = data;
    data = NULL; 
    {
        
        char * dataBuffer = (char *)ALLOCA(sizeof(char));
        *dataBuffer = 'A';
        data = dataBuffer;
    }
    {
        char * data = dataRef;
        printHexCharLine(*data);
        
        delete data;
"
12363,0,CWE252_Unchecked_Return_Value__char_rename_09.c,"    if(GLOBAL_CONST_TRUE)
    {
        
        RENAME(OLD_BAD_FILE_NAME, ""newbadfilename.txt"");
"
10891,0,CWE78_OS_Command_Injection__char_listen_socket_popen_11.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(globalReturnsTrue())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                data[dataLen + recvResult / sizeof(char)] = '\0';
                
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    {
        FILE *pipe;
        
        pipe = POPEN(data, ""w"");
        if (pipe != NULL)
        {
            PCLOSE(pipe);
        }
"
344,0,CWE758_Undefined_Behavior__int_pointer_new_use_14.cpp,"    if(globalFive==5)
    {
        {
            int * * pointer = new int *;
            int * data = *pointer; 
            delete pointer;
            printIntLine(*data);
        }
"
696,0,CWE590_Free_Memory_Not_on_Heap__delete_long_static_81_bad.cpp,"Label Definition File: CWE590_Free_Memory_Not_on_Heap__delete.nonpointer.label.xml
Template File: sources-sink-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 590 Free Memory Not on Heap
 * BadSource: static Data buffer is declared static on the stack
 * GoodSource: Allocate memory on the heap
 * Sinks:
 *    BadSink : Print then free data
 * Flow Variant: 81 Data flow: data passed in a parameter to a virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE590_Free_Memory_Not_on_Heap__delete_long_static_81.h""

namespace CWE590_Free_Memory_Not_on_Heap__delete_long_static_81
{

void CWE590_Free_Memory_Not_on_Heap__delete_long_static_81_bad::action(long * data) const
{
    printLongLine(*data);
    
    delete data;
}

}
"
12566,0,CWE190_Integer_Overflow__char_max_postinc_41.c,"    char data;
    data = ' ';
    
    data = CHAR_MAX;
"
2000,0,CWE78_OS_Command_Injection__char_environment_popen_52a.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
        
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        
        if (environment != NULL)
        {
            
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
"
2849,0,CWE590_Free_Memory_Not_on_Heap__delete_array_class_static_67a.cpp,"    TwoIntsClass * data;
    structType myStruct;
    data = NULL; 
    {
        
        static TwoIntsClass dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i].intOne = 1;
                dataBuffer[i].intTwo = 1;
            }
        }
        data = dataBuffer;
    }
    myStruct.structFirst = data;
"
7951,0,CWE401_Memory_Leak__int64_t_realloc_08.c,"    int64_t * data;
    data = NULL;
    if(staticReturnsTrue())
    {
        
        data = (int64_t *)realloc(data, 100*sizeof(int64_t));
        if (data == NULL) {exit(-1);}
        
        data[0] = 5LL;
        printLongLongLine(data[0]);
    }
    if(staticReturnsTrue())
    {
        
        ; 
"
6060,0,CWE190_Integer_Overflow__char_fscanf_preinc_04.c,"    char data;
    data = ' ';
    if(STATIC_CONST_TRUE)
    {
        
        fscanf (stdin, ""%c"", &data);
    }
    if(STATIC_CONST_TRUE)
    {
        {
            
            ++data;
            char result = data;
            printHexCharLine(result);
        }
"
15668,0,CWE190_Integer_Overflow__int64_t_fscanf_add_63a.c,"    int64_t data;
    data = 0LL;
    
    fscanf (stdin, ""%"" SCNd64, &data);
"
10729,0,CWE590_Free_Memory_Not_on_Heap__delete_int_alloca_81a.cpp,"    int * data;
    data = NULL; 
    {
        
        int * dataBuffer = (int *)ALLOCA(sizeof(int));
        *dataBuffer = 5;
        data = dataBuffer;
    }
    const CWE590_Free_Memory_Not_on_Heap__delete_int_alloca_81_base& baseObject = CWE590_Free_Memory_Not_on_Heap__delete_int_alloca_81_bad();
"
7583,0,CWE758_Undefined_Behavior__struct_pointer_alloca_use_02.c,"    if(1)
    {
        {
            twoIntsStruct * * pointer = (twoIntsStruct * *)ALLOCA(sizeof(twoIntsStruct *));
            twoIntsStruct * data = *pointer; 
            printIntLine(data->intOne);
            printIntLine(data->intTwo);
        }
"
16072,0,CWE590_Free_Memory_Not_on_Heap__delete_array_struct_declare_12.cpp,"    twoIntsStruct * data;
    data = NULL; 
    if(globalReturnsTrueOrFalse())
    {
        {
            
            twoIntsStruct dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i].intOne = 1;
                    dataBuffer[i].intTwo = 1;
                }
            }
            data = dataBuffer;
        }
    }
    else
    {
        {
            
            twoIntsStruct * dataBuffer = new twoIntsStruct[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i].intOne = 1;
                    dataBuffer[i].intTwo = 1;
                }
            }
            data = dataBuffer;
        }
    }
    printStructLine(&data[0]);
    
"
7696,0,CWE590_Free_Memory_Not_on_Heap__delete_long_placement_new_14.cpp,"    long * data;
    data = NULL; 
    if(globalFive==5)
    {
        {
            
            char buffer[sizeof(long)];
            long * dataBuffer = new(buffer) long;
            *dataBuffer = 5L;
            data = dataBuffer;
        }
    }
    printLongLine(*data);
    
"
16264,1,CWE758_Undefined_Behavior__int64_t_malloc_use_15.c,"    switch(6)
    {
    case 6:
    {
        int64_t data;
        int64_t * pointer = (int64_t *)malloc(sizeof(int64_t));
        if (pointer == NULL) {exit(-1);}
        data = 5LL;
        *pointer = data; 
        {
            int64_t data = *pointer;
            printLongLongLine(data);
        }
        free(pointer);
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
240,0,CWE690_NULL_Deref_From_Return__int64_t_realloc_08.c,"    int64_t * data;
    data = NULL; 
    
    data = (int64_t *)realloc(data, 1*sizeof(int64_t));
    if(staticReturnsTrue())
    {
        
        data[0] = 5LL;
        printLongLongLine(data[0]);
        free(data);
"
3266,0,CWE563_Unused_Variable__unused_value_int_13.c,"    int data;
    if(GLOBAL_CONST_FIVE==5)
    {
        
        data = 5;
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        
        data = 10;
        printIntLine(data);
"
18,0,CWE190_Integer_Overflow__short_max_add_01.c,"    short data;
    data = 0;
    
    data = SHRT_MAX;
    {
        
        short result = data + 1;
        printIntLine(result);
"
4170,0,CWE789_Uncontrolled_Mem_Alloc__new_char_connect_socket_04.cpp,"    size_t data;
    
    data = 0;
    if(STATIC_CONST_TRUE)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = strtoul(inputBuffer, NULL, 0);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(STATIC_CONST_TRUE)
    {
        {
            char * myString;
            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
             * for the strcpy() function to not cause a buffer overflow */
            
            if (data > strlen(HELLO_STRING))
            {
                myString = new char[data];
                
                strcpy(myString, HELLO_STRING);
                printLine(myString);
                delete [] myString;
            }
            else
            {
                printLine(""Input is less than the length of the source string"");
            }
        }
"
12987,0,CWE563_Unused_Variable__unused_value_struct_11.c,"    twoIntsStruct data;
    if(globalReturnsTrue())
    {
        
        data.intOne = 0;
        data.intTwo = 0;
    }
    if(globalReturnsTrue())
    {
        
        data.intOne = 1;
        data.intTwo = 1;
        printStructLine(&data);
"
4926,0,CWE197_Numeric_Truncation_Error__int_fscanf_to_char_01.c,"    int data;
    
    data = -1;
    
    fscanf(stdin, ""%d"", &data);
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
7406,0,CWE190_Integer_Overflow__short_rand_square_13.c,"    short data;
    data = 0;
    if(GLOBAL_CONST_FIVE==5)
    {
        
        data = (short)RAND32();
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            
            short result = data * data;
            printIntLine(result);
        }
"
13900,0,CWE690_NULL_Deref_From_Return__long_malloc_34.c,"    long * data;
    CWE690_NULL_Deref_From_Return__long_malloc_34_unionType myUnion;
    data = NULL; 
    
    data = (long *)malloc(1*sizeof(long));
    myUnion.unionFirst = data;
    {
        long * data = myUnion.unionSecond;
        
        data[0] = 5L;
        printLongLine(data[0]);
        free(data);
"
1135,0,CWE690_NULL_Deref_From_Return__int64_t_malloc_42.c,"    int64_t * data;
    data = NULL; 
    data = badSource(data);
    
    data[0] = 5LL;
    printLongLongLine(data[0]);
"
18137,1,CWE401_Memory_Leak__malloc_realloc_twoIntsStruct_09.c,"    if(GLOBAL_CONST_TRUE)
    {
        {
            twoIntsStruct * data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
            if (data == NULL) {exit(-1);}
            twoIntsStruct * tmpData;
            
            data[0].intOne = 0;
            data[0].intTwo = 0;
            printStructLine(&data[0]);
            tmpData = (twoIntsStruct *)realloc(data, (130000)*sizeof(twoIntsStruct));
            /* FIX: Ensure realloc() was successful before assigning data to the memory block
            * allocated with realloc() */
            if (tmpData != NULL)
            {
                data = tmpData;
                
                data[0].intOne = 1;
                data[0].intTwo = 1;
                printStructLine(&data[0]);
            }
            free(data);
        }
"
900,0,CWE190_Integer_Overflow__short_max_preinc_09.c,"    short data;
    data = 0;
    if(GLOBAL_CONST_TRUE)
    {
        
        data = SHRT_MAX;
    }
    if(GLOBAL_CONST_TRUE)
    {
        {
            
            ++data;
            short result = data;
            printIntLine(result);
        }
"
17979,1,CWE758_Undefined_Behavior__struct_alloca_use_04.c,"    if(STATIC_CONST_TRUE)
    {
        {
            twoIntsStruct data;
            twoIntsStruct * pointer = (twoIntsStruct *)ALLOCA(sizeof(twoIntsStruct));
            data.intOne = 1;
            data.intTwo = 2;
            *pointer = data; 
            {
                twoIntsStruct data = *pointer;
                printIntLine(data.intOne);
                printIntLine(data.intTwo);
            }
        }
"
13402,0,CWE190_Integer_Overflow__int_listen_socket_square_83_bad.cpp,"Label Definition File: CWE190_Integer_Overflow__int.label.xml
Template File: sources-sinks-83_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 190 Integer Overflow
 * BadSource: listen_socket Read data using a listen socket (server side)
 * GoodSource: Set data to a small, non-zero number (two)
 * Sinks: square
 *    GoodSink: Ensure there will not be an overflow before squaring data
 *    BadSink : Square data, which can lead to overflow
 * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE190_Integer_Overflow__int_listen_socket_square_83.h""

#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif

#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)

#include <math.h>

namespace CWE190_Integer_Overflow__int_listen_socket_square_83
{
CWE190_Integer_Overflow__int_listen_socket_square_83_bad::CWE190_Integer_Overflow__int_listen_socket_square_83_bad(int dataCopy)
{
    data = dataCopy;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
}

CWE190_Integer_Overflow__int_listen_socket_square_83_bad::~CWE190_Integer_Overflow__int_listen_socket_square_83_bad()
{
    {
        
        int result = data * data;
        printIntLine(result);
    }
}
}
"
6435,0,CWE401_Memory_Leak__twoIntsStruct_calloc_07.c,"    twoIntsStruct * data;
    data = NULL;
    if(staticFive==5)
    {
        
        data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));
        if (data == NULL) {exit(-1);}
        
        data[0].intOne = 0;
        data[0].intTwo = 0;
        printStructLine(&data[0]);
    }
    if(staticFive==5)
    {
        
        ; 
"
10957,0,CWE190_Integer_Overflow__int_listen_socket_square_45.c,"    int data;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    CWE190_Integer_Overflow__int_listen_socket_square_45_badData = data;
"
11008,0,CWE134_Uncontrolled_Format_String__char_file_vfprintf_68a.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        FILE * pFile;
        
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
    CWE134_Uncontrolled_Format_String__char_file_vfprintf_68_badData = data;
"
10944,0,CWE190_Integer_Overflow__short_fscanf_preinc_02.c,"    short data;
    data = 0;
    if(1)
    {
        
        fscanf (stdin, ""%hd"", &data);
    }
    if(1)
    {
        {
            
            ++data;
            short result = data;
            printIntLine(result);
        }
"
11886,0,CWE401_Memory_Leak__int64_t_malloc_32.c,"    int64_t * data;
    int64_t * *dataPtr1 = &data;
    int64_t * *dataPtr2 = &data;
    data = NULL;
    {
        int64_t * data = *dataPtr1;
        
        data = (int64_t *)malloc(100*sizeof(int64_t));
        if (data == NULL) {exit(-1);}
        
        data[0] = 5LL;
        printLongLongLine(data[0]);
        *dataPtr1 = data;
    }
    {
        int64_t * data = *dataPtr2;
        
        ; 
"
1018,0,CWE457_Use_of_Uninitialized_Variable__struct_pointer_64a.c,"    twoIntsStruct * data;
    
    ; 
"
3383,0,CWE415_Double_Free__malloc_free_int_13.c,"    int * data;
    
    data = NULL;
    if(GLOBAL_CONST_FIVE==5)
    {
        data = (int *)malloc(100*sizeof(int));
        if (data == NULL) {exit(-1);}
        
        free(data);
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        
        free(data);
"
9855,0,CWE758_Undefined_Behavior__char_alloca_use_14.c,"    if(globalFive==5)
    {
        {
            char * pointer = (char *)ALLOCA(sizeof(char));
            char data = *pointer; 
            printHexCharLine(data);
        }
"
16384,0,CWE252_Unchecked_Return_Value__char_snprintf_14.c,"    if(globalFive==5)
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            
            SNPRINTF(data,100-strlen(SRC)-1, ""%s\n"", SRC);
        }
"
17900,0,CWE590_Free_Memory_Not_on_Heap__free_struct_alloca_51a.c,"    twoIntsStruct * data;
    data = NULL; 
    {
        
        twoIntsStruct * dataBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i].intOne = 1;
                dataBuffer[i].intTwo = 1;
            }
        }
        data = dataBuffer;
    }
"
8800,1,CWE416_Use_After_Free__return_freed_ptr_12.c,"    if(globalReturnsTrueOrFalse())
    {
        {
            
            char * reversedString = helperGood(""GoodSink"");
            printLine(reversedString);
            /* free(reversedString);
             * This call to free() was removed because we want the tool to detect the use after free,
             * but we don't want that function to be free(). Essentially we want to avoid a double free
             */
        }
    }
    else
    {
        {
            
            char * reversedString = helperGood(""GoodSink"");
            printLine(reversedString);
            /* free(reversedString);
             * This call to free() was removed because we want the tool to detect the use after free,
             * but we don't want that function to be free(). Essentially we want to avoid a double free
             */
        }
"
5858,0,CWE197_Numeric_Truncation_Error__int_fscanf_to_short_44.c,"    int data;
    
    void (*funcPtr) (int) = badSink;
    
    data = -1;
    
    fscanf(stdin, ""%d"", &data);
    
"
8013,0,CWE78_OS_Command_Injection__char_file_system_52a.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
        
        size_t dataLen = strlen(data);
        FILE * pFile;
        
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
"
6260,0,CWE369_Divide_by_Zero__int_rand_modulo_64a.c,"    int data;
    
    data = -1;
    
    data = RAND32();
"
3005,0,CWE416_Use_After_Free__new_delete_array_long_43.cpp,"    long * data;
    
    data = NULL;
    badSource(data);
    
    printLongLine(data[0]);
"
8263,0,CWE190_Integer_Overflow__int_listen_socket_square_82a.cpp,"    int data;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    CWE190_Integer_Overflow__int_listen_socket_square_82_base* baseObject = new CWE190_Integer_Overflow__int_listen_socket_square_82_bad;
    baseObject->action(data);
"
1355,0,CWE416_Use_After_Free__new_delete_char_10.cpp,"    char * data;
    
    data = NULL;
    if(globalTrue)
    {
        data = new char;
        *data = 'A';
        
        delete data;
    }
    if(globalTrue)
    {
        
        printHexCharLine(*data);
        
"
10551,0,CWE590_Free_Memory_Not_on_Heap__free_struct_declare_32.c,"    twoIntsStruct * data;
    twoIntsStruct * *dataPtr1 = &data;
    twoIntsStruct * *dataPtr2 = &data;
    data = NULL; 
    {
        twoIntsStruct * data = *dataPtr1;
        {
            
            twoIntsStruct dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i].intOne = 1;
                    dataBuffer[i].intTwo = 1;
                }
            }
            data = dataBuffer;
        }
        *dataPtr1 = data;
    }
    {
        twoIntsStruct * data = *dataPtr2;
        printStructLine(&data[0]);
        
        free(data);
"
5082,0,CWE190_Integer_Overflow__char_rand_multiply_65a.c,"    char data;
    
    void (*funcPtr) (char) = CWE190_Integer_Overflow__char_rand_multiply_65b_badSink;
    data = ' ';
    
    data = (char)RAND32();
    
"
15732,0,CWE401_Memory_Leak__char_calloc_08.c,"    char * data;
    data = NULL;
    if(staticReturnsTrue())
    {
        
        data = (char *)calloc(100, sizeof(char));
        if (data == NULL) {exit(-1);}
        
        strcpy(data, ""A String"");
        printLine(data);
    }
    if(staticReturnsTrue())
    {
        
        ; 
"
11471,0,CWE190_Integer_Overflow__short_fscanf_multiply_06.c,"    short data;
    data = 0;
    if(STATIC_CONST_FIVE==5)
    {
        
        fscanf (stdin, ""%hd"", &data);
    }
    if(STATIC_CONST_FIVE==5)
    {
        if(data > 0) 
        {
            
            short result = data * 2;
            printIntLine(result);
        }
"
11399,1,CWE467_Use_of_sizeof_on_Pointer_Type__int_15.c,"    switch(6)
    {
    case 6:
    {
        int * goodInt = NULL;
        
        goodInt = (int *)malloc(sizeof(*goodInt));
        if (goodInt == NULL) {exit(-1);}
        *goodInt = 6;
        printIntLine(*goodInt);
        free(goodInt);
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
11655,0,CWE401_Memory_Leak__int64_t_malloc_33.cpp,"    int64_t * data;
    int64_t * &dataRef = data;
    data = NULL;
    
    data = (int64_t *)malloc(100*sizeof(int64_t));
    if (data == NULL) {exit(-1);}
    
    data[0] = 5LL;
    printLongLongLine(data[0]);
    {
        int64_t * data = dataRef;
        
        ; 
"
15788,0,CWE369_Divide_by_Zero__float_zero_32.c,"    float data;
    float *dataPtr1 = &data;
    float *dataPtr2 = &data;
    
    data = 0.0F;
    {
        float data = *dataPtr1;
        
        data = 0.0F;
        *dataPtr1 = data;
    }
    {
        float data = *dataPtr2;
        {
            
            int result = (int)(100.0 / data);
            printIntLine(result);
        }
"
9125,0,CWE369_Divide_by_Zero__int_fscanf_modulo_82a.cpp,"    int data;
    
    data = -1;
    
    fscanf(stdin, ""%d"", &data);
    CWE369_Divide_by_Zero__int_fscanf_modulo_82_base* baseObject = new CWE369_Divide_by_Zero__int_fscanf_modulo_82_bad;
    baseObject->action(data);
"
16042,0,CWE457_Use_of_Uninitialized_Variable__double_array_alloca_partial_init_01.c,"    double * data;
    data = (double *)ALLOCA(10*sizeof(double));
    
    {
        int i;
        for(i=0; i<(10/2); i++)
        {
            data[i] = (double)i;
        }
    }
    
    {
        int i;
        for(i=0; i<10; i++)
        {
            printDoubleLine(data[i]);
        }
"
6176,0,CWE590_Free_Memory_Not_on_Heap__free_int_declare_52a.c,"    int * data;
    data = NULL; 
    {
        
        int dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5;
            }
        }
        data = dataBuffer;
    }
"
18155,0,CWE197_Numeric_Truncation_Error__short_large_45.c,"    short data;
    
    data = -1;
    
    data = CHAR_MAX + 1;
    CWE197_Numeric_Truncation_Error__short_large_45_badData = data;
"
4932,0,CWE415_Double_Free__malloc_free_char_83a.cpp,"    char * data;
    
    data = NULL;
"
14945,0,CWE401_Memory_Leak__malloc_realloc_twoIntsStruct_04.c,"    if(STATIC_CONST_TRUE)
    {
        {
            twoIntsStruct * data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
            if (data == NULL) {exit(-1);}
            
            data[0].intOne = 0;
            data[0].intTwo = 0;
            printStructLine(&data[0]);
            
            data = (twoIntsStruct *)realloc(data, (130000)*sizeof(twoIntsStruct));
            if (data != NULL)
            {
                
                data[0].intOne = 1;
                data[0].intTwo = 1;
                printStructLine(&data[0]);
                free(data);
            }
        }
"
9059,0,CWE190_Integer_Overflow__int_listen_socket_add_15.c,"    int data;
    
    data = 0;
    switch(6)
    {
    case 6:
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
    {
        
        int result = data + 1;
        printIntLine(result);
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
14981,0,CWE190_Integer_Overflow__int64_t_fscanf_multiply_66a.c,"    int64_t data;
    int64_t dataArray[5];
    data = 0LL;
    
    fscanf (stdin, ""%"" SCNd64, &data);
    
    dataArray[2] = data;
"
8202,0,CWE401_Memory_Leak__new_array_char_08.cpp,"    char * data;
    data = NULL;
    if(staticReturnsTrue())
    {
        
        data = new char[100];
        
        strcpy(data, ""A String"");
        printLine(data);
    }
    if(staticReturnsTrue())
    {
        
        ; 
"
2250,0,CWE190_Integer_Overflow__int64_t_max_preinc_08.c,"    int64_t data;
    data = 0LL;
    if(staticReturnsTrue())
    {
        
        data = LLONG_MAX;
    }
    if(staticReturnsTrue())
    {
        {
            
            ++data;
            int64_t result = data;
            printLongLongLine(result);
        }
"
4751,0,CWE78_OS_Command_Injection__char_listen_socket_popen_03.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(5==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                data[dataLen + recvResult / sizeof(char)] = '\0';
                
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    {
        FILE *pipe;
        
        pipe = POPEN(data, ""w"");
        if (pipe != NULL)
        {
            PCLOSE(pipe);
        }
"
9605,0,CWE190_Integer_Overflow__int64_t_max_square_07.c,"    int64_t data;
    data = 0LL;
    if(staticFive==5)
    {
        
        data = LLONG_MAX;
    }
    if(staticFive==5)
    {
        {
            
            int64_t result = data * data;
            printLongLongLine(result);
        }
"
2026,1,CWE688_Function_Call_With_Incorrect_Variable_or_Reference_as_Argument__basic_08.c,"    if(staticReturnsFalse())
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            char dest[DEST_SIZE];
            int intFive = 5;
            
            sprintf(dest, ""%d"", intFive);
            printLine(dest);
        }
"
9532,0,CWE190_Integer_Overflow__short_fscanf_square_61a.c,"    short data;
    data = 0;
    data = CWE190_Integer_Overflow__short_fscanf_square_61b_badSource(data);
    {
        
        short result = data * data;
        printIntLine(result);
"
11730,0,CWE78_OS_Command_Injection__char_connect_socket_system_45.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
"
1733,0,CWE252_Unchecked_Return_Value__char_snprintf_03.c,"    if(5==5)
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            
            SNPRINTF(data,100-strlen(SRC)-1, ""%s\n"", SRC);
        }
"
7856,0,CWE78_OS_Command_Injection__char_environment_system_03.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(5==5)
    {
        {
            
            size_t dataLen = strlen(data);
            char * environment = GETENV(ENV_VARIABLE);
            
            if (environment != NULL)
            {
                
                strncat(data+dataLen, environment, 100-dataLen-1);
            }
        }
    }
    
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
"
12518,0,CWE369_Divide_by_Zero__int_fscanf_modulo_54a.c,"    int data;
    
    data = -1;
    
    fscanf(stdin, ""%d"", &data);
"
5042,0,CWE590_Free_Memory_Not_on_Heap__delete_int64_t_declare_03.cpp,"    int64_t * data;
    data = NULL; 
    if(5==5)
    {
        {
            
            int64_t dataBuffer;
            dataBuffer = 5LL;
            data = &dataBuffer;
        }
    }
    printLongLongLine(*data);
    
"
5872,1,CWE476_NULL_Pointer_Dereference__binary_if_14.c,"    if(globalFive==5)
    {
        {
            twoIntsStruct *twoIntsStructPointer = NULL;
            /* FIX: Use && in the if statement so that if the left side of the expression fails then
             * the right side will not be evaluated */
            if ((twoIntsStructPointer != NULL) && (twoIntsStructPointer->intOne == 5))
            {
                printLine(""intOne == 5"");
            }
        }
"
10488,0,CWE416_Use_After_Free__new_delete_array_char_18.cpp,"    char * data;
    
    data = NULL;
    goto source;
source:
    data = new char[100];
    memset(data, 'A', 100-1);
    data[100-1] = '\0';
    
    delete [] data;
    goto sink;
sink:
    
    printLine(data);
"
18861,0,CWE190_Integer_Overflow__int64_t_fscanf_multiply_83_bad.cpp,"Label Definition File: CWE190_Integer_Overflow.label.xml
Template File: sources-sinks-83_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 190 Integer Overflow
 * BadSource: fscanf Read data from the console using fscanf()
 * GoodSource: Set data to a small, non-zero number (two)
 * Sinks: multiply
 *    GoodSink: Ensure there will not be an overflow before multiplying data by 2
 *    BadSink : If data is positive, multiply by 2, which can cause an overflow
 * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack
 *
 * */
#ifndef OMITBAD

#include <inttypes.h>
#include ""std_testcase.h""
#include ""CWE190_Integer_Overflow__int64_t_fscanf_multiply_83.h""

namespace CWE190_Integer_Overflow__int64_t_fscanf_multiply_83
{
CWE190_Integer_Overflow__int64_t_fscanf_multiply_83_bad::CWE190_Integer_Overflow__int64_t_fscanf_multiply_83_bad(int64_t dataCopy)
{
    data = dataCopy;
    
    fscanf (stdin, ""%"" SCNd64, &data);
}

CWE190_Integer_Overflow__int64_t_fscanf_multiply_83_bad::~CWE190_Integer_Overflow__int64_t_fscanf_multiply_83_bad()
{
    if(data > 0) 
    {
        
        int64_t result = data * 2;
        printLongLongLine(result);
    }
}
}
"
8281,0,CWE190_Integer_Overflow__unsigned_int_max_square_42.c,"    unsigned int data;
    data = 0;
    data = badSource(data);
    {
        
        unsigned int result = data * data;
        printUnsignedLine(result);
"
6855,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_13.c,"    size_t data;
    
    data = 0;
    if(GLOBAL_CONST_FIVE==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = strtoul(inputBuffer, NULL, 0);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            char * myString;
            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
             * for the strcpy() function to not cause a buffer overflow */
            
            if (data > strlen(HELLO_STRING))
            {
                myString = (char *)malloc(data*sizeof(char));
                if (myString == NULL) {exit(-1);}
                
                strcpy(myString, HELLO_STRING);
                printLine(myString);
                free(myString);
            }
            else
            {
                printLine(""Input is less than the length of the source string"");
            }
        }
"
3980,0,CWE190_Integer_Overflow__short_rand_postinc_15.c,"    short data;
    data = 0;
    switch(6)
    {
    case 6:
        
        data = (short)RAND32();
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
    {
        
        data++;
        short result = data;
        printIntLine(result);
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
7217,0,CWE590_Free_Memory_Not_on_Heap__delete_class_static_11.cpp,"    TwoIntsClass * data;
    data = NULL; 
    if(globalReturnsTrue())
    {
        {
            
            static TwoIntsClass dataBuffer;
            dataBuffer.intOne = 1;
            dataBuffer.intTwo = 1;
            data = &dataBuffer;
        }
    }
    printIntLine(data->intOne);
    
"
9399,0,CWE457_Use_of_Uninitialized_Variable__struct_array_alloca_partial_init_43.cpp,"    twoIntsStruct * data;
    data = (twoIntsStruct *)ALLOCA(10*sizeof(twoIntsStruct));
    badSource(data);
    
    {
        int i;
        for(i=0; i<10; i++)
        {
            printIntLine(data[i].intOne);
            printIntLine(data[i].intTwo);
        }
"
14307,0,CWE475_Undefined_Behavior_for_Input_to_API__char_07.c,"    if(staticFive==5)
    {
        {
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            strcpy(data, ""abcdefghijklmnopqrstuvwxyz"");
            
            memcpy(data + 6, data + 4, 10*sizeof(char));
            printLine(data);
        }
"
3426,0,CWE78_OS_Command_Injection__char_connect_socket_popen_01.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
"
6240,1,CWE758_Undefined_Behavior__struct_pointer_malloc_use_16.c,"    while(1)
    {
        {
            twoIntsStruct * data;
            twoIntsStruct * * pointer = (twoIntsStruct * *)malloc(sizeof(twoIntsStruct *));
            if (pointer == NULL) {exit(-1);}
            
            data = (twoIntsStruct *)malloc(sizeof(twoIntsStruct));
            if (data == NULL) {exit(-1);}
            data->intOne = 5;
            data->intTwo = 6;
            *pointer = data; 
            {
                twoIntsStruct * data = *pointer;
                printIntLine(data->intOne);
                printIntLine(data->intTwo);
            }
            free(pointer);
        }
        break;
"
8326,0,CWE590_Free_Memory_Not_on_Heap__delete_class_placement_new_08.cpp,"    TwoIntsClass * data;
    data = NULL; 
    if(staticReturnsTrue())
    {
        {
            
            char buffer[sizeof(TwoIntsClass)];
            TwoIntsClass * dataBuffer = new(buffer) TwoIntsClass;
            dataBuffer->intOne = 2;
            dataBuffer->intTwo = 2;
            data = dataBuffer;
        }
    }
    printIntLine(data->intOne);
    
"
14064,0,CWE190_Integer_Overflow__short_max_postinc_44.c,"    short data;
    
    void (*funcPtr) (short) = badSink;
    data = 0;
    
    data = SHRT_MAX;
    
"
14766,0,CWE563_Unused_Variable__unused_uninit_variable_int_04.c,"    int data;
    
    ; 
    if(STATIC_CONST_TRUE)
    {
        
        
        ; 
"
7283,0,CWE190_Integer_Overflow__int_max_multiply_04.c,"    int data;
    
    data = 0;
    if(STATIC_CONST_TRUE)
    {
        
        data = INT_MAX;
    }
    if(STATIC_CONST_TRUE)
    {
        if(data > 0) 
        {
            
            int result = data * 2;
            printIntLine(result);
        }
"
19317,1,CWE252_Unchecked_Return_Value__char_fputc_03.c,"    if(5!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        
        if (fputc((int)'A', stdout) == EOF)
        {
            printLine(""fputc failed!"");
        }
"
19062,0,CWE190_Integer_Overflow__int_fgets_postinc_61a.c,"    int data;
    
    data = 0;
    data = CWE190_Integer_Overflow__int_fgets_postinc_61b_badSource(data);
    {
        
        data++;
        int result = data;
        printIntLine(result);
"
6997,1,CWE401_Memory_Leak__malloc_realloc_int64_t_13.c,"    if(GLOBAL_CONST_FIVE==5)
    {
        {
            int64_t * data = (int64_t *)malloc(100*sizeof(int64_t));
            if (data == NULL) {exit(-1);}
            int64_t * tmpData;
            
            data[0] = 5LL;
            printLongLongLine(data[0]);
            tmpData = (int64_t *)realloc(data, (130000)*sizeof(int64_t));
            /* FIX: Ensure realloc() was successful before assigning data to the memory block
            * allocated with realloc() */
            if (tmpData != NULL)
            {
                data = tmpData;
                
                data[0] = 10LL;
                printLongLongLine(data[0]);
            }
            free(data);
        }
"
3317,0,CWE401_Memory_Leak__twoIntsStruct_malloc_31.c,"    twoIntsStruct * data;
    data = NULL;
    
    data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
    if (data == NULL) {exit(-1);}
    
    data[0].intOne = 0;
    data[0].intTwo = 0;
    printStructLine(&data[0]);
    {
        twoIntsStruct * dataCopy = data;
        twoIntsStruct * data = dataCopy;
        
        ; 
"
1958,0,CWE78_OS_Command_Injection__char_listen_socket_execlp_81_bad.cpp,"Label Definition File: CWE78_OS_Command_Injection.strings.label.xml
Template File: sources-sink-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 78 OS Command Injection
 * BadSource: listen_socket Read data using a listen socket (server side)
 * GoodSource: Fixed string
 * Sinks: execlp
 *    BadSink : execute command with execlp
 * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE78_OS_Command_Injection__char_listen_socket_execlp_81.h""

#ifdef _WIN32
#include <process.h>
#define EXECLP _execlp
#else 
#define EXECLP execlp
#endif

namespace CWE78_OS_Command_Injection__char_listen_socket_execlp_81
{

void CWE78_OS_Command_Injection__char_listen_socket_execlp_81_bad::action(char * data) const
{
    /* execlp - searches for the location of the command among
     * the directories specified by the PATH environment variable */
    
    EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}

}
"
8985,0,CWE197_Numeric_Truncation_Error__int_fgets_to_char_10.c,"    int data;
    
    data = -1;
    if(globalTrue)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
4524,1,CWE758_Undefined_Behavior__class_pointer_new_use_13.cpp,"    if(GLOBAL_CONST_FIVE!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            TwoIntsClass * data;
            
            data = new TwoIntsClass;
            data->intOne = 5;
            data->intTwo = 6;
            TwoIntsClass * * pointer = new TwoIntsClass *;
            *pointer = data; 
            {
                TwoIntsClass * data = *pointer;
                printIntLine(data->intOne);
                printIntLine(data->intTwo);
            }
            delete pointer;
        }
"
15840,0,CWE590_Free_Memory_Not_on_Heap__delete_long_placement_new_09.cpp,"    long * data;
    data = NULL; 
    if(GLOBAL_CONST_TRUE)
    {
        {
            
            char buffer[sizeof(long)];
            long * dataBuffer = new(buffer) long;
            *dataBuffer = 5L;
            data = dataBuffer;
        }
    }
    printLongLine(*data);
    
"
5451,0,CWE78_OS_Command_Injection__char_file_execl_82a.cpp,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        FILE * pFile;
        
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
    CWE78_OS_Command_Injection__char_file_execl_82_base* baseObject = new CWE78_OS_Command_Injection__char_file_execl_82_bad;
    baseObject->action(data);
"
3521,0,CWE197_Numeric_Truncation_Error__int_rand_to_short_63a.c,"    int data;
    
    data = -1;
    
    data = RAND32();
"
12541,0,CWE197_Numeric_Truncation_Error__int_listen_socket_to_char_13.c,"    int data;
    
    data = -1;
    if(GLOBAL_CONST_FIVE==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
3264,0,CWE415_Double_Free__new_delete_array_struct_81a.cpp,"    twoIntsStruct * data;
    
    data = NULL;
    data = new twoIntsStruct[100];
    
    delete [] data;
    const CWE415_Double_Free__new_delete_array_struct_81_base& o = CWE415_Double_Free__new_delete_array_struct_81_bad();
"
13698,0,CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_65a.c,"    char * data;
    
    void (*funcPtr) (char *) = CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_65b_badSink;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
"
1755,0,CWE190_Integer_Overflow__char_fscanf_square_16.c,"    char data;
    data = ' ';
    while(1)
    {
        
        fscanf (stdin, ""%c"", &data);
        break;
    }
    while(1)
    {
        {
            
            char result = data * data;
            printHexCharLine(result);
        }
        break;
"
2814,0,CWE190_Integer_Overflow__int_connect_socket_square_08.c,"    int data;
    
    data = 0;
    if(staticReturnsTrue())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(staticReturnsTrue())
    {
        {
            
            int result = data * data;
            printIntLine(result);
        }
"
10438,0,CWE134_Uncontrolled_Format_String__char_environment_snprintf_83a.cpp,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
"
5259,0,CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_33.cpp,"    char * data;
    char * &dataRef = data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    {
        char * data = dataRef;
        badVaSink(data, data);
"
17199,1,CWE563_Unused_Variable__unused_parameter_variable_01.c,
15713,0,CWE690_NULL_Deref_From_Return__char_malloc_16.c,"    char * data;
    data = NULL; 
    
    data = (char *)malloc(20*sizeof(char));
    while(1)
    {
        
        strcpy(data, ""Initialize"");
        printLine(data);
        free(data);
        break;
"
3973,0,CWE457_Use_of_Uninitialized_Variable__int_array_alloca_partial_init_10.c,"    int * data;
    data = (int *)ALLOCA(10*sizeof(int));
    if(globalTrue)
    {
        
        {
            int i;
            for(i=0; i<(10/2); i++)
            {
                data[i] = i;
            }
        }
    }
    if(globalTrue)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i]);
            }
        }
"
16423,0,CWE190_Integer_Overflow__unsigned_int_max_preinc_45.c,"    unsigned int data;
    data = 0;
    
    data = UINT_MAX;
    CWE190_Integer_Overflow__unsigned_int_max_preinc_45_badData = data;
"
10253,0,CWE690_NULL_Deref_From_Return__struct_realloc_32.c,"    twoIntsStruct * data;
    twoIntsStruct * *dataPtr1 = &data;
    twoIntsStruct * *dataPtr2 = &data;
    data = NULL; 
    {
        twoIntsStruct * data = *dataPtr1;
        
        data = (twoIntsStruct *)realloc(data, 1*sizeof(twoIntsStruct));
        *dataPtr1 = data;
    }
    {
        twoIntsStruct * data = *dataPtr2;
        
        data[0].intOne = 1;
        data[0].intTwo = 1;
        printStructLine(&data[0]);
        free(data);
"
16436,0,CWE369_Divide_by_Zero__int_connect_socket_divide_05.c,"    int data;
    
    data = -1;
    if(staticTrue)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(staticTrue)
    {
        
        printIntLine(100 / data);
"
12926,0,CWE415_Double_Free__new_delete_array_class_73a.cpp,"    TwoIntsClass * data;
    list<TwoIntsClass *> dataList;
    
    data = NULL;
    data = new TwoIntsClass[100];
    
    delete [] data;
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
9793,0,CWE190_Integer_Overflow__int_rand_add_68a.c,"    int data;
    
    data = 0;
    
    data = RAND32();
    CWE190_Integer_Overflow__int_rand_add_68_badData = data;
"
16928,0,CWE134_Uncontrolled_Format_String__char_file_fprintf_02.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(1)
    {
        {
            
            size_t dataLen = strlen(data);
            FILE * pFile;
            
            if (100-dataLen > 1)
            {
                pFile = fopen(FILENAME, ""r"");
                if (pFile != NULL)
                {
                    
                    if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                    {
                        printLine(""fgets() failed"");
                        
                        data[dataLen] = '\0';
                    }
                    fclose(pFile);
                }
            }
        }
    }
    if(1)
    {
        
        fprintf(stdout, data);
"
10517,1,CWE758_Undefined_Behavior__int_alloca_use_14.c,"    if(globalFive==5)
    {
        {
            int data;
            int * pointer = (int *)ALLOCA(sizeof(int));
            data = 5;
            *pointer = data; 
            {
                int data = *pointer;
                printIntLine(data);
            }
        }
"
17075,0,CWE190_Integer_Overflow__int_listen_socket_add_42.c,"    int data;
    
    data = 0;
    data = badSource(data);
    {
        
        int result = data + 1;
        printIntLine(result);
"
6745,0,CWE590_Free_Memory_Not_on_Heap__delete_int_alloca_10.cpp,"    int * data;
    data = NULL; 
    if(globalTrue)
    {
        {
            
            int * dataBuffer = (int *)ALLOCA(sizeof(int));
            *dataBuffer = 5;
            data = dataBuffer;
        }
    }
    printIntLine(*data);
    
"
1526,0,CWE197_Numeric_Truncation_Error__int_large_to_short_08.c,"    int data;
    
    data = -1;
    if(staticReturnsTrue())
    {
        
        data = SHRT_MAX + 5;
    }
    {
        
        short shortData = (short)data;
        printShortLine(shortData);
"
5940,0,CWE457_Use_of_Uninitialized_Variable__int_array_alloca_partial_init_13.c,"    int * data;
    data = (int *)ALLOCA(10*sizeof(int));
    if(GLOBAL_CONST_FIVE==5)
    {
        
        {
            int i;
            for(i=0; i<(10/2); i++)
            {
                data[i] = i;
            }
        }
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i]);
            }
        }
"
1656,0,CWE190_Integer_Overflow__unsigned_int_max_add_44.c,"    unsigned int data;
    
    void (*funcPtr) (unsigned int) = badSink;
    data = 0;
    
    data = UINT_MAX;
    
"
4263,0,CWE252_Unchecked_Return_Value__char_remove_11.c,"    if(globalReturnsTrue())
    {
        
        REMOVE(""removemebad.txt"");
"
19427,0,CWE415_Double_Free__new_delete_class_65a.cpp,"    TwoIntsClass * data;
    
    void (*funcPtr) (TwoIntsClass *) = badSink;
    
    data = NULL;
    data = new TwoIntsClass;
    
    delete data;
    
"
11746,0,CWE590_Free_Memory_Not_on_Heap__free_int_declare_06.c,"    int * data;
    data = NULL; 
    if(STATIC_CONST_FIVE==5)
    {
        {
            
            int dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5;
                }
            }
            data = dataBuffer;
        }
    }
    printIntLine(data[0]);
    
"
8568,0,CWE190_Integer_Overflow__short_rand_add_65a.c,"    short data;
    
    void (*funcPtr) (short) = CWE190_Integer_Overflow__short_rand_add_65b_badSink;
    data = 0;
    
    data = (short)RAND32();
    
"
18468,0,CWE457_Use_of_Uninitialized_Variable__double_12.c,"    double data;
    if(globalReturnsTrueOrFalse())
    {
        
        ; 
    }
    else
    {
        
        data = 5.0;
    }
    if(globalReturnsTrueOrFalse())
    {
        
        printDoubleLine(data);
    }
    else
    {
        
        data = 5.0;
        printDoubleLine(data);
"
16037,0,CWE758_Undefined_Behavior__int_malloc_use_09.c,"    if(GLOBAL_CONST_TRUE)
    {
        {
            int * pointer = (int *)malloc(sizeof(int));
            if (pointer == NULL) {exit(-1);}
            int data = *pointer; 
            free(pointer);
            printIntLine(data);
        }
"
1491,0,CWE197_Numeric_Truncation_Error__int_fgets_to_char_68a.c,"    int data;
    
    data = -1;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    CWE197_Numeric_Truncation_Error__int_fgets_to_char_68_badData = data;
"
9854,0,CWE134_Uncontrolled_Format_String__char_environment_vprintf_04.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(STATIC_CONST_TRUE)
    {
        {
            
            size_t dataLen = strlen(data);
            char * environment = GETENV(ENV_VARIABLE);
            
            if (environment != NULL)
            {
                
                strncat(data+dataLen, environment, 100-dataLen-1);
            }
        }
    }
    if(STATIC_CONST_TRUE)
    {
        badVaSinkB(data, data);
"
18364,0,CWE134_Uncontrolled_Format_String__char_connect_socket_printf_62a.cpp,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    badSource(data);
    
"
6780,0,CWE78_OS_Command_Injection__char_connect_socket_system_63a.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
13801,1,CWE758_Undefined_Behavior__double_pointer_new_use_04.cpp,"    if(STATIC_CONST_TRUE)
    {
        {
            double * data;
            
            data = new double;
            *data = 5.0;
            double * * pointer = new double *;
            *pointer = data; 
            {
                double * data = *pointer;
                printDoubleLine(*data);
            }
            delete pointer;
        }
"
8396,0,CWE690_NULL_Deref_From_Return__struct_calloc_33.cpp,"    twoIntsStruct * data;
    twoIntsStruct * &dataRef = data;
    data = NULL; 
    
    data = (twoIntsStruct *)calloc(1, sizeof(twoIntsStruct));
    {
        twoIntsStruct * data = dataRef;
        
        data[0].intOne = 1;
        data[0].intTwo = 1;
        printStructLine(&data[0]);
        free(data);
"
15379,0,CWE134_Uncontrolled_Format_String__char_file_printf_14.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(globalFive==5)
    {
        {
            
            size_t dataLen = strlen(data);
            FILE * pFile;
            
            if (100-dataLen > 1)
            {
                pFile = fopen(FILENAME, ""r"");
                if (pFile != NULL)
                {
                    
                    if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                    {
                        printLine(""fgets() failed"");
                        
                        data[dataLen] = '\0';
                    }
                    fclose(pFile);
                }
            }
        }
    }
    if(globalFive==5)
    {
        
        printf(data);
"
13071,0,CWE190_Integer_Overflow__int_fscanf_multiply_73a.cpp,"    int data;
    list<int> dataList;
    
    data = 0;
    
    fscanf(stdin, ""%d"", &data);
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
6038,0,CWE190_Integer_Overflow__unsigned_int_max_preinc_02.c,"    unsigned int data;
    data = 0;
    if(1)
    {
        
        data = UINT_MAX;
    }
    if(1)
    {
        {
            
            ++data;
            unsigned int result = data;
            printUnsignedLine(result);
        }
"
5485,0,CWE369_Divide_by_Zero__float_fscanf_62a.cpp,"    float data;
    
    data = 0.0F;
    badSource(data);
    {
        
        int result = (int)(100.0 / data);
        printIntLine(result);
"
222,0,CWE190_Integer_Overflow__short_rand_multiply_14.c,"    short data;
    data = 0;
    if(globalFive==5)
    {
        
        data = (short)RAND32();
    }
    if(globalFive==5)
    {
        if(data > 0) 
        {
            
            short result = data * 2;
            printIntLine(result);
        }
"
14750,0,CWE190_Integer_Overflow__short_rand_add_81a.cpp,"    short data;
    data = 0;
    
    data = (short)RAND32();
    const CWE190_Integer_Overflow__short_rand_add_81_base& baseObject = CWE190_Integer_Overflow__short_rand_add_81_bad();
"
10587,1,CWE758_Undefined_Behavior__long_new_use_14.cpp,"    if(globalFive!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            long data;
            data = 5L;
            long * pointer = new long;
            *pointer = data; 
            {
                long data = *pointer;
                printLongLine(data);
            }
            delete pointer;
        }
"
8620,0,CWE78_OS_Command_Injection__char_connect_socket_system_05.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(staticTrue)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET connectSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
"
15757,0,CWE190_Integer_Overflow__char_rand_preinc_21.c,"    char data;
    data = ' ';
    
    data = (char)RAND32();
    badStatic = 1; 
"
7210,0,CWE190_Integer_Overflow__int_fscanf_square_05.c,"    int data;
    
    data = 0;
    if(staticTrue)
    {
        
        fscanf(stdin, ""%d"", &data);
    }
    if(staticTrue)
    {
        {
            
            int result = data * data;
            printIntLine(result);
        }
"
16467,0,CWE190_Integer_Overflow__char_fscanf_preinc_68a.c,"    char data;
    data = ' ';
    
    fscanf (stdin, ""%c"", &data);
    CWE190_Integer_Overflow__char_fscanf_preinc_68_badData = data;
"
2675,0,CWE190_Integer_Overflow__int64_t_rand_multiply_07.c,"    int64_t data;
    data = 0LL;
    if(staticFive==5)
    {
        
        data = (int64_t)RAND64();
    }
    if(staticFive==5)
    {
        if(data > 0) 
        {
            
            int64_t result = data * 2;
            printLongLongLine(result);
        }
"
14961,0,CWE590_Free_Memory_Not_on_Heap__delete_array_int64_t_declare_13.cpp,"    int64_t * data;
    data = NULL; 
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            
            int64_t dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5LL;
                }
            }
            data = dataBuffer;
        }
    }
    printLongLongLine(data[0]);
    
"
11707,0,CWE401_Memory_Leak__int_realloc_12.c,"    int * data;
    data = NULL;
    if(globalReturnsTrueOrFalse())
    {
        
        data = (int *)realloc(data, 100*sizeof(int));
        if (data == NULL) {exit(-1);}
        
        data[0] = 5;
        printIntLine(data[0]);
    }
    else
    {
        
        data = (int *)ALLOCA(100*sizeof(int));
        
        data[0] = 5;
        printIntLine(data[0]);
    }
    if(globalReturnsTrueOrFalse())
    {
        
        ; 
    }
    else
    {
        
        free(data);
"
3233,1,CWE688_Function_Call_With_Incorrect_Variable_or_Reference_as_Argument__basic_16.c,"    while(1)
    {
        {
            char dest[DEST_SIZE];
            int intFive = 5;
            
            sprintf(dest, ""%d"", intFive);
            printLine(dest);
        }
        break;
"
16624,0,CWE134_Uncontrolled_Format_String__char_environment_vfprintf_17.c,"    int i,j;
    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    for(i = 0; i < 1; i++)
    {
        {
            
            size_t dataLen = strlen(data);
            char * environment = GETENV(ENV_VARIABLE);
            
            if (environment != NULL)
            {
                
                strncat(data+dataLen, environment, 100-dataLen-1);
            }
        }
    }
    for(j = 0; j < 1; j++)
    {
        badVaSinkB(data, data);
"
8283,0,CWE401_Memory_Leak__struct_twoIntsStruct_realloc_14.c,"    struct _twoIntsStruct * data;
    data = NULL;
    if(globalFive==5)
    {
        
        data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));
        if (data == NULL) {exit(-1);}
        
        data[0].intOne = 0;
        data[0].intTwo = 0;
        printStructLine((twoIntsStruct *)&data[0]);
    }
    if(globalFive==5)
    {
        
        ; 
"
9931,0,CWE190_Integer_Overflow__int64_t_fscanf_square_15.c,"    int64_t data;
    data = 0LL;
    switch(6)
    {
    case 6:
        
        fscanf (stdin, ""%"" SCNd64, &data);
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
    {
        
        int64_t result = data * data;
        printLongLongLine(result);
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
4092,0,CWE758_Undefined_Behavior__long_malloc_use_02.c,"    if(1)
    {
        {
            long * pointer = (long *)malloc(sizeof(long));
            if (pointer == NULL) {exit(-1);}
            long data = *pointer; 
            free(pointer);
            printLongLine(data);
        }
"
11116,1,CWE476_NULL_Pointer_Dereference__deref_after_check_15.c,"    switch(5)
    {
    case 6:
        
        printLine(""Benign, fixed string"");
        break;
    default:
    {
        
        int *intPointer = NULL;
        if (intPointer == NULL)
        {
            printLine(""pointer is NULL"");
        }
    }
    break;
"
15946,0,CWE476_NULL_Pointer_Dereference__char_03.c,"    char * data;
    if(5==5)
    {
        
        data = NULL;
    }
    if(5==5)
    {
        
        
        printHexCharLine(data[0]);
"
11047,0,CWE590_Free_Memory_Not_on_Heap__delete_int64_t_alloca_45.cpp,"    int64_t * data;
    data = NULL; 
    {
        
        int64_t * dataBuffer = (int64_t *)ALLOCA(sizeof(int64_t));
        *dataBuffer = 5LL;
        data = dataBuffer;
    }
    badData = data;
"
3899,0,CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_82_bad.cpp,"Label Definition File: CWE134_Uncontrolled_Format_String.label.xml
Template File: sources-sinks-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 134 Uncontrolled Format String
 * BadSource: listen_socket Read data using a listen socket (server side)
 * GoodSource: Copy a fixed string into data
 * Sinks: snprintf
 *    GoodSink: snprintf with ""%s"" as the third argument and data as the fourth
 *    BadSink : snprintf with data as the third argument
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_82.h""

#ifdef _WIN32
#define SNPRINTF _snprintf
#else
#define SNPRINTF snprintf
#endif

namespace CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_82
{

void CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_82_bad::action(char * data)
{
    {
        char dest[100] = """";
        
        SNPRINTF(dest, 100-1, data);
        printLine(dest);
    }
}

}
"
8521,0,CWE78_OS_Command_Injection__char_file_popen_81a.cpp,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
        
        size_t dataLen = strlen(data);
        FILE * pFile;
        
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
    const CWE78_OS_Command_Injection__char_file_popen_81_base& baseObject = CWE78_OS_Command_Injection__char_file_popen_81_bad();
"
9625,0,CWE190_Integer_Overflow__char_rand_multiply_17.c,"    int i,j;
    char data;
    data = ' ';
    for(i = 0; i < 1; i++)
    {
        
        data = (char)RAND32();
    }
    for(j = 0; j < 1; j++)
    {
        if(data > 0) 
        {
            
            char result = data * 2;
            printHexCharLine(result);
        }
"
4501,0,CWE134_Uncontrolled_Format_String__char_console_fprintf_11.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(globalReturnsTrue())
    {
        {
            
            size_t dataLen = strlen(data);
            
            if (100-dataLen > 1)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
                {
                    /* The next few lines remove the carriage return from the string that is
                     * inserted by fgets() */
                    dataLen = strlen(data);
                    if (dataLen > 0 && data[dataLen-1] == '\n')
                    {
                        data[dataLen-1] = '\0';
                    }
                }
                else
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
            }
        }
    }
    if(globalReturnsTrue())
    {
        
        fprintf(stdout, data);
"
10121,0,CWE369_Divide_by_Zero__float_zero_08.c,"    float data;
    
    data = 0.0F;
    if(staticReturnsTrue())
    {
        
        data = 0.0F;
    }
    if(staticReturnsTrue())
    {
        {
            
            int result = (int)(100.0 / data);
            printIntLine(result);
        }
"
11077,0,CWE475_Undefined_Behavior_for_Input_to_API__char_02.c,"    if(1)
    {
        {
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            strcpy(data, ""abcdefghijklmnopqrstuvwxyz"");
            
            memcpy(data + 6, data + 4, 10*sizeof(char));
            printLine(data);
        }
"
17047,0,CWE457_Use_of_Uninitialized_Variable__double_array_alloca_partial_init_13.c,"    double * data;
    data = (double *)ALLOCA(10*sizeof(double));
    if(GLOBAL_CONST_FIVE==5)
    {
        
        {
            int i;
            for(i=0; i<(10/2); i++)
            {
                data[i] = (double)i;
            }
        }
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printDoubleLine(data[i]);
            }
        }
"
12637,0,CWE401_Memory_Leak__twoIntsStruct_calloc_11.c,"    twoIntsStruct * data;
    data = NULL;
    if(globalReturnsTrue())
    {
        
        data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));
        if (data == NULL) {exit(-1);}
        
        data[0].intOne = 0;
        data[0].intTwo = 0;
        printStructLine(&data[0]);
    }
    if(globalReturnsTrue())
    {
        
        ; 
"
16632,0,CWE401_Memory_Leak__char_malloc_15.c,"    char * data;
    data = NULL;
    switch(6)
    {
    case 6:
        
        data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        
        strcpy(data, ""A String"");
        printLine(data);
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
        
        ; 
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
19469,0,CWE590_Free_Memory_Not_on_Heap__delete_array_int64_t_declare_02.cpp,"    int64_t * data;
    data = NULL; 
    if(1)
    {
        {
            
            int64_t dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5LL;
                }
            }
            data = dataBuffer;
        }
    }
    printLongLongLine(data[0]);
    
"
8329,0,CWE190_Integer_Overflow__short_rand_preinc_09.c,"    short data;
    data = 0;
    if(GLOBAL_CONST_TRUE)
    {
        
        data = (short)RAND32();
    }
    if(GLOBAL_CONST_TRUE)
    {
        {
            
            ++data;
            short result = data;
            printIntLine(result);
        }
"
17446,0,CWE590_Free_Memory_Not_on_Heap__free_int_declare_16.c,"    int * data;
    data = NULL; 
    while(1)
    {
        {
            
            int dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5;
                }
            }
            data = dataBuffer;
        }
        break;
    }
    printIntLine(data[0]);
    
"
10143,0,CWE369_Divide_by_Zero__int_listen_socket_modulo_83_bad.cpp,"Label Definition File: CWE369_Divide_by_Zero__int.label.xml
Template File: sources-sinks-83_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 369 Divide by Zero
 * BadSource: listen_socket Read data using a listen socket (server side)
 * GoodSource: Non-zero
 * Sinks: modulo
 *    GoodSink: Check for zero before modulo
 *    BadSink : Modulo a constant with data
 * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE369_Divide_by_Zero__int_listen_socket_modulo_83.h""

#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif

#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)

namespace CWE369_Divide_by_Zero__int_listen_socket_modulo_83
{
CWE369_Divide_by_Zero__int_listen_socket_modulo_83_bad::CWE369_Divide_by_Zero__int_listen_socket_modulo_83_bad(int dataCopy)
{
    data = dataCopy;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
}

CWE369_Divide_by_Zero__int_listen_socket_modulo_83_bad::~CWE369_Divide_by_Zero__int_listen_socket_modulo_83_bad()
{
    
    printIntLine(100 % data);
}
}
"
6611,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_82_bad.cpp,"Label Definition File: CWE789_Uncontrolled_Mem_Alloc__malloc.label.xml
Template File: sources-sinks-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: rand Set data to result of rand(), which may be zero
 * GoodSource: Small number greater than zero
 * Sinks:
 *    GoodSink: Allocate memory with malloc() and check the size of the memory to be allocated
 *    BadSink : Allocate memory with malloc(), but incorrectly check the size of the memory to be allocated
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_82.h""

#define HELLO_STRING ""hello""

namespace CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_82
{

void CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_82_bad::action(size_t data)
{
    {
        char * myString;
        /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
         * for the strcpy() function to not cause a buffer overflow */
        
        if (data > strlen(HELLO_STRING))
        {
            myString = (char *)malloc(data*sizeof(char));
            if (myString == NULL) {exit(-1);}
            
            strcpy(myString, HELLO_STRING);
            printLine(myString);
            free(myString);
        }
        else
        {
            printLine(""Input is less than the length of the source string"");
        }
    }
}

}
"
16529,0,CWE415_Double_Free__new_delete_array_class_83a.cpp,"    TwoIntsClass * data;
    
    data = NULL;
"
19291,0,CWE590_Free_Memory_Not_on_Heap__delete_int64_t_static_63a.cpp,"    int64_t * data;
    data = NULL; 
    {
        
        static int64_t dataBuffer;
        dataBuffer = 5LL;
        data = &dataBuffer;
    }
"
2196,0,CWE457_Use_of_Uninitialized_Variable__struct_array_alloca_no_init_17.c,"    int i,j;
    twoIntsStruct * data;
    data = (twoIntsStruct *)ALLOCA(10*sizeof(twoIntsStruct));
    for(i = 0; i < 1; i++)
    {
        
        ; 
    }
    for(j = 0; j < 1; j++)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i].intOne);
                printIntLine(data[i].intTwo);
            }
        }
"
15634,0,CWE78_OS_Command_Injection__char_file_execl_07.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(staticFive==5)
    {
        {
            
            size_t dataLen = strlen(data);
            FILE * pFile;
            
            if (100-dataLen > 1)
            {
                pFile = fopen(FILENAME, ""r"");
                if (pFile != NULL)
                {
                    
                    if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                    {
                        printLine(""fgets() failed"");
                        
                        data[dataLen] = '\0';
                    }
                    fclose(pFile);
                }
            }
        }
    }
    
    
"
5607,1,CWE758_Undefined_Behavior__long_malloc_use_06.c,"    if(STATIC_CONST_FIVE==5)
    {
        {
            long data;
            long * pointer = (long *)malloc(sizeof(long));
            if (pointer == NULL) {exit(-1);}
            data = 5L;
            *pointer = data; 
            {
                long data = *pointer;
                printLongLine(data);
            }
            free(pointer);
        }
"
7153,1,CWE416_Use_After_Free__return_freed_ptr_11.c,"    if(globalReturnsTrue())
    {
        {
            
            char * reversedString = helperGood(""GoodSink"");
            printLine(reversedString);
            /* free(reversedString);
             * This call to free() was removed because we want the tool to detect the use after free,
             * but we don't want that function to be free(). Essentially we want to avoid a double free
             */
        }
"
16971,0,CWE457_Use_of_Uninitialized_Variable__double_array_alloca_partial_init_06.c,"    double * data;
    data = (double *)ALLOCA(10*sizeof(double));
    if(STATIC_CONST_FIVE==5)
    {
        
        {
            int i;
            for(i=0; i<(10/2); i++)
            {
                data[i] = (double)i;
            }
        }
    }
    if(STATIC_CONST_FIVE==5)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printDoubleLine(data[i]);
            }
        }
"
3021,0,CWE590_Free_Memory_Not_on_Heap__delete_array_char_declare_72a.cpp,"    char * data;
    vector<char *> dataVector;
    data = NULL; 
    {
        
        char dataBuffer[100];
        memset(dataBuffer, 'A', 100-1); 
        dataBuffer[100-1] = '\0'; 
        data = dataBuffer;
    }
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
4788,0,CWE134_Uncontrolled_Format_String__char_file_fprintf_34.c,"    char * data;
    CWE134_Uncontrolled_Format_String__char_file_fprintf_34_unionType myUnion;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        FILE * pFile;
        
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
    myUnion.unionFirst = data;
    {
        char * data = myUnion.unionSecond;
        
        fprintf(stdout, data);
"
7329,1,CWE252_Unchecked_Return_Value__char_fgets_06.c,"    if(STATIC_CONST_FIVE==5)
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            printLine(""Please enter a string: "");
            
            if (fgets(data, 100, stdin) == NULL)
            {
                printLine(""fgets failed!"");
                exit(1);
            }
            printLine(data);
        }
"
16713,0,CWE190_Integer_Overflow__int_max_preinc_11.c,"    int data;
    
    data = 0;
    if(globalReturnsTrue())
    {
        
        data = INT_MAX;
    }
    if(globalReturnsTrue())
    {
        {
            
            ++data;
            int result = data;
            printIntLine(result);
        }
"
14040,0,CWE469_Use_of_Pointer_Subtraction_to_Determine_Size__char_11.c,"    if(globalReturnsTrue())
    {
        {
            char string1[] = SOURCE_STRING;
            char string2[] = SOURCE_STRING;
            char * slashInString1;
            size_t indexOfSlashInString1;
            slashInString1 = strchr(string1, '/');
            if (slashInString1 == NULL)
            {
                exit(1);
            }
            
            indexOfSlashInString1 = (size_t)(slashInString1 - string2);
            
            printUnsignedLine(indexOfSlashInString1);
        }
"
6431,0,CWE190_Integer_Overflow__int_fgets_postinc_18.c,"    int data;
    
    data = 0;
    goto source;
source:
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    goto sink;
sink:
    {
        
        data++;
        int result = data;
        printIntLine(result);
"
11943,0,CWE190_Integer_Overflow__short_fscanf_multiply_08.c,"    short data;
    data = 0;
    if(staticReturnsTrue())
    {
        
        fscanf (stdin, ""%hd"", &data);
    }
    if(staticReturnsTrue())
    {
        if(data > 0) 
        {
            
            short result = data * 2;
            printIntLine(result);
        }
"
6616,0,CWE401_Memory_Leak__struct_twoIntsStruct_malloc_09.c,"    struct _twoIntsStruct * data;
    data = NULL;
    if(GLOBAL_CONST_TRUE)
    {
        
        data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));
        if (data == NULL) {exit(-1);}
        
        data[0].intOne = 0;
        data[0].intTwo = 0;
        printStructLine((twoIntsStruct *)&data[0]);
    }
    if(GLOBAL_CONST_TRUE)
    {
        
        ; 
"
12247,1,CWE252_Unchecked_Return_Value__char_snprintf_03.c,"    if(5!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            
            if (SNPRINTF(data,100-strlen(SRC)-1, ""%s\n"", SRC) < 0)
            {
                printLine(""snprintf failed!"");
            }
        }
"
16253,0,CWE758_Undefined_Behavior__char_new_use_04.cpp,"    if(STATIC_CONST_TRUE)
    {
        {
            char * pointer = new char;
            char data = *pointer; 
            delete pointer;
            printHexCharLine(data);
        }
"
11966,0,CWE590_Free_Memory_Not_on_Heap__delete_class_placement_new_72a.cpp,"    TwoIntsClass * data;
    vector<TwoIntsClass *> dataVector;
    data = NULL; 
    {
        
        char buffer[sizeof(TwoIntsClass)];
        TwoIntsClass * dataBuffer = new(buffer) TwoIntsClass;
        dataBuffer->intOne = 2;
        dataBuffer->intTwo = 2;
        data = dataBuffer;
    }
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
13631,0,CWE415_Double_Free__new_delete_array_int64_t_06.cpp,"    int64_t * data;
    
    data = NULL;
    if(STATIC_CONST_FIVE==5)
    {
        data = new int64_t[100];
        
        delete [] data;
    }
    if(STATIC_CONST_FIVE==5)
    {
        
        delete [] data;
"
37,0,CWE78_OS_Command_Injection__char_console_popen_15.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    switch(6)
    {
    case 6:
    {
        
        size_t dataLen = strlen(data);
        
        if (100-dataLen > 1)
        {
            
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgets() */
"
14019,0,CWE590_Free_Memory_Not_on_Heap__delete_long_alloca_01.cpp,"    long * data;
    data = NULL; 
    {
        
        long * dataBuffer = (long *)ALLOCA(sizeof(long));
        *dataBuffer = 5L;
        data = dataBuffer;
    }
    printLongLine(*data);
    
"
16164,0,CWE197_Numeric_Truncation_Error__int_listen_socket_to_char_63a.c,"    int data;
    
    data = -1;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
776,0,CWE190_Integer_Overflow__int_fgets_multiply_32.c,"    int data;
    int *dataPtr1 = &data;
    int *dataPtr2 = &data;
    
    data = 0;
    {
        int data = *dataPtr1;
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
        *dataPtr1 = data;
    }
    {
        int data = *dataPtr2;
        if(data > 0) 
        {
            
            int result = data * 2;
            printIntLine(result);
        }
"
4886,0,CWE590_Free_Memory_Not_on_Heap__delete_class_alloca_11.cpp,"    TwoIntsClass * data;
    data = NULL; 
    if(globalReturnsTrue())
    {
        {
            
            TwoIntsClass * dataBuffer = (TwoIntsClass *)ALLOCA(sizeof(TwoIntsClass));
            dataBuffer->intOne = 2;
            dataBuffer->intTwo = 2;
            data = dataBuffer;
        }
    }
    printIntLine(data->intOne);
    
"
3684,0,CWE190_Integer_Overflow__char_fscanf_square_18.c,"    char data;
    data = ' ';
    goto source;
source:
    
    fscanf (stdin, ""%c"", &data);
    goto sink;
sink:
    {
        
        char result = data * data;
        printHexCharLine(result);
"
19194,0,CWE134_Uncontrolled_Format_String__char_environment_vfprintf_73a.cpp,"    char * data;
    list<char *> dataList;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        
        if (environment != NULL)
        {
            
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
13440,0,CWE190_Integer_Overflow__int_rand_add_52a.c,"    int data;
    
    data = 0;
    
    data = RAND32();
"
11629,0,CWE197_Numeric_Truncation_Error__int_large_to_char_09.c,"    int data;
    
    data = -1;
    if(GLOBAL_CONST_TRUE)
    {
        
        data = SHRT_MAX + 5;
    }
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
13473,0,CWE590_Free_Memory_Not_on_Heap__free_int_alloca_82_bad.cpp,"Label Definition File: CWE590_Free_Memory_Not_on_Heap__free.label.xml
Template File: sources-sink-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 590 Free Memory Not on Heap
 * BadSource: alloca Data buffer is allocated on the stack with alloca()
 * GoodSource: Allocate memory on the heap
 * Sinks:
 *    BadSink : Print then free data
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE590_Free_Memory_Not_on_Heap__free_int_alloca_82.h""

namespace CWE590_Free_Memory_Not_on_Heap__free_int_alloca_82
{

void CWE590_Free_Memory_Not_on_Heap__free_int_alloca_82_bad::action(int * data)
{
    printIntLine(data[0]);
    
    free(data);
}

}
"
10266,0,CWE78_OS_Command_Injection__char_file_popen_43.cpp,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    badSource(data);
    {
        FILE *pipe;
        
        pipe = POPEN(data, ""w"");
        if (pipe != NULL)
        {
            PCLOSE(pipe);
        }
"
9209,0,CWE476_NULL_Pointer_Dereference__char_05.c,"    char * data;
    if(staticTrue)
    {
        
        data = NULL;
    }
    if(staticTrue)
    {
        
        
        printHexCharLine(data[0]);
"
15799,0,CWE416_Use_After_Free__new_delete_class_18.cpp,"    TwoIntsClass * data;
    
    data = NULL;
    goto source;
source:
    data = new TwoIntsClass;
    data->intOne = 1;
    data->intTwo = 2;
    
    delete data;
    goto sink;
sink:
    
    printIntLine(data->intOne);
"
11161,0,CWE78_OS_Command_Injection__char_connect_socket_execl_53a.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
7032,0,CWE190_Integer_Overflow__char_max_preinc_22a.c,"    char data;
    data = ' ';
    
    data = CHAR_MAX;
    CWE190_Integer_Overflow__char_max_preinc_22_badGlobal = 1; 
"
15691,0,CWE190_Integer_Overflow__int_fgets_preinc_63a.c,"    int data;
    
    data = 0;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
"
12237,0,CWE457_Use_of_Uninitialized_Variable__long_03.c,"    long data;
    if(5==5)
    {
        
        ; 
    }
    if(5==5)
    {
        
        printLongLine(data);
"
834,0,CWE590_Free_Memory_Not_on_Heap__delete_array_int64_t_static_31.cpp,"    int64_t * data;
    data = NULL; 
    {
        
        static int64_t dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5LL;
            }
        }
        data = dataBuffer;
    }
    {
        int64_t * dataCopy = data;
        int64_t * data = dataCopy;
        printLongLongLine(data[0]);
        
        delete [] data;
"
8861,0,CWE78_OS_Command_Injection__char_console_popen_54a.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
        
        size_t dataLen = strlen(data);
        
        if (100-dataLen > 1)
        {
            
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgets() */
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
                    data[dataLen-1] = '\0';
                }
            }
            else
            {
                printLine(""fgets() failed"");
                
                data[dataLen] = '\0';
            }
        }
    }
"
3162,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_03.c,"    size_t data;
    
    data = 0;
    if(5==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = strtoul(inputBuffer, NULL, 0);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(5==5)
    {
        {
            char * myString;
            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
             * for the strcpy() function to not cause a buffer overflow */
            
            if (data > strlen(HELLO_STRING))
            {
                myString = (char *)malloc(data*sizeof(char));
                if (myString == NULL) {exit(-1);}
                
                strcpy(myString, HELLO_STRING);
                printLine(myString);
                free(myString);
            }
            else
            {
                printLine(""Input is less than the length of the source string"");
            }
        }
"
1430,0,CWE401_Memory_Leak__malloc_realloc_int64_t_12.c,"    if(globalReturnsTrueOrFalse())
    {
        {
            int64_t * data = (int64_t *)malloc(100*sizeof(int64_t));
            if (data == NULL) {exit(-1);}
            
            data[0] = 5LL;
            printLongLongLine(data[0]);
            
            data = (int64_t *)realloc(data, (130000)*sizeof(int64_t));
            if (data != NULL)
            {
                
                data[0] = 10LL;
                printLongLongLine(data[0]);
                free(data);
            }
        }
    }
    else
    {
        {
            int64_t * data = (int64_t *)malloc(100*sizeof(int64_t));
            if (data == NULL) {exit(-1);}
            int64_t * tmpData;
            
            data[0] = 5LL;
            printLongLongLine(data[0]);
            tmpData = (int64_t *)realloc(data, (130000)*sizeof(int64_t));
            /* FIX: Ensure realloc() was successful before assigning data to the memory block
            * allocated with realloc() */
            if (tmpData != NULL)
            {
                data = tmpData;
                
                data[0] = 10LL;
                printLongLongLine(data[0]);
            }
            free(data);
        }
"
16225,0,CWE78_OS_Command_Injection__char_file_execlp_14.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(globalFive==5)
    {
        {
            
            size_t dataLen = strlen(data);
            FILE * pFile;
            
            if (100-dataLen > 1)
            {
                pFile = fopen(FILENAME, ""r"");
                if (pFile != NULL)
                {
                    
                    if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                    {
                        printLine(""fgets() failed"");
                        
                        data[dataLen] = '\0';
                    }
                    fclose(pFile);
                }
            }
        }
    }
    /* execlp - searches for the location of the command among
     * the directories specified by the PATH environment variable */
    
"
4694,0,CWE134_Uncontrolled_Format_String__char_console_fprintf_53a.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        
        if (100-dataLen > 1)
        {
            
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgets() */
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
                    data[dataLen-1] = '\0';
                }
            }
            else
            {
                printLine(""fgets() failed"");
                
                data[dataLen] = '\0';
            }
        }
    }
"
19058,0,CWE190_Integer_Overflow__int64_t_max_square_54a.c,"    int64_t data;
    data = 0LL;
    
    data = LLONG_MAX;
"
17871,0,CWE190_Integer_Overflow__unsigned_int_max_add_81_bad.cpp,"Label Definition File: CWE190_Integer_Overflow.label.xml
Template File: sources-sinks-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 190 Integer Overflow
 * BadSource: max Set data to the max value for unsigned int
 * GoodSource: Set data to a small, non-zero number (two)
 * Sinks: add
 *    GoodSink: Ensure there will not be an overflow before adding 1 to data
 *    BadSink : Add 1 to data, which can cause an overflow
 * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE190_Integer_Overflow__unsigned_int_max_add_81.h""

namespace CWE190_Integer_Overflow__unsigned_int_max_add_81
{

void CWE190_Integer_Overflow__unsigned_int_max_add_81_bad::action(unsigned int data) const
{
    {
        
        unsigned int result = data + 1;
        printUnsignedLine(result);
    }
}

}
"
15513,1,CWE252_Unchecked_Return_Value__char_fprintf_11.c,"    if(globalReturnsFalse())
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        
        if (fprintf(stdout, ""%s\n"", ""string"") < 0)
        {
            printLine(""fprintf failed!"");
        }
"
8756,0,CWE197_Numeric_Truncation_Error__short_rand_81_bad.cpp,"Label Definition File: CWE197_Numeric_Truncation_Error__short.label.xml
Template File: sources-sink-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 197 Numeric Truncation Error
 * BadSource: rand Set data to result of RAND32(), which could be negative
 * GoodSource: Less than CHAR_MAX
 * Sinks:
 *    BadSink : Convert data to a char
 * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE197_Numeric_Truncation_Error__short_rand_81.h""

namespace CWE197_Numeric_Truncation_Error__short_rand_81
{

void CWE197_Numeric_Truncation_Error__short_rand_81_bad::action(short data) const
{
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
    }
}

}
"
5717,0,CWE401_Memory_Leak__int_malloc_84_bad.cpp,"Label Definition File: CWE401_Memory_Leak.c.label.xml
Template File: sources-sinks-84_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 401 Memory Leak
 * BadSource: malloc Allocate data using malloc()
 * GoodSource: Allocate data on the stack
 * Sinks:
 *    GoodSink: call free() on data
 *    BadSink : no deallocation of data
 * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE401_Memory_Leak__int_malloc_84.h""

namespace CWE401_Memory_Leak__int_malloc_84
{
CWE401_Memory_Leak__int_malloc_84_bad::CWE401_Memory_Leak__int_malloc_84_bad(int * dataCopy)
{
    data = dataCopy;
    
    data = (int *)malloc(100*sizeof(int));
    if (data == NULL) {exit(-1);}
    
    data[0] = 5;
    printIntLine(data[0]);
}

CWE401_Memory_Leak__int_malloc_84_bad::~CWE401_Memory_Leak__int_malloc_84_bad()
{
    
    ; 
}
}
"
12887,0,CWE457_Use_of_Uninitialized_Variable__double_array_declare_partial_init_62a.cpp,"    double * data;
    double dataUninitArray[10];
    data = dataUninitArray;
    badSource(data);
    
    {
        int i;
        for(i=0; i<10; i++)
        {
            printDoubleLine(data[i]);
        }
"
9544,0,CWE415_Double_Free__malloc_free_char_68a.c,"    char * data;
    
    data = NULL;
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    
    free(data);
    CWE415_Double_Free__malloc_free_char_68_badData = data;
"
5446,0,CWE590_Free_Memory_Not_on_Heap__delete_array_int_declare_33.cpp,"    int * data;
    int * &dataRef = data;
    data = NULL; 
    {
        
        int dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5;
            }
        }
        data = dataBuffer;
    }
    {
        int * data = dataRef;
        printIntLine(data[0]);
        
        delete [] data;
"
5590,0,CWE190_Integer_Overflow__char_fscanf_preinc_22a.c,"    char data;
    data = ' ';
    
    fscanf (stdin, ""%c"", &data);
    CWE190_Integer_Overflow__char_fscanf_preinc_22_badGlobal = 1; 
"
15326,0,CWE369_Divide_by_Zero__int_connect_socket_modulo_74a.cpp,"    int data;
    map<int, int> dataMap;
    
    data = -1;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
7082,0,CWE590_Free_Memory_Not_on_Heap__delete_array_int_declare_06.cpp,"    int * data;
    data = NULL; 
    if(STATIC_CONST_FIVE==5)
    {
        {
            
            int dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5;
                }
            }
            data = dataBuffer;
        }
    }
    printIntLine(data[0]);
    
"
17059,0,CWE469_Use_of_Pointer_Subtraction_to_Determine_Size__char_18.c,"    goto sink;
sink:
    {
        char string1[] = SOURCE_STRING;
        char string2[] = SOURCE_STRING;
        char * slashInString1;
        size_t indexOfSlashInString1;
        slashInString1 = strchr(string1, '/');
        if (slashInString1 == NULL)
        {
            exit(1);
        }
        
        indexOfSlashInString1 = (size_t)(slashInString1 - string2);
        
        printUnsignedLine(indexOfSlashInString1);
"
15882,0,CWE401_Memory_Leak__int64_t_realloc_34.c,"    int64_t * data;
    CWE401_Memory_Leak__int64_t_realloc_34_unionType myUnion;
    data = NULL;
    
    data = (int64_t *)realloc(data, 100*sizeof(int64_t));
    if (data == NULL) {exit(-1);}
    
    data[0] = 5LL;
    printLongLongLine(data[0]);
    myUnion.unionFirst = data;
    {
        int64_t * data = myUnion.unionSecond;
        
        ; 
"
16552,0,CWE252_Unchecked_Return_Value__char_rename_05.c,"    if(staticTrue)
    {
        
        RENAME(OLD_BAD_FILE_NAME, ""newbadfilename.txt"");
"
12191,0,CWE415_Double_Free__new_delete_array_int_45.cpp,"    int * data;
    
    data = NULL;
    data = new int[100];
    
    delete [] data;
    badData = data;
"
13499,0,CWE401_Memory_Leak__strdup_char_82a.cpp,"    char * data;
    data = NULL;
    {
        char myString[] = ""myString"";
        
        data = strdup(myString);
        
        printLine(data);
    }
    CWE401_Memory_Leak__strdup_char_82_base* baseObject = new CWE401_Memory_Leak__strdup_char_82_bad;
    baseObject->action(data);
"
711,0,CWE401_Memory_Leak__new_struct_twoIntsStruct_11.cpp,"    struct _twoIntsStruct * data;
    data = NULL;
    if(globalReturnsTrue())
    {
        
        data = new struct _twoIntsStruct;
        
        data->intOne = 0;
        data->intTwo = 0;
        printStructLine((twoIntsStruct *)data);
    }
    if(globalReturnsTrue())
    {
        
        ; 
"
3157,0,CWE401_Memory_Leak__twoIntsStruct_malloc_81a.cpp,"    twoIntsStruct * data;
    data = NULL;
    
    data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
    if (data == NULL) {exit(-1);}
    
    data[0].intOne = 0;
    data[0].intTwo = 0;
    printStructLine(&data[0]);
    const CWE401_Memory_Leak__twoIntsStruct_malloc_81_base& baseObject = CWE401_Memory_Leak__twoIntsStruct_malloc_81_bad();
"
12444,0,CWE190_Integer_Overflow__short_fscanf_square_04.c,"    short data;
    data = 0;
    if(STATIC_CONST_TRUE)
    {
        
        fscanf (stdin, ""%hd"", &data);
    }
    if(STATIC_CONST_TRUE)
    {
        {
            
            short result = data * data;
            printIntLine(result);
        }
"
1182,0,CWE197_Numeric_Truncation_Error__int_listen_socket_to_char_12.c,"    int data;
    
    data = -1;
    if(globalReturnsTrueOrFalse())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    else
    {
        
        data = CHAR_MAX-5;
    }
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
1977,0,CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_15.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    switch(6)
    {
    case 6:
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
    {
        char dest[100] = """";
        
        SNPRINTF(dest, 100-1, data);
        printLine(dest);
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
16069,0,CWE197_Numeric_Truncation_Error__int_rand_to_short_81a.cpp,"    int data;
    
    data = -1;
    
    data = RAND32();
    const CWE197_Numeric_Truncation_Error__int_rand_to_short_81_base& baseObject = CWE197_Numeric_Truncation_Error__int_rand_to_short_81_bad();
"
7817,0,CWE197_Numeric_Truncation_Error__int_listen_socket_to_short_06.c,"    int data;
    
    data = -1;
    if(STATIC_CONST_FIVE==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    {
        
        short shortData = (short)data;
        printShortLine(shortData);
"
14670,0,CWE590_Free_Memory_Not_on_Heap__delete_int64_t_alloca_74a.cpp,"    int64_t * data;
    map<int, int64_t *> dataMap;
    data = NULL; 
    {
        
        int64_t * dataBuffer = (int64_t *)ALLOCA(sizeof(int64_t));
        *dataBuffer = 5LL;
        data = dataBuffer;
    }
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
16540,0,CWE415_Double_Free__new_delete_class_07.cpp,"    TwoIntsClass * data;
    
    data = NULL;
    if(staticFive==5)
    {
        data = new TwoIntsClass;
        
        delete data;
    }
    if(staticFive==5)
    {
        
        delete data;
"
11774,0,CWE78_OS_Command_Injection__char_listen_socket_popen_52a.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
349,0,CWE401_Memory_Leak__new_char_31.cpp,"    char * data;
    data = NULL;
    
    data = new char;
    
    *data = 'A';
    printHexCharLine(*data);
    {
        char * dataCopy = data;
        char * data = dataCopy;
        
        ; 
"
3012,0,CWE415_Double_Free__new_delete_struct_82_bad.cpp,"Label Definition File: CWE415_Double_Free__new_delete.label.xml
Template File: sources-sinks-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 415 Double Free
 * BadSource:  Allocate data using new and Deallocae data using delete
 * GoodSource: Allocate data using new
 * Sinks:
 *    GoodSink: do nothing
 *    BadSink : Deallocate data using delete
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE415_Double_Free__new_delete_struct_82.h""

namespace CWE415_Double_Free__new_delete_struct_82
{

void CWE415_Double_Free__new_delete_struct_82_bad::action(twoIntsStruct * data)
{
    
    delete data;
}

}
"
8931,0,CWE190_Integer_Overflow__int_listen_socket_preinc_64a.c,"    int data;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
2656,0,CWE252_Unchecked_Return_Value__char_fread_05.c,"    if(staticTrue)
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            
            fread((char *)data, sizeof(char), (size_t)(100-1), stdin);
        }
"
5950,1,CWE758_Undefined_Behavior__struct_alloca_use_09.c,"    if(GLOBAL_CONST_FALSE)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            twoIntsStruct data;
            twoIntsStruct * pointer = (twoIntsStruct *)ALLOCA(sizeof(twoIntsStruct));
            data.intOne = 1;
            data.intTwo = 2;
            *pointer = data; 
            {
                twoIntsStruct data = *pointer;
                printIntLine(data.intOne);
                printIntLine(data.intTwo);
            }
        }
"
3195,1,CWE252_Unchecked_Return_Value__char_fread_02.c,"    if(0)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            
            if (fread((char *)data, sizeof(char), (size_t)(100-1), stdin) != 100-1)
            {
                printLine(""fread failed!"");
            }
        }
"
486,0,CWE476_NULL_Pointer_Dereference__long_34.c,"    long * data;
    CWE476_NULL_Pointer_Dereference__long_34_unionType myUnion;
    
    data = NULL;
    myUnion.unionFirst = data;
    {
        long * data = myUnion.unionSecond;
        
        printLongLine(*data);
"
14752,0,CWE415_Double_Free__new_delete_array_char_83a.cpp,"    char * data;
    
    data = NULL;
"
14841,0,CWE758_Undefined_Behavior__char_new_use_15.cpp,"    switch(6)
    {
    case 6:
    {
        char * pointer = new char;
        char data = *pointer; 
        delete pointer;
        printHexCharLine(data);
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
2110,0,CWE78_OS_Command_Injection__char_file_execlp_53a.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        FILE * pFile;
        
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
"
14821,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_05.c,"    size_t data;
    
    data = 0;
    if(staticTrue)
    {
        
        fscanf(stdin, ""%zu"", &data);
    }
    if(staticTrue)
    {
        {
            char * myString;
            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
             * for the strcpy() function to not cause a buffer overflow */
            
            if (data > strlen(HELLO_STRING))
            {
                myString = (char *)malloc(data*sizeof(char));
                if (myString == NULL) {exit(-1);}
                
                strcpy(myString, HELLO_STRING);
                printLine(myString);
                free(myString);
            }
            else
            {
                printLine(""Input is less than the length of the source string"");
            }
        }
"
18521,0,CWE190_Integer_Overflow__int64_t_rand_add_13.c,"    int64_t data;
    data = 0LL;
    if(GLOBAL_CONST_FIVE==5)
    {
        
        data = (int64_t)RAND64();
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            
            int64_t result = data + 1;
            printLongLongLine(result);
        }
"
6839,0,CWE590_Free_Memory_Not_on_Heap__delete_array_int_alloca_63a.cpp,"    int * data;
    data = NULL; 
    {
        
        int * dataBuffer = (int *)ALLOCA(100*sizeof(int));
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5;
            }
        }
        data = dataBuffer;
    }
"
7544,0,CWE190_Integer_Overflow__int_connect_socket_add_63a.c,"    int data;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
9366,0,CWE590_Free_Memory_Not_on_Heap__delete_long_declare_44.cpp,"    long * data;
    
    void (*funcPtr) (long *) = badSink;
    data = NULL; 
    {
        
        long dataBuffer;
        dataBuffer = 5L;
        data = &dataBuffer;
    }
    
"
15681,0,CWE563_Unused_Variable__unused_init_variable_long_81a.cpp,"    long data;
    
    data = 5L;
    const CWE563_Unused_Variable__unused_init_variable_long_81_base& baseObject = CWE563_Unused_Variable__unused_init_variable_long_81_bad();
"
13866,0,CWE415_Double_Free__new_delete_array_char_66a.cpp,"    char * data;
    char * dataArray[5];
    
    data = NULL;
    data = new char[100];
    
    delete [] data;
    
    dataArray[2] = data;
"
12433,0,CWE190_Integer_Overflow__unsigned_int_max_add_06.c,"    unsigned int data;
    data = 0;
    if(STATIC_CONST_FIVE==5)
    {
        
        data = UINT_MAX;
    }
    if(STATIC_CONST_FIVE==5)
    {
        {
            
            unsigned int result = data + 1;
            printUnsignedLine(result);
        }
"
11266,0,CWE415_Double_Free__new_delete_class_84a.cpp,"    TwoIntsClass * data;
    
    data = NULL;
    CWE415_Double_Free__new_delete_class_84_bad * badObject = new CWE415_Double_Free__new_delete_class_84_bad(data);
"
15129,0,CWE190_Integer_Overflow__int_listen_socket_postinc_01.c,"    int data;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    {
        
        data++;
        int result = data;
        printIntLine(result);
"
18413,0,CWE401_Memory_Leak__new_twoIntsStruct_74a.cpp,"    twoIntsStruct * data;
    map<int, twoIntsStruct *> dataMap;
    data = NULL;
    
    data = new twoIntsStruct;
    
    data->intOne = 0;
    data->intTwo = 0;
    printStructLine(data);
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
9680,0,CWE401_Memory_Leak__char_malloc_31.c,"    char * data;
    data = NULL;
    
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    
    strcpy(data, ""A String"");
    printLine(data);
    {
        char * dataCopy = data;
        char * data = dataCopy;
        
        ; 
"
14616,0,CWE590_Free_Memory_Not_on_Heap__delete_array_class_declare_06.cpp,"    TwoIntsClass * data;
    data = NULL; 
    if(STATIC_CONST_FIVE==5)
    {
        {
            
            TwoIntsClass dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i].intOne = 1;
                    dataBuffer[i].intTwo = 1;
                }
            }
            data = dataBuffer;
        }
    }
    printIntLine(data[0].intOne);
    
"
17473,0,CWE190_Integer_Overflow__char_max_multiply_81a.cpp,"    char data;
    data = ' ';
    
    data = CHAR_MAX;
    const CWE190_Integer_Overflow__char_max_multiply_81_base& baseObject = CWE190_Integer_Overflow__char_max_multiply_81_bad();
"
14771,0,CWE134_Uncontrolled_Format_String__char_file_printf_15.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    switch(6)
    {
    case 6:
    {
        
        size_t dataLen = strlen(data);
        FILE * pFile;
        
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
        
        printf(data);
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
4304,0,CWE190_Integer_Overflow__int_fscanf_add_17.c,"    int i,j;
    int data;
    
    data = 0;
    for(i = 0; i < 1; i++)
    {
        
        fscanf(stdin, ""%d"", &data);
    }
    for(j = 0; j < 1; j++)
    {
        {
            
            int result = data + 1;
            printIntLine(result);
        }
"
1417,0,CWE190_Integer_Overflow__char_rand_square_21.c,"    char data;
    data = ' ';
    
    data = (char)RAND32();
    badStatic = 1; 
"
10600,0,CWE690_NULL_Deref_From_Return__int64_t_calloc_32.c,"    int64_t * data;
    int64_t * *dataPtr1 = &data;
    int64_t * *dataPtr2 = &data;
    data = NULL; 
    {
        int64_t * data = *dataPtr1;
        
        data = (int64_t *)calloc(1, sizeof(int64_t));
        *dataPtr1 = data;
    }
    {
        int64_t * data = *dataPtr2;
        
        data[0] = 5LL;
        printLongLongLine(data[0]);
        free(data);
"
16513,0,CWE590_Free_Memory_Not_on_Heap__delete_array_long_declare_01.cpp,"    long * data;
    data = NULL; 
    {
        
        long dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5L;
            }
        }
        data = dataBuffer;
    }
    printLongLine(data[0]);
    
"
1940,0,CWE401_Memory_Leak__char_calloc_82_bad.cpp,"Label Definition File: CWE401_Memory_Leak.c.label.xml
Template File: sources-sinks-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 401 Memory Leak
 * BadSource: calloc Allocate data using calloc()
 * GoodSource: Allocate data on the stack
 * Sinks:
 *    GoodSink: call free() on data
 *    BadSink : no deallocation of data
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE401_Memory_Leak__char_calloc_82.h""

namespace CWE401_Memory_Leak__char_calloc_82
{

void CWE401_Memory_Leak__char_calloc_82_bad::action(char * data)
{
    
    ; 
}

}
"
4753,0,CWE78_OS_Command_Injection__char_environment_execl_65a.c,"    char * data;
    
    void (*funcPtr) (char *) = CWE78_OS_Command_Injection__char_environment_execl_65b_badSink;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        
        if (environment != NULL)
        {
            
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    
"
8999,0,CWE190_Integer_Overflow__int64_t_max_postinc_01.c,"    int64_t data;
    data = 0LL;
    
    data = LLONG_MAX;
    {
        
        data++;
        int64_t result = data;
        printLongLongLine(result);
"
16691,0,CWE190_Integer_Overflow__int64_t_fscanf_square_31.c,"    int64_t data;
    data = 0LL;
    
    fscanf (stdin, ""%"" SCNd64, &data);
    {
        int64_t dataCopy = data;
        int64_t data = dataCopy;
        {
            
            int64_t result = data * data;
            printLongLongLine(result);
        }
"
6924,0,CWE758_Undefined_Behavior__int_pointer_alloca_use_11.c,"    if(globalReturnsTrue())
    {
        {
            int * * pointer = (int * *)ALLOCA(sizeof(int *));
            int * data = *pointer; 
            printIntLine(*data);
        }
"
14573,0,CWE457_Use_of_Uninitialized_Variable__double_array_alloca_no_init_62a.cpp,"    double * data;
    data = (double *)ALLOCA(10*sizeof(double));
    badSource(data);
    
    {
        int i;
        for(i=0; i<10; i++)
        {
            printDoubleLine(data[i]);
        }
"
6480,0,CWE590_Free_Memory_Not_on_Heap__delete_int64_t_placement_new_81_bad.cpp,"Label Definition File: CWE590_Free_Memory_Not_on_Heap__delete.pointer.label.xml
Template File: sources-sink-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 590 Free Memory Not on Heap
 * BadSource: placement_new Data buffer is declared on the stack
 * GoodSource: Allocate memory on the heap
 * Sinks:
 *    BadSink : Print then free data
 * Flow Variant: 81 Data flow: data passed in a parameter to a virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE590_Free_Memory_Not_on_Heap__delete_int64_t_placement_new_81.h""

namespace CWE590_Free_Memory_Not_on_Heap__delete_int64_t_placement_new_81
{

void CWE590_Free_Memory_Not_on_Heap__delete_int64_t_placement_new_81_bad::action(int64_t * data) const
{
    printLongLongLine(*data);
    
    delete data;
}

}
"
17805,0,CWE415_Double_Free__new_delete_int_43.cpp,"    int * data;
    
    data = NULL;
    badSource(data);
    
"
16705,0,CWE134_Uncontrolled_Format_String__char_console_snprintf_33.cpp,"    char * data;
    char * &dataRef = data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        
        if (100-dataLen > 1)
        {
            
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgets() */
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
                    data[dataLen-1] = '\0';
                }
            }
            else
            {
                printLine(""fgets() failed"");
                
                data[dataLen] = '\0';
            }
        }
    }
    {
        char * data = dataRef;
        {
            char dest[100] = """";
            
            SNPRINTF(dest, 100-1, data);
            printLine(dest);
        }
"
15037,0,CWE590_Free_Memory_Not_on_Heap__delete_int64_t_alloca_52a.cpp,"    int64_t * data;
    data = NULL; 
    {
        
        int64_t * dataBuffer = (int64_t *)ALLOCA(sizeof(int64_t));
        *dataBuffer = 5LL;
        data = dataBuffer;
    }
"
14807,0,CWE690_NULL_Deref_From_Return__long_realloc_05.c,"    long * data;
    data = NULL; 
    
    data = (long *)realloc(data, 1*sizeof(long));
    if(staticTrue)
    {
        
        data[0] = 5L;
        printLongLine(data[0]);
        free(data);
"
17584,0,CWE457_Use_of_Uninitialized_Variable__double_array_malloc_no_init_43.cpp,"    double * data;
    data = (double *)malloc(10*sizeof(double));
    if (data == NULL) {exit(-1);}
    badSource(data);
    
    {
        int i;
        for(i=0; i<10; i++)
        {
            printDoubleLine(data[i]);
        }
"
8654,0,CWE401_Memory_Leak__struct_twoIntsStruct_realloc_45.c,"    struct _twoIntsStruct * data;
    data = NULL;
    
    data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));
    if (data == NULL) {exit(-1);}
    
    data[0].intOne = 0;
    data[0].intTwo = 0;
    printStructLine((twoIntsStruct *)&data[0]);
    CWE401_Memory_Leak__struct_twoIntsStruct_realloc_45_badData = data;
"
10576,0,CWE369_Divide_by_Zero__int_rand_modulo_66a.c,"    int data;
    int dataArray[5];
    
    data = -1;
    
    data = RAND32();
    
    dataArray[2] = data;
"
11760,0,CWE369_Divide_by_Zero__float_fscanf_63a.c,"    float data;
    
    data = 0.0F;
    
    fscanf (stdin, ""%f"", &data);
"
9040,1,CWE476_NULL_Pointer_Dereference__binary_if_13.c,"    if(GLOBAL_CONST_FIVE!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            twoIntsStruct *twoIntsStructPointer = NULL;
            /* FIX: Use && in the if statement so that if the left side of the expression fails then
             * the right side will not be evaluated */
            if ((twoIntsStructPointer != NULL) && (twoIntsStructPointer->intOne == 5))
            {
                printLine(""intOne == 5"");
            }
        }
"
10505,0,CWE190_Integer_Overflow__short_fscanf_multiply_42.c,"    short data;
    data = 0;
    data = badSource(data);
    if(data > 0) 
    {
        
        short result = data * 2;
        printIntLine(result);
"
3194,0,CWE190_Integer_Overflow__unsigned_int_rand_square_82a.cpp,"    unsigned int data;
    data = 0;
    
    data = (unsigned int)RAND32();
    CWE190_Integer_Overflow__unsigned_int_rand_square_82_base* baseObject = new CWE190_Integer_Overflow__unsigned_int_rand_square_82_bad;
    baseObject->action(data);
"
5229,0,CWE190_Integer_Overflow__int_fscanf_postinc_08.c,"    int data;
    
    data = 0;
    if(staticReturnsTrue())
    {
        
        fscanf(stdin, ""%d"", &data);
    }
    if(staticReturnsTrue())
    {
        {
            
            data++;
            int result = data;
            printIntLine(result);
        }
"
5276,0,CWE590_Free_Memory_Not_on_Heap__free_int64_t_declare_53a.c,"    int64_t * data;
    data = NULL; 
    {
        
        int64_t dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5LL;
            }
        }
        data = dataBuffer;
    }
"
5232,0,CWE252_Unchecked_Return_Value__char_fwrite_05.c,"    if(staticTrue)
    {
        
        fwrite((char *)""string"", sizeof(char), strlen(""string""), stdout);
"
19298,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_13.c,"    size_t data;
    
    data = 0;
    if(GLOBAL_CONST_FIVE==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = strtoul(inputBuffer, NULL, 0);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            char * myString;
            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
             * for the strcpy() function to not cause a buffer overflow */
            
            if (data > strlen(HELLO_STRING))
            {
                myString = (char *)malloc(data*sizeof(char));
                if (myString == NULL) {exit(-1);}
                
                strcpy(myString, HELLO_STRING);
                printLine(myString);
                free(myString);
            }
            else
            {
                printLine(""Input is less than the length of the source string"");
            }
        }
"
364,1,CWE758_Undefined_Behavior__char_malloc_use_08.c,"    if(staticReturnsTrue())
    {
        {
            char data;
            char * pointer = (char *)malloc(sizeof(char));
            if (pointer == NULL) {exit(-1);}
            data = 5;
            *pointer = data; 
            {
                char data = *pointer;
                printHexCharLine(data);
            }
            free(pointer);
        }
"
5278,0,CWE190_Integer_Overflow__int_listen_socket_multiply_31.c,"    int data;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    {
        int dataCopy = data;
        int data = dataCopy;
        if(data > 0) 
        {
            
            int result = data * 2;
            printIntLine(result);
        }
"
12011,0,CWE457_Use_of_Uninitialized_Variable__new_struct_array_partial_init_14.cpp,"    twoIntsStruct * data;
    data = new twoIntsStruct[10];
    if(globalFive==5)
    {
        
        {
            int i;
            for(i=0; i<(10/2); i++)
            {
                data[i].intOne = i;
                data[i].intTwo = i;
            }
        }
    }
    if(globalFive==5)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i].intOne);
                printIntLine(data[i].intTwo);
            }
        }
        
        delete [] data;
"
17839,1,CWE587_Assignment_of_Fixed_Address_to_Pointer__basic_03.c,"    if(5==5)
    {
        {
            
            char charStack = 'a';
            char *charPointer = &charStack;
            printHexCharLine(*charPointer);
        }
"
6011,0,CWE78_OS_Command_Injection__char_file_system_04.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(STATIC_CONST_TRUE)
    {
        {
            
            size_t dataLen = strlen(data);
            FILE * pFile;
            
            if (100-dataLen > 1)
            {
                pFile = fopen(FILENAME, ""r"");
                if (pFile != NULL)
                {
                    
                    if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                    {
                        printLine(""fgets() failed"");
                        
                        data[dataLen] = '\0';
                    }
                    fclose(pFile);
                }
            }
        }
    }
    
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
"
9100,0,CWE457_Use_of_Uninitialized_Variable__int_62a.cpp,"    int data;
    badSource(data);
    
"
8386,0,CWE78_OS_Command_Injection__char_connect_socket_execl_16.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    while(1)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET connectSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
"
15400,0,CWE401_Memory_Leak__struct_twoIntsStruct_realloc_13.c,"    struct _twoIntsStruct * data;
    data = NULL;
    if(GLOBAL_CONST_FIVE==5)
    {
        
        data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));
        if (data == NULL) {exit(-1);}
        
        data[0].intOne = 0;
        data[0].intTwo = 0;
        printStructLine((twoIntsStruct *)&data[0]);
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        
        ; 
"
635,0,CWE590_Free_Memory_Not_on_Heap__free_int64_t_declare_54a.c,"    int64_t * data;
    data = NULL; 
    {
        
        int64_t dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5LL;
            }
        }
        data = dataBuffer;
    }
"
16463,0,CWE190_Integer_Overflow__unsigned_int_rand_postinc_16.c,"    unsigned int data;
    data = 0;
    while(1)
    {
        
        data = (unsigned int)RAND32();
        break;
    }
    while(1)
    {
        {
            
            data++;
            unsigned int result = data;
            printUnsignedLine(result);
        }
        break;
"
17468,0,CWE590_Free_Memory_Not_on_Heap__delete_char_declare_16.cpp,"    char * data;
    data = NULL; 
    while(1)
    {
        {
            
            char dataBuffer;
            dataBuffer = 'A';
            data = &dataBuffer;
        }
        break;
    }
    printHexCharLine(*data);
    
"
4831,0,CWE401_Memory_Leak__struct_twoIntsStruct_malloc_82_bad.cpp,"Label Definition File: CWE401_Memory_Leak.c.label.xml
Template File: sources-sinks-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 401 Memory Leak
 * BadSource: malloc Allocate data using malloc()
 * GoodSource: Allocate data on the stack
 * Sinks:
 *    GoodSink: call free() on data
 *    BadSink : no deallocation of data
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE401_Memory_Leak__struct_twoIntsStruct_malloc_82.h""

namespace CWE401_Memory_Leak__struct_twoIntsStruct_malloc_82
{

void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_82_bad::action(struct _twoIntsStruct * data)
{
    
    ; 
}

}
"
14387,0,CWE190_Integer_Overflow__unsigned_int_rand_postinc_15.c,"    unsigned int data;
    data = 0;
    switch(6)
    {
    case 6:
        
        data = (unsigned int)RAND32();
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
    {
        
        data++;
        unsigned int result = data;
        printUnsignedLine(result);
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
11842,0,CWE590_Free_Memory_Not_on_Heap__delete_class_declare_68a.cpp,"    TwoIntsClass * data;
    data = NULL; 
    {
        
        TwoIntsClass dataBuffer;
        dataBuffer.intOne = 1;
        dataBuffer.intTwo = 1;
        data = &dataBuffer;
    }
    CWE590_Free_Memory_Not_on_Heap__delete_class_declare_68_badData = data;
"
16336,0,CWE590_Free_Memory_Not_on_Heap__delete_struct_placement_new_72a.cpp,"    twoIntsStruct * data;
    vector<twoIntsStruct *> dataVector;
    data = NULL; 
    {
        
        char buffer[sizeof(twoIntsStruct)];
        twoIntsStruct * dataBuffer = new(buffer) twoIntsStruct;
        dataBuffer->intOne = 1;
        dataBuffer->intTwo = 1;
        data = dataBuffer;
    }
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
4641,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_12.c,"    size_t data;
    
    data = 0;
    if(globalReturnsTrueOrFalse())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = strtoul(inputBuffer, NULL, 0);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    else
    {
        
        data = 20;
    }
    if(globalReturnsTrueOrFalse())
    {
        {
            char * myString;
            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
             * for the strcpy() function to not cause a buffer overflow */
            
            if (data > strlen(HELLO_STRING))
            {
                myString = (char *)malloc(data*sizeof(char));
                if (myString == NULL) {exit(-1);}
                
                strcpy(myString, HELLO_STRING);
                printLine(myString);
                free(myString);
            }
            else
            {
                printLine(""Input is less than the length of the source string"");
            }
        }
    }
    else
    {
        {
            char * myString;
            /* FIX: Include a MAXIMUM limitation for memory allocation and a check to ensure data is large enough
             * for the strcpy() function to not cause a buffer overflow */
            
            if (data > strlen(HELLO_STRING) && data < 100)
            {
                myString = (char *)malloc(data*sizeof(char));
                if (myString == NULL) {exit(-1);}
                
                strcpy(myString, HELLO_STRING);
                printLine(myString);
                free(myString);
            }
            else
            {
                printLine(""Input is less than the length of the source string or too large"");
            }
        }
"
13245,0,CWE690_NULL_Deref_From_Return__long_realloc_84_bad.cpp,"Label Definition File: CWE690_NULL_Deref_From_Return.free.label.xml
Template File: source-sinks-84_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 690 Unchecked Return Value To NULL Pointer
 * BadSource: realloc Allocate data using realloc()
 * Sinks:
 *    GoodSink: Check to see if the data allocation failed and if not, use data
 *    BadSink : Don't check for NULL and use data
 * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE690_NULL_Deref_From_Return__long_realloc_84.h""

namespace CWE690_NULL_Deref_From_Return__long_realloc_84
{
CWE690_NULL_Deref_From_Return__long_realloc_84_bad::CWE690_NULL_Deref_From_Return__long_realloc_84_bad(long * dataCopy)
{
    data = dataCopy;
    
    data = (long *)realloc(data, 1*sizeof(long));
}

CWE690_NULL_Deref_From_Return__long_realloc_84_bad::~CWE690_NULL_Deref_From_Return__long_realloc_84_bad()
{
    
    data[0] = 5L;
    printLongLine(data[0]);
    free(data);
}
}
"
14187,0,CWE758_Undefined_Behavior__char_pointer_new_use_12.cpp,"    if(globalReturnsTrueOrFalse())
    {
        {
            char * * pointer = new char *;
            char * data = *pointer; 
            delete pointer;
            printLine(data);
        }
    }
    else
    {
        {
            char * data;
            data = ""string"";
            char * * pointer = new char *;
            *pointer = data; 
            {
                char * data = *pointer;
                printLine(data);
            }
            delete pointer;
        }
"
2015,0,CWE590_Free_Memory_Not_on_Heap__delete_array_int_declare_81_bad.cpp,"Label Definition File: CWE590_Free_Memory_Not_on_Heap__delete_array.label.xml
Template File: sources-sink-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 590 Free Memory Not on Heap
 * BadSource: declare Data buffer is declared on the stack
 * GoodSource: Allocate memory on the heap
 * Sinks:
 *    BadSink : Print then free data
 * Flow Variant: 81 Data flow: data passed in a parameter to a virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE590_Free_Memory_Not_on_Heap__delete_array_int_declare_81.h""

namespace CWE590_Free_Memory_Not_on_Heap__delete_array_int_declare_81
{

void CWE590_Free_Memory_Not_on_Heap__delete_array_int_declare_81_bad::action(int * data) const
{
    printIntLine(data[0]);
    
    delete [] data;
}

}
"
8944,0,CWE415_Double_Free__new_delete_array_long_07.cpp,"    long * data;
    
    data = NULL;
    if(staticFive==5)
    {
        data = new long[100];
        
        delete [] data;
    }
    if(staticFive==5)
    {
        
        delete [] data;
"
17646,0,CWE690_NULL_Deref_From_Return__int64_t_malloc_08.c,"    int64_t * data;
    data = NULL; 
    
    data = (int64_t *)malloc(1*sizeof(int64_t));
    if(staticReturnsTrue())
    {
        
        data[0] = 5LL;
        printLongLongLine(data[0]);
        free(data);
"
5416,1,CWE758_Undefined_Behavior__int_pointer_alloca_use_03.c,"    if(5==5)
    {
        {
            int * data;
            int * * pointer = (int * *)ALLOCA(sizeof(int *));
            
            data = (int *)malloc(sizeof(int));
            if (data == NULL) {exit(-1);}
            *data = 5;
            *pointer = data; 
            {
                int * data = *pointer;
                printIntLine(*data);
            }
        }
"
14539,0,CWE690_NULL_Deref_From_Return__struct_calloc_15.c,"    twoIntsStruct * data;
    data = NULL; 
    
    data = (twoIntsStruct *)calloc(1, sizeof(twoIntsStruct));
    switch(6)
    {
    case 6:
        
        data[0].intOne = 1;
        data[0].intTwo = 1;
        printStructLine(&data[0]);
        free(data);
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
8788,0,CWE416_Use_After_Free__new_delete_class_43.cpp,"    TwoIntsClass * data;
    
    data = NULL;
    badSource(data);
    
    printIntLine(data->intOne);
"
3348,0,CWE758_Undefined_Behavior__long_new_use_06.cpp,"    if(STATIC_CONST_FIVE==5)
    {
        {
            long * pointer = new long;
            long data = *pointer; 
            delete pointer;
            printLongLine(data);
        }
"
3018,1,CWE476_NULL_Pointer_Dereference__binary_if_15.c,"    switch(6)
    {
    case 6:
    {
        twoIntsStruct *twoIntsStructPointer = NULL;
        /* FIX: Use && in the if statement so that if the left side of the expression fails then
         * the right side will not be evaluated */
        if ((twoIntsStructPointer != NULL) && (twoIntsStructPointer->intOne == 5))
        {
            printLine(""intOne == 5"");
        }
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
12480,0,CWE590_Free_Memory_Not_on_Heap__delete_array_char_static_51a.cpp,"    char * data;
    data = NULL; 
    {
        
        static char dataBuffer[100];
        memset(dataBuffer, 'A', 100-1); 
        dataBuffer[100-1] = '\0'; 
        data = dataBuffer;
    }
"
1162,0,CWE78_OS_Command_Injection__char_listen_socket_execl_03.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(5==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                data[dataLen + recvResult / sizeof(char)] = '\0';
                
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    
    
"
14233,0,CWE78_OS_Command_Injection__char_listen_socket_execl_43.cpp,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    badSource(data);
    
    
"
12535,0,CWE190_Integer_Overflow__int64_t_rand_add_73a.cpp,"    int64_t data;
    list<int64_t> dataList;
    data = 0LL;
    
    data = (int64_t)RAND64();
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
11716,1,CWE758_Undefined_Behavior__int_malloc_use_10.c,"    if(globalFalse)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            int data;
            int * pointer = (int *)malloc(sizeof(int));
            if (pointer == NULL) {exit(-1);}
            data = 5;
            *pointer = data; 
            {
                int data = *pointer;
                printIntLine(data);
            }
            free(pointer);
        }
"
12041,0,CWE134_Uncontrolled_Format_String__char_file_snprintf_18.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    goto source;
source:
    {
        
        size_t dataLen = strlen(data);
        FILE * pFile;
        
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
    goto sink;
sink:
    {
        char dest[100] = """";
        
        SNPRINTF(dest, 100-1, data);
        printLine(dest);
"
8179,0,CWE590_Free_Memory_Not_on_Heap__delete_int64_t_alloca_07.cpp,"    int64_t * data;
    data = NULL; 
    if(staticFive==5)
    {
        {
            
            int64_t * dataBuffer = (int64_t *)ALLOCA(sizeof(int64_t));
            *dataBuffer = 5LL;
            data = dataBuffer;
        }
    }
    printLongLongLine(*data);
    
"
8398,0,CWE690_NULL_Deref_From_Return__int_realloc_63a.c,"    int * data;
    data = NULL; 
    
    data = (int *)realloc(data, 1*sizeof(int));
"
13017,0,CWE369_Divide_by_Zero__int_rand_divide_84a.cpp,"    int data;
    
    data = -1;
    CWE369_Divide_by_Zero__int_rand_divide_84_bad * badObject = new CWE369_Divide_by_Zero__int_rand_divide_84_bad(data);
"
11122,0,CWE197_Numeric_Truncation_Error__int_rand_to_short_16.c,"    int data;
    
    data = -1;
    while(1)
    {
        
        data = RAND32();
        break;
    }
    {
        
        short shortData = (short)data;
        printShortLine(shortData);
"
2049,0,CWE590_Free_Memory_Not_on_Heap__delete_array_class_static_06.cpp,"    TwoIntsClass * data;
    data = NULL; 
    if(STATIC_CONST_FIVE==5)
    {
        {
            
            static TwoIntsClass dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i].intOne = 1;
                    dataBuffer[i].intTwo = 1;
                }
            }
            data = dataBuffer;
        }
    }
    printIntLine(data[0].intOne);
    
"
7408,0,CWE590_Free_Memory_Not_on_Heap__delete_int64_t_declare_17.cpp,"    int i;
    int64_t * data;
    data = NULL; 
    for(i = 0; i < 1; i++)
    {
        {
            
            int64_t dataBuffer;
            dataBuffer = 5LL;
            data = &dataBuffer;
        }
    }
    printLongLongLine(*data);
    
"
9806,0,CWE190_Integer_Overflow__char_fscanf_add_66a.c,"    char data;
    char dataArray[5];
    data = ' ';
    
    fscanf (stdin, ""%c"", &data);
    
    dataArray[2] = data;
"
5679,0,CWE78_OS_Command_Injection__char_file_execlp_74a.cpp,"    char * data;
    map<int, char *> dataMap;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        FILE * pFile;
        
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
6201,0,CWE758_Undefined_Behavior__char_malloc_use_16.c,"    while(1)
    {
        {
            char * pointer = (char *)malloc(sizeof(char));
            if (pointer == NULL) {exit(-1);}
            char data = *pointer; 
            free(pointer);
            printHexCharLine(data);
        }
        break;
"
13544,0,CWE190_Integer_Overflow__int_connect_socket_multiply_83a.cpp,"    int data;
    
    data = 0;
"
7835,0,CWE415_Double_Free__malloc_free_char_82a.cpp,"    char * data;
    
    data = NULL;
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    
    free(data);
    CWE415_Double_Free__malloc_free_char_82_base* baseObject = new CWE415_Double_Free__malloc_free_char_82_bad;
    baseObject->action(data);
"
4880,0,CWE197_Numeric_Truncation_Error__int_rand_to_short_34.c,"    int data;
    CWE197_Numeric_Truncation_Error__int_rand_to_short_34_unionType myUnion;
    
    data = -1;
    
    data = RAND32();
    myUnion.unionFirst = data;
    {
        int data = myUnion.unionSecond;
        {
            
            short shortData = (short)data;
            printShortLine(shortData);
        }
"
8237,1,CWE252_Unchecked_Return_Value__char_fputc_04.c,"    if(STATIC_CONST_TRUE)
    {
        
        if (fputc((int)'A', stdout) == EOF)
        {
            printLine(""fputc failed!"");
        }
"
18779,0,CWE190_Integer_Overflow__char_max_multiply_44.c,"    char data;
    
    void (*funcPtr) (char) = badSink;
    data = ' ';
    
    data = CHAR_MAX;
    
"
4193,1,CWE758_Undefined_Behavior__int_malloc_use_14.c,"    if(globalFive!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            int data;
            int * pointer = (int *)malloc(sizeof(int));
            if (pointer == NULL) {exit(-1);}
            data = 5;
            *pointer = data; 
            {
                int data = *pointer;
                printIntLine(data);
            }
            free(pointer);
        }
"
17351,0,CWE416_Use_After_Free__malloc_free_int_11.c,"    int * data;
    
    data = NULL;
    if(globalReturnsTrue())
    {
        data = (int *)malloc(100*sizeof(int));
        if (data == NULL) {exit(-1);}
        {
            size_t i;
            for(i = 0; i < 100; i++)
            {
                data[i] = 5;
            }
        }
        
        free(data);
    }
    if(globalReturnsTrue())
    {
        
        printIntLine(data[0]);
        
"
19524,0,CWE190_Integer_Overflow__char_max_add_15.c,"    char data;
    data = ' ';
    switch(6)
    {
    case 6:
        
        data = CHAR_MAX;
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
    {
        
        char result = data + 1;
        printHexCharLine(result);
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
13551,0,CWE197_Numeric_Truncation_Error__short_fgets_41.c,"    short data;
    
    data = -1;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = (short)atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
"
7440,0,CWE190_Integer_Overflow__int64_t_rand_postinc_05.c,"    int64_t data;
    data = 0LL;
    if(staticTrue)
    {
        
        data = (int64_t)RAND64();
    }
    if(staticTrue)
    {
        {
            
            data++;
            int64_t result = data;
            printLongLongLine(result);
        }
"
6525,0,CWE197_Numeric_Truncation_Error__short_listen_socket_82_bad.cpp,"Label Definition File: CWE197_Numeric_Truncation_Error__short.label.xml
Template File: sources-sink-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 197 Numeric Truncation Error
 * BadSource: listen_socket Read data using a listen socket (server side)
 * GoodSource: Less than CHAR_MAX
 * Sinks:
 *    BadSink : Convert data to a char
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE197_Numeric_Truncation_Error__short_listen_socket_82.h""

namespace CWE197_Numeric_Truncation_Error__short_listen_socket_82
{

void CWE197_Numeric_Truncation_Error__short_listen_socket_82_bad::action(short data)
{
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
    }
}

}
"
7831,1,CWE252_Unchecked_Return_Value__char_scanf_18.c,"    goto sink;
sink:
    {
        /* By initializing dataBuffer, we ensure this will not be the
         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
        char dataBuffer[100] = """";
        char * data = dataBuffer;
        
        if (scanf(""%99s\0"", data) == EOF)
        {
            printLine(""scanf failed!"");
        }
"
11171,0,CWE78_OS_Command_Injection__char_file_system_17.c,"    int i;
    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    for(i = 0; i < 1; i++)
    {
        {
            
            size_t dataLen = strlen(data);
            FILE * pFile;
            
            if (100-dataLen > 1)
            {
                pFile = fopen(FILENAME, ""r"");
                if (pFile != NULL)
                {
                    
                    if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                    {
                        printLine(""fgets() failed"");
                        
                        data[dataLen] = '\0';
                    }
                    fclose(pFile);
                }
            }
        }
    }
    
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
"
9168,0,CWE78_OS_Command_Injection__char_environment_execlp_67a.c,"    char * data;
    CWE78_OS_Command_Injection__char_environment_execlp_67_structType myStruct;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        
        if (environment != NULL)
        {
            
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    myStruct.structFirst = data;
"
10254,0,CWE78_OS_Command_Injection__char_connect_socket_execlp_66a.c,"    char * data;
    char * dataArray[5];
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
    dataArray[2] = data;
"
8668,0,CWE190_Integer_Overflow__short_max_add_81a.cpp,"    short data;
    data = 0;
    
    data = SHRT_MAX;
    const CWE190_Integer_Overflow__short_max_add_81_base& baseObject = CWE190_Integer_Overflow__short_max_add_81_bad();
"
18273,1,CWE475_Undefined_Behavior_for_Input_to_API__char_05.c,"    if(staticFalse)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            strcpy(data, ""abcdefghijklmnopqrstuvwxyz"");
            
            memmove(data + 6, data + 4, 10*sizeof(char));
            printLine(data);
        }
"
16518,0,CWE190_Integer_Overflow__int64_t_fscanf_add_51a.c,"    int64_t data;
    data = 0LL;
    
    fscanf (stdin, ""%"" SCNd64, &data);
"
2036,0,CWE197_Numeric_Truncation_Error__int_fgets_to_char_66a.c,"    int data;
    int dataArray[5];
    
    data = -1;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    
    dataArray[2] = data;
"
16470,0,CWE190_Integer_Overflow__int_fscanf_square_09.c,"    int data;
    
    data = 0;
    if(GLOBAL_CONST_TRUE)
    {
        
        fscanf(stdin, ""%d"", &data);
    }
    if(GLOBAL_CONST_TRUE)
    {
        {
            
            int result = data * data;
            printIntLine(result);
        }
"
2087,0,CWE590_Free_Memory_Not_on_Heap__delete_long_declare_52a.cpp,"    long * data;
    data = NULL; 
    {
        
        long dataBuffer;
        dataBuffer = 5L;
        data = &dataBuffer;
    }
"
16876,0,CWE563_Unused_Variable__unused_init_variable_int_07.c,"    int data;
    
    data = 5;
    if(staticFive==5)
    {
        
        
        ; 
"
5268,0,CWE190_Integer_Overflow__short_fscanf_add_15.c,"    short data;
    data = 0;
    switch(6)
    {
    case 6:
        
        fscanf (stdin, ""%hd"", &data);
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
    {
        
        short result = data + 1;
        printIntLine(result);
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
4296,0,CWE78_OS_Command_Injection__char_listen_socket_execl_63a.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
790,0,CWE190_Integer_Overflow__int_max_multiply_84_bad.cpp,"Label Definition File: CWE190_Integer_Overflow__int.label.xml
Template File: sources-sinks-84_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 190 Integer Overflow
 * BadSource: max Set data to the max value for int
 * GoodSource: Set data to a small, non-zero number (two)
 * Sinks: multiply
 *    GoodSink: Ensure there will not be an overflow before multiplying data by 2
 *    BadSink : If data is positive, multiply by 2, which can cause an overflow
 * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE190_Integer_Overflow__int_max_multiply_84.h""

namespace CWE190_Integer_Overflow__int_max_multiply_84
{
CWE190_Integer_Overflow__int_max_multiply_84_bad::CWE190_Integer_Overflow__int_max_multiply_84_bad(int dataCopy)
{
    data = dataCopy;
    
    data = INT_MAX;
}

CWE190_Integer_Overflow__int_max_multiply_84_bad::~CWE190_Integer_Overflow__int_max_multiply_84_bad()
{
    if(data > 0) 
    {
        
        int result = data * 2;
        printIntLine(result);
    }
}
}
"
12024,0,CWE190_Integer_Overflow__int64_t_fscanf_preinc_15.c,"    int64_t data;
    data = 0LL;
    switch(6)
    {
    case 6:
        
        fscanf (stdin, ""%"" SCNd64, &data);
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
    {
        
        ++data;
        int64_t result = data;
        printLongLongLine(result);
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
11799,0,CWE457_Use_of_Uninitialized_Variable__new_struct_array_partial_init_04.cpp,"    twoIntsStruct * data;
    data = new twoIntsStruct[10];
    if(STATIC_CONST_TRUE)
    {
        
        {
            int i;
            for(i=0; i<(10/2); i++)
            {
                data[i].intOne = i;
                data[i].intTwo = i;
            }
        }
    }
    if(STATIC_CONST_TRUE)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i].intOne);
                printIntLine(data[i].intTwo);
            }
        }
        
        delete [] data;
"
2961,1,CWE252_Unchecked_Return_Value__char_rename_12.c,"    if(globalReturnsTrueOrFalse())
    {
        
        if (RENAME(OLD_GOOD_FILE_NAME, ""newgoodfilename.txt"") != 0)
        {
            printLine(""rename failed!"");
        }
    }
    else
    {
        
        if (RENAME(OLD_GOOD_FILE_NAME, ""newgoodfilename.txt"") != 0)
        {
            printLine(""rename failed!"");
        }
"
1900,0,CWE190_Integer_Overflow__char_fscanf_square_52a.c,"    char data;
    data = ' ';
    
    fscanf (stdin, ""%c"", &data);
"
4552,1,CWE401_Memory_Leak__malloc_realloc_int64_t_06.c,"    if(STATIC_CONST_FIVE==5)
    {
        {
            int64_t * data = (int64_t *)malloc(100*sizeof(int64_t));
            if (data == NULL) {exit(-1);}
            int64_t * tmpData;
            
            data[0] = 5LL;
            printLongLongLine(data[0]);
            tmpData = (int64_t *)realloc(data, (130000)*sizeof(int64_t));
            /* FIX: Ensure realloc() was successful before assigning data to the memory block
            * allocated with realloc() */
            if (tmpData != NULL)
            {
                data = tmpData;
                
                data[0] = 10LL;
                printLongLongLine(data[0]);
            }
            free(data);
        }
"
1231,0,CWE369_Divide_by_Zero__int_fscanf_modulo_13.c,"    int data;
    
    data = -1;
    if(GLOBAL_CONST_FIVE==5)
    {
        
        fscanf(stdin, ""%d"", &data);
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        
        printIntLine(100 % data);
"
17847,0,CWE197_Numeric_Truncation_Error__short_fscanf_22a.c,"    short data;
    
    data = -1;
    CWE197_Numeric_Truncation_Error__short_fscanf_22_badGlobal = 1; 
    data = CWE197_Numeric_Truncation_Error__short_fscanf_22_badSource(data);
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
18982,0,CWE476_NULL_Pointer_Dereference__int_54a.c,"    int * data;
    
    data = NULL;
"
17532,0,CWE590_Free_Memory_Not_on_Heap__free_int64_t_alloca_01.c,"    int64_t * data;
    data = NULL; 
    {
        
        int64_t * dataBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5LL;
            }
        }
        data = dataBuffer;
    }
    printLongLongLine(data[0]);
    
"
8087,0,CWE78_OS_Command_Injection__char_file_execlp_52a.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        FILE * pFile;
        
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
"
1035,0,CWE190_Integer_Overflow__short_fscanf_add_83a.cpp,"    short data;
    data = 0;
"
17777,1,CWE758_Undefined_Behavior__char_new_use_10.cpp,"    if(globalTrue)
    {
        {
            char data;
            data = 5;
            char * pointer = new char;
            *pointer = data; 
            {
                char data = *pointer;
                printHexCharLine(data);
            }
            delete pointer;
        }
"
7924,0,CWE476_NULL_Pointer_Dereference__binary_if_13.c,"    if(GLOBAL_CONST_FIVE==5)
    {
        {
            twoIntsStruct *twoIntsStructPointer = NULL;
            /* FLAW: Using a single & in the if statement will cause both sides of the expression to be evaluated
             * thus causing a NPD */
            if ((twoIntsStructPointer != NULL) & (twoIntsStructPointer->intOne == 5))
            {
                printLine(""intOne == 5"");
            }
        }
"
18792,0,CWE190_Integer_Overflow__short_max_add_61a.c,"    short data;
    data = 0;
    data = CWE190_Integer_Overflow__short_max_add_61b_badSource(data);
    {
        
        short result = data + 1;
        printIntLine(result);
"
4428,0,CWE252_Unchecked_Return_Value__char_fwrite_01.c,"    
"
13305,1,CWE252_Unchecked_Return_Value__char_sscanf_08.c,"    if(staticReturnsFalse())
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            
            if (sscanf(SRC, ""%99s\0"", data) == EOF)
            {
                printLine(""sscanf failed!"");
            }
        }
"
9773,1,CWE252_Unchecked_Return_Value__char_putc_15.c,"    switch(6)
    {
    case 6:
        
        if (putc((int)'A', stdout) == EOF)
        {
            printLine(""putc failed!"");
        }
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
1580,0,CWE78_OS_Command_Injection__char_listen_socket_execl_53a.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
10725,0,CWE457_Use_of_Uninitialized_Variable__struct_array_malloc_no_init_17.c,"    int i,j;
    twoIntsStruct * data;
    data = (twoIntsStruct *)malloc(10*sizeof(twoIntsStruct));
    if (data == NULL) {exit(-1);}
    for(i = 0; i < 1; i++)
    {
        
        ; 
    }
    for(j = 0; j < 1; j++)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i].intOne);
                printIntLine(data[i].intTwo);
            }
        }
"
407,0,CWE590_Free_Memory_Not_on_Heap__delete_int64_t_declare_68a.cpp,"    int64_t * data;
    data = NULL; 
    {
        
        int64_t dataBuffer;
        dataBuffer = 5LL;
        data = &dataBuffer;
    }
    CWE590_Free_Memory_Not_on_Heap__delete_int64_t_declare_68_badData = data;
"
11581,0,CWE457_Use_of_Uninitialized_Variable__twointsclass_array_alloca_partial_init_16.cpp,"    TwoIntsClass * data;
    data = reinterpret_cast<TwoIntsClass *>(ALLOCA(10*sizeof(TwoIntsClass)));
    while(1)
    {
        
        for(int i=0; i<(10/2); i++)
        {
            data[i].intOne = i;
            data[i].intTwo = i;
        }
        break;
    }
    while(1)
    {
        
        for(int i=0; i<10; i++)
        {
            printIntLine(data[i].intOne);
            printIntLine(data[i].intTwo);
        }
        break;
"
11748,0,CWE401_Memory_Leak__int_realloc_66a.c,"    int * data;
    int * dataArray[5];
    data = NULL;
    
    data = (int *)realloc(data, 100*sizeof(int));
    if (data == NULL) {exit(-1);}
    
    data[0] = 5;
    printIntLine(data[0]);
    
    dataArray[2] = data;
"
7000,0,CWE190_Integer_Overflow__int_fgets_preinc_18.c,"    int data;
    
    data = 0;
    goto source;
source:
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    goto sink;
sink:
    {
        
        ++data;
        int result = data;
        printIntLine(result);
"
3614,0,CWE197_Numeric_Truncation_Error__int_rand_to_short_82_bad.cpp,"Label Definition File: CWE197_Numeric_Truncation_Error__int.label.xml
Template File: sources-sink-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 197 Numeric Truncation Error
 * BadSource: rand Set data to result of rand(), which may be zero
 * GoodSource: Less than CHAR_MAX
 * Sinks: to_short
 *    BadSink : Convert data to a short
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE197_Numeric_Truncation_Error__int_rand_to_short_82.h""

namespace CWE197_Numeric_Truncation_Error__int_rand_to_short_82
{

void CWE197_Numeric_Truncation_Error__int_rand_to_short_82_bad::action(int data)
{
    {
        
        short shortData = (short)data;
        printShortLine(shortData);
    }
}

}
"
7012,0,CWE369_Divide_by_Zero__int_rand_modulo_09.c,"    int data;
    
    data = -1;
    if(GLOBAL_CONST_TRUE)
    {
        
        data = RAND32();
    }
    if(GLOBAL_CONST_TRUE)
    {
        
        printIntLine(100 % data);
"
14772,0,CWE401_Memory_Leak__malloc_realloc_struct_twoIntsStruct_12.c,"    if(globalReturnsTrueOrFalse())
    {
        {
            struct _twoIntsStruct * data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));
            if (data == NULL) {exit(-1);}
            
            data[0].intOne = 0;
            data[0].intTwo = 0;
            printStructLine((twoIntsStruct *)&data[0]);
            
            data = (struct _twoIntsStruct *)realloc(data, (130000)*sizeof(struct _twoIntsStruct));
            if (data != NULL)
            {
                
                data[0].intOne = 1;
                data[0].intTwo = 1;
                printStructLine((twoIntsStruct *)&data[0]);
                free(data);
            }
        }
    }
    else
    {
        {
            struct _twoIntsStruct * data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));
            if (data == NULL) {exit(-1);}
            struct _twoIntsStruct * tmpData;
            
            data[0].intOne = 0;
            data[0].intTwo = 0;
            printStructLine((twoIntsStruct *)&data[0]);
            tmpData = (struct _twoIntsStruct *)realloc(data, (130000)*sizeof(struct _twoIntsStruct));
            /* FIX: Ensure realloc() was successful before assigning data to the memory block
            * allocated with realloc() */
            if (tmpData != NULL)
            {
                data = tmpData;
                
                data[0].intOne = 1;
                data[0].intTwo = 1;
                printStructLine((twoIntsStruct *)&data[0]);
            }
            free(data);
        }
"
6439,0,CWE590_Free_Memory_Not_on_Heap__delete_array_struct_declare_65a.cpp,"    twoIntsStruct * data;
    
    void (*funcPtr) (twoIntsStruct *) = badSink;
    data = NULL; 
    {
        
        twoIntsStruct dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i].intOne = 1;
                dataBuffer[i].intTwo = 1;
            }
        }
        data = dataBuffer;
    }
    
"
8584,0,CWE401_Memory_Leak__new_array_int64_t_54a.cpp,"    int64_t * data;
    data = NULL;
    
    data = new int64_t[100];
    
    data[0] = 5LL;
    printLongLongLine(data[0]);
"
1530,0,CWE590_Free_Memory_Not_on_Heap__delete_array_int64_t_alloca_67a.cpp,"    int64_t * data;
    structType myStruct;
    data = NULL; 
    {
        
        int64_t * dataBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5LL;
            }
        }
        data = dataBuffer;
    }
    myStruct.structFirst = data;
"
11892,0,CWE690_NULL_Deref_From_Return__int64_t_realloc_16.c,"    int64_t * data;
    data = NULL; 
    
    data = (int64_t *)realloc(data, 1*sizeof(int64_t));
    while(1)
    {
        
        data[0] = 5LL;
        printLongLongLine(data[0]);
        free(data);
        break;
"
7333,0,CWE457_Use_of_Uninitialized_Variable__new_int_array_no_init_09.cpp,"    int * data;
    data = new int[10];
    if(GLOBAL_CONST_TRUE)
    {
        
        ; 
    }
    if(GLOBAL_CONST_TRUE)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i]);
            }
        }
        
        delete [] data;
"
16998,0,CWE190_Integer_Overflow__int_fscanf_square_03.c,"    int data;
    
    data = 0;
    if(5==5)
    {
        
        fscanf(stdin, ""%d"", &data);
    }
    if(5==5)
    {
        {
            
            int result = data * data;
            printIntLine(result);
        }
"
2810,0,CWE590_Free_Memory_Not_on_Heap__delete_int_declare_15.cpp,"    int * data;
    data = NULL; 
    switch(6)
    {
    case 6:
    {
        
        int dataBuffer;
        dataBuffer = 5;
        data = &dataBuffer;
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    printIntLine(*data);
    
"
18372,0,CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_81a.cpp,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    const CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_81_base& baseObject = CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_81_bad();
"
16758,0,CWE590_Free_Memory_Not_on_Heap__delete_char_alloca_17.cpp,"    int i;
    char * data;
    data = NULL; 
    for(i = 0; i < 1; i++)
    {
        {
            
            char * dataBuffer = (char *)ALLOCA(sizeof(char));
            *dataBuffer = 'A';
            data = dataBuffer;
        }
    }
    printHexCharLine(*data);
    
"
3409,0,CWE190_Integer_Overflow__short_max_add_52a.c,"    short data;
    data = 0;
    
    data = SHRT_MAX;
"
11625,0,CWE190_Integer_Overflow__short_rand_preinc_67a.c,"    short data;
    CWE190_Integer_Overflow__short_rand_preinc_67_structType myStruct;
    data = 0;
    
    data = (short)RAND32();
    myStruct.structFirst = data;
"
16036,0,CWE369_Divide_by_Zero__int_fgets_modulo_54a.c,"    int data;
    
    data = -1;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
"
10704,0,CWE78_OS_Command_Injection__char_console_system_81_bad.cpp,"Label Definition File: CWE78_OS_Command_Injection.one_string.label.xml
Template File: sources-sink-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 78 OS Command Injection
 * BadSource: console Read input from the console
 * GoodSource: Fixed string
 * Sinks: system
 *    BadSink : Execute command in data using system()
 * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE78_OS_Command_Injection__char_console_system_81.h""
"
18944,0,CWE457_Use_of_Uninitialized_Variable__struct_array_malloc_partial_init_18.c,"    twoIntsStruct * data;
    data = (twoIntsStruct *)malloc(10*sizeof(twoIntsStruct));
    if (data == NULL) {exit(-1);}
    goto source;
source:
    
    {
        int i;
        for(i=0; i<(10/2); i++)
        {
            data[i].intOne = i;
            data[i].intTwo = i;
        }
    }
    goto sink;
sink:
    
    {
        int i;
        for(i=0; i<10; i++)
        {
            printIntLine(data[i].intOne);
            printIntLine(data[i].intTwo);
        }
"
5435,0,CWE590_Free_Memory_Not_on_Heap__free_long_alloca_18.c,"    long * data;
    data = NULL; 
    goto source;
source:
    {
        
        long * dataBuffer = (long *)ALLOCA(100*sizeof(long));
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5L;
            }
        }
        data = dataBuffer;
    }
    printLongLine(data[0]);
    
"
2897,0,CWE590_Free_Memory_Not_on_Heap__delete_int64_t_alloca_67a.cpp,"    int64_t * data;
    structType myStruct;
    data = NULL; 
    {
        
        int64_t * dataBuffer = (int64_t *)ALLOCA(sizeof(int64_t));
        *dataBuffer = 5LL;
        data = dataBuffer;
    }
    myStruct.structFirst = data;
"
17495,0,CWE665_Improper_Initialization__char_ncat_74a.cpp,"    char * data;
    map<int, char *> dataMap;
    char dataBuffer[100];
    data = dataBuffer;
    
    ; 
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
9056,0,CWE78_OS_Command_Injection__char_console_system_10.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(globalTrue)
    {
        {
            
            size_t dataLen = strlen(data);
            
            if (100-dataLen > 1)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
                {
                    /* The next few lines remove the carriage return from the string that is
                     * inserted by fgets() */
                    dataLen = strlen(data);
"
11567,0,CWE415_Double_Free__new_delete_array_int64_t_21.cpp,"    int64_t * data;
    
    data = NULL;
    data = new int64_t[100];
    
    delete [] data;
    badStatic = 1; 
"
4011,0,CWE190_Integer_Overflow__short_max_multiply_51a.c,"    short data;
    data = 0;
    
    data = SHRT_MAX;
"
16407,0,CWE415_Double_Free__new_delete_int_03.cpp,"    int * data;
    
    data = NULL;
    if(5==5)
    {
        data = new int;
        
        delete data;
    }
    if(5==5)
    {
        
        delete data;
"
4750,0,CWE457_Use_of_Uninitialized_Variable__twointsclass_array_new_partial_init_05.cpp,"    TwoIntsClass * data;
    data = new TwoIntsClass[10];
    if(staticTrue)
    {
        
        for(int i=0; i<(10/2); i++)
        {
            data[i].intOne = i;
            data[i].intTwo = i;
        }
    }
    if(staticTrue)
    {
        
        for(int i=0; i<10; i++)
        {
            printIntLine(data[i].intOne);
            printIntLine(data[i].intTwo);
        }
"
2703,1,CWE758_Undefined_Behavior__char_pointer_alloca_use_05.c,"    if(staticFalse)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            char * data;
            char * * pointer = (char * *)ALLOCA(sizeof(char *));
            data = ""string"";
            *pointer = data; 
            {
                char * data = *pointer;
                printLine(data);
            }
        }
"
5638,0,CWE416_Use_After_Free__malloc_free_int_15.c,"    int * data;
    
    data = NULL;
    switch(6)
    {
    case 6:
        data = (int *)malloc(100*sizeof(int));
        if (data == NULL) {exit(-1);}
        {
            size_t i;
            for(i = 0; i < 100; i++)
            {
                data[i] = 5;
            }
        }
        
        free(data);
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
        
        printIntLine(data[0]);
        
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
18588,0,CWE78_OS_Command_Injection__char_file_execlp_62a.cpp,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    badSource(data);
    /* execlp - searches for the location of the command among
     * the directories specified by the PATH environment variable */
    
"
877,0,CWE457_Use_of_Uninitialized_Variable__new_double_array_no_init_13.cpp,"    double * data;
    data = new double[10];
    if(GLOBAL_CONST_FIVE==5)
    {
        
        ; 
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printDoubleLine(data[i]);
            }
        }
        
        delete [] data;
"
183,0,CWE190_Integer_Overflow__int_connect_socket_add_84_bad.cpp,"Label Definition File: CWE190_Integer_Overflow__int.label.xml
Template File: sources-sinks-84_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 190 Integer Overflow
 * BadSource: connect_socket Read data using a connect socket (client side)
 * GoodSource: Set data to a small, non-zero number (two)
 * Sinks: add
 *    GoodSink: Ensure there will not be an overflow before adding 1 to data
 *    BadSink : Add 1 to data, which can cause an overflow
 * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE190_Integer_Overflow__int_connect_socket_add_84.h""

#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif

#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)

namespace CWE190_Integer_Overflow__int_connect_socket_add_84
{
CWE190_Integer_Overflow__int_connect_socket_add_84_bad::CWE190_Integer_Overflow__int_connect_socket_add_84_bad(int dataCopy)
{
    data = dataCopy;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
}

CWE190_Integer_Overflow__int_connect_socket_add_84_bad::~CWE190_Integer_Overflow__int_connect_socket_add_84_bad()
{
    {
        
        int result = data + 1;
        printIntLine(result);
    }
}
}
"
3938,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_81_bad.cpp,"Label Definition File: CWE789_Uncontrolled_Mem_Alloc__malloc.label.xml
Template File: sources-sinks-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: fscanf Read data from the console using fscanf()
 * GoodSource: Small number greater than zero
 * Sinks:
 *    GoodSink: Allocate memory with malloc() and check the size of the memory to be allocated
 *    BadSink : Allocate memory with malloc(), but incorrectly check the size of the memory to be allocated
 * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_81.h""

#define HELLO_STRING ""hello""

namespace CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_81
{

void CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_81_bad::action(size_t data) const
{
    {
        char * myString;
        /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
         * for the strcpy() function to not cause a buffer overflow */
        
        if (data > strlen(HELLO_STRING))
        {
            myString = (char *)malloc(data*sizeof(char));
            if (myString == NULL) {exit(-1);}
            
            strcpy(myString, HELLO_STRING);
            printLine(myString);
            free(myString);
        }
        else
        {
            printLine(""Input is less than the length of the source string"");
        }
    }
}

}
"
15990,0,CWE401_Memory_Leak__malloc_realloc_int_15.c,"    switch(6)
    {
    case 6:
    {
        int * data = (int *)malloc(100*sizeof(int));
        if (data == NULL) {exit(-1);}
        
        data[0] = 5;
        printIntLine(data[0]);
        
        data = (int *)realloc(data, (130000)*sizeof(int));
        if (data != NULL)
        {
            
            data[0] = 10;
            printIntLine(data[0]);
            free(data);
        }
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
16967,0,CWE563_Unused_Variable__unused_uninit_variable_int_83a.cpp,"    int data;
"
1650,0,CWE590_Free_Memory_Not_on_Heap__delete_char_alloca_53a.cpp,"    char * data;
    data = NULL; 
    {
        
        char * dataBuffer = (char *)ALLOCA(sizeof(char));
        *dataBuffer = 'A';
        data = dataBuffer;
    }
"
13687,0,CWE134_Uncontrolled_Format_String__char_console_printf_52a.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        
        if (100-dataLen > 1)
        {
            
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgets() */
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
                    data[dataLen-1] = '\0';
                }
            }
            else
            {
                printLine(""fgets() failed"");
                
                data[dataLen] = '\0';
            }
        }
    }
"
526,0,CWE415_Double_Free__malloc_free_int64_t_01.c,"    int64_t * data;
    
    data = NULL;
    data = (int64_t *)malloc(100*sizeof(int64_t));
    if (data == NULL) {exit(-1);}
    
    free(data);
    
"
12915,0,CWE416_Use_After_Free__malloc_free_long_02.c,"    long * data;
    
    data = NULL;
    if(1)
    {
        data = (long *)malloc(100*sizeof(long));
        if (data == NULL) {exit(-1);}
        {
            size_t i;
            for(i = 0; i < 100; i++)
            {
                data[i] = 5L;
            }
        }
        
        free(data);
    }
    if(1)
    {
        
        printLongLine(data[0]);
        
"
17858,0,CWE415_Double_Free__malloc_free_int_61a.c,"    int * data;
    
    data = NULL;
    data = CWE415_Double_Free__malloc_free_int_61b_badSource(data);
    
"
3338,0,CWE134_Uncontrolled_Format_String__char_file_fprintf_11.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(globalReturnsTrue())
    {
        {
            
            size_t dataLen = strlen(data);
            FILE * pFile;
            
            if (100-dataLen > 1)
            {
                pFile = fopen(FILENAME, ""r"");
                if (pFile != NULL)
                {
                    
                    if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                    {
                        printLine(""fgets() failed"");
                        
                        data[dataLen] = '\0';
                    }
                    fclose(pFile);
                }
            }
        }
    }
    if(globalReturnsTrue())
    {
        
        fprintf(stdout, data);
"
669,0,CWE690_NULL_Deref_From_Return__struct_calloc_68a.c,"    twoIntsStruct * data;
    data = NULL; 
    
    data = (twoIntsStruct *)calloc(1, sizeof(twoIntsStruct));
    CWE690_NULL_Deref_From_Return__struct_calloc_68_badDataForBadSink = data;
"
4700,0,CWE416_Use_After_Free__new_delete_class_08.cpp,"    TwoIntsClass * data;
    
    data = NULL;
    if(staticReturnsTrue())
    {
        data = new TwoIntsClass;
        data->intOne = 1;
        data->intTwo = 2;
        
        delete data;
    }
    if(staticReturnsTrue())
    {
        
        printIntLine(data->intOne);
        
"
6728,0,CWE197_Numeric_Truncation_Error__int_fscanf_to_char_45.c,"    int data;
    
    data = -1;
    
    fscanf(stdin, ""%d"", &data);
    CWE197_Numeric_Truncation_Error__int_fscanf_to_char_45_badData = data;
"
4094,0,CWE415_Double_Free__new_delete_struct_81a.cpp,"    twoIntsStruct * data;
    
    data = NULL;
    data = new twoIntsStruct;
    
    delete data;
    const CWE415_Double_Free__new_delete_struct_81_base& o = CWE415_Double_Free__new_delete_struct_81_bad();
"
8024,0,CWE78_OS_Command_Injection__char_connect_socket_popen_81_bad.cpp,"Label Definition File: CWE78_OS_Command_Injection.one_string.label.xml
Template File: sources-sink-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 78 OS Command Injection
 * BadSource: connect_socket Read data using a connect socket (client side)
 * GoodSource: Fixed string
 * Sinks: popen
 *    BadSink : Execute command in data using popen()
 * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE78_OS_Command_Injection__char_connect_socket_popen_81.h""
"
14962,0,CWE401_Memory_Leak__new_array_int_04.cpp,"    int * data;
    data = NULL;
    if(STATIC_CONST_TRUE)
    {
        
        data = new int[100];
        
        data[0] = 5;
        printIntLine(data[0]);
    }
    if(STATIC_CONST_TRUE)
    {
        
        ; 
"
3613,0,CWE190_Integer_Overflow__int64_t_fscanf_preinc_32.c,"    int64_t data;
    int64_t *dataPtr1 = &data;
    int64_t *dataPtr2 = &data;
    data = 0LL;
    {
        int64_t data = *dataPtr1;
        
        fscanf (stdin, ""%"" SCNd64, &data);
        *dataPtr1 = data;
    }
    {
        int64_t data = *dataPtr2;
        {
            
            ++data;
            int64_t result = data;
            printLongLongLine(result);
        }
"
17215,0,CWE401_Memory_Leak__int_realloc_05.c,"    int * data;
    data = NULL;
    if(staticTrue)
    {
        
        data = (int *)realloc(data, 100*sizeof(int));
        if (data == NULL) {exit(-1);}
        
        data[0] = 5;
        printIntLine(data[0]);
    }
    if(staticTrue)
    {
        
        ; 
"
17228,0,CWE690_NULL_Deref_From_Return__char_calloc_22a.c,"    char * data;
    data = NULL; 
    
    data = (char *)calloc(20, sizeof(char));
    CWE690_NULL_Deref_From_Return__char_calloc_22_badGlobal = 1; 
"
5400,0,CWE415_Double_Free__new_delete_int_41.cpp,"    int * data;
    
    data = NULL;
    data = new int;
    
    delete data;
"
611,0,CWE190_Integer_Overflow__int_fscanf_multiply_22a.c,"    int data;
    
    data = 0;
    
    fscanf(stdin, ""%d"", &data);
    CWE190_Integer_Overflow__int_fscanf_multiply_22_badGlobal = 1; 
"
387,0,CWE190_Integer_Overflow__int64_t_max_square_21.c,"    int64_t data;
    data = 0LL;
    
    data = LLONG_MAX;
    badStatic = 1; 
"
16405,0,CWE369_Divide_by_Zero__float_fscanf_65a.c,"    float data;
    
    void (*funcPtr) (float) = CWE369_Divide_by_Zero__float_fscanf_65b_badSink;
    
    data = 0.0F;
    
    fscanf (stdin, ""%f"", &data);
    
"
8198,0,CWE190_Integer_Overflow__int_fgets_preinc_22a.c,"    int data;
    
    data = 0;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    CWE190_Integer_Overflow__int_fgets_preinc_22_badGlobal = 1; 
"
7711,0,CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_12.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(globalReturnsTrueOrFalse())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET connectSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                
                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                data[dataLen + recvResult / sizeof(char)] = '\0';
                
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    else
    {
        
        strcpy(data, ""fixedstringtest"");
    }
    if(globalReturnsTrueOrFalse())
    {
        {
            char dest[100] = """";
            
            SNPRINTF(dest, 100-1, data);
            printLine(dest);
        }
    }
    else
    {
        {
            char dest[100] = """";
            
            SNPRINTF(dest, 100-1, ""%s"", data);
            printLine(dest);
        }
"
60,0,CWE415_Double_Free__malloc_free_int_11.c,"    int * data;
    
    data = NULL;
    if(globalReturnsTrue())
    {
        data = (int *)malloc(100*sizeof(int));
        if (data == NULL) {exit(-1);}
        
        free(data);
    }
    if(globalReturnsTrue())
    {
        
        free(data);
"
13748,0,CWE690_NULL_Deref_From_Return__long_malloc_54a.c,"    long * data;
    data = NULL; 
    
    data = (long *)malloc(1*sizeof(long));
"
9863,0,CWE590_Free_Memory_Not_on_Heap__free_long_alloca_33.cpp,"    long * data;
    long * &dataRef = data;
    data = NULL; 
    {
        
        long * dataBuffer = (long *)ALLOCA(100*sizeof(long));
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5L;
            }
        }
        data = dataBuffer;
    }
    {
        long * data = dataRef;
        printLongLine(data[0]);
        
        free(data);
"
162,0,CWE401_Memory_Leak__int_malloc_03.c,"    int * data;
    data = NULL;
    if(5==5)
    {
        
        data = (int *)malloc(100*sizeof(int));
        if (data == NULL) {exit(-1);}
        
        data[0] = 5;
        printIntLine(data[0]);
    }
    if(5==5)
    {
        
        ; 
"
5614,0,CWE190_Integer_Overflow__unsigned_int_rand_multiply_73a.cpp,"    unsigned int data;
    list<unsigned int> dataList;
    data = 0;
    
    data = (unsigned int)RAND32();
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
496,0,CWE690_NULL_Deref_From_Return__int_calloc_06.c,"    int * data;
    data = NULL; 
    
    data = (int *)calloc(1, sizeof(int));
    if(STATIC_CONST_FIVE==5)
    {
        
        data[0] = 5;
        printIntLine(data[0]);
        free(data);
"
8377,0,CWE190_Integer_Overflow__unsigned_int_max_multiply_10.c,"    unsigned int data;
    data = 0;
    if(globalTrue)
    {
        
        data = UINT_MAX;
    }
    if(globalTrue)
    {
        if(data > 0) 
        {
            
            unsigned int result = data * 2;
            printUnsignedLine(result);
        }
"
4719,0,CWE415_Double_Free__new_delete_struct_82a.cpp,"    twoIntsStruct * data;
    
    data = NULL;
    data = new twoIntsStruct;
    
    delete data;
    CWE415_Double_Free__new_delete_struct_82_base* baseObject = new CWE415_Double_Free__new_delete_struct_82_bad;
    baseObject->action(data);
"
4814,0,CWE190_Integer_Overflow__int64_t_max_square_67a.c,"    int64_t data;
    CWE190_Integer_Overflow__int64_t_max_square_67_structType myStruct;
    data = 0LL;
    
    data = LLONG_MAX;
    myStruct.structFirst = data;
"
17304,0,CWE415_Double_Free__new_delete_int64_t_66a.cpp,"    int64_t * data;
    int64_t * dataArray[5];
    
    data = NULL;
    data = new int64_t;
    
    delete data;
    
    dataArray[2] = data;
"
731,0,CWE758_Undefined_Behavior__class_new_use_13.cpp,"    if(GLOBAL_CONST_FIVE==5)
    {
        {
            TwoIntsClass * pointer = new TwoIntsClass;
            TwoIntsClass data = *pointer; 
            delete pointer;
            printIntLine(data.intOne);
            printIntLine(data.intTwo);
        }
"
18725,0,CWE197_Numeric_Truncation_Error__int_connect_socket_to_short_81_bad.cpp,"Label Definition File: CWE197_Numeric_Truncation_Error__int.label.xml
Template File: sources-sink-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 197 Numeric Truncation Error
 * BadSource: connect_socket Read data using a connect socket (client side)
 * GoodSource: Less than CHAR_MAX
 * Sinks: to_short
 *    BadSink : Convert data to a short
 * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE197_Numeric_Truncation_Error__int_connect_socket_to_short_81.h""

namespace CWE197_Numeric_Truncation_Error__int_connect_socket_to_short_81
{

void CWE197_Numeric_Truncation_Error__int_connect_socket_to_short_81_bad::action(int data) const
{
    {
        
        short shortData = (short)data;
        printShortLine(shortData);
    }
}

}
"
15205,1,CWE252_Unchecked_Return_Value__char_remove_03.c,"    if(5==5)
    {
        
        if (REMOVE(""removemegood.txt"") != 0)
        {
            printLine(""remove failed!"");
        }
"
19296,0,CWE416_Use_After_Free__new_delete_int_15.cpp,"    int * data;
    
    data = NULL;
    switch(6)
    {
    case 6:
        data = new int;
        *data = 5;
        
        delete data;
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
        
        printIntLine(*data);
        
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
19484,0,CWE190_Integer_Overflow__int_listen_socket_postinc_45.c,"    int data;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    CWE190_Integer_Overflow__int_listen_socket_postinc_45_badData = data;
"
9809,0,CWE476_NULL_Pointer_Dereference__char_21.c,"    char * data;
    
    data = NULL;
    badStatic = 1; 
"
12094,0,CWE590_Free_Memory_Not_on_Heap__delete_array_int_alloca_64a.cpp,"    int * data;
    data = NULL; 
    {
        
        int * dataBuffer = (int *)ALLOCA(100*sizeof(int));
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5;
            }
        }
        data = dataBuffer;
    }
"
10969,0,CWE415_Double_Free__new_delete_array_long_61a.cpp,"    long * data;
    
    data = NULL;
    data = badSource(data);
    
"
19049,0,CWE590_Free_Memory_Not_on_Heap__delete_array_char_declare_07.cpp,"    char * data;
    data = NULL; 
    if(staticFive==5)
    {
        {
            
            char dataBuffer[100];
            memset(dataBuffer, 'A', 100-1); 
            dataBuffer[100-1] = '\0'; 
            data = dataBuffer;
        }
    }
    printLine(data);
    
"
4439,0,CWE78_OS_Command_Injection__char_file_execl_15.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    switch(6)
    {
    case 6:
    {
        
        size_t dataLen = strlen(data);
        FILE * pFile;
        
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    
    
"
16604,0,CWE690_NULL_Deref_From_Return__char_realloc_08.c,"    char * data;
    data = NULL; 
    
    data = (char *)realloc(data, 20*sizeof(char));
    if(staticReturnsTrue())
    {
        
        strcpy(data, ""Initialize"");
        printLine(data);
        free(data);
"
5999,1,CWE758_Undefined_Behavior__double_pointer_new_use_11.cpp,"    if(globalReturnsFalse())
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            double * data;
            
            data = new double;
            *data = 5.0;
            double * * pointer = new double *;
            *pointer = data; 
            {
                double * data = *pointer;
                printDoubleLine(*data);
            }
            delete pointer;
        }
"
6530,0,CWE690_NULL_Deref_From_Return__char_calloc_63a.c,"    char * data;
    data = NULL; 
    
    data = (char *)calloc(20, sizeof(char));
"
3337,1,CWE758_Undefined_Behavior__int_pointer_malloc_use_16.c,"    while(1)
    {
        {
            int * data;
            int * * pointer = (int * *)malloc(sizeof(int *));
            if (pointer == NULL) {exit(-1);}
            
            data = (int *)malloc(sizeof(int));
            if (data == NULL) {exit(-1);}
            *data = 5;
            *pointer = data; 
            {
                int * data = *pointer;
                printIntLine(*data);
            }
            free(pointer);
        }
        break;
"
178,0,CWE190_Integer_Overflow__char_fscanf_multiply_07.c,"    char data;
    data = ' ';
    if(staticFive==5)
    {
        
        fscanf (stdin, ""%c"", &data);
    }
    if(staticFive==5)
    {
        if(data > 0) 
        {
            
            char result = data * 2;
            printHexCharLine(result);
        }
"
9859,0,CWE190_Integer_Overflow__int_listen_socket_add_72a.cpp,"    int data;
    vector<int> dataVector;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
2987,0,CWE134_Uncontrolled_Format_String__char_environment_vprintf_63a.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        
        if (environment != NULL)
        {
            
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
"
521,0,CWE401_Memory_Leak__char_malloc_73a.cpp,"    char * data;
    list<char *> dataList;
    data = NULL;
    
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    
    strcpy(data, ""A String"");
    printLine(data);
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
3756,1,CWE758_Undefined_Behavior__long_alloca_use_13.c,"    if(GLOBAL_CONST_FIVE==5)
    {
        {
            long data;
            long * pointer = (long *)ALLOCA(sizeof(long));
            data = 5L;
            *pointer = data; 
            {
                long data = *pointer;
                printLongLine(data);
            }
        }
"
19116,0,CWE190_Integer_Overflow__short_fscanf_postinc_09.c,"    short data;
    data = 0;
    if(GLOBAL_CONST_TRUE)
    {
        
        fscanf (stdin, ""%hd"", &data);
    }
    if(GLOBAL_CONST_TRUE)
    {
        {
            
            data++;
            short result = data;
            printIntLine(result);
        }
"
2505,0,CWE690_NULL_Deref_From_Return__long_malloc_66a.c,"    long * data;
    long * dataArray[5];
    data = NULL; 
    
    data = (long *)malloc(1*sizeof(long));
    
    dataArray[2] = data;
"
8440,0,CWE789_Uncontrolled_Mem_Alloc__new_char_rand_12.cpp,"    size_t data;
    
    data = 0;
    if(globalReturnsTrueOrFalse())
    {
        
        data = rand();
    }
    else
    {
        
        data = 20;
    }
    if(globalReturnsTrueOrFalse())
    {
        {
            char * myString;
            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
             * for the strcpy() function to not cause a buffer overflow */
            
            if (data > strlen(HELLO_STRING))
            {
                myString = new char[data];
                
                strcpy(myString, HELLO_STRING);
                printLine(myString);
                delete [] myString;
            }
            else
            {
                printLine(""Input is less than the length of the source string"");
            }
        }
    }
    else
    {
        {
            char * myString;
            /* FIX: Include a MAXIMUM limitation for memory allocation and a check to ensure data is large enough
             * for the strcpy() function to not cause a buffer overflow */
            
            if (data > strlen(HELLO_STRING) && data < 100)
            {
                myString = new char[data];
                
                strcpy(myString, HELLO_STRING);
                printLine(myString);
                delete [] myString;
            }
            else
            {
                printLine(""Input is less than the length of the source string or too large"");
            }
        }
"
645,0,CWE415_Double_Free__new_delete_array_int64_t_03.cpp,"    int64_t * data;
    
    data = NULL;
    if(5==5)
    {
        data = new int64_t[100];
        
        delete [] data;
    }
    if(5==5)
    {
        
        delete [] data;
"
8170,0,CWE758_Undefined_Behavior__int_malloc_use_16.c,"    while(1)
    {
        {
            int * pointer = (int *)malloc(sizeof(int));
            if (pointer == NULL) {exit(-1);}
            int data = *pointer; 
            free(pointer);
            printIntLine(data);
        }
        break;
"
5917,1,CWE758_Undefined_Behavior__long_new_use_04.cpp,"    if(STATIC_CONST_FALSE)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            long data;
            data = 5L;
            long * pointer = new long;
            *pointer = data; 
            {
                long data = *pointer;
                printLongLine(data);
            }
            delete pointer;
        }
"
8204,1,CWE252_Unchecked_Return_Value__char_fwrite_05.c,"    if(staticFalse)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        
        if (fwrite((char *)""string"", sizeof(char), strlen(""string""), stdout) != strlen(""string""))
        {
            printLine(""fwrite failed!"");
        }
"
1498,0,CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_04.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(STATIC_CONST_TRUE)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET connectSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                
                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                data[dataLen + recvResult / sizeof(char)] = '\0';
                
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(STATIC_CONST_TRUE)
    {
        badVaSinkB(data, data);
"
7267,0,CWE415_Double_Free__new_delete_array_struct_13.cpp,"    twoIntsStruct * data;
    
    data = NULL;
    if(GLOBAL_CONST_FIVE==5)
    {
        data = new twoIntsStruct[100];
        
        delete [] data;
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        
        delete [] data;
"
12057,0,CWE369_Divide_by_Zero__float_fscanf_53a.c,"    float data;
    
    data = 0.0F;
    
    fscanf (stdin, ""%f"", &data);
"
561,0,CWE690_NULL_Deref_From_Return__int_realloc_04.c,"    int * data;
    data = NULL; 
    
    data = (int *)realloc(data, 1*sizeof(int));
    if(STATIC_CONST_TRUE)
    {
        
        data[0] = 5;
        printIntLine(data[0]);
        free(data);
"
11916,0,CWE369_Divide_by_Zero__int_connect_socket_divide_74a.cpp,"    int data;
    map<int, int> dataMap;
    
    data = -1;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
17634,0,CWE590_Free_Memory_Not_on_Heap__free_struct_static_54a.c,"    twoIntsStruct * data;
    data = NULL; 
    {
        
        static twoIntsStruct dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i].intOne = 1;
                dataBuffer[i].intTwo = 1;
            }
        }
        data = dataBuffer;
    }
"
5260,0,CWE401_Memory_Leak__new_array_char_41.cpp,"    char * data;
    data = NULL;
    
    data = new char[100];
    
    strcpy(data, ""A String"");
    printLine(data);
"
2299,0,CWE78_OS_Command_Injection__char_file_system_14.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(globalFive==5)
    {
        {
            
            size_t dataLen = strlen(data);
            FILE * pFile;
            
            if (100-dataLen > 1)
            {
                pFile = fopen(FILENAME, ""r"");
                if (pFile != NULL)
                {
                    
                    if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                    {
                        printLine(""fgets() failed"");
                        
                        data[dataLen] = '\0';
                    }
                    fclose(pFile);
                }
            }
        }
    }
    
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
"
18172,0,CWE134_Uncontrolled_Format_String__char_file_snprintf_82a.cpp,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        FILE * pFile;
        
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
    CWE134_Uncontrolled_Format_String__char_file_snprintf_82_base* baseObject = new CWE134_Uncontrolled_Format_String__char_file_snprintf_82_bad;
    baseObject->action(data);
"
17699,0,CWE401_Memory_Leak__malloc_realloc_struct_twoIntsStruct_01.c,"    {
        struct _twoIntsStruct * data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));
        if (data == NULL) {exit(-1);}
        
        data[0].intOne = 0;
        data[0].intTwo = 0;
        printStructLine((twoIntsStruct *)&data[0]);
        
        data = (struct _twoIntsStruct *)realloc(data, (130000)*sizeof(struct _twoIntsStruct));
        if (data != NULL)
        {
            
            data[0].intOne = 1;
            data[0].intTwo = 1;
            printStructLine((twoIntsStruct *)&data[0]);
            free(data);
        }
"
2127,1,CWE758_Undefined_Behavior__char_malloc_use_04.c,"    if(STATIC_CONST_FALSE)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            char data;
            char * pointer = (char *)malloc(sizeof(char));
            if (pointer == NULL) {exit(-1);}
            data = 5;
            *pointer = data; 
            {
                char data = *pointer;
                printHexCharLine(data);
            }
            free(pointer);
        }
"
3514,0,CWE190_Integer_Overflow__short_fscanf_preinc_14.c,"    short data;
    data = 0;
    if(globalFive==5)
    {
        
        fscanf (stdin, ""%hd"", &data);
    }
    if(globalFive==5)
    {
        {
            
            ++data;
            short result = data;
            printIntLine(result);
        }
"
11328,0,CWE416_Use_After_Free__new_delete_struct_11.cpp,"    twoIntsStruct * data;
    
    data = NULL;
    if(globalReturnsTrue())
    {
        data = new twoIntsStruct;
        data->intOne = 1;
        data->intTwo = 2;
        
        delete data;
    }
    if(globalReturnsTrue())
    {
        
        printStructLine(data);
        
"
11941,0,CWE401_Memory_Leak__malloc_realloc_char_04.c,"    if(STATIC_CONST_TRUE)
    {
        {
            char * data = (char *)malloc(100*sizeof(char));
            if (data == NULL) {exit(-1);}
            
            strcpy(data, ""A String"");
            printLine(data);
            
            data = (char *)realloc(data, (130000)*sizeof(char));
            if (data != NULL)
            {
                
                strcpy(data, ""New String"");
                printLine(data);
                free(data);
            }
        }
"
5264,0,CWE415_Double_Free__malloc_free_char_43.cpp,"    char * data;
    
    data = NULL;
    badSource(data);
    
"
14346,0,CWE369_Divide_by_Zero__int_rand_modulo_31.c,"    int data;
    
    data = -1;
    
    data = RAND32();
    {
        int dataCopy = data;
        int data = dataCopy;
        
        printIntLine(100 % data);
"
18867,1,CWE758_Undefined_Behavior__char_pointer_alloca_use_09.c,"    if(GLOBAL_CONST_TRUE)
    {
        {
            char * data;
            char * * pointer = (char * *)ALLOCA(sizeof(char *));
            data = ""string"";
            *pointer = data; 
            {
                char * data = *pointer;
                printLine(data);
            }
        }
"
4117,0,CWE590_Free_Memory_Not_on_Heap__delete_struct_placement_new_67a.cpp,"    twoIntsStruct * data;
    structType myStruct;
    data = NULL; 
    {
        
        char buffer[sizeof(twoIntsStruct)];
        twoIntsStruct * dataBuffer = new(buffer) twoIntsStruct;
        dataBuffer->intOne = 1;
        dataBuffer->intTwo = 1;
        data = dataBuffer;
    }
    myStruct.structFirst = data;
"
18302,1,CWE688_Function_Call_With_Incorrect_Variable_or_Reference_as_Argument__basic_06.c,"    if(STATIC_CONST_FIVE!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            char dest[DEST_SIZE];
            int intFive = 5;
            
            sprintf(dest, ""%d"", intFive);
            printLine(dest);
        }
"
14112,0,CWE401_Memory_Leak__int64_t_malloc_02.c,"    int64_t * data;
    data = NULL;
    if(1)
    {
        
        data = (int64_t *)malloc(100*sizeof(int64_t));
        if (data == NULL) {exit(-1);}
        
        data[0] = 5LL;
        printLongLongLine(data[0]);
    }
    if(1)
    {
        
        ; 
"
15362,0,CWE190_Integer_Overflow__int64_t_rand_square_18.c,"    int64_t data;
    data = 0LL;
    goto source;
source:
    
    data = (int64_t)RAND64();
    goto sink;
sink:
    {
        
        int64_t result = data * data;
        printLongLongLine(result);
"
5893,0,CWE190_Integer_Overflow__int_listen_socket_square_84a.cpp,"    int data;
    
    data = 0;
    CWE190_Integer_Overflow__int_listen_socket_square_84_bad * badObject = new CWE190_Integer_Overflow__int_listen_socket_square_84_bad(data);
"
4458,0,CWE758_Undefined_Behavior__struct_malloc_use_15.c,"    switch(6)
    {
    case 6:
    {
        twoIntsStruct * pointer = (twoIntsStruct *)malloc(sizeof(twoIntsStruct));
        if (pointer == NULL) {exit(-1);}
        twoIntsStruct data = *pointer; 
        free(pointer);
        printIntLine(data.intOne);
        printIntLine(data.intTwo);
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
17901,0,CWE190_Integer_Overflow__short_rand_square_16.c,"    short data;
    data = 0;
    while(1)
    {
        
        data = (short)RAND32();
        break;
    }
    while(1)
    {
        {
            
            short result = data * data;
            printIntLine(result);
        }
        break;
"
3839,0,CWE190_Integer_Overflow__int_rand_postinc_66a.c,"    int data;
    int dataArray[5];
    
    data = 0;
    
    data = RAND32();
    
    dataArray[2] = data;
"
6729,0,CWE416_Use_After_Free__new_delete_class_09.cpp,"    TwoIntsClass * data;
    
    data = NULL;
    if(GLOBAL_CONST_TRUE)
    {
        data = new TwoIntsClass;
        data->intOne = 1;
        data->intTwo = 2;
        
        delete data;
    }
    if(GLOBAL_CONST_TRUE)
    {
        
        printIntLine(data->intOne);
        
"
2161,0,CWE563_Unused_Variable__unused_value_char_17.c,"    int i,j;
    char data;
    for(i = 0; i < 1; i++)
    {
        
        data = 'C';
    }
    for(j = 0; j < 1; j++)
    {
        
        data = 'Z';
        printHexCharLine(data);
"
1931,0,CWE190_Integer_Overflow__short_fscanf_preinc_03.c,"    short data;
    data = 0;
    if(5==5)
    {
        
        fscanf (stdin, ""%hd"", &data);
    }
    if(5==5)
    {
        {
            
            ++data;
            short result = data;
            printIntLine(result);
        }
"
14153,0,CWE401_Memory_Leak__new_int64_t_73a.cpp,"    int64_t * data;
    list<int64_t *> dataList;
    data = NULL;
    
    data = new int64_t;
    
    *data = 5LL;
    printLongLongLine(*data);
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
16714,0,CWE416_Use_After_Free__new_delete_class_10.cpp,"    TwoIntsClass * data;
    
    data = NULL;
    if(globalTrue)
    {
        data = new TwoIntsClass;
        data->intOne = 1;
        data->intTwo = 2;
        
        delete data;
    }
    if(globalTrue)
    {
        
        printIntLine(data->intOne);
        
"
15552,0,CWE190_Integer_Overflow__int_rand_square_63a.c,"    int data;
    
    data = 0;
    
    data = RAND32();
"
101,0,CWE590_Free_Memory_Not_on_Heap__delete_array_int_declare_13.cpp,"    int * data;
    data = NULL; 
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            
            int dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5;
                }
            }
            data = dataBuffer;
        }
    }
    printIntLine(data[0]);
    
"
18912,0,CWE190_Integer_Overflow__int64_t_rand_postinc_15.c,"    int64_t data;
    data = 0LL;
    switch(6)
    {
    case 6:
        
        data = (int64_t)RAND64();
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
    {
        
        data++;
        int64_t result = data;
        printLongLongLine(result);
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
14790,0,CWE401_Memory_Leak__new_array_int_09.cpp,"    int * data;
    data = NULL;
    if(GLOBAL_CONST_TRUE)
    {
        
        data = new int[100];
        
        data[0] = 5;
        printIntLine(data[0]);
    }
    if(GLOBAL_CONST_TRUE)
    {
        
        ; 
"
188,0,CWE401_Memory_Leak__struct_twoIntsStruct_calloc_53a.c,"    struct _twoIntsStruct * data;
    data = NULL;
    
    data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));
    if (data == NULL) {exit(-1);}
    
    data[0].intOne = 0;
    data[0].intTwo = 0;
    printStructLine((twoIntsStruct *)&data[0]);
"
1189,0,CWE690_NULL_Deref_From_Return__char_realloc_34.c,"    char * data;
    CWE690_NULL_Deref_From_Return__char_realloc_34_unionType myUnion;
    data = NULL; 
    
    data = (char *)realloc(data, 20*sizeof(char));
    myUnion.unionFirst = data;
    {
        char * data = myUnion.unionSecond;
        
        strcpy(data, ""Initialize"");
        printLine(data);
        free(data);
"
14682,0,CWE190_Integer_Overflow__unsigned_int_max_postinc_03.c,"    unsigned int data;
    data = 0;
    if(5==5)
    {
        
        data = UINT_MAX;
    }
    if(5==5)
    {
        {
            
            data++;
            unsigned int result = data;
            printUnsignedLine(result);
        }
"
6957,0,CWE590_Free_Memory_Not_on_Heap__delete_int64_t_static_81a.cpp,"    int64_t * data;
    data = NULL; 
    {
        
        static int64_t dataBuffer;
        dataBuffer = 5LL;
        data = &dataBuffer;
    }
    const CWE590_Free_Memory_Not_on_Heap__delete_int64_t_static_81_base& baseObject = CWE590_Free_Memory_Not_on_Heap__delete_int64_t_static_81_bad();
"
5615,0,CWE401_Memory_Leak__int64_t_malloc_22a.c,"    int64_t * data;
    data = NULL;
    
    data = (int64_t *)malloc(100*sizeof(int64_t));
    if (data == NULL) {exit(-1);}
    
    data[0] = 5LL;
    printLongLongLine(data[0]);
    CWE401_Memory_Leak__int64_t_malloc_22_badGlobal = 1; 
"
9760,0,CWE415_Double_Free__new_delete_int64_t_17.cpp,"    int i,j;
    int64_t * data;
    
    data = NULL;
    for(i = 0; i < 1; i++)
    {
        data = new int64_t;
        
        delete data;
    }
    for(j = 0; j < 1; j++)
    {
        
        delete data;
"
18869,0,CWE590_Free_Memory_Not_on_Heap__free_char_alloca_52a.c,"    char * data;
    data = NULL; 
    {
        
        char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
        memset(dataBuffer, 'A', 100-1); 
        dataBuffer[100-1] = '\0'; 
        data = dataBuffer;
    }
"
11661,0,CWE197_Numeric_Truncation_Error__short_connect_socket_31.c,"    short data;
    
    data = -1;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = (short)atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    {
        short dataCopy = data;
        short data = dataCopy;
        {
            
            char charData = (char)data;
            printHexCharLine(charData);
        }
"
10424,0,CWE197_Numeric_Truncation_Error__short_rand_41.c,"    short data;
    
    data = -1;
    
    data = (short)RAND32();
"
16052,0,CWE590_Free_Memory_Not_on_Heap__delete_array_struct_alloca_11.cpp,"    twoIntsStruct * data;
    data = NULL; 
    if(globalReturnsTrue())
    {
        {
            
            twoIntsStruct * dataBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i].intOne = 1;
                    dataBuffer[i].intTwo = 1;
                }
            }
            data = dataBuffer;
        }
    }
    printStructLine(&data[0]);
    
"
8159,0,CWE401_Memory_Leak__new_array_int_12.cpp,"    int * data;
    data = NULL;
    if(globalReturnsTrueOrFalse())
    {
        
        data = new int[100];
        
        data[0] = 5;
        printIntLine(data[0]);
    }
    else
    {
        
        int dataGoodBuffer[100];
        data = dataGoodBuffer;
        
        data[0] = 5;
        printIntLine(data[0]);
    }
    if(globalReturnsTrueOrFalse())
    {
        
        ; 
    }
    else
    {
        
        delete[] data;
"
8641,0,CWE590_Free_Memory_Not_on_Heap__free_int_static_67a.c,"    int * data;
    CWE590_Free_Memory_Not_on_Heap__free_int_static_67_structType myStruct;
    data = NULL; 
    {
        
        static int dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5;
            }
        }
        data = dataBuffer;
    }
    myStruct.structFirst = data;
"
5447,0,CWE369_Divide_by_Zero__float_rand_51a.c,"    float data;
    
    data = 0.0F;
    
    data = (float)RAND32();
"
5490,0,CWE563_Unused_Variable__unused_init_variable_long_14.c,"    long data;
    
    data = 5L;
    if(globalFive==5)
    {
        
        
        ; 
"
1586,0,CWE190_Integer_Overflow__char_max_square_83_bad.cpp,"Label Definition File: CWE190_Integer_Overflow.label.xml
Template File: sources-sinks-83_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 190 Integer Overflow
 * BadSource: max Set data to the max value for char
 * GoodSource: Set data to a small, non-zero number (two)
 * Sinks: square
 *    GoodSink: Ensure there will not be an overflow before squaring data
 *    BadSink : Square data, which can lead to overflow
 * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE190_Integer_Overflow__char_max_square_83.h""

#include <math.h>

namespace CWE190_Integer_Overflow__char_max_square_83
{
CWE190_Integer_Overflow__char_max_square_83_bad::CWE190_Integer_Overflow__char_max_square_83_bad(char dataCopy)
{
    data = dataCopy;
    
    data = CHAR_MAX;
}

CWE190_Integer_Overflow__char_max_square_83_bad::~CWE190_Integer_Overflow__char_max_square_83_bad()
{
    {
        
        char result = data * data;
        printHexCharLine(result);
    }
}
}
"
12590,0,CWE590_Free_Memory_Not_on_Heap__free_long_static_10.c,"    long * data;
    data = NULL; 
    if(globalTrue)
    {
        {
            
            static long dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5L;
                }
            }
            data = dataBuffer;
        }
    }
    printLongLine(data[0]);
    
"
1630,1,CWE758_Undefined_Behavior__char_pointer_malloc_use_16.c,"    while(1)
    {
        {
            char * data;
            char * * pointer = (char * *)malloc(sizeof(char *));
            if (pointer == NULL) {exit(-1);}
            data = ""string"";
            *pointer = data; 
            {
                char * data = *pointer;
                printLine(data);
            }
            free(pointer);
        }
        break;
"
16853,0,CWE252_Unchecked_Return_Value__char_fwrite_04.c,"    if(STATIC_CONST_TRUE)
    {
        
        fwrite((char *)""string"", sizeof(char), strlen(""string""), stdout);
"
5360,0,CWE190_Integer_Overflow__short_max_preinc_52a.c,"    short data;
    data = 0;
    
    data = SHRT_MAX;
"
4243,1,CWE758_Undefined_Behavior__int_pointer_new_use_06.cpp,"    if(STATIC_CONST_FIVE==5)
    {
        {
            int * data;
            
            data = new int;
            *data = 5;
            int * * pointer = new int *;
            *pointer = data; 
            {
                int * data = *pointer;
                printIntLine(*data);
            }
            delete pointer;
        }
"
19505,0,CWE190_Integer_Overflow__char_fscanf_square_33.cpp,"    char data;
    char &dataRef = data;
    data = ' ';
    
    fscanf (stdin, ""%c"", &data);
    {
        char data = dataRef;
        {
            
            char result = data * data;
            printHexCharLine(result);
        }
"
14662,0,CWE190_Integer_Overflow__int_fscanf_square_01.c,"    int data;
    
    data = 0;
    
    fscanf(stdin, ""%d"", &data);
    {
        
        int result = data * data;
        printIntLine(result);
"
2661,0,CWE415_Double_Free__malloc_free_long_61a.c,"    long * data;
    
    data = NULL;
    data = CWE415_Double_Free__malloc_free_long_61b_badSource(data);
    
"
19075,0,CWE457_Use_of_Uninitialized_Variable__struct_array_declare_partial_init_09.c,"    twoIntsStruct * data;
    twoIntsStruct dataUninitArray[10];
    data = dataUninitArray;
    if(GLOBAL_CONST_TRUE)
    {
        
        {
            int i;
            for(i=0; i<(10/2); i++)
            {
                data[i].intOne = i;
                data[i].intTwo = i;
            }
        }
    }
    if(GLOBAL_CONST_TRUE)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i].intOne);
                printIntLine(data[i].intTwo);
            }
        }
"
15001,0,CWE78_OS_Command_Injection__char_console_execlp_83_bad.cpp,"Label Definition File: CWE78_OS_Command_Injection.strings.label.xml
Template File: sources-sink-83_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 78 OS Command Injection
 * BadSource: console Read input from the console
 * GoodSource: Fixed string
 * Sinks: execlp
 *    BadSink : execute command with execlp
 * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE78_OS_Command_Injection__char_console_execlp_83.h""
"
5830,0,CWE78_OS_Command_Injection__char_console_execlp_08.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(staticReturnsTrue())
    {
        {
            
            size_t dataLen = strlen(data);
            
            if (100-dataLen > 1)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
                {
                    /* The next few lines remove the carriage return from the string that is
                     * inserted by fgets() */
                    dataLen = strlen(data);
"
9897,0,CWE590_Free_Memory_Not_on_Heap__free_char_declare_33.cpp,"    char * data;
    char * &dataRef = data;
    data = NULL; 
    {
        
        char dataBuffer[100];
        memset(dataBuffer, 'A', 100-1); 
        dataBuffer[100-1] = '\0'; 
        data = dataBuffer;
    }
    {
        char * data = dataRef;
        printLine(data);
        
        free(data);
"
5084,0,CWE563_Unused_Variable__unused_value_long_82a.cpp,"    long data;
    
    data = 5L;
    CWE563_Unused_Variable__unused_value_long_82_base* baseObject = new CWE563_Unused_Variable__unused_value_long_82_bad;
    baseObject->action(data);
"
4757,0,CWE416_Use_After_Free__new_delete_char_15.cpp,"    char * data;
    
    data = NULL;
    switch(6)
    {
    case 6:
        data = new char;
        *data = 'A';
        
        delete data;
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
        
        printHexCharLine(*data);
        
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
19312,0,CWE134_Uncontrolled_Format_String__char_console_snprintf_66a.c,"    char * data;
    char * dataArray[5];
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        
        if (100-dataLen > 1)
        {
            
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgets() */
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
                    data[dataLen-1] = '\0';
                }
            }
            else
            {
                printLine(""fgets() failed"");
                
                data[dataLen] = '\0';
            }
        }
    }
    
    dataArray[2] = data;
"
13840,0,CWE590_Free_Memory_Not_on_Heap__free_int64_t_alloca_11.c,"    int64_t * data;
    data = NULL; 
    if(globalReturnsTrue())
    {
        {
            
            int64_t * dataBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5LL;
                }
            }
            data = dataBuffer;
        }
    }
    printLongLongLine(data[0]);
    
"
736,1,CWE252_Unchecked_Return_Value__char_putc_04.c,"    if(STATIC_CONST_TRUE)
    {
        
        if (putc((int)'A', stdout) == EOF)
        {
            printLine(""putc failed!"");
        }
"
16988,0,CWE190_Integer_Overflow__short_max_square_18.c,"    short data;
    data = 0;
    goto source;
source:
    
    data = SHRT_MAX;
    goto sink;
sink:
    {
        
        short result = data * data;
        printIntLine(result);
"
3208,0,CWE563_Unused_Variable__unused_uninit_variable_long_83_bad.cpp,"Label Definition File: CWE563_Unused_Variable__unused_uninit_variable.label.xml
Template File: source-sinks-83_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 563 Unused Variable
 * BadSource:  Initialize data
 * Sinks:
 *    GoodSink: Initialize, then use data
 *    BadSink : Do nothing
 * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE563_Unused_Variable__unused_uninit_variable_long_83.h""

namespace CWE563_Unused_Variable__unused_uninit_variable_long_83
{
CWE563_Unused_Variable__unused_uninit_variable_long_83_bad::CWE563_Unused_Variable__unused_uninit_variable_long_83_bad(long dataCopy)
{
    data = dataCopy;
    
    ; 
}

CWE563_Unused_Variable__unused_uninit_variable_long_83_bad::~CWE563_Unused_Variable__unused_uninit_variable_long_83_bad()
{
    
    
    ; 
}
}
"
14504,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_81a.cpp,"    size_t data;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = strtoul(inputBuffer, NULL, 0);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    const CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_81_base& baseObject = CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_81_bad();
"
7002,0,CWE590_Free_Memory_Not_on_Heap__delete_array_struct_alloca_15.cpp,"    twoIntsStruct * data;
    data = NULL; 
    switch(6)
    {
    case 6:
    {
        
        twoIntsStruct * dataBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i].intOne = 1;
                dataBuffer[i].intTwo = 1;
            }
        }
        data = dataBuffer;
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    printStructLine(&data[0]);
    
"
7547,0,CWE369_Divide_by_Zero__float_connect_socket_54a.c,"    float data;
    
    data = 0.0F;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = (float)atof(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
11664,0,CWE590_Free_Memory_Not_on_Heap__free_char_alloca_44.c,"    char * data;
    
    void (*funcPtr) (char *) = badSink;
    data = NULL; 
    {
        
        char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
        memset(dataBuffer, 'A', 100-1); 
        dataBuffer[100-1] = '\0'; 
        data = dataBuffer;
    }
    
"
9413,0,CWE690_NULL_Deref_From_Return__int64_t_malloc_53a.c,"    int64_t * data;
    data = NULL; 
    
    data = (int64_t *)malloc(1*sizeof(int64_t));
"
13407,1,CWE252_Unchecked_Return_Value__char_fwrite_17.c,"    int k;
    for(k = 0; k < 1; k++)
    {
        
        if (fwrite((char *)""string"", sizeof(char), strlen(""string""), stdout) != strlen(""string""))
        {
            printLine(""fwrite failed!"");
        }
"
2824,0,CWE476_NULL_Pointer_Dereference__struct_67a.c,"    twoIntsStruct * data;
    CWE476_NULL_Pointer_Dereference__struct_67_structType myStruct;
    
    data = NULL;
    myStruct.structFirst = data;
"
11176,1,CWE758_Undefined_Behavior__int_pointer_alloca_use_15.c,"    switch(5)
    {
    case 6:
        
        printLine(""Benign, fixed string"");
        break;
    default:
    {
        int * data;
        int * * pointer = (int * *)ALLOCA(sizeof(int *));
        
        data = (int *)malloc(sizeof(int));
        if (data == NULL) {exit(-1);}
        *data = 5;
        *pointer = data; 
        {
            int * data = *pointer;
            printIntLine(*data);
        }
    }
    break;
"
7380,0,CWE78_OS_Command_Injection__char_console_execlp_33.cpp,"    char * data;
    char * &dataRef = data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        
        if (100-dataLen > 1)
        {
            
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgets() */
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
"
6658,0,CWE457_Use_of_Uninitialized_Variable__struct_array_malloc_no_init_06.c,"    twoIntsStruct * data;
    data = (twoIntsStruct *)malloc(10*sizeof(twoIntsStruct));
    if (data == NULL) {exit(-1);}
    if(STATIC_CONST_FIVE==5)
    {
        
        ; 
    }
    if(STATIC_CONST_FIVE==5)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i].intOne);
                printIntLine(data[i].intTwo);
            }
        }
"
4156,1,CWE758_Undefined_Behavior__struct_malloc_use_04.c,"    if(STATIC_CONST_FALSE)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            twoIntsStruct data;
            twoIntsStruct * pointer = (twoIntsStruct *)malloc(sizeof(twoIntsStruct));
            if (pointer == NULL) {exit(-1);}
            data.intOne = 1;
            data.intTwo = 2;
            *pointer = data; 
            {
                twoIntsStruct data = *pointer;
                printIntLine(data.intOne);
                printIntLine(data.intTwo);
            }
            free(pointer);
        }
"
1835,0,CWE665_Improper_Initialization__char_ncat_16.c,"    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    while(1)
    {
        
        ; 
        break;
    }
    {
        size_t sourceLen;
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        sourceLen = strlen(source);
        
        strncat(data, source, sourceLen);
        printLine(data);
"
8587,0,CWE590_Free_Memory_Not_on_Heap__delete_char_placement_new_15.cpp,"    char * data;
    data = NULL; 
    switch(6)
    {
    case 6:
    {
        
        char buffer[sizeof(char)];
        char * dataBuffer = new(buffer) char;
        *dataBuffer = 'A';
        data = dataBuffer;
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    printHexCharLine(*data);
    
"
8348,0,CWE457_Use_of_Uninitialized_Variable__double_array_alloca_partial_init_15.c,"    double * data;
    data = (double *)ALLOCA(10*sizeof(double));
    switch(6)
    {
    case 6:
        
    {
        int i;
        for(i=0; i<(10/2); i++)
        {
            data[i] = (double)i;
        }
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
        
    {
        int i;
        for(i=0; i<10; i++)
        {
            printDoubleLine(data[i]);
        }
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
11263,0,CWE190_Integer_Overflow__char_fscanf_add_05.c,"    char data;
    data = ' ';
    if(staticTrue)
    {
        
        fscanf (stdin, ""%c"", &data);
    }
    if(staticTrue)
    {
        {
            
            char result = data + 1;
            printHexCharLine(result);
        }
"
1898,0,CWE758_Undefined_Behavior__char_new_use_03.cpp,"    if(5==5)
    {
        {
            char * pointer = new char;
            char data = *pointer; 
            delete pointer;
            printHexCharLine(data);
        }
"
4174,0,CWE416_Use_After_Free__new_delete_int_14.cpp,"    int * data;
    
    data = NULL;
    if(globalFive==5)
    {
        data = new int;
        *data = 5;
        
        delete data;
    }
    if(globalFive==5)
    {
        
        printIntLine(*data);
        
"
19483,0,CWE590_Free_Memory_Not_on_Heap__delete_int_alloca_11.cpp,"    int * data;
    data = NULL; 
    if(globalReturnsTrue())
    {
        {
            
            int * dataBuffer = (int *)ALLOCA(sizeof(int));
            *dataBuffer = 5;
            data = dataBuffer;
        }
    }
    printIntLine(*data);
    
"
10175,0,CWE415_Double_Free__malloc_free_int64_t_68a.c,"    int64_t * data;
    
    data = NULL;
    data = (int64_t *)malloc(100*sizeof(int64_t));
    if (data == NULL) {exit(-1);}
    
    free(data);
    CWE415_Double_Free__malloc_free_int64_t_68_badData = data;
"
10679,0,CWE401_Memory_Leak__int64_t_calloc_84_bad.cpp,"Label Definition File: CWE401_Memory_Leak.c.label.xml
Template File: sources-sinks-84_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 401 Memory Leak
 * BadSource: calloc Allocate data using calloc()
 * GoodSource: Allocate data on the stack
 * Sinks:
 *    GoodSink: call free() on data
 *    BadSink : no deallocation of data
 * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE401_Memory_Leak__int64_t_calloc_84.h""

namespace CWE401_Memory_Leak__int64_t_calloc_84
{
CWE401_Memory_Leak__int64_t_calloc_84_bad::CWE401_Memory_Leak__int64_t_calloc_84_bad(int64_t * dataCopy)
{
    data = dataCopy;
    
    data = (int64_t *)calloc(100, sizeof(int64_t));
    if (data == NULL) {exit(-1);}
    
    data[0] = 5LL;
    printLongLongLine(data[0]);
}

CWE401_Memory_Leak__int64_t_calloc_84_bad::~CWE401_Memory_Leak__int64_t_calloc_84_bad()
{
    
    ; 
}
}
"
10053,0,CWE590_Free_Memory_Not_on_Heap__delete_long_static_66a.cpp,"    long * data;
    long * dataArray[5];
    data = NULL; 
    {
        
        static long dataBuffer;
        dataBuffer = 5L;
        data = &dataBuffer;
    }
    
    dataArray[2] = data;
"
2573,0,CWE590_Free_Memory_Not_on_Heap__free_long_alloca_11.c,"    long * data;
    data = NULL; 
    if(globalReturnsTrue())
    {
        {
            
            long * dataBuffer = (long *)ALLOCA(100*sizeof(long));
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5L;
                }
            }
            data = dataBuffer;
        }
    }
    printLongLine(data[0]);
    
"
19375,0,CWE457_Use_of_Uninitialized_Variable__long_10.c,"    long data;
    if(globalTrue)
    {
        
        ; 
    }
    if(globalTrue)
    {
        
        printLongLine(data);
"
17812,0,CWE590_Free_Memory_Not_on_Heap__free_int_alloca_82a.cpp,"    int * data;
    data = NULL; 
    {
        
        int * dataBuffer = (int *)ALLOCA(100*sizeof(int));
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5;
            }
        }
        data = dataBuffer;
    }
    CWE590_Free_Memory_Not_on_Heap__free_int_alloca_82_base* baseObject = new CWE590_Free_Memory_Not_on_Heap__free_int_alloca_82_bad;
    baseObject->action(data);
"
12445,0,CWE197_Numeric_Truncation_Error__short_rand_82_bad.cpp,"Label Definition File: CWE197_Numeric_Truncation_Error__short.label.xml
Template File: sources-sink-82_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 197 Numeric Truncation Error
 * BadSource: rand Set data to result of RAND32(), which could be negative
 * GoodSource: Less than CHAR_MAX
 * Sinks:
 *    BadSink : Convert data to a char
 * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE197_Numeric_Truncation_Error__short_rand_82.h""

namespace CWE197_Numeric_Truncation_Error__short_rand_82
{

void CWE197_Numeric_Truncation_Error__short_rand_82_bad::action(short data)
{
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
    }
}

}
"
10895,0,CWE590_Free_Memory_Not_on_Heap__delete_array_struct_alloca_64a.cpp,"    twoIntsStruct * data;
    data = NULL; 
    {
        
        twoIntsStruct * dataBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i].intOne = 1;
                dataBuffer[i].intTwo = 1;
            }
        }
        data = dataBuffer;
    }
"
3857,0,CWE190_Integer_Overflow__int64_t_max_preinc_52a.c,"    int64_t data;
    data = 0LL;
    
    data = LLONG_MAX;
"
7246,0,CWE457_Use_of_Uninitialized_Variable__double_02.c,"    double data;
    if(1)
    {
        
        ; 
    }
    if(1)
    {
        
        printDoubleLine(data);
"
17498,0,CWE758_Undefined_Behavior__char_pointer_alloca_use_03.c,"    if(5==5)
    {
        {
            char * * pointer = (char * *)ALLOCA(sizeof(char *));
            char * data = *pointer; 
            printLine(data);
        }
"
12081,0,CWE78_OS_Command_Injection__char_connect_socket_popen_10.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(globalTrue)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET connectSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
"
1471,0,CWE190_Integer_Overflow__int64_t_max_multiply_41.c,"    int64_t data;
    data = 0LL;
    
    data = LLONG_MAX;
"
13591,0,CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_81_bad.cpp,"Label Definition File: CWE134_Uncontrolled_Format_String.vasinks.label.xml
Template File: sources-vasinks-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 134 Uncontrolled Format String
 * BadSource: listen_socket Read data using a listen socket (server side)
 * GoodSource: Copy a fixed string into data
 * Sinks: vprintf
 *    GoodSink: vprintf with a format string
 *    BadSink : vprintf without a format string
 * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include <stdarg.h>
#include ""std_testcase.h""
#include ""CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_81.h""

namespace CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_81
{

static void badVaSink(char * data, ...)
{
    {
        va_list args;
        va_start(args, data);
        
        vprintf(data, args);
        va_end(args);
    }
}

void CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_81_bad::action(char * data) const
{
    badVaSink(data, data);
}

}
"
1708,0,CWE590_Free_Memory_Not_on_Heap__delete_array_int64_t_alloca_08.cpp,"    int64_t * data;
    data = NULL; 
    if(staticReturnsTrue())
    {
        {
            
            int64_t * dataBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5LL;
                }
            }
            data = dataBuffer;
        }
    }
    printLongLongLine(data[0]);
    
"
8493,0,CWE590_Free_Memory_Not_on_Heap__delete_array_long_alloca_51a.cpp,"    long * data;
    data = NULL; 
    {
        
        long * dataBuffer = (long *)ALLOCA(100*sizeof(long));
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5L;
            }
        }
        data = dataBuffer;
    }
"
9597,0,CWE369_Divide_by_Zero__float_fscanf_61a.c,"    float data;
    
    data = 0.0F;
    data = CWE369_Divide_by_Zero__float_fscanf_61b_badSource(data);
    {
        
        int result = (int)(100.0 / data);
        printIntLine(result);
"
7286,0,CWE78_OS_Command_Injection__char_listen_socket_system_17.c,"    int i;
    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    for(i = 0; i < 1; i++)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                data[dataLen + recvResult / sizeof(char)] = '\0';
                
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
"
15254,0,CWE401_Memory_Leak__strdup_char_08.c,"    char * data;
    data = NULL;
    if(staticReturnsTrue())
    {
        {
            char myString[] = ""myString"";
            
            data = strdup(myString);
            
            printLine(data);
        }
    }
    if(staticReturnsTrue())
    {
        
        
        ; 
"
18193,0,CWE190_Integer_Overflow__char_rand_square_15.c,"    char data;
    data = ' ';
    switch(6)
    {
    case 6:
        
        data = (char)RAND32();
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
    {
        
        char result = data * data;
        printHexCharLine(result);
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
16337,0,CWE690_NULL_Deref_From_Return__struct_malloc_07.c,"    twoIntsStruct * data;
    data = NULL; 
    
    data = (twoIntsStruct *)malloc(1*sizeof(twoIntsStruct));
    if(staticFive==5)
    {
        
        data[0].intOne = 1;
        data[0].intTwo = 1;
        printStructLine(&data[0]);
        free(data);
"
8712,0,CWE415_Double_Free__new_delete_array_int_01.cpp,"    int * data;
    
    data = NULL;
    data = new int[100];
    
    delete [] data;
    
"
14237,0,CWE563_Unused_Variable__unused_value_int_11.c,"    int data;
    if(globalReturnsTrue())
    {
        
        data = 5;
    }
    if(globalReturnsTrue())
    {
        
        data = 10;
        printIntLine(data);
"
6474,1,CWE252_Unchecked_Return_Value__char_rename_18.c,"    goto sink;
sink:
    
    if (RENAME(OLD_GOOD_FILE_NAME, ""newgoodfilename.txt"") != 0)
    {
        printLine(""rename failed!"");
"
17825,0,CWE590_Free_Memory_Not_on_Heap__delete_class_declare_81a.cpp,"    TwoIntsClass * data;
    data = NULL; 
    {
        
        TwoIntsClass dataBuffer;
        dataBuffer.intOne = 1;
        dataBuffer.intTwo = 1;
        data = &dataBuffer;
    }
    const CWE590_Free_Memory_Not_on_Heap__delete_class_declare_81_base& baseObject = CWE590_Free_Memory_Not_on_Heap__delete_class_declare_81_bad();
"
14312,0,CWE457_Use_of_Uninitialized_Variable__twointsclass_array_alloca_partial_init_43.cpp,"    TwoIntsClass * data;
    data = reinterpret_cast<TwoIntsClass *>(ALLOCA(10*sizeof(TwoIntsClass)));
    badSource(data);
    
    for(int i=0; i<10; i++)
    {
        printIntLine(data[i].intOne);
        printIntLine(data[i].intTwo);
"
2616,0,CWE590_Free_Memory_Not_on_Heap__free_struct_static_63a.c,"    twoIntsStruct * data;
    data = NULL; 
    {
        
        static twoIntsStruct dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i].intOne = 1;
                dataBuffer[i].intTwo = 1;
            }
        }
        data = dataBuffer;
    }
"
19198,0,CWE590_Free_Memory_Not_on_Heap__delete_array_char_static_33.cpp,"    char * data;
    char * &dataRef = data;
    data = NULL; 
    {
        
        static char dataBuffer[100];
        memset(dataBuffer, 'A', 100-1); 
        dataBuffer[100-1] = '\0'; 
        data = dataBuffer;
    }
    {
        char * data = dataRef;
        printLine(data);
        
        delete [] data;
"
7489,0,CWE665_Improper_Initialization__char_ncat_09.c,"    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    if(GLOBAL_CONST_TRUE)
    {
        
        ; 
    }
    {
        size_t sourceLen;
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        sourceLen = strlen(source);
        
        strncat(data, source, sourceLen);
        printLine(data);
"
4989,0,CWE758_Undefined_Behavior__int64_t_new_use_16.cpp,"    while(1)
    {
        {
            int64_t * pointer = new int64_t;
            int64_t data = *pointer; 
            delete pointer;
            printLongLongLine(data);
        }
        break;
"
12120,0,CWE78_OS_Command_Injection__char_file_popen_07.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(staticFive==5)
    {
        {
            
            size_t dataLen = strlen(data);
            FILE * pFile;
            
            if (100-dataLen > 1)
            {
                pFile = fopen(FILENAME, ""r"");
                if (pFile != NULL)
                {
                    
                    if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                    {
                        printLine(""fgets() failed"");
                        
                        data[dataLen] = '\0';
                    }
                    fclose(pFile);
                }
            }
        }
    }
    {
        FILE *pipe;
        
        pipe = POPEN(data, ""w"");
        if (pipe != NULL)
        {
            PCLOSE(pipe);
        }
"
11068,0,CWE190_Integer_Overflow__int_listen_socket_add_22a.c,"    int data;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    CWE190_Integer_Overflow__int_listen_socket_add_22_badGlobal = 1; 
"
10596,0,CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_65a.c,"    unsigned int data;
    
    void (*funcPtr) (unsigned int) = CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_65b_badSink;
    data = 0;
    
    fscanf (stdin, ""%u"", &data);
    
"
13768,0,CWE190_Integer_Overflow__short_max_multiply_67a.c,"    short data;
    CWE190_Integer_Overflow__short_max_multiply_67_structType myStruct;
    data = 0;
    
    data = SHRT_MAX;
    myStruct.structFirst = data;
"
7454,0,CWE590_Free_Memory_Not_on_Heap__delete_int64_t_placement_new_52a.cpp,"    int64_t * data;
    data = NULL; 
    {
        
        char buffer[sizeof(int64_t)];
        int64_t * dataBuffer = new(buffer) int64_t;
        *dataBuffer = 5LL;
        data = dataBuffer;
    }
"
3558,0,CWE78_OS_Command_Injection__char_listen_socket_popen_22a.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    CWE78_OS_Command_Injection__char_listen_socket_popen_22_badGlobal = 1; 
    data = CWE78_OS_Command_Injection__char_listen_socket_popen_22_badSource(data);
    {
        FILE *pipe;
        
        pipe = POPEN(data, ""w"");
        if (pipe != NULL)
        {
            PCLOSE(pipe);
        }
"
861,0,CWE197_Numeric_Truncation_Error__int_fscanf_to_short_06.c,"    int data;
    
    data = -1;
    if(STATIC_CONST_FIVE==5)
    {
        
        fscanf(stdin, ""%d"", &data);
    }
    {
        
        short shortData = (short)data;
        printShortLine(shortData);
"
3574,0,CWE401_Memory_Leak__new_struct_twoIntsStruct_65a.cpp,"    struct _twoIntsStruct * data;
    
    void (*funcPtr) (struct _twoIntsStruct *) = badSink;
    data = NULL;
    
    data = new struct _twoIntsStruct;
    
    data->intOne = 0;
    data->intTwo = 0;
    printStructLine((twoIntsStruct *)data);
    
"
13526,0,CWE590_Free_Memory_Not_on_Heap__delete_array_class_declare_18.cpp,"    TwoIntsClass * data;
    data = NULL; 
    goto source;
source:
    {
        
        TwoIntsClass dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i].intOne = 1;
                dataBuffer[i].intTwo = 1;
            }
        }
        data = dataBuffer;
    }
    printIntLine(data[0].intOne);
    
"
4596,0,CWE758_Undefined_Behavior__char_pointer_malloc_use_03.c,"    if(5==5)
    {
        {
            char * * pointer = (char * *)malloc(sizeof(char *));
            if (pointer == NULL) {exit(-1);}
            char * data = *pointer; 
            free(pointer);
            printLine(data);
        }
"
14144,0,CWE134_Uncontrolled_Format_String__char_environment_vfprintf_65a.c,"    char * data;
    
    void (*funcPtr) (char *, ...) = CWE134_Uncontrolled_Format_String__char_environment_vfprintf_65b_badVaSink;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        
        if (environment != NULL)
        {
            
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    
"
18270,0,CWE190_Integer_Overflow__int_rand_preinc_08.c,"    int data;
    
    data = 0;
    if(staticReturnsTrue())
    {
        
        data = RAND32();
    }
    if(staticReturnsTrue())
    {
        {
            
            ++data;
            int result = data;
            printIntLine(result);
        }
"
14761,0,CWE690_NULL_Deref_From_Return__int_malloc_83a.cpp,"    int * data;
    data = NULL; 
"
17243,0,CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_74a.cpp,"    size_t data;
    map<int, size_t> dataMap;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = strtoul(inputBuffer, NULL, 0);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
4513,0,CWE416_Use_After_Free__new_delete_long_06.cpp,"    long * data;
    
    data = NULL;
    if(STATIC_CONST_FIVE==5)
    {
        data = new long;
        *data = 5L;
        
        delete data;
    }
    if(STATIC_CONST_FIVE==5)
    {
        
        printLongLine(*data);
        
"
18000,0,CWE190_Integer_Overflow__short_fscanf_add_52a.c,"    short data;
    data = 0;
    
    fscanf (stdin, ""%hd"", &data);
"
19130,0,CWE401_Memory_Leak__strdup_char_16.c,"    char * data;
    data = NULL;
    while(1)
    {
        {
            char myString[] = ""myString"";
            
            data = strdup(myString);
            
            printLine(data);
        }
        break;
    }
    while(1)
    {
        
        
        ; 
        break;
"
15448,0,CWE690_NULL_Deref_From_Return__char_realloc_16.c,"    char * data;
    data = NULL; 
    
    data = (char *)realloc(data, 20*sizeof(char));
    while(1)
    {
        
        strcpy(data, ""Initialize"");
        printLine(data);
        free(data);
        break;
"
11379,0,CWE190_Integer_Overflow__char_rand_preinc_01.c,"    char data;
    data = ' ';
    
    data = (char)RAND32();
    {
        
        ++data;
        char result = data;
        printHexCharLine(result);
"
10904,0,CWE789_Uncontrolled_Mem_Alloc__new_char_connect_socket_84_bad.cpp,"Label Definition File: CWE789_Uncontrolled_Mem_Alloc__new.label.xml
Template File: sources-sinks-84_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: connect_socket Read data using a connect socket (client side)
 * GoodSource: Small number greater than zero
 * Sinks:
 *    GoodSink: Allocate memory with new [] and check the size of the memory to be allocated
 *    BadSink : Allocate memory with new [], but incorrectly check the size of the memory to be allocated
 * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE789_Uncontrolled_Mem_Alloc__new_char_connect_socket_84.h""

#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif

#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)

#define HELLO_STRING ""hello""

namespace CWE789_Uncontrolled_Mem_Alloc__new_char_connect_socket_84
{
CWE789_Uncontrolled_Mem_Alloc__new_char_connect_socket_84_bad::CWE789_Uncontrolled_Mem_Alloc__new_char_connect_socket_84_bad(size_t dataCopy)
{
    data = dataCopy;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = strtoul(inputBuffer, NULL, 0);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
}

CWE789_Uncontrolled_Mem_Alloc__new_char_connect_socket_84_bad::~CWE789_Uncontrolled_Mem_Alloc__new_char_connect_socket_84_bad()
{
    {
        char * myString;
        /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
         * for the strcpy() function to not cause a buffer overflow */
        
        if (data > strlen(HELLO_STRING))
        {
            myString = new char[data];
            
            strcpy(myString, HELLO_STRING);
            printLine(myString);
            delete [] myString;
        }
        else
        {
            printLine(""Input is less than the length of the source string"");
        }
    }
}
}
"
5672,0,CWE369_Divide_by_Zero__int_rand_divide_10.c,"    int data;
    
    data = -1;
    if(globalTrue)
    {
        
        data = RAND32();
    }
    if(globalTrue)
    {
        
        printIntLine(100 / data);
"
16350,0,CWE190_Integer_Overflow__short_fscanf_postinc_04.c,"    short data;
    data = 0;
    if(STATIC_CONST_TRUE)
    {
        
        fscanf (stdin, ""%hd"", &data);
    }
    if(STATIC_CONST_TRUE)
    {
        {
            
            data++;
            short result = data;
            printIntLine(result);
        }
"
11906,0,CWE197_Numeric_Truncation_Error__int_fgets_to_short_81_bad.cpp,"Label Definition File: CWE197_Numeric_Truncation_Error__int.label.xml
Template File: sources-sink-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 197 Numeric Truncation Error
 * BadSource: fgets Read data from the console using fgets()
 * GoodSource: Less than CHAR_MAX
 * Sinks: to_short
 *    BadSink : Convert data to a short
 * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE197_Numeric_Truncation_Error__int_fgets_to_short_81.h""

namespace CWE197_Numeric_Truncation_Error__int_fgets_to_short_81
{

void CWE197_Numeric_Truncation_Error__int_fgets_to_short_81_bad::action(int data) const
{
    {
        
        short shortData = (short)data;
        printShortLine(shortData);
    }
}

}
"
9977,0,CWE563_Unused_Variable__unused_value_int_83a.cpp,"    int data;
"
12991,0,CWE401_Memory_Leak__int64_t_realloc_54a.c,"    int64_t * data;
    data = NULL;
    
    data = (int64_t *)realloc(data, 100*sizeof(int64_t));
    if (data == NULL) {exit(-1);}
    
    data[0] = 5LL;
    printLongLongLine(data[0]);
"
6643,0,CWE190_Integer_Overflow__int64_t_max_postinc_31.c,"    int64_t data;
    data = 0LL;
    
    data = LLONG_MAX;
    {
        int64_t dataCopy = data;
        int64_t data = dataCopy;
        {
            
            data++;
            int64_t result = data;
            printLongLongLine(result);
        }
"
16259,0,CWE190_Integer_Overflow__int_fscanf_postinc_22a.c,"    int data;
    
    data = 0;
    
    fscanf(stdin, ""%d"", &data);
    CWE190_Integer_Overflow__int_fscanf_postinc_22_badGlobal = 1; 
"
7825,0,CWE758_Undefined_Behavior__double_pointer_alloca_use_17.c,"    int j;
    for(j = 0; j < 1; j++)
    {
        {
            double * * pointer = (double * *)ALLOCA(sizeof(double *));
            double * data = *pointer; 
            printDoubleLine(*data);
        }
"
7770,0,CWE78_OS_Command_Injection__char_connect_socket_execlp_03.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(5==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET connectSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
"
9578,0,CWE197_Numeric_Truncation_Error__int_large_to_short_51a.c,"    int data;
    
    data = -1;
    
    data = SHRT_MAX + 5;
"
1378,0,CWE590_Free_Memory_Not_on_Heap__free_char_alloca_14.c,"    char * data;
    data = NULL; 
    if(globalFive==5)
    {
        {
            
            char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
            memset(dataBuffer, 'A', 100-1); 
            dataBuffer[100-1] = '\0'; 
            data = dataBuffer;
        }
    }
    printLine(data);
    
"
16559,0,CWE690_NULL_Deref_From_Return__struct_malloc_41.c,"    twoIntsStruct * data;
    data = NULL; 
    
    data = (twoIntsStruct *)malloc(1*sizeof(twoIntsStruct));
"
14575,0,CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_11.c,"    unsigned int data;
    data = 0;
    if(globalReturnsTrue())
    {
        
        fscanf (stdin, ""%u"", &data);
    }
    if(globalReturnsTrue())
    {
        if(data > 0) 
        {
            
            unsigned int result = data * 2;
            printUnsignedLine(result);
        }
"
11307,1,CWE401_Memory_Leak__malloc_realloc_int64_t_17.c,"    int k;
    for(k = 0; k < 1; k++)
    {
        {
            int64_t * data = (int64_t *)malloc(100*sizeof(int64_t));
            if (data == NULL) {exit(-1);}
            int64_t * tmpData;
            
            data[0] = 5LL;
            printLongLongLine(data[0]);
            tmpData = (int64_t *)realloc(data, (130000)*sizeof(int64_t));
            /* FIX: Ensure realloc() was successful before assigning data to the memory block
            * allocated with realloc() */
            if (tmpData != NULL)
            {
                data = tmpData;
                
                data[0] = 10LL;
                printLongLongLine(data[0]);
            }
            free(data);
        }
"
17605,0,CWE78_OS_Command_Injection__char_connect_socket_execlp_09.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(GLOBAL_CONST_TRUE)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET connectSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
"
11474,0,CWE590_Free_Memory_Not_on_Heap__delete_long_alloca_53a.cpp,"    long * data;
    data = NULL; 
    {
        
        long * dataBuffer = (long *)ALLOCA(sizeof(long));
        *dataBuffer = 5L;
        data = dataBuffer;
    }
"
8201,0,CWE469_Use_of_Pointer_Subtraction_to_Determine_Size__char_02.c,"    if(1)
    {
        {
            char string1[] = SOURCE_STRING;
            char string2[] = SOURCE_STRING;
            char * slashInString1;
            size_t indexOfSlashInString1;
            slashInString1 = strchr(string1, '/');
            if (slashInString1 == NULL)
            {
                exit(1);
            }
            
            indexOfSlashInString1 = (size_t)(slashInString1 - string2);
            
            printUnsignedLine(indexOfSlashInString1);
        }
"
5901,0,CWE401_Memory_Leak__new_array_char_02.cpp,"    char * data;
    data = NULL;
    if(1)
    {
        
        data = new char[100];
        
        strcpy(data, ""A String"");
        printLine(data);
    }
    if(1)
    {
        
        ; 
"
2977,0,CWE190_Integer_Overflow__int_fscanf_preinc_61a.c,"    int data;
    
    data = 0;
    data = CWE190_Integer_Overflow__int_fscanf_preinc_61b_badSource(data);
    {
        
        ++data;
        int result = data;
        printIntLine(result);
"
6072,0,CWE401_Memory_Leak__twoIntsStruct_calloc_83_bad.cpp,"Label Definition File: CWE401_Memory_Leak.c.label.xml
Template File: sources-sinks-83_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 401 Memory Leak
 * BadSource: calloc Allocate data using calloc()
 * GoodSource: Allocate data on the stack
 * Sinks:
 *    GoodSink: call free() on data
 *    BadSink : no deallocation of data
 * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE401_Memory_Leak__twoIntsStruct_calloc_83.h""

namespace CWE401_Memory_Leak__twoIntsStruct_calloc_83
{
CWE401_Memory_Leak__twoIntsStruct_calloc_83_bad::CWE401_Memory_Leak__twoIntsStruct_calloc_83_bad(twoIntsStruct * dataCopy)
{
    data = dataCopy;
    
    data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));
    if (data == NULL) {exit(-1);}
    
    data[0].intOne = 0;
    data[0].intTwo = 0;
    printStructLine(&data[0]);
}

CWE401_Memory_Leak__twoIntsStruct_calloc_83_bad::~CWE401_Memory_Leak__twoIntsStruct_calloc_83_bad()
{
    
    ; 
}
}
"
2279,0,CWE758_Undefined_Behavior__double_pointer_new_use_13.cpp,"    if(GLOBAL_CONST_FIVE==5)
    {
        {
            double * * pointer = new double *;
            double * data = *pointer; 
            delete pointer;
            printDoubleLine(*data);
        }
"
18704,0,CWE401_Memory_Leak__malloc_realloc_char_10.c,"    if(globalTrue)
    {
        {
            char * data = (char *)malloc(100*sizeof(char));
            if (data == NULL) {exit(-1);}
            
            strcpy(data, ""A String"");
            printLine(data);
            
            data = (char *)realloc(data, (130000)*sizeof(char));
            if (data != NULL)
            {
                
                strcpy(data, ""New String"");
                printLine(data);
                free(data);
            }
        }
"
5570,0,CWE789_Uncontrolled_Mem_Alloc__new_char_connect_socket_11.cpp,"    size_t data;
    
    data = 0;
    if(globalReturnsTrue())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = strtoul(inputBuffer, NULL, 0);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(globalReturnsTrue())
    {
        {
            char * myString;
            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
             * for the strcpy() function to not cause a buffer overflow */
            
            if (data > strlen(HELLO_STRING))
            {
                myString = new char[data];
                
                strcpy(myString, HELLO_STRING);
                printLine(myString);
                delete [] myString;
            }
            else
            {
                printLine(""Input is less than the length of the source string"");
            }
        }
"
15558,1,CWE758_Undefined_Behavior__struct_pointer_new_use_04.cpp,"    if(STATIC_CONST_FALSE)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            twoIntsStruct * data;
            
            data = new twoIntsStruct;
            data->intOne = 5;
            data->intTwo = 6;
            twoIntsStruct * * pointer = new twoIntsStruct *;
            *pointer = data; 
            {
                twoIntsStruct * data = *pointer;
                printIntLine(data->intOne);
                printIntLine(data->intTwo);
            }
            delete pointer;
        }
"
1043,0,CWE134_Uncontrolled_Format_String__char_console_vprintf_81a.cpp,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        
        if (100-dataLen > 1)
        {
            
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgets() */
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
                    data[dataLen-1] = '\0';
                }
            }
            else
            {
                printLine(""fgets() failed"");
                
                data[dataLen] = '\0';
            }
        }
    }
    const CWE134_Uncontrolled_Format_String__char_console_vprintf_81_base& baseObject = CWE134_Uncontrolled_Format_String__char_console_vprintf_81_bad();
"
3360,0,CWE457_Use_of_Uninitialized_Variable__new_struct_array_partial_init_05.cpp,"    twoIntsStruct * data;
    data = new twoIntsStruct[10];
    if(staticTrue)
    {
        
        {
            int i;
            for(i=0; i<(10/2); i++)
            {
                data[i].intOne = i;
                data[i].intTwo = i;
            }
        }
    }
    if(staticTrue)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i].intOne);
                printIntLine(data[i].intTwo);
            }
        }
        
        delete [] data;
"
18175,0,CWE690_NULL_Deref_From_Return__char_calloc_31.c,"    char * data;
    data = NULL; 
    
    data = (char *)calloc(20, sizeof(char));
    {
        char * dataCopy = data;
        char * data = dataCopy;
        
        strcpy(data, ""Initialize"");
        printLine(data);
        free(data);
"
14995,0,CWE457_Use_of_Uninitialized_Variable__double_array_malloc_no_init_05.c,"    double * data;
    data = (double *)malloc(10*sizeof(double));
    if (data == NULL) {exit(-1);}
    if(staticTrue)
    {
        
        ; 
    }
    if(staticTrue)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printDoubleLine(data[i]);
            }
        }
"
15955,0,CWE401_Memory_Leak__struct_twoIntsStruct_calloc_84a.cpp,"    struct _twoIntsStruct * data;
    data = NULL;
    CWE401_Memory_Leak__struct_twoIntsStruct_calloc_84_bad * badObject = new CWE401_Memory_Leak__struct_twoIntsStruct_calloc_84_bad(data);
"
12706,0,CWE197_Numeric_Truncation_Error__int_fgets_to_char_43.cpp,"    int data;
    
    data = -1;
    badSource(data);
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
68,0,CWE457_Use_of_Uninitialized_Variable__struct_pointer_07.c,"    twoIntsStruct * data;
    if(staticFive==5)
    {
        
        ; 
    }
    if(staticFive==5)
    {
        
        printIntLine(data->intOne);
        printIntLine(data->intTwo);
"
8624,1,CWE401_Memory_Leak__malloc_realloc_twoIntsStruct_11.c,"    if(globalReturnsFalse())
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            twoIntsStruct * data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
            if (data == NULL) {exit(-1);}
            twoIntsStruct * tmpData;
            
            data[0].intOne = 0;
            data[0].intTwo = 0;
            printStructLine(&data[0]);
            tmpData = (twoIntsStruct *)realloc(data, (130000)*sizeof(twoIntsStruct));
            /* FIX: Ensure realloc() was successful before assigning data to the memory block
            * allocated with realloc() */
            if (tmpData != NULL)
            {
                data = tmpData;
                
                data[0].intOne = 1;
                data[0].intTwo = 1;
                printStructLine(&data[0]);
            }
            free(data);
        }
"
12472,0,CWE190_Integer_Overflow__char_rand_square_07.c,"    char data;
    data = ' ';
    if(staticFive==5)
    {
        
        data = (char)RAND32();
    }
    if(staticFive==5)
    {
        {
            
            char result = data * data;
            printHexCharLine(result);
        }
"
10518,0,CWE590_Free_Memory_Not_on_Heap__free_struct_declare_73a.cpp,"    twoIntsStruct * data;
    list<twoIntsStruct *> dataList;
    data = NULL; 
    {
        
        twoIntsStruct dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i].intOne = 1;
                dataBuffer[i].intTwo = 1;
            }
        }
        data = dataBuffer;
    }
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
6784,0,CWE415_Double_Free__new_delete_struct_05.cpp,"    twoIntsStruct * data;
    
    data = NULL;
    if(staticTrue)
    {
        data = new twoIntsStruct;
        
        delete data;
    }
    if(staticTrue)
    {
        
        delete data;
"
5392,0,CWE190_Integer_Overflow__int64_t_fscanf_preinc_54a.c,"    int64_t data;
    data = 0LL;
    
    fscanf (stdin, ""%"" SCNd64, &data);
"
10378,0,CWE78_OS_Command_Injection__char_environment_popen_02.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(1)
    {
        {
            
            size_t dataLen = strlen(data);
            char * environment = GETENV(ENV_VARIABLE);
            
            if (environment != NULL)
            {
                
                strncat(data+dataLen, environment, 100-dataLen-1);
            }
        }
    }
    {
        FILE *pipe;
        
        pipe = POPEN(data, ""w"");
        if (pipe != NULL)
        {
            PCLOSE(pipe);
        }
"
17772,0,CWE134_Uncontrolled_Format_String__char_file_fprintf_51a.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        FILE * pFile;
        
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
"
15009,1,CWE758_Undefined_Behavior__struct_new_use_11.cpp,"    if(globalReturnsTrue())
    {
        {
            twoIntsStruct data;
            data.intOne = 1;
            data.intTwo = 2;
            twoIntsStruct * pointer = new twoIntsStruct;
            *pointer = data; 
            {
                twoIntsStruct data = *pointer;
                printIntLine(data.intOne);
                printIntLine(data.intTwo);
            }
            delete pointer;
        }
"
11070,0,CWE758_Undefined_Behavior__char_pointer_alloca_use_05.c,"    if(staticTrue)
    {
        {
            char * * pointer = (char * *)ALLOCA(sizeof(char *));
            char * data = *pointer; 
            printLine(data);
        }
"
6418,0,CWE190_Integer_Overflow__int_max_multiply_06.c,"    int data;
    
    data = 0;
    if(STATIC_CONST_FIVE==5)
    {
        
        data = INT_MAX;
    }
    if(STATIC_CONST_FIVE==5)
    {
        if(data > 0) 
        {
            
            int result = data * 2;
            printIntLine(result);
        }
"
13463,0,CWE190_Integer_Overflow__int_fscanf_add_61a.c,"    int data;
    
    data = 0;
    data = CWE190_Integer_Overflow__int_fscanf_add_61b_badSource(data);
    {
        
        int result = data + 1;
        printIntLine(result);
"
1774,0,CWE190_Integer_Overflow__int_connect_socket_preinc_21.c,"    int data;
    
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    badStatic = 1; 
"
8072,0,CWE190_Integer_Overflow__char_fscanf_postinc_10.c,"    char data;
    data = ' ';
    if(globalTrue)
    {
        
        fscanf (stdin, ""%c"", &data);
    }
    if(globalTrue)
    {
        {
            
            data++;
            char result = data;
            printHexCharLine(result);
        }
"
14460,0,CWE134_Uncontrolled_Format_String__char_file_snprintf_64a.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        FILE * pFile;
        
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
"
7203,0,CWE758_Undefined_Behavior__class_pointer_new_use_12.cpp,"    if(globalReturnsTrueOrFalse())
    {
        {
            TwoIntsClass * * pointer = new TwoIntsClass *;
            TwoIntsClass * data = *pointer; 
            delete pointer;
            printIntLine(data->intOne);
            printIntLine(data->intTwo);
        }
    }
    else
    {
        {
            TwoIntsClass * data;
            
            data = new TwoIntsClass;
            data->intOne = 5;
            data->intTwo = 6;
            TwoIntsClass * * pointer = new TwoIntsClass *;
            *pointer = data; 
            {
                TwoIntsClass * data = *pointer;
                printIntLine(data->intOne);
                printIntLine(data->intTwo);
            }
            delete pointer;
        }
"
1187,0,CWE415_Double_Free__malloc_free_struct_31.c,"    twoIntsStruct * data;
    
    data = NULL;
    data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
    if (data == NULL) {exit(-1);}
    
    free(data);
    {
        twoIntsStruct * dataCopy = data;
        twoIntsStruct * data = dataCopy;
        
        free(data);
"
19289,0,CWE476_NULL_Pointer_Dereference__deref_after_check_02.c,"    if(1)
    {
        {
            
            int *intPointer = NULL;
            if (intPointer == NULL)
            {
                printIntLine(*intPointer);
            }
        }
"
16249,0,CWE590_Free_Memory_Not_on_Heap__delete_int_static_74a.cpp,"    int * data;
    map<int, int *> dataMap;
    data = NULL; 
    {
        
        static int dataBuffer;
        dataBuffer = 5;
        data = &dataBuffer;
    }
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
6411,1,CWE252_Unchecked_Return_Value__char_remove_15.c,"    switch(5)
    {
    case 6:
        
        printLine(""Benign, fixed string"");
        break;
    default:
        
        if (REMOVE(""removemegood.txt"") != 0)
        {
            printLine(""remove failed!"");
        }
        break;
"
18261,0,CWE190_Integer_Overflow__int64_t_max_postinc_52a.c,"    int64_t data;
    data = 0LL;
    
    data = LLONG_MAX;
"
15287,0,CWE190_Integer_Overflow__int64_t_fscanf_preinc_18.c,"    int64_t data;
    data = 0LL;
    goto source;
source:
    
    fscanf (stdin, ""%"" SCNd64, &data);
    goto sink;
sink:
    {
        
        ++data;
        int64_t result = data;
        printLongLongLine(result);
"
16787,0,CWE78_OS_Command_Injection__char_environment_execlp_41.c,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        
        if (environment != NULL)
        {
            
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
"
8550,0,CWE416_Use_After_Free__new_delete_class_17.cpp,"    int i,j;
    TwoIntsClass * data;
    
    data = NULL;
    for(i = 0; i < 1; i++)
    {
        data = new TwoIntsClass;
        data->intOne = 1;
        data->intTwo = 2;
        
        delete data;
    }
    for(j = 0; j < 1; j++)
    {
        
        printIntLine(data->intOne);
        
"
13823,0,CWE190_Integer_Overflow__char_fscanf_preinc_53a.c,"    char data;
    data = ' ';
    
    fscanf (stdin, ""%c"", &data);
"
6581,0,CWE190_Integer_Overflow__unsigned_int_max_add_15.c,"    unsigned int data;
    data = 0;
    switch(6)
    {
    case 6:
        
        data = UINT_MAX;
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
    {
        
        unsigned int result = data + 1;
        printUnsignedLine(result);
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
18487,0,CWE401_Memory_Leak__twoIntsStruct_calloc_02.c,"    twoIntsStruct * data;
    data = NULL;
    if(1)
    {
        
        data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));
        if (data == NULL) {exit(-1);}
        
        data[0].intOne = 0;
        data[0].intTwo = 0;
        printStructLine(&data[0]);
    }
    if(1)
    {
        
        ; 
"
3873,0,CWE476_NULL_Pointer_Dereference__class_04.cpp,"    TwoIntsClass * data;
    if(STATIC_CONST_TRUE)
    {
        
        data = NULL;
    }
    if(STATIC_CONST_TRUE)
    {
        
        printIntLine(data->intOne);
        
        delete data;
"
5261,0,CWE457_Use_of_Uninitialized_Variable__int_array_alloca_no_init_18.c,"    int * data;
    data = (int *)ALLOCA(10*sizeof(int));
    goto source;
source:
    
    ; 
    goto sink;
sink:
    
    {
        int i;
        for(i=0; i<10; i++)
        {
            printIntLine(data[i]);
        }
"
11557,0,CWE457_Use_of_Uninitialized_Variable__twointsclass_array_alloca_partial_init_14.cpp,"    TwoIntsClass * data;
    data = reinterpret_cast<TwoIntsClass *>(ALLOCA(10*sizeof(TwoIntsClass)));
    if(globalFive==5)
    {
        
        for(int i=0; i<(10/2); i++)
        {
            data[i].intOne = i;
            data[i].intTwo = i;
        }
    }
    if(globalFive==5)
    {
        
        for(int i=0; i<10; i++)
        {
            printIntLine(data[i].intOne);
            printIntLine(data[i].intTwo);
        }
"
2180,0,CWE190_Integer_Overflow__int_listen_socket_preinc_17.c,"    int i,j;
    int data;
    
    data = 0;
    for(i = 0; i < 1; i++)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    for(j = 0; j < 1; j++)
    {
        {
            
            ++data;
            int result = data;
            printIntLine(result);
        }
"
18152,0,CWE590_Free_Memory_Not_on_Heap__delete_array_int_declare_10.cpp,"    int * data;
    data = NULL; 
    if(globalTrue)
    {
        {
            
            int dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i] = 5;
                }
            }
            data = dataBuffer;
        }
    }
    printIntLine(data[0]);
    
"
8028,0,CWE401_Memory_Leak__struct_twoIntsStruct_calloc_81a.cpp,"    struct _twoIntsStruct * data;
    data = NULL;
    
    data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));
    if (data == NULL) {exit(-1);}
    
    data[0].intOne = 0;
    data[0].intTwo = 0;
    printStructLine((twoIntsStruct *)&data[0]);
    const CWE401_Memory_Leak__struct_twoIntsStruct_calloc_81_base& baseObject = CWE401_Memory_Leak__struct_twoIntsStruct_calloc_81_bad();
"
1988,0,CWE590_Free_Memory_Not_on_Heap__free_int_declare_01.c,"    int * data;
    data = NULL; 
    {
        
        int dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5;
            }
        }
        data = dataBuffer;
    }
    printIntLine(data[0]);
    
"
16309,0,CWE190_Integer_Overflow__short_max_postinc_14.c,"    short data;
    data = 0;
    if(globalFive==5)
    {
        
        data = SHRT_MAX;
    }
    if(globalFive==5)
    {
        {
            
            data++;
            short result = data;
            printIntLine(result);
        }
"
15737,1,CWE467_Use_of_sizeof_on_Pointer_Type__char_03.c,"    if(5==5)
    {
        {
            char * goodChar = NULL;
            
            goodChar = (char *)malloc(sizeof(*goodChar));
            if (goodChar == NULL) {exit(-1);}
            *goodChar = 'G';
            printHexCharLine(*goodChar);
            free(goodChar);
        }
"
11193,0,CWE590_Free_Memory_Not_on_Heap__free_int_alloca_65a.c,"    int * data;
    
    void (*funcPtr) (int *) = CWE590_Free_Memory_Not_on_Heap__free_int_alloca_65b_badSink;
    data = NULL; 
    {
        
        int * dataBuffer = (int *)ALLOCA(100*sizeof(int));
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5;
            }
        }
        data = dataBuffer;
    }
    
"
12284,0,CWE369_Divide_by_Zero__int_listen_socket_modulo_21.c,"    int data;
    
    data = -1;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    badStatic = 1; 
"
13384,0,CWE416_Use_After_Free__new_delete_long_43.cpp,"    long * data;
    
    data = NULL;
    badSource(data);
    
    printLongLine(*data);
"
8849,0,CWE190_Integer_Overflow__char_max_add_51a.c,"    char data;
    data = ' ';
    
    data = CHAR_MAX;
"
12180,1,CWE758_Undefined_Behavior__struct_pointer_alloca_use_14.c,"    if(globalFive==5)
    {
        {
            twoIntsStruct * data;
            twoIntsStruct * * pointer = (twoIntsStruct * *)ALLOCA(sizeof(twoIntsStruct *));
            
            data = (twoIntsStruct *)malloc(sizeof(twoIntsStruct));
            if (data == NULL) {exit(-1);}
            data->intOne = 5;
            data->intTwo = 6;
            *pointer = data; 
            {
                twoIntsStruct * data = *pointer;
                printIntLine(data->intOne);
                printIntLine(data->intTwo);
            }
        }
"
236,0,CWE590_Free_Memory_Not_on_Heap__delete_class_static_73a.cpp,"    TwoIntsClass * data;
    list<TwoIntsClass *> dataList;
    data = NULL; 
    {
        
        static TwoIntsClass dataBuffer;
        dataBuffer.intOne = 1;
        dataBuffer.intTwo = 1;
        data = &dataBuffer;
    }
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
15720,1,CWE758_Undefined_Behavior__int_pointer_new_use_11.cpp,"    if(globalReturnsTrue())
    {
        {
            int * data;
            
            data = new int;
            *data = 5;
            int * * pointer = new int *;
            *pointer = data; 
            {
                int * data = *pointer;
                printIntLine(*data);
            }
            delete pointer;
        }
"
15998,0,CWE190_Integer_Overflow__int_fscanf_square_64a.c,"    int data;
    
    data = 0;
    
    fscanf(stdin, ""%d"", &data);
"
16902,0,CWE590_Free_Memory_Not_on_Heap__free_char_declare_04.c,"    char * data;
    data = NULL; 
    if(STATIC_CONST_TRUE)
    {
        {
            
            char dataBuffer[100];
            memset(dataBuffer, 'A', 100-1); 
            dataBuffer[100-1] = '\0'; 
            data = dataBuffer;
        }
    }
    printLine(data);
    
"
3522,0,CWE457_Use_of_Uninitialized_Variable__struct_array_declare_partial_init_06.c,"    twoIntsStruct * data;
    twoIntsStruct dataUninitArray[10];
    data = dataUninitArray;
    if(STATIC_CONST_FIVE==5)
    {
        
        {
            int i;
            for(i=0; i<(10/2); i++)
            {
                data[i].intOne = i;
                data[i].intTwo = i;
            }
        }
    }
    if(STATIC_CONST_FIVE==5)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i].intOne);
                printIntLine(data[i].intTwo);
            }
        }
"
3802,0,CWE590_Free_Memory_Not_on_Heap__delete_int64_t_alloca_09.cpp,"    int64_t * data;
    data = NULL; 
    if(GLOBAL_CONST_TRUE)
    {
        {
            
            int64_t * dataBuffer = (int64_t *)ALLOCA(sizeof(int64_t));
            *dataBuffer = 5LL;
            data = dataBuffer;
        }
    }
    printLongLongLine(*data);
    
"
11994,0,CWE190_Integer_Overflow__unsigned_int_fscanf_square_07.c,"    unsigned int data;
    data = 0;
    if(staticFive==5)
    {
        
        fscanf (stdin, ""%u"", &data);
    }
    if(staticFive==5)
    {
        {
            
            unsigned int result = data * data;
            printUnsignedLine(result);
        }
"
13531,0,CWE369_Divide_by_Zero__int_rand_modulo_52a.c,"    int data;
    
    data = -1;
    
    data = RAND32();
"
2859,0,CWE134_Uncontrolled_Format_String__char_console_vfprintf_64a.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        
        if (100-dataLen > 1)
        {
            
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgets() */
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
                    data[dataLen-1] = '\0';
                }
            }
            else
            {
                printLine(""fgets() failed"");
                
                data[dataLen] = '\0';
            }
        }
    }
"
11384,0,CWE134_Uncontrolled_Format_String__char_console_fprintf_84a.cpp,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    CWE134_Uncontrolled_Format_String__char_console_fprintf_84_bad * badObject = new CWE134_Uncontrolled_Format_String__char_console_fprintf_84_bad(data);
"
1918,0,CWE690_NULL_Deref_From_Return__int64_t_calloc_53a.c,"    int64_t * data;
    data = NULL; 
    
    data = (int64_t *)calloc(1, sizeof(int64_t));
"
14639,0,CWE190_Integer_Overflow__int64_t_max_postinc_41.c,"    int64_t data;
    data = 0LL;
    
    data = LLONG_MAX;
"
7204,0,CWE415_Double_Free__new_delete_array_int64_t_11.cpp,"    int64_t * data;
    
    data = NULL;
    if(globalReturnsTrue())
    {
        data = new int64_t[100];
        
        delete [] data;
    }
    if(globalReturnsTrue())
    {
        
        delete [] data;
"
4521,0,CWE134_Uncontrolled_Format_String__char_connect_socket_printf_32.c,"    char * data;
    char * *dataPtr1 = &data;
    char * *dataPtr2 = &data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        char * data = *dataPtr1;
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET connectSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                
                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                data[dataLen + recvResult / sizeof(char)] = '\0';
                
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
        *dataPtr1 = data;
    }
    {
        char * data = *dataPtr2;
        
        printf(data);
"
5587,0,CWE758_Undefined_Behavior__int64_t_malloc_use_05.c,"    if(staticTrue)
    {
        {
            int64_t * pointer = (int64_t *)malloc(sizeof(int64_t));
            if (pointer == NULL) {exit(-1);}
            int64_t data = *pointer; 
            free(pointer);
            printLongLongLine(data);
        }
"
3900,0,CWE134_Uncontrolled_Format_String__char_environment_fprintf_32.c,"    char * data;
    char * *dataPtr1 = &data;
    char * *dataPtr2 = &data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        char * data = *dataPtr1;
        {
            
            size_t dataLen = strlen(data);
            char * environment = GETENV(ENV_VARIABLE);
            
            if (environment != NULL)
            {
                
                strncat(data+dataLen, environment, 100-dataLen-1);
            }
        }
        *dataPtr1 = data;
    }
    {
        char * data = *dataPtr2;
        
        fprintf(stdout, data);
"
13589,0,CWE190_Integer_Overflow__int64_t_max_add_45.c,"    int64_t data;
    data = 0LL;
    
    data = LLONG_MAX;
    CWE190_Integer_Overflow__int64_t_max_add_45_badData = data;
"
2001,0,CWE369_Divide_by_Zero__float_zero_06.c,"    float data;
    
    data = 0.0F;
    if(STATIC_CONST_FIVE==5)
    {
        
        data = 0.0F;
    }
    if(STATIC_CONST_FIVE==5)
    {
        {
            
            int result = (int)(100.0 / data);
            printIntLine(result);
        }
"
10443,0,CWE134_Uncontrolled_Format_String__char_connect_socket_printf_03.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(5==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET connectSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                
                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                data[dataLen + recvResult / sizeof(char)] = '\0';
                
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(5==5)
    {
        
        printf(data);
"
15296,0,CWE590_Free_Memory_Not_on_Heap__delete_char_declare_06.cpp,"    char * data;
    data = NULL; 
    if(STATIC_CONST_FIVE==5)
    {
        {
            
            char dataBuffer;
            dataBuffer = 'A';
            data = &dataBuffer;
        }
    }
    printHexCharLine(*data);
    
"
13031,0,CWE758_Undefined_Behavior__double_pointer_new_use_07.cpp,"    if(staticFive==5)
    {
        {
            double * * pointer = new double *;
            double * data = *pointer; 
            delete pointer;
            printDoubleLine(*data);
        }
"
19012,1,CWE252_Unchecked_Return_Value__char_snprintf_17.c,"    int k;
    for(k = 0; k < 1; k++)
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            
            if (SNPRINTF(data,100-strlen(SRC)-1, ""%s\n"", SRC) < 0)
            {
                printLine(""snprintf failed!"");
            }
        }
"
6306,0,CWE190_Integer_Overflow__int_listen_socket_preinc_11.c,"    int data;
    
    data = 0;
    if(globalReturnsTrue())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(globalReturnsTrue())
    {
        {
            
            ++data;
            int result = data;
            printIntLine(result);
        }
"
14332,0,CWE78_OS_Command_Injection__char_connect_socket_popen_33.cpp,"    char * data;
    char * &dataRef = data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
"
2090,0,CWE401_Memory_Leak__int64_t_calloc_68a.c,"    int64_t * data;
    data = NULL;
    
    data = (int64_t *)calloc(100, sizeof(int64_t));
    if (data == NULL) {exit(-1);}
    
    data[0] = 5LL;
    printLongLongLine(data[0]);
    CWE401_Memory_Leak__int64_t_calloc_68_badData = data;
"
18156,0,CWE590_Free_Memory_Not_on_Heap__free_int_declare_44.c,"    int * data;
    
    void (*funcPtr) (int *) = badSink;
    data = NULL; 
    {
        
        int dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5;
            }
        }
        data = dataBuffer;
    }
    
"
13300,0,CWE467_Use_of_sizeof_on_Pointer_Type__int_15.c,"    switch(6)
    {
    case 6:
    {
        int * badInt = NULL;
        
        badInt = (int *)malloc(sizeof(badInt));
        if (badInt == NULL) {exit(-1);}
        *badInt = 5;
        printIntLine(*badInt);
        free(badInt);
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
15716,0,CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_12.cpp,"    size_t data;
    
    data = 0;
    if(globalReturnsTrueOrFalse())
    {
        
        fscanf(stdin, ""%zu"", &data);
    }
    else
    {
        
        data = 20;
    }
    if(globalReturnsTrueOrFalse())
    {
        {
            char * myString;
            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
             * for the strcpy() function to not cause a buffer overflow */
            
            if (data > strlen(HELLO_STRING))
            {
                myString = new char[data];
                
                strcpy(myString, HELLO_STRING);
                printLine(myString);
                delete [] myString;
            }
            else
            {
                printLine(""Input is less than the length of the source string"");
            }
        }
    }
    else
    {
        {
            char * myString;
            /* FIX: Include a MAXIMUM limitation for memory allocation and a check to ensure data is large enough
             * for the strcpy() function to not cause a buffer overflow */
            
            if (data > strlen(HELLO_STRING) && data < 100)
            {
                myString = new char[data];
                
                strcpy(myString, HELLO_STRING);
                printLine(myString);
                delete [] myString;
            }
            else
            {
                printLine(""Input is less than the length of the source string or too large"");
            }
        }
"
6993,0,CWE134_Uncontrolled_Format_String__char_file_printf_64a.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        FILE * pFile;
        
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
"
1766,0,CWE134_Uncontrolled_Format_String__char_file_printf_43.cpp,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    badSource(data);
    
"
3645,0,CWE690_NULL_Deref_From_Return__long_realloc_01.c,"    long * data;
    data = NULL; 
    
    data = (long *)realloc(data, 1*sizeof(long));
    
    data[0] = 5L;
    printLongLine(data[0]);
"
8417,0,CWE401_Memory_Leak__new_array_TwoIntsClass_73a.cpp,"    TwoIntsClass * data;
    list<TwoIntsClass *> dataList;
    data = NULL;
    
    data = new TwoIntsClass[100];
    
    data[0].intOne = 0;
    data[0].intTwo = 0;
    printIntLine(data[0].intOne);
    printIntLine(data[0].intTwo);
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
13347,0,CWE758_Undefined_Behavior__char_alloca_use_15.c,"    switch(6)
    {
    case 6:
    {
        char * pointer = (char *)ALLOCA(sizeof(char));
        char data = *pointer; 
        printHexCharLine(data);
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
15522,0,CWE134_Uncontrolled_Format_String__char_environment_snprintf_81a.cpp,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        
        if (environment != NULL)
        {
            
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    const CWE134_Uncontrolled_Format_String__char_environment_snprintf_81_base& baseObject = CWE134_Uncontrolled_Format_String__char_environment_snprintf_81_bad();
"
17661,0,CWE197_Numeric_Truncation_Error__int_fgets_to_short_08.c,"    int data;
    
    data = -1;
    if(staticReturnsTrue())
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    {
        
        short shortData = (short)data;
        printShortLine(shortData);
"
1446,0,CWE690_NULL_Deref_From_Return__struct_realloc_45.c,"    twoIntsStruct * data;
    data = NULL; 
    
    data = (twoIntsStruct *)realloc(data, 1*sizeof(twoIntsStruct));
    CWE690_NULL_Deref_From_Return__struct_realloc_45_badData = data;
"
7085,0,CWE190_Integer_Overflow__int_fscanf_multiply_68a.c,"    int data;
    
    data = 0;
    
    fscanf(stdin, ""%d"", &data);
    CWE190_Integer_Overflow__int_fscanf_multiply_68_badData = data;
"
7612,0,CWE590_Free_Memory_Not_on_Heap__delete_array_char_static_53a.cpp,"    char * data;
    data = NULL; 
    {
        
        static char dataBuffer[100];
        memset(dataBuffer, 'A', 100-1); 
        dataBuffer[100-1] = '\0'; 
        data = dataBuffer;
    }
"
16151,1,CWE758_Undefined_Behavior__struct_pointer_malloc_use_05.c,"    if(staticTrue)
    {
        {
            twoIntsStruct * data;
            twoIntsStruct * * pointer = (twoIntsStruct * *)malloc(sizeof(twoIntsStruct *));
            if (pointer == NULL) {exit(-1);}
            
            data = (twoIntsStruct *)malloc(sizeof(twoIntsStruct));
            if (data == NULL) {exit(-1);}
            data->intOne = 5;
            data->intTwo = 6;
            *pointer = data; 
            {
                twoIntsStruct * data = *pointer;
                printIntLine(data->intOne);
                printIntLine(data->intTwo);
            }
            free(pointer);
        }
"
9695,0,CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_17.c,"    int i,j;
    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    for(i = 0; i < 1; i++)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET connectSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                
                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                data[dataLen + recvResult / sizeof(char)] = '\0';
                
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    for(j = 0; j < 1; j++)
    {
        {
            char dest[100] = """";
            
            SNPRINTF(dest, 100-1, data);
            printLine(dest);
        }
"
10591,0,CWE369_Divide_by_Zero__int_zero_divide_33.cpp,"    int data;
    int &dataRef = data;
    
    data = -1;
    
    data = 0;
    {
        int data = dataRef;
        
        printIntLine(100 / data);
"
282,0,CWE590_Free_Memory_Not_on_Heap__delete_array_class_static_45.cpp,"    TwoIntsClass * data;
    data = NULL; 
    {
        
        static TwoIntsClass dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i].intOne = 1;
                dataBuffer[i].intTwo = 1;
            }
        }
        data = dataBuffer;
    }
    badData = data;
"
4740,0,CWE190_Integer_Overflow__short_fscanf_postinc_68a.c,"    short data;
    data = 0;
    
    fscanf (stdin, ""%hd"", &data);
    CWE190_Integer_Overflow__short_fscanf_postinc_68_badData = data;
"
797,0,CWE134_Uncontrolled_Format_String__char_environment_printf_43.cpp,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    badSource(data);
    
"
13443,0,CWE590_Free_Memory_Not_on_Heap__delete_char_alloca_64a.cpp,"    char * data;
    data = NULL; 
    {
        
        char * dataBuffer = (char *)ALLOCA(sizeof(char));
        *dataBuffer = 'A';
        data = dataBuffer;
    }
"
2940,0,CWE401_Memory_Leak__new_array_int_05.cpp,"    int * data;
    data = NULL;
    if(staticTrue)
    {
        
        data = new int[100];
        
        data[0] = 5;
        printIntLine(data[0]);
    }
    if(staticTrue)
    {
        
        ; 
"
14805,0,CWE190_Integer_Overflow__char_max_square_41.c,"    char data;
    data = ' ';
    
    data = CHAR_MAX;
"
15612,0,CWE401_Memory_Leak__int_calloc_45.c,"    int * data;
    data = NULL;
    
    data = (int *)calloc(100, sizeof(int));
    if (data == NULL) {exit(-1);}
    
    data[0] = 5;
    printIntLine(data[0]);
    CWE401_Memory_Leak__int_calloc_45_badData = data;
"
18012,0,CWE415_Double_Free__new_delete_array_class_03.cpp,"    TwoIntsClass * data;
    
    data = NULL;
    if(5==5)
    {
        data = new TwoIntsClass[100];
        
        delete [] data;
    }
    if(5==5)
    {
        
        delete [] data;
"
4529,0,CWE690_NULL_Deref_From_Return__struct_realloc_44.c,"    twoIntsStruct * data;
    
    void (*funcPtr) (twoIntsStruct *) = badSink;
    data = NULL; 
    
    data = (twoIntsStruct *)realloc(data, 1*sizeof(twoIntsStruct));
    
"
76,0,CWE197_Numeric_Truncation_Error__int_rand_to_short_43.cpp,"    int data;
    
    data = -1;
    badSource(data);
    {
        
        short shortData = (short)data;
        printShortLine(shortData);
"
7824,0,CWE78_OS_Command_Injection__char_connect_socket_execl_81_bad.cpp,"Label Definition File: CWE78_OS_Command_Injection.strings.label.xml
Template File: sources-sink-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 78 OS Command Injection
 * BadSource: connect_socket Read data using a connect socket (client side)
 * GoodSource: Fixed string
 * Sinks: execl
 *    BadSink : execute command with execl
 * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE78_OS_Command_Injection__char_connect_socket_execl_81.h""
"
19338,0,CWE401_Memory_Leak__struct_twoIntsStruct_realloc_05.c,"    struct _twoIntsStruct * data;
    data = NULL;
    if(staticTrue)
    {
        
        data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));
        if (data == NULL) {exit(-1);}
        
        data[0].intOne = 0;
        data[0].intTwo = 0;
        printStructLine((twoIntsStruct *)&data[0]);
    }
    if(staticTrue)
    {
        
        ; 
"
1399,0,CWE190_Integer_Overflow__int_fscanf_add_84_bad.cpp,"Label Definition File: CWE190_Integer_Overflow__int.label.xml
Template File: sources-sinks-84_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 190 Integer Overflow
 * BadSource: fscanf Read data from the console using fscanf()
 * GoodSource: Set data to a small, non-zero number (two)
 * Sinks: add
 *    GoodSink: Ensure there will not be an overflow before adding 1 to data
 *    BadSink : Add 1 to data, which can cause an overflow
 * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE190_Integer_Overflow__int_fscanf_add_84.h""

namespace CWE190_Integer_Overflow__int_fscanf_add_84
{
CWE190_Integer_Overflow__int_fscanf_add_84_bad::CWE190_Integer_Overflow__int_fscanf_add_84_bad(int dataCopy)
{
    data = dataCopy;
    
    fscanf(stdin, ""%d"", &data);
}

CWE190_Integer_Overflow__int_fscanf_add_84_bad::~CWE190_Integer_Overflow__int_fscanf_add_84_bad()
{
    {
        
        int result = data + 1;
        printIntLine(result);
    }
}
}
"
7228,0,CWE190_Integer_Overflow__int64_t_rand_multiply_72a.cpp,"    int64_t data;
    vector<int64_t> dataVector;
    data = 0LL;
    
    data = (int64_t)RAND64();
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
16094,0,CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_03.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(5==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET connectSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                
                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                data[dataLen + recvResult / sizeof(char)] = '\0';
                
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(5==5)
    {
        {
            char dest[100] = """";
            
            SNPRINTF(dest, 100-1, data);
            printLine(dest);
        }
"
4623,0,CWE190_Integer_Overflow__unsigned_int_rand_square_81a.cpp,"    unsigned int data;
    data = 0;
    
    data = (unsigned int)RAND32();
    const CWE190_Integer_Overflow__unsigned_int_rand_square_81_base& baseObject = CWE190_Integer_Overflow__unsigned_int_rand_square_81_bad();
"
18259,0,CWE190_Integer_Overflow__short_rand_multiply_41.c,"    short data;
    data = 0;
    
    data = (short)RAND32();
"
18279,1,CWE252_Unchecked_Return_Value__char_snprintf_14.c,"    if(globalFive!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            
            if (SNPRINTF(data,100-strlen(SRC)-1, ""%s\n"", SRC) < 0)
            {
                printLine(""snprintf failed!"");
            }
        }
"
12001,0,CWE252_Unchecked_Return_Value__char_fscanf_16.c,"    while(1)
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            
            fscanf(stdin, ""%99s\0"", data);
        }
        break;
"
19495,0,CWE197_Numeric_Truncation_Error__int_connect_socket_to_short_05.c,"    int data;
    
    data = -1;
    if(staticTrue)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    {
        
        short shortData = (short)data;
        printShortLine(shortData);
"
12971,1,CWE401_Memory_Leak__malloc_realloc_struct_twoIntsStruct_15.c,"    switch(5)
    {
    case 6:
        
        printLine(""Benign, fixed string"");
        break;
    default:
    {
        struct _twoIntsStruct * data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));
        if (data == NULL) {exit(-1);}
        struct _twoIntsStruct * tmpData;
        
        data[0].intOne = 0;
        data[0].intTwo = 0;
        printStructLine((twoIntsStruct *)&data[0]);
        tmpData = (struct _twoIntsStruct *)realloc(data, (130000)*sizeof(struct _twoIntsStruct));
        /* FIX: Ensure realloc() was successful before assigning data to the memory block
        * allocated with realloc() */
        if (tmpData != NULL)
        {
            data = tmpData;
            
            data[0].intOne = 1;
            data[0].intTwo = 1;
            printStructLine((twoIntsStruct *)&data[0]);
        }
        free(data);
    }
    break;
"
14051,0,CWE457_Use_of_Uninitialized_Variable__new_struct_array_no_init_05.cpp,"    twoIntsStruct * data;
    data = new twoIntsStruct[10];
    if(staticTrue)
    {
        
        ; 
    }
    if(staticTrue)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i].intOne);
                printIntLine(data[i].intTwo);
            }
        }
        
        delete [] data;
"
15022,0,CWE190_Integer_Overflow__int_fgets_postinc_21.c,"    int data;
    
    data = 0;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    badStatic = 1; 
"
3481,0,CWE415_Double_Free__new_delete_char_65a.cpp,"    char * data;
    
    void (*funcPtr) (char *) = badSink;
    
    data = NULL;
    data = new char;
    
    delete data;
    
"
13055,0,CWE190_Integer_Overflow__short_rand_add_07.c,"    short data;
    data = 0;
    if(staticFive==5)
    {
        
        data = (short)RAND32();
    }
    if(staticFive==5)
    {
        {
            
            short result = data + 1;
            printIntLine(result);
        }
"
6649,0,CWE190_Integer_Overflow__short_max_square_04.c,"    short data;
    data = 0;
    if(STATIC_CONST_TRUE)
    {
        
        data = SHRT_MAX;
    }
    if(STATIC_CONST_TRUE)
    {
        {
            
            short result = data * data;
            printIntLine(result);
        }
"
18844,1,CWE252_Unchecked_Return_Value__char_fprintf_02.c,"    if(0)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        
        if (fprintf(stdout, ""%s\n"", ""string"") < 0)
        {
            printLine(""fprintf failed!"");
        }
"
3478,0,CWE134_Uncontrolled_Format_String__char_environment_fprintf_73a.cpp,"    char * data;
    list<char *> dataList;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        
        if (environment != NULL)
        {
            
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
13495,0,CWE457_Use_of_Uninitialized_Variable__double_pointer_15.c,"    double * data;
    switch(6)
    {
    case 6:
        
        ; 
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
        
        printDoubleLine(*data);
        break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
"
7042,0,CWE369_Divide_by_Zero__int_connect_socket_modulo_08.c,"    int data;
    
    data = -1;
    if(staticReturnsTrue())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                /* Abort on error or the connection was closed, make sure to recv one
                 * less char than is in the recv_buf in order to append a terminator */
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(staticReturnsTrue())
    {
        
        printIntLine(100 % data);
"
11608,0,CWE690_NULL_Deref_From_Return__int64_t_malloc_45.c,"    int64_t * data;
    data = NULL; 
    
    data = (int64_t *)malloc(1*sizeof(int64_t));
    CWE690_NULL_Deref_From_Return__int64_t_malloc_45_badData = data;
"
10061,0,CWE665_Improper_Initialization__char_cat_54a.c,"    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    
    ; 
"
14130,0,CWE190_Integer_Overflow__char_rand_multiply_21.c,"    char data;
    data = ' ';
    
    data = (char)RAND32();
    badStatic = 1; 
"
3062,0,CWE590_Free_Memory_Not_on_Heap__free_int64_t_static_41.c,"    int64_t * data;
    data = NULL; 
    {
        
        static int64_t dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5LL;
            }
        }
        data = dataBuffer;
    }
"
19216,0,CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_42.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    data = badSource(data);
"
2624,0,CWE467_Use_of_sizeof_on_Pointer_Type__int_06.c,"    if(STATIC_CONST_FIVE==5)
    {
        {
            int * badInt = NULL;
            
            badInt = (int *)malloc(sizeof(badInt));
            if (badInt == NULL) {exit(-1);}
            *badInt = 5;
            printIntLine(*badInt);
            free(badInt);
        }
"
12331,0,CWE416_Use_After_Free__new_delete_array_long_07.cpp,"    long * data;
    
    data = NULL;
    if(staticFive==5)
    {
        data = new long[100];
        {
            size_t i;
            for(i = 0; i < 100; i++)
            {
                data[i] = 5L;
            }
        }
        
        delete [] data;
    }
    if(staticFive==5)
    {
        
        printLongLine(data[0]);
        
"
9869,0,CWE190_Integer_Overflow__unsigned_int_fscanf_add_63a.c,"    unsigned int data;
    data = 0;
    
    fscanf (stdin, ""%u"", &data);
"
5029,0,CWE401_Memory_Leak__twoIntsStruct_malloc_74a.cpp,"    twoIntsStruct * data;
    map<int, twoIntsStruct *> dataMap;
    data = NULL;
    
    data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
    if (data == NULL) {exit(-1);}
    
    data[0].intOne = 0;
    data[0].intTwo = 0;
    printStructLine(&data[0]);
    
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
"
4859,0,CWE190_Integer_Overflow__char_max_multiply_67a.c,"    char data;
    CWE190_Integer_Overflow__char_max_multiply_67_structType myStruct;
    data = ' ';
    
    data = CHAR_MAX;
    myStruct.structFirst = data;
"
14035,0,CWE590_Free_Memory_Not_on_Heap__delete_array_struct_declare_05.cpp,"    twoIntsStruct * data;
    data = NULL; 
    if(staticTrue)
    {
        {
            
            twoIntsStruct dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i].intOne = 1;
                    dataBuffer[i].intTwo = 1;
                }
            }
            data = dataBuffer;
        }
    }
    printStructLine(&data[0]);
    
"
14568,0,CWE590_Free_Memory_Not_on_Heap__free_struct_alloca_08.c,"    twoIntsStruct * data;
    data = NULL; 
    if(staticReturnsTrue())
    {
        {
            
            twoIntsStruct * dataBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i].intOne = 1;
                    dataBuffer[i].intTwo = 1;
                }
            }
            data = dataBuffer;
        }
    }
    printStructLine(&data[0]);
    
"
2589,1,CWE758_Undefined_Behavior__double_pointer_alloca_use_06.c,"    if(STATIC_CONST_FIVE!=5)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            double * data;
            double * * pointer = (double * *)ALLOCA(sizeof(double *));
            
            data = (double *)malloc(sizeof(double));
            if (data == NULL) {exit(-1);}
            *data = 5.0;
            *pointer = data; 
            {
                double * data = *pointer;
                printDoubleLine(*data);
            }
        }
"
12567,0,CWE590_Free_Memory_Not_on_Heap__delete_array_int_static_15.cpp,"    int * data;
    data = NULL; 
    switch(6)
    {
    case 6:
    {
        
        static int dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5;
            }
        }
        data = dataBuffer;
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    printIntLine(data[0]);
    
"
12980,0,CWE563_Unused_Variable__unused_value_long_08.c,"    long data;
    if(staticReturnsTrue())
    {
        
        data = 5L;
    }
    if(staticReturnsTrue())
    {
        
        data = 10L;
        printLongLine(data);
"
18225,0,CWE789_Uncontrolled_Mem_Alloc__new_char_fgets_84_bad.cpp,"Label Definition File: CWE789_Uncontrolled_Mem_Alloc__new.label.xml
Template File: sources-sinks-84_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 789 Uncontrolled Memory Allocation
 * BadSource: fgets Read data from the console using fgets()
 * GoodSource: Small number greater than zero
 * Sinks:
 *    GoodSink: Allocate memory with new [] and check the size of the memory to be allocated
 *    BadSink : Allocate memory with new [], but incorrectly check the size of the memory to be allocated
 * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE789_Uncontrolled_Mem_Alloc__new_char_fgets_84.h""

#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)

#define HELLO_STRING ""hello""

namespace CWE789_Uncontrolled_Mem_Alloc__new_char_fgets_84
{
CWE789_Uncontrolled_Mem_Alloc__new_char_fgets_84_bad::CWE789_Uncontrolled_Mem_Alloc__new_char_fgets_84_bad(size_t dataCopy)
{
    data = dataCopy;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = strtoul(inputBuffer, NULL, 0);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
}

CWE789_Uncontrolled_Mem_Alloc__new_char_fgets_84_bad::~CWE789_Uncontrolled_Mem_Alloc__new_char_fgets_84_bad()
{
    {
        char * myString;
        /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
         * for the strcpy() function to not cause a buffer overflow */
        
        if (data > strlen(HELLO_STRING))
        {
            myString = new char[data];
            
            strcpy(myString, HELLO_STRING);
            printLine(myString);
            delete [] myString;
        }
        else
        {
            printLine(""Input is less than the length of the source string"");
        }
    }
}
}
"
4583,0,CWE416_Use_After_Free__new_delete_array_long_16.cpp,"    long * data;
    
    data = NULL;
    while(1)
    {
        data = new long[100];
        {
            size_t i;
            for(i = 0; i < 100; i++)
            {
                data[i] = 5L;
            }
        }
        
        delete [] data;
        break;
    }
    while(1)
    {
        
        printLongLine(data[0]);
        
        break;
"
18839,0,CWE401_Memory_Leak__char_calloc_06.c,"    char * data;
    data = NULL;
    if(STATIC_CONST_FIVE==5)
    {
        
        data = (char *)calloc(100, sizeof(char));
        if (data == NULL) {exit(-1);}
        
        strcpy(data, ""A String"");
        printLine(data);
    }
    if(STATIC_CONST_FIVE==5)
    {
        
        ; 
"
19092,0,CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_10.c,"    unsigned int data;
    data = 0;
    if(globalTrue)
    {
        
        fscanf (stdin, ""%u"", &data);
    }
    if(globalTrue)
    {
        {
            
            data++;
            unsigned int result = data;
            printUnsignedLine(result);
        }
"
12639,0,CWE457_Use_of_Uninitialized_Variable__double_array_alloca_no_init_18.c,"    double * data;
    data = (double *)ALLOCA(10*sizeof(double));
    goto source;
source:
    
    ; 
    goto sink;
sink:
    
    {
        int i;
        for(i=0; i<10; i++)
        {
            printDoubleLine(data[i]);
        }
"
1541,0,CWE401_Memory_Leak__new_int64_t_05.cpp,"    int64_t * data;
    data = NULL;
    if(staticTrue)
    {
        
        data = new int64_t;
        
        *data = 5LL;
        printLongLongLine(*data);
    }
    if(staticTrue)
    {
        
        ; 
"
2787,0,CWE190_Integer_Overflow__char_max_add_14.c,"    char data;
    data = ' ';
    if(globalFive==5)
    {
        
        data = CHAR_MAX;
    }
    if(globalFive==5)
    {
        {
            
            char result = data + 1;
            printHexCharLine(result);
        }
"
1982,0,CWE758_Undefined_Behavior__int_new_use_14.cpp,"    if(globalFive==5)
    {
        {
            int * pointer = new int;
            int data = *pointer; 
            delete pointer;
            printIntLine(data);
        }
"
7717,0,CWE197_Numeric_Truncation_Error__short_fgets_15.c,"    short data;
    
    data = -1;
    switch(6)
    {
    case 6:
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = (short)atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    break;
    default:
        
        printLine(""Benign, fixed string"");
        break;
    }
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
1047,0,CWE476_NULL_Pointer_Dereference__long_18.c,"    long * data;
    goto source;
source:
    
    data = NULL;
    goto sink;
sink:
    
"
17232,0,CWE78_OS_Command_Injection__char_console_popen_65a.c,"    char * data;
    
    void (*funcPtr) (char *) = CWE78_OS_Command_Injection__char_console_popen_65b_badSink;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
        
        size_t dataLen = strlen(data);
        
        if (100-dataLen > 1)
        {
            
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgets() */
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
                    data[dataLen-1] = '\0';
                }
            }
            else
            {
                printLine(""fgets() failed"");
                
                data[dataLen] = '\0';
            }
        }
    }
    
"
19455,0,CWE252_Unchecked_Return_Value__char_sscanf_13.c,"    if(GLOBAL_CONST_FIVE==5)
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            
            sscanf(SRC, ""%99s\0"", data);
        }
"
7511,0,CWE415_Double_Free__malloc_free_struct_11.c,"    twoIntsStruct * data;
    
    data = NULL;
    if(globalReturnsTrue())
    {
        data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
        if (data == NULL) {exit(-1);}
        
        free(data);
    }
    if(globalReturnsTrue())
    {
        
        free(data);
"
6329,1,CWE252_Unchecked_Return_Value__char_scanf_06.c,"    if(STATIC_CONST_FIVE==5)
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            
            if (scanf(""%99s\0"", data) == EOF)
            {
                printLine(""scanf failed!"");
            }
        }
"
11247,0,CWE758_Undefined_Behavior__class_new_use_11.cpp,"    if(globalReturnsTrue())
    {
        {
            TwoIntsClass * pointer = new TwoIntsClass;
            TwoIntsClass data = *pointer; 
            delete pointer;
            printIntLine(data.intOne);
            printIntLine(data.intTwo);
        }
"
13501,0,CWE415_Double_Free__new_delete_array_char_84a.cpp,"    char * data;
    
    data = NULL;
    CWE415_Double_Free__new_delete_array_char_84_bad * badObject = new CWE415_Double_Free__new_delete_array_char_84_bad(data);
"
9110,0,CWE190_Integer_Overflow__int_fgets_square_68a.c,"    int data;
    
    data = 0;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    CWE190_Integer_Overflow__int_fgets_square_68_badData = data;
"
13484,0,CWE78_OS_Command_Injection__char_environment_popen_10.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(globalTrue)
    {
        {
            
            size_t dataLen = strlen(data);
            char * environment = GETENV(ENV_VARIABLE);
            
            if (environment != NULL)
            {
                
                strncat(data+dataLen, environment, 100-dataLen-1);
            }
        }
    }
    {
        FILE *pipe;
        
        pipe = POPEN(data, ""w"");
        if (pipe != NULL)
        {
            PCLOSE(pipe);
        }
"
1433,0,CWE590_Free_Memory_Not_on_Heap__delete_array_int_static_66a.cpp,"    int * data;
    int * dataArray[5];
    data = NULL; 
    {
        
        static int dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i] = 5;
            }
        }
        data = dataBuffer;
    }
    
    dataArray[2] = data;
"
1954,0,CWE134_Uncontrolled_Format_String__char_environment_vprintf_14.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(globalFive==5)
    {
        {
            
            size_t dataLen = strlen(data);
            char * environment = GETENV(ENV_VARIABLE);
            
            if (environment != NULL)
            {
                
                strncat(data+dataLen, environment, 100-dataLen-1);
            }
        }
    }
    if(globalFive==5)
    {
        badVaSinkB(data, data);
"
17220,0,CWE563_Unused_Variable__unused_init_variable_int_84a.cpp,"    int data;
    CWE563_Unused_Variable__unused_init_variable_int_84_bad * badObject = new CWE563_Unused_Variable__unused_init_variable_int_84_bad(data);
"
15318,0,CWE457_Use_of_Uninitialized_Variable__int64_t_43.cpp,"    int64_t data;
    badSource(data);
    
"
9047,0,CWE78_OS_Command_Injection__char_connect_socket_system_66a.c,"    char * data;
    char * dataArray[5];
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    
    dataArray[2] = data;
"
6735,0,CWE590_Free_Memory_Not_on_Heap__delete_long_placement_new_72a.cpp,"    long * data;
    vector<long *> dataVector;
    data = NULL; 
    {
        
        char buffer[sizeof(long)];
        long * dataBuffer = new(buffer) long;
        *dataBuffer = 5L;
        data = dataBuffer;
    }
    
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
"
14934,0,CWE467_Use_of_sizeof_on_Pointer_Type__short_18.c,"    goto sink;
sink:
    {
        short * badShort = NULL;
        
        badShort = (short *)malloc(sizeof(badShort));
        if (badShort == NULL) {exit(-1);}
        *badShort = 5;
        printShortLine(*badShort);
        free(badShort);
"
4684,0,CWE457_Use_of_Uninitialized_Variable__struct_array_declare_partial_init_63a.c,"    twoIntsStruct * data;
    twoIntsStruct dataUninitArray[10];
    data = dataUninitArray;
    
    {
        int i;
        for(i=0; i<(10/2); i++)
        {
            data[i].intOne = i;
            data[i].intTwo = i;
        }
    }
"
18918,0,CWE789_Uncontrolled_Mem_Alloc__new_char_connect_socket_18.cpp,"    size_t data;
    
    data = 0;
    goto source;
source:
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            inputBuffer[recvResult] = '\0';
            
            data = strtoul(inputBuffer, NULL, 0);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    goto sink;
sink:
    {
        char * myString;
        /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
         * for the strcpy() function to not cause a buffer overflow */
        
        if (data > strlen(HELLO_STRING))
        {
            myString = new char[data];
            
            strcpy(myString, HELLO_STRING);
            printLine(myString);
            delete [] myString;
        }
        else
        {
            printLine(""Input is less than the length of the source string"");
        }
"
18553,0,CWE401_Memory_Leak__strdup_char_33.cpp,"    char * data;
    char * &dataRef = data;
    data = NULL;
    {
        char myString[] = ""myString"";
        
        data = strdup(myString);
        
        printLine(data);
    }
    {
        char * data = dataRef;
        
        
        ; 
"
14410,0,CWE190_Integer_Overflow__char_rand_preinc_09.c,"    char data;
    data = ' ';
    if(GLOBAL_CONST_TRUE)
    {
        
        data = (char)RAND32();
    }
    if(GLOBAL_CONST_TRUE)
    {
        {
            
            ++data;
            char result = data;
            printHexCharLine(result);
        }
"
10901,1,CWE758_Undefined_Behavior__int_pointer_new_use_05.cpp,"    if(staticFalse)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            int * data;
            
            data = new int;
            *data = 5;
            int * * pointer = new int *;
            *pointer = data; 
            {
                int * data = *pointer;
                printIntLine(*data);
            }
            delete pointer;
        }
"
7470,0,CWE789_Uncontrolled_Mem_Alloc__new_char_listen_socket_32.cpp,"    size_t data;
    size_t *dataPtr1 = &data;
    size_t *dataPtr2 = &data;
    
    data = 0;
    {
        size_t data = *dataPtr1;
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                
                inputBuffer[recvResult] = '\0';
                
                data = strtoul(inputBuffer, NULL, 0);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
        *dataPtr1 = data;
    }
    {
        size_t data = *dataPtr2;
        {
            char * myString;
            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
             * for the strcpy() function to not cause a buffer overflow */
            
            if (data > strlen(HELLO_STRING))
            {
                myString = new char[data];
                
                strcpy(myString, HELLO_STRING);
                printLine(myString);
                delete [] myString;
            }
            else
            {
                printLine(""Input is less than the length of the source string"");
            }
        }
"
1932,0,CWE758_Undefined_Behavior__int_new_use_11.cpp,"    if(globalReturnsTrue())
    {
        {
            int * pointer = new int;
            int data = *pointer; 
            delete pointer;
            printIntLine(data);
        }
"
14359,0,CWE401_Memory_Leak__new_array_int64_t_12.cpp,"    int64_t * data;
    data = NULL;
    if(globalReturnsTrueOrFalse())
    {
        
        data = new int64_t[100];
        
        data[0] = 5LL;
        printLongLongLine(data[0]);
    }
    else
    {
        
        int64_t dataGoodBuffer[100];
        data = dataGoodBuffer;
        
        data[0] = 5LL;
        printLongLongLine(data[0]);
    }
    if(globalReturnsTrueOrFalse())
    {
        
        ; 
    }
    else
    {
        
        delete[] data;
"
10124,0,CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_53a.c,"    unsigned int data;
    data = 0;
    
    fscanf (stdin, ""%u"", &data);
"
12841,0,CWE190_Integer_Overflow__int_fgets_preinc_52a.c,"    int data;
    
    data = 0;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
"
1976,0,CWE134_Uncontrolled_Format_String__char_console_vprintf_03.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(5==5)
    {
        {
            
            size_t dataLen = strlen(data);
            
            if (100-dataLen > 1)
            {
                
                if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
                {
                    /* The next few lines remove the carriage return from the string that is
                     * inserted by fgets() */
                    dataLen = strlen(data);
                    if (dataLen > 0 && data[dataLen-1] == '\n')
                    {
                        data[dataLen-1] = '\0';
                    }
                }
                else
                {
                    printLine(""fgets() failed"");
                    
                    data[dataLen] = '\0';
                }
            }
        }
    }
    if(5==5)
    {
        badVaSinkB(data, data);
"
3781,0,CWE401_Memory_Leak__twoIntsStruct_calloc_68a.c,"    twoIntsStruct * data;
    data = NULL;
    
    data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));
    if (data == NULL) {exit(-1);}
    
    data[0].intOne = 0;
    data[0].intTwo = 0;
    printStructLine(&data[0]);
    CWE401_Memory_Leak__twoIntsStruct_calloc_68_badData = data;
"
4967,0,CWE190_Integer_Overflow__int_fscanf_preinc_31.c,"    int data;
    
    data = 0;
    
    fscanf(stdin, ""%d"", &data);
    {
        int dataCopy = data;
        int data = dataCopy;
        {
            
            ++data;
            int result = data;
            printIntLine(result);
        }
"
11670,0,CWE134_Uncontrolled_Format_String__char_environment_fprintf_53a.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        
        if (environment != NULL)
        {
            
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
"
3953,0,CWE476_NULL_Pointer_Dereference__null_check_after_deref_12.c,"    if(globalReturnsTrueOrFalse())
    {
        {
            int *intPointer = NULL;
            intPointer = (int *)malloc(sizeof(int));
            *intPointer = 5;
            printIntLine(*intPointer);
            
            if (intPointer != NULL)
            {
                *intPointer = 10;
            }
            printIntLine(*intPointer);
        }
    }
    else
    {
        {
            int *intPointer = NULL;
            intPointer = (int *)malloc(sizeof(int));
            *intPointer = 5;
            printIntLine(*intPointer);
            
            *intPointer = 10;
            printIntLine(*intPointer);
        }
"
3485,0,CWE190_Integer_Overflow__int64_t_max_postinc_18.c,"    int64_t data;
    data = 0LL;
    goto source;
source:
    
    data = LLONG_MAX;
    goto sink;
sink:
    {
        
        data++;
        int64_t result = data;
        printLongLongLine(result);
"
10782,0,CWE190_Integer_Overflow__int_fgets_multiply_84_bad.cpp,"Label Definition File: CWE190_Integer_Overflow__int.label.xml
Template File: sources-sinks-84_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 190 Integer Overflow
 * BadSource: fgets Read data from the console using fgets()
 * GoodSource: Set data to a small, non-zero number (two)
 * Sinks: multiply
 *    GoodSink: Ensure there will not be an overflow before multiplying data by 2
 *    BadSink : If data is positive, multiply by 2, which can cause an overflow
 * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE190_Integer_Overflow__int_fgets_multiply_84.h""

#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)

namespace CWE190_Integer_Overflow__int_fgets_multiply_84
{
CWE190_Integer_Overflow__int_fgets_multiply_84_bad::CWE190_Integer_Overflow__int_fgets_multiply_84_bad(int dataCopy)
{
    data = dataCopy;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
}

CWE190_Integer_Overflow__int_fgets_multiply_84_bad::~CWE190_Integer_Overflow__int_fgets_multiply_84_bad()
{
    if(data > 0) 
    {
        
        int result = data * 2;
        printIntLine(result);
    }
}
}
"
3260,0,CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_51a.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            /* Abort on error or the connection was closed, make sure to recv one
             * less char than is in the recv_buf in order to append a terminator */
            
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            
            data[dataLen + recvResult / sizeof(char)] = '\0';
            
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
"
12200,0,CWE590_Free_Memory_Not_on_Heap__delete_long_placement_new_08.cpp,"    long * data;
    data = NULL; 
    if(staticReturnsTrue())
    {
        {
            
            char buffer[sizeof(long)];
            long * dataBuffer = new(buffer) long;
            *dataBuffer = 5L;
            data = dataBuffer;
        }
    }
    printLongLine(*data);
    
"
9733,0,CWE758_Undefined_Behavior__class_new_use_17.cpp,"    int j;
    for(j = 0; j < 1; j++)
    {
        {
            TwoIntsClass * pointer = new TwoIntsClass;
            TwoIntsClass data = *pointer; 
            delete pointer;
            printIntLine(data.intOne);
            printIntLine(data.intTwo);
        }
"
18480,0,CWE369_Divide_by_Zero__int_rand_modulo_17.c,"    int i,j;
    int data;
    
    data = -1;
    for(i = 0; i < 1; i++)
    {
        
        data = RAND32();
    }
    for(j = 0; j < 1; j++)
    {
        
        printIntLine(100 % data);
"
19342,0,CWE690_NULL_Deref_From_Return__int64_t_realloc_82a.cpp,"    int64_t * data;
    data = NULL; 
    
    data = (int64_t *)realloc(data, 1*sizeof(int64_t));
    CWE690_NULL_Deref_From_Return__int64_t_realloc_82_base* baseObject = new CWE690_NULL_Deref_From_Return__int64_t_realloc_82_bad;
    baseObject->action(data);
"
12772,0,CWE415_Double_Free__new_delete_long_81a.cpp,"    long * data;
    
    data = NULL;
    data = new long;
    
    delete data;
    const CWE415_Double_Free__new_delete_long_81_base& o = CWE415_Double_Free__new_delete_long_81_bad();
"
15896,0,CWE369_Divide_by_Zero__int_zero_modulo_02.c,"    int data;
    
    data = -1;
    if(1)
    {
        
        data = 0;
    }
    if(1)
    {
        
        printIntLine(100 % data);
"
12621,0,CWE197_Numeric_Truncation_Error__short_rand_18.c,"    short data;
    
    data = -1;
    goto source;
source:
    
    data = (short)RAND32();
    {
        
        char charData = (char)data;
        printHexCharLine(charData);
"
11323,1,CWE467_Use_of_sizeof_on_Pointer_Type__short_04.c,"    if(STATIC_CONST_FALSE)
    {
        
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            short * goodShort = NULL;
            
            goodShort = (short *)malloc(sizeof(*goodShort));
            if (goodShort == NULL) {exit(-1);}
            *goodShort = 6;
            printShortLine(*goodShort);
            free(goodShort);
        }
"
11793,0,CWE78_OS_Command_Injection__char_connect_socket_execl_84a.cpp,"    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    CWE78_OS_Command_Injection__char_connect_socket_execl_84_bad * badObject = new CWE78_OS_Command_Injection__char_connect_socket_execl_84_bad(data);
"
2326,0,CWE190_Integer_Overflow__short_rand_add_54a.c,"    short data;
    data = 0;
    
    data = (short)RAND32();
"
14803,0,CWE457_Use_of_Uninitialized_Variable__int_array_alloca_no_init_05.c,"    int * data;
    data = (int *)ALLOCA(10*sizeof(int));
    if(staticTrue)
    {
        
        ; 
    }
    if(staticTrue)
    {
        
        {
            int i;
            for(i=0; i<10; i++)
            {
                printIntLine(data[i]);
            }
        }
"
261,0,CWE590_Free_Memory_Not_on_Heap__delete_struct_alloca_05.cpp,"    twoIntsStruct * data;
    data = NULL; 
    if(staticTrue)
    {
        {
            
            twoIntsStruct * dataBuffer = (twoIntsStruct *)ALLOCA(sizeof(twoIntsStruct));
            dataBuffer->intOne = 1;
            dataBuffer->intTwo = 1;
            data = dataBuffer;
        }
    }
    printStructLine(data);
    
"
18460,0,CWE401_Memory_Leak__int64_t_realloc_61a.c,"    int64_t * data;
    data = NULL;
    data = CWE401_Memory_Leak__int64_t_realloc_61b_badSource(data);
    
"
6678,0,CWE690_NULL_Deref_From_Return__char_realloc_81_bad.cpp,"Label Definition File: CWE690_NULL_Deref_From_Return.free.label.xml
Template File: source-sinks-81_bad.tmpl.cpp
*/
/*
 * @description
 * CWE: 690 Unchecked Return Value To NULL Pointer
 * BadSource: realloc Allocate data using realloc()
 * Sinks:
 *    GoodSink: Check to see if the data allocation failed and if not, use data
 *    BadSink : Don't check for NULL and use data
 * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference
 *
 * */
#ifndef OMITBAD

#include ""std_testcase.h""
#include ""CWE690_NULL_Deref_From_Return__char_realloc_81.h""

namespace CWE690_NULL_Deref_From_Return__char_realloc_81
{

void CWE690_NULL_Deref_From_Return__char_realloc_81_bad::action(char * data) const
{
    
    strcpy(data, ""Initialize"");
    printLine(data);
    free(data);
}

}
"
4893,0,CWE190_Integer_Overflow__int_fgets_square_17.c,"    int i,j;
    int data;
    
    data = 0;
    for(i = 0; i < 1; i++)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    for(j = 0; j < 1; j++)
    {
        {
            
            int result = data * data;
            printIntLine(result);
        }
"
839,0,CWE401_Memory_Leak__malloc_realloc_twoIntsStruct_17.c,"    int j;
    for(j = 0; j < 1; j++)
    {
        {
            twoIntsStruct * data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
            if (data == NULL) {exit(-1);}
            
            data[0].intOne = 0;
            data[0].intTwo = 0;
            printStructLine(&data[0]);
            
            data = (twoIntsStruct *)realloc(data, (130000)*sizeof(twoIntsStruct));
            if (data != NULL)
            {
                
                data[0].intOne = 1;
                data[0].intTwo = 1;
                printStructLine(&data[0]);
                free(data);
            }
        }
"
18540,0,CWE190_Integer_Overflow__int64_t_fscanf_multiply_73a.cpp,"    int64_t data;
    list<int64_t> dataList;
    data = 0LL;
    
    fscanf (stdin, ""%"" SCNd64, &data);
    
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
"
11657,0,CWE190_Integer_Overflow__unsigned_int_rand_postinc_65a.c,"    unsigned int data;
    
    void (*funcPtr) (unsigned int) = CWE190_Integer_Overflow__unsigned_int_rand_postinc_65b_badSink;
    data = 0;
    
    data = (unsigned int)RAND32();
    
"
15962,0,CWE401_Memory_Leak__int_realloc_64a.c,"    int * data;
    data = NULL;
    
    data = (int *)realloc(data, 100*sizeof(int));
    if (data == NULL) {exit(-1);}
    
    data[0] = 5;
    printIntLine(data[0]);
"
18769,0,CWE190_Integer_Overflow__int_rand_square_51a.c,"    int data;
    
    data = 0;
    
    data = RAND32();
"
17281,0,CWE401_Memory_Leak__twoIntsStruct_calloc_83a.cpp,"    twoIntsStruct * data;
    data = NULL;
"
16851,0,CWE252_Unchecked_Return_Value__char_fputc_02.c,"    if(1)
    {
        
        fputc((int)'A', stdout);
"
3555,0,CWE78_OS_Command_Injection__char_file_system_10.c,"    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(globalTrue)
    {
        {
            
            size_t dataLen = strlen(data);
            FILE * pFile;
            
            if (100-dataLen > 1)
            {
                pFile = fopen(FILENAME, ""r"");
                if (pFile != NULL)
                {
                    
                    if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                    {
                        printLine(""fgets() failed"");
                        
                        data[dataLen] = '\0';
                    }
                    fclose(pFile);
                }
            }
        }
    }
    
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
"
14518,0,CWE590_Free_Memory_Not_on_Heap__delete_array_class_declare_32.cpp,"    TwoIntsClass * data;
    TwoIntsClass * *dataPtr1 = &data;
    TwoIntsClass * *dataPtr2 = &data;
    data = NULL; 
    {
        TwoIntsClass * data = *dataPtr1;
        {
            
            TwoIntsClass dataBuffer[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    dataBuffer[i].intOne = 1;
                    dataBuffer[i].intTwo = 1;
                }
            }
            data = dataBuffer;
        }
        *dataPtr1 = data;
    }
    {
        TwoIntsClass * data = *dataPtr2;
        printIntLine(data[0].intOne);
        
        delete [] data;
"
6921,0,CWE369_Divide_by_Zero__int_fscanf_modulo_62a.cpp,"    int data;
    
    data = -1;
    badSource(data);
    
"
9801,0,CWE190_Integer_Overflow__int_rand_postinc_08.c,"    int data;
    
    data = 0;
    if(staticReturnsTrue())
    {
        
        data = RAND32();
    }
    if(staticReturnsTrue())
    {
        {
            
            data++;
            int result = data;
            printIntLine(result);
        }
"
1152,0,CWE134_Uncontrolled_Format_String__char_environment_printf_10.c,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(globalTrue)
    {
        {
            
            size_t dataLen = strlen(data);
            char * environment = GETENV(ENV_VARIABLE);
            
            if (environment != NULL)
            {
                
                strncat(data+dataLen, environment, 100-dataLen-1);
            }
        }
    }
    if(globalTrue)
    {
        
        printf(data);
"
13377,0,CWE590_Free_Memory_Not_on_Heap__delete_char_static_44.cpp,"    char * data;
    
    void (*funcPtr) (char *) = badSink;
    data = NULL; 
    {
        
        static char dataBuffer;
        dataBuffer = 'A';
        data = &dataBuffer;
    }
    
"
10747,0,CWE590_Free_Memory_Not_on_Heap__free_struct_declare_52a.c,"    twoIntsStruct * data;
    data = NULL; 
    {
        
        twoIntsStruct dataBuffer[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                dataBuffer[i].intOne = 1;
                dataBuffer[i].intTwo = 1;
            }
        }
        data = dataBuffer;
    }
"
9501,0,CWE252_Unchecked_Return_Value__char_fread_02.c,"    if(1)
    {
        {
            /* By initializing dataBuffer, we ensure this will not be the
             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */
            char dataBuffer[100] = """";
            char * data = dataBuffer;
            
            fread((char *)data, sizeof(char), (size_t)(100-1), stdin);
        }
"
17523,0,CWE401_Memory_Leak__char_malloc_64a.c,"    char * data;
    data = NULL;
    
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    
    strcpy(data, ""A String"");
    printLine(data);
"
18461,0,CWE401_Memory_Leak__twoIntsStruct_calloc_43.cpp,"    twoIntsStruct * data;
    data = NULL;
    badSource(data);
    
"
8472,0,CWE758_Undefined_Behavior__char_pointer_new_use_11.cpp,"    if(globalReturnsTrue())
    {
        {
            char * * pointer = new char *;
            char * data = *pointer; 
            delete pointer;
            printLine(data);
        }
"
13844,0,CWE789_Uncontrolled_Mem_Alloc__new_char_fgets_32.cpp,"    size_t data;
    size_t *dataPtr1 = &data;
    size_t *dataPtr2 = &data;
    
    data = 0;
    {
        size_t data = *dataPtr1;
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                
                data = strtoul(inputBuffer, NULL, 0);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
        *dataPtr1 = data;
    }
    {
        size_t data = *dataPtr2;
        {
            char * myString;
            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
             * for the strcpy() function to not cause a buffer overflow */
            
            if (data > strlen(HELLO_STRING))
            {
                myString = new char[data];
                
                strcpy(myString, HELLO_STRING);
                printLine(myString);
                delete [] myString;
            }
            else
            {
                printLine(""Input is less than the length of the source string"");
            }
        }
"
14932,0,CWE690_NULL_Deref_From_Return__long_calloc_18.c,"    long * data;
    data = NULL; 
    
    data = (long *)calloc(1, sizeof(long));
    goto sink;
sink:
    
    data[0] = 5L;
    printLongLine(data[0]);
"
1727,0,CWE457_Use_of_Uninitialized_Variable__twointsclass_05.cpp,"    TwoIntsClass data;
    if(staticTrue)
    {
        
        ; 
    }
    if(staticTrue)
    {
        
        printIntLine(data.intOne);
        printIntLine(data.intTwo);
"
12391,0,CWE758_Undefined_Behavior__char_pointer_alloca_use_13.c,"    if(GLOBAL_CONST_FIVE==5)
    {
        {
            char * * pointer = (char * *)ALLOCA(sizeof(char *));
            char * data = *pointer; 
            printLine(data);
        }
"
5979,0,CWE252_Unchecked_Return_Value__char_fputs_17.c,"    int j;
    for(j = 0; j < 1; j++)
    {
        
        fputs(""string"", stdout);
"
